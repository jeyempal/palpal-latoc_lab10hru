// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (
  modules,
  entry,
  mainEntry,
  parcelRequireName,
  externals,
  distDir,
  publicUrl,
  devServer
) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var importMap = previousRequire.i || {};
  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        if (externals[name]) {
          return externals[name];
        }
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        globalObject
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.require = nodeRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.distDir = distDir;
  newRequire.publicUrl = publicUrl;
  newRequire.devServer = devServer;
  newRequire.i = importMap;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  // Only insert newRequire.load when it is actually used.
  // The code in this file is linted against ES5, so dynamic import is not allowed.
  // INSERT_LOAD_HERE

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });
    }
  }
})({"e0foL":[function(require,module,exports,__globalThis) {
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SERVER_PORT = 1234;
var HMR_SECURE = false;
var HMR_ENV_HASH = "439701173a9199ea";
var HMR_USE_SSE = false;
module.bundle.HMR_BUNDLE_ID = "8f8355b15e0e6471";
"use strict";
/* global HMR_HOST, HMR_PORT, HMR_SERVER_PORT, HMR_ENV_HASH, HMR_SECURE, HMR_USE_SSE, chrome, browser, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: {|[string]: mixed|};
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
    getURL(url: string): string;
    getManifest(): {manifest_version: number, ...};
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_SERVER_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var HMR_USE_SSE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
declare var __parcel__import__: (string) => Promise<void>;
declare var __parcel__importScripts__: (string) => Promise<void>;
declare var globalThis: typeof self;
declare var ServiceWorkerGlobalScope: Object;
*/ var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData[moduleName],
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData[moduleName] = undefined;
}
module.bundle.Module = Module;
module.bundle.hotData = {};
var checkedAssets /*: {|[string]: boolean|} */ , disposedAssets /*: {|[string]: boolean|} */ , assetsToDispose /*: Array<[ParcelRequire, string]> */ , assetsToAccept /*: Array<[ParcelRequire, string]> */ , bundleNotFound = false;
function getHostname() {
    return HMR_HOST || (typeof location !== 'undefined' && location.protocol.indexOf('http') === 0 ? location.hostname : 'localhost');
}
function getPort() {
    return HMR_PORT || (typeof location !== 'undefined' ? location.port : HMR_SERVER_PORT);
}
// eslint-disable-next-line no-redeclare
let WebSocket = globalThis.WebSocket;
if (!WebSocket && typeof module.bundle.root === 'function') try {
    // eslint-disable-next-line no-global-assign
    WebSocket = module.bundle.root('ws');
} catch  {
// ignore.
}
var hostname = getHostname();
var port = getPort();
var protocol = HMR_SECURE || typeof location !== 'undefined' && location.protocol === 'https:' && ![
    'localhost',
    '127.0.0.1',
    '0.0.0.0'
].includes(hostname) ? 'wss' : 'ws';
// eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if (!parent || !parent.isParcelRequire) {
    // Web extension context
    var extCtx = typeof browser === 'undefined' ? typeof chrome === 'undefined' ? null : chrome : browser;
    // Safari doesn't support sourceURL in error stacks.
    // eval may also be disabled via CSP, so do a quick check.
    var supportsSourceURL = false;
    try {
        (0, eval)('throw new Error("test"); //# sourceURL=test.js');
    } catch (err) {
        supportsSourceURL = err.stack.includes('test.js');
    }
    var ws;
    if (HMR_USE_SSE) ws = new EventSource('/__parcel_hmr');
    else try {
        // If we're running in the dev server's node runner, listen for messages on the parent port.
        let { workerData, parentPort } = module.bundle.root('node:worker_threads') /*: any*/ ;
        if (workerData !== null && workerData !== void 0 && workerData.__parcel) {
            parentPort.on('message', async (message)=>{
                try {
                    await handleMessage(message);
                    parentPort.postMessage('updated');
                } catch  {
                    parentPort.postMessage('restart');
                }
            });
            // After the bundle has finished running, notify the dev server that the HMR update is complete.
            queueMicrotask(()=>parentPort.postMessage('ready'));
        }
    } catch  {
        if (typeof WebSocket !== 'undefined') try {
            ws = new WebSocket(protocol + '://' + hostname + (port ? ':' + port : '') + '/');
        } catch (err) {
            // Ignore cloudflare workers error.
            if (err.message && !err.message.includes('Disallowed operation called within global scope')) console.error(err.message);
        }
    }
    if (ws) {
        // $FlowFixMe
        ws.onmessage = async function(event /*: {data: string, ...} */ ) {
            var data /*: HMRMessage */  = JSON.parse(event.data);
            await handleMessage(data);
        };
        if (ws instanceof WebSocket) {
            ws.onerror = function(e) {
                if (e.message) console.error(e.message);
            };
            ws.onclose = function() {
                console.warn("[parcel] \uD83D\uDEA8 Connection to the HMR server was lost");
            };
        }
    }
}
async function handleMessage(data /*: HMRMessage */ ) {
    checkedAssets = {} /*: {|[string]: boolean|} */ ;
    disposedAssets = {} /*: {|[string]: boolean|} */ ;
    assetsToAccept = [];
    assetsToDispose = [];
    bundleNotFound = false;
    if (data.type === 'reload') fullReload();
    else if (data.type === 'update') {
        // Remove error overlay if there is one
        if (typeof document !== 'undefined') removeErrorOverlay();
        let assets = data.assets;
        // Handle HMR Update
        let handled = assets.every((asset)=>{
            return asset.type === 'css' || asset.type === 'js' && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
        });
        // Dispatch a custom event in case a bundle was not found. This might mean
        // an asset on the server changed and we should reload the page. This event
        // gives the client an opportunity to refresh without losing state
        // (e.g. via React Server Components). If e.preventDefault() is not called,
        // we will trigger a full page reload.
        if (handled && bundleNotFound && assets.some((a)=>a.envHash !== HMR_ENV_HASH) && typeof window !== 'undefined' && typeof CustomEvent !== 'undefined') handled = !window.dispatchEvent(new CustomEvent('parcelhmrreload', {
            cancelable: true
        }));
        if (handled) {
            console.clear();
            // Dispatch custom event so other runtimes (e.g React Refresh) are aware.
            if (typeof window !== 'undefined' && typeof CustomEvent !== 'undefined') window.dispatchEvent(new CustomEvent('parcelhmraccept'));
            await hmrApplyUpdates(assets);
            hmrDisposeQueue();
            // Run accept callbacks. This will also re-execute other disposed assets in topological order.
            let processedAssets = {};
            for(let i = 0; i < assetsToAccept.length; i++){
                let id = assetsToAccept[i][1];
                if (!processedAssets[id]) {
                    hmrAccept(assetsToAccept[i][0], id);
                    processedAssets[id] = true;
                }
            }
        } else fullReload();
    }
    if (data.type === 'error') {
        // Log parcel errors to console
        for (let ansiDiagnostic of data.diagnostics.ansi){
            let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
            console.error("\uD83D\uDEA8 [parcel]: " + ansiDiagnostic.message + '\n' + stack + '\n\n' + ansiDiagnostic.hints.join('\n'));
        }
        if (typeof document !== 'undefined') {
            // Render the fancy html overlay
            removeErrorOverlay();
            var overlay = createErrorOverlay(data.diagnostics.html);
            // $FlowFixMe
            document.body.appendChild(overlay);
        }
    }
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log("[parcel] \u2728 Error resolved");
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement('div');
    overlay.id = OVERLAY_ID;
    let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    for (let diagnostic of diagnostics){
        let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame)=>{
            return `${p}
<a href="${protocol === 'wss' ? 'https' : 'http'}://${hostname}:${port}/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}" style="text-decoration: underline; color: #888" onclick="fetch(this.href); return false">${frame.location}</a>
${frame.code}`;
        }, '') : diagnostic.stack;
        errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          \u{1F6A8} ${diagnostic.message}
        </div>
        <pre>${stack}</pre>
        <div>
          ${diagnostic.hints.map((hint)=>"<div>\uD83D\uDCA1 " + hint + '</div>').join('')}
        </div>
        ${diagnostic.documentation ? `<div>\u{1F4DD} <a style="color: violet" href="${diagnostic.documentation}" target="_blank">Learn more</a></div>` : ''}
      </div>
    `;
    }
    errorHTML += '</div>';
    overlay.innerHTML = errorHTML;
    return overlay;
}
function fullReload() {
    if (typeof location !== 'undefined' && 'reload' in location) location.reload();
    else if (typeof extCtx !== 'undefined' && extCtx && extCtx.runtime && extCtx.runtime.reload) extCtx.runtime.reload();
    else try {
        let { workerData, parentPort } = module.bundle.root('node:worker_threads') /*: any*/ ;
        if (workerData !== null && workerData !== void 0 && workerData.__parcel) parentPort.postMessage('restart');
    } catch (err) {
        console.error("[parcel] \u26A0\uFE0F An HMR update was not accepted. Please restart the process.");
    }
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var href = link.getAttribute('href');
    if (!href) return;
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute('href', // $FlowFixMe
    href.split('?')[0] + '?' + Date.now());
    // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout || typeof document === 'undefined') return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href /*: string */  = links[i].getAttribute('href');
            var hostname = getHostname();
            var servedFromHMRServer = hostname === 'localhost' ? new RegExp('^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):' + getPort()).test(href) : href.indexOf(hostname + ':' + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrDownload(asset) {
    if (asset.type === 'js') {
        if (typeof document !== 'undefined') {
            let script = document.createElement('script');
            script.src = asset.url + '?t=' + Date.now();
            if (asset.outputFormat === 'esmodule') script.type = 'module';
            return new Promise((resolve, reject)=>{
                var _document$head;
                script.onload = ()=>resolve(script);
                script.onerror = reject;
                (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);
            });
        } else if (typeof importScripts === 'function') {
            // Worker scripts
            if (asset.outputFormat === 'esmodule') return import(asset.url + '?t=' + Date.now());
            else return new Promise((resolve, reject)=>{
                try {
                    importScripts(asset.url + '?t=' + Date.now());
                    resolve();
                } catch (err) {
                    reject(err);
                }
            });
        }
    }
}
async function hmrApplyUpdates(assets) {
    global.parcelHotUpdate = Object.create(null);
    let scriptsToRemove;
    try {
        // If sourceURL comments aren't supported in eval, we need to load
        // the update from the dev server over HTTP so that stack traces
        // are correct in errors/logs. This is much slower than eval, so
        // we only do it if needed (currently just Safari).
        // https://bugs.webkit.org/show_bug.cgi?id=137297
        // This path is also taken if a CSP disallows eval.
        if (!supportsSourceURL) {
            let promises = assets.map((asset)=>{
                var _hmrDownload;
                return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch((err)=>{
                    // Web extension fix
                    if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3 && typeof ServiceWorkerGlobalScope != 'undefined' && global instanceof ServiceWorkerGlobalScope) {
                        extCtx.runtime.reload();
                        return;
                    }
                    throw err;
                });
            });
            scriptsToRemove = await Promise.all(promises);
        }
        assets.forEach(function(asset) {
            hmrApply(module.bundle.root, asset);
        });
    } finally{
        delete global.parcelHotUpdate;
        if (scriptsToRemove) scriptsToRemove.forEach((script)=>{
            if (script) {
                var _document$head2;
                (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);
            }
        });
    }
}
function hmrApply(bundle /*: ParcelRequire */ , asset /*:  HMRAsset */ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === 'css') reloadCSS();
    else if (asset.type === 'js') {
        let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                let oldDeps = modules[asset.id][1];
                for(let dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    let id = oldDeps[dep];
                    let parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            if (supportsSourceURL) // Global eval. We would use `new Function` here but browser
            // support for source maps is better with eval.
            (0, eval)(asset.output);
            // $FlowFixMe
            let fn = global.parcelHotUpdate[asset.id];
            modules[asset.id] = [
                fn,
                deps
            ];
        }
        // Always traverse to the parent bundle, even if we already replaced the asset in this bundle.
        // This is required in case modules are duplicated. We need to ensure all instances have the updated code.
        if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id) {
    let modules = bundle.modules;
    if (!modules) return;
    if (modules[id]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        let deps = modules[id][1];
        let orphans = [];
        for(let dep in deps){
            let parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        }
        // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id];
        delete bundle.cache[id];
        // Now delete the orphans.
        orphans.forEach((id)=>{
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id);
}
function hmrAcceptCheck(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    checkedAssets = {};
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
    // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    let parents = getParents(module.bundle.root, id);
    let accepted = false;
    while(parents.length > 0){
        let v = parents.shift();
        let a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else if (a !== null) {
            // Otherwise, queue the parents in the next level upward.
            let p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push(...p);
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) {
            bundleNotFound = true;
            return true;
        }
        return hmrAcceptCheckOne(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return null;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    if (!cached) return true;
    assetsToDispose.push([
        bundle,
        id
    ]);
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
        assetsToAccept.push([
            bundle,
            id
        ]);
        return true;
    }
    return false;
}
function hmrDisposeQueue() {
    // Dispose all old assets.
    for(let i = 0; i < assetsToDispose.length; i++){
        let id = assetsToDispose[i][1];
        if (!disposedAssets[id]) {
            hmrDispose(assetsToDispose[i][0], id);
            disposedAssets[id] = true;
        }
    }
    assetsToDispose = [];
}
function hmrDispose(bundle /*: ParcelRequire */ , id /*: string */ ) {
    var cached = bundle.cache[id];
    bundle.hotData[id] = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData[id];
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData[id]);
    });
    delete bundle.cache[id];
}
function hmrAccept(bundle /*: ParcelRequire */ , id /*: string */ ) {
    // Execute the module.
    bundle(id);
    // Run the accept callbacks in the new version of the module.
    var cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
        let assetsToAlsoAccept = [];
        cached.hot._acceptCallbacks.forEach(function(cb) {
            let additionalAssets = cb(function() {
                return getParents(module.bundle.root, id);
            });
            if (Array.isArray(additionalAssets) && additionalAssets.length) assetsToAlsoAccept.push(...additionalAssets);
        });
        if (assetsToAlsoAccept.length) {
            let handled = assetsToAlsoAccept.every(function(a) {
                return hmrAcceptCheck(a[0], a[1]);
            });
            if (!handled) return fullReload();
            hmrDisposeQueue();
        }
    }
}

},{}],"ly4KV":[function(require,module,exports,__globalThis) {
var _model = require("./model");
var _view = require("./view");
var _update = require("./update");
var _src = require("cs12242-mvu/src");
const root = document.getElementById("app");
(0, _src.startModelCmd)(root, (0, _model.initModel), (0, _update.update), (0, _view.view));

},{"./model":"lPixF","./view":"jcg5z","./update":"jYYJY","cs12242-mvu/src":"lHyd2"}],"lPixF":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Model", ()=>Model);
parcelHelpers.export(exports, "initModel", ()=>initModel);
var _effect = require("effect");
const Model = (0, _effect.Schema).Struct({
    pokemonData: (0, _effect.Schema).Object,
    isFetching: (0, _effect.Schema).Boolean,
    pokemon: (0, _effect.Schema).String,
    error: (0, _effect.Schema).String,
    text: (0, _effect.Schema).String
});
const initModel = Model.make({
    pokemonData: {
        "name": "",
        "types": [],
        "height": null,
        "weight": null
    },
    isFetching: false,
    pokemon: "",
    error: "",
    text: ""
});

},{"effect":"613jd","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"613jd":[function(require,module,exports,__globalThis) {
/**
 * @since 2.0.0
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "absurd", ()=>(0, _functionJs.absurd));
parcelHelpers.export(exports, "flow", ()=>(0, _functionJs.flow));
parcelHelpers.export(exports, "hole", ()=>(0, _functionJs.hole));
parcelHelpers.export(exports, "identity", ()=>(0, _functionJs.identity));
parcelHelpers.export(exports, "pipe", ()=>(0, _functionJs.pipe));
parcelHelpers.export(exports, "unsafeCoerce", ()=>(0, _functionJs.unsafeCoerce));
/**
 * @since 3.10.0
 */ parcelHelpers.export(exports, "Arbitrary", ()=>_arbitraryJs);
/**
 * This module provides utility functions for working with arrays in TypeScript.
 *
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Array", ()=>_arrayJs);
/**
 * This module provides utility functions and type class instances for working with the `BigDecimal` type in TypeScript.
 * It includes functions for basic arithmetic operations, as well as type class instances for `Equivalence` and `Order`.
 *
 * A `BigDecimal` allows storing any real number to arbitrary precision; which avoids common floating point errors
 * (such as 0.1 + 0.2 ≠ 0.3) at the cost of complexity.
 *
 * Internally, `BigDecimal` uses a `BigInt` object, paired with a 64-bit integer which determines the position of the
 * decimal point. Therefore, the precision *is not* actually arbitrary, but limited to 2<sup>63</sup> decimal places.
 *
 * It is not recommended to convert a floating point number to a decimal directly, as the floating point representation
 * may be unexpected.
 *
 * @module BigDecimal
 * @since 2.0.0
 * @see {@link module:BigInt} for more similar operations on `bigint` types
 * @see {@link module:Number} for more similar operations on `number` types
 */ parcelHelpers.export(exports, "BigDecimal", ()=>_bigDecimalJs);
/**
 * This module provides utility functions and type class instances for working with the `bigint` type in TypeScript.
 * It includes functions for basic arithmetic operations, as well as type class instances for
 * `Equivalence` and `Order`.
 *
 * @module BigInt
 * @since 2.0.0
 * @see {@link module:BigDecimal} for more similar operations on `BigDecimal` types
 * @see {@link module:Number} for more similar operations on `number` types
 */ parcelHelpers.export(exports, "BigInt", ()=>_bigIntJs);
/**
 * This module provides utility functions and type class instances for working with the `boolean` type in TypeScript.
 * It includes functions for basic boolean operations, as well as type class instances for
 * `Equivalence` and `Order`.
 *
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Boolean", ()=>_booleanJs);
/**
 * This module provides types and utility functions to create and work with branded types,
 * which are TypeScript types with an added type tag to prevent accidental usage of a value in the wrong context.
 *
 * The `refined` and `nominal` functions are both used to create branded types in TypeScript.
 * The main difference between them is that `refined` allows for validation of the data, while `nominal` does not.
 *
 * The `nominal` function is used to create a new branded type that has the same underlying type as the input, but with a different name.
 * This is useful when you want to distinguish between two values of the same type that have different meanings.
 * The `nominal` function does not perform any validation of the input data.
 *
 * On the other hand, the `refined` function is used to create a new branded type that has the same underlying type as the input,
 * but with a different name, and it also allows for validation of the input data.
 * The `refined` function takes a predicate that is used to validate the input data.
 * If the input data fails the validation, a `BrandErrors` is returned, which provides information about the specific validation failure.
 *
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Brand", ()=>_brandJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Cache", ()=>_cacheJs);
/**
 * The `Effect<A, E, R>` type is polymorphic in values of type `E` and we can
 * work with any error type that we want. However, there is a lot of information
 * that is not inside an arbitrary `E` value. So as a result, an `Effect` needs
 * somewhere to store things like unexpected errors or defects, stack and
 * execution traces, causes of fiber interruptions, and so forth.
 *
 * Effect-TS is very strict about preserving the full information related to a
 * failure. It captures all type of errors into the `Cause` data type. `Effect`
 * uses the `Cause<E>` data type to store the full story of failure. So its
 * error model is lossless. It doesn't throw information related to the failure
 * result. So we can figure out exactly what happened during the operation of
 * our effects.
 *
 * It is important to note that `Cause` is an underlying data type representing
 * errors occuring within an `Effect` workflow. Thus, we don't usually deal with
 * `Cause`s directly. Even though it is not a data type that we deal with very
 * often, the `Cause` of a failing `Effect` workflow can be accessed at any
 * time, which gives us total access to all parallel and sequential errors in
 * occurring within our codebase.
 *
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Cause", ()=>_causeJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Channel", ()=>_channelJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "ChildExecutorDecision", ()=>_childExecutorDecisionJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Chunk", ()=>_chunkJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Clock", ()=>_clockJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Config", ()=>_configJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "ConfigError", ()=>_configErrorJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "ConfigProvider", ()=>_configProviderJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "ConfigProviderPathPatch", ()=>_configProviderPathPatchJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Console", ()=>_consoleJs);
/**
 * This module provides a data structure called `Context` that can be used for dependency injection in effectful
 * programs. It is essentially a table mapping `Tag`s to their implementations (called `Service`s), and can be used to
 * manage dependencies in a type-safe way. The `Context` data structure is essentially a way of providing access to a set
 * of related services that can be passed around as a single unit. This module provides functions to create, modify, and
 * query the contents of a `Context`, as well as a number of utility types for working with tags and services.
 *
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Context", ()=>_contextJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Cron", ()=>_cronJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Data", ()=>_dataJs);
/**
 * @since 3.6.0
 */ parcelHelpers.export(exports, "DateTime", ()=>_dateTimeJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "DefaultServices", ()=>_defaultServicesJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Deferred", ()=>_deferredJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Differ", ()=>_differJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Duration", ()=>_durationJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Effect", ()=>_effectJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Effectable", ()=>_effectableJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Either", ()=>_eitherJs);
/**
 * This module provides encoding & decoding functionality for:
 *
 * - base64 (RFC4648)
 * - base64 (URL)
 * - hex
 *
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Encoding", ()=>_encodingJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Equal", ()=>_equalJs);
/**
 * This module provides an implementation of the `Equivalence` type class, which defines a binary relation
 * that is reflexive, symmetric, and transitive. In other words, it defines a notion of equivalence between values of a certain type.
 * These properties are also known in mathematics as an "equivalence relation".
 *
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Equivalence", ()=>_equivalenceJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "ExecutionStrategy", ()=>_executionStrategyJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Exit", ()=>_exitJs);
/**
 * @since 3.10.0
 */ parcelHelpers.export(exports, "FastCheck", ()=>_fastCheckJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Fiber", ()=>_fiberJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "FiberHandle", ()=>_fiberHandleJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "FiberId", ()=>_fiberIdJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "FiberMap", ()=>_fiberMapJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "FiberRef", ()=>_fiberRefJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "FiberRefs", ()=>_fiberRefsJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "FiberRefsPatch", ()=>_fiberRefsPatchJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "FiberSet", ()=>_fiberSetJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "FiberStatus", ()=>_fiberStatusJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Function", ()=>_functionJs);
/**
 * The `GlobalValue` module ensures that a single instance of a value is created globally,
 * even when modules are imported multiple times (e.g., due to mixing CommonJS and ESM builds)
 * or during hot-reloading in development environments like Next.js or Remix.
 *
 * It achieves this by using a versioned global store, identified by a unique `Symbol` tied to
 * the current version of the `effect` library. The store holds values that are keyed by an identifier,
 * allowing the reuse of previously computed instances across imports or reloads.
 *
 * This pattern is particularly useful in scenarios where frequent reloading can cause services or
 * single-instance objects to be recreated unnecessarily, such as in development environments with hot-reloading.
 *
 * @since 2.0.0
 */ parcelHelpers.export(exports, "GlobalValue", ()=>_globalValueJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "GroupBy", ()=>_groupByJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "HKT", ()=>_hktJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Hash", ()=>_hashJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "HashMap", ()=>_hashMapJs);
/**
 * # HashSet
 *
 * An immutable `HashSet` provides a collection of unique values with efficient
 * lookup, insertion and removal. Once created, a `HashSet` cannot be modified;
 * any operation that would alter the set instead returns a new `HashSet` with
 * the changes. This immutability offers benefits like predictable state
 * management and easier reasoning about your code.
 *
 * ## What Problem Does It Solve?
 *
 * `HashSet` solves the problem of maintaining an unsorted collection where each
 * value appears exactly once, with fast operations for checking membership and
 * adding/removing values.
 *
 * ## When to Use
 *
 * Use `HashSet` when you need:
 *
 * - A collection with no duplicate values
 * - Efficient membership testing (**`O(1)`** average complexity)
 * - Set operations like union, intersection, and difference
 * - An immutable data structure that preserves functional programming patterns
 *
 * ## Advanced Features
 *
 * HashSet provides operations for:
 *
 * - Transforming sets with map and flatMap
 * - Filtering elements with filter
 * - Combining sets with union, intersection and difference
 * - Performance optimizations via mutable operations in controlled contexts
 *
 * ## Performance Characteristics
 *
 * - **Lookup** operations ({@link module:HashSet.has}): **`O(1)`** average time
 *   complexity
 * - **Insertion** operations ({@link module:HashSet.add}): **`O(1)`** average time
 *   complexity
 * - **Removal** operations ({@link module:HashSet.remove}): **`O(1)`** average
 *   time complexity
 * - **Set** operations ({@link module:HashSet.union},
 *   {@link module:HashSet.intersection}): **`O(n)`** where n is the size of the
 *   smaller set
 * - **Iteration**: **`O(n)`** where n is the size of the set
 *
 * The HashSet data structure implements the following traits:
 *
 * - {@link Iterable}: allows iterating over the values in the set
 * - {@link Equal}: allows comparing two sets for value-based equality
 * - {@link Pipeable}: allows chaining operations with the pipe operator
 * - {@link Inspectable}: allows inspecting the contents of the set
 *
 * ## Operations Reference
 *
 * | Category     | Operation                           | Description                                 | Complexity |
 * | ------------ | ----------------------------------- | ------------------------------------------- | ---------- |
 * | constructors | {@link module:HashSet.empty}        | Creates an empty HashSet                    | O(1)       |
 * | constructors | {@link module:HashSet.fromIterable} | Creates a HashSet from an iterable          | O(n)       |
 * | constructors | {@link module:HashSet.make}         | Creates a HashSet from multiple values      | O(n)       |
 * |              |                                     |                                             |            |
 * | elements     | {@link module:HashSet.has}          | Checks if a value exists in the set         | O(1) avg   |
 * | elements     | {@link module:HashSet.some}         | Checks if any element satisfies a predicate | O(n)       |
 * | elements     | {@link module:HashSet.every}        | Checks if all elements satisfy a predicate  | O(n)       |
 * | elements     | {@link module:HashSet.isSubset}     | Checks if a set is a subset of another      | O(n)       |
 * |              |                                     |                                             |            |
 * | getters      | {@link module:HashSet.values}       | Gets an iterator of all values              | O(1)       |
 * | getters      | {@link module:HashSet.toValues}     | Gets an array of all values                 | O(n)       |
 * | getters      | {@link module:HashSet.size}         | Gets the number of elements                 | O(1)       |
 * |              |                                     |                                             |            |
 * | mutations    | {@link module:HashSet.add}          | Adds a value to the set                     | O(1) avg   |
 * | mutations    | {@link module:HashSet.remove}       | Removes a value from the set                | O(1) avg   |
 * | mutations    | {@link module:HashSet.toggle}       | Toggles a value's presence                  | O(1) avg   |
 * |              |                                     |                                             |            |
 * | operations   | {@link module:HashSet.difference}   | Computes set difference (A - B)             | O(n)       |
 * | operations   | {@link module:HashSet.intersection} | Computes set intersection (A ∩ B)           | O(n)       |
 * | operations   | {@link module:HashSet.union}        | Computes set union (A ∪ B)                  | O(n)       |
 * |              |                                     |                                             |            |
 * | mapping      | {@link module:HashSet.map}          | Transforms each element                     | O(n)       |
 * |              |                                     |                                             |            |
 * | sequencing   | {@link module:HashSet.flatMap}      | Transforms and flattens elements            | O(n)       |
 * |              |                                     |                                             |            |
 * | traversing   | {@link module:HashSet.forEach}      | Applies a function to each element          | O(n)       |
 * |              |                                     |                                             |            |
 * | folding      | {@link module:HashSet.reduce}       | Reduces the set to a single value           | O(n)       |
 * |              |                                     |                                             |            |
 * | filtering    | {@link module:HashSet.filter}       | Keeps elements that satisfy a predicate     | O(n)       |
 * |              |                                     |                                             |            |
 * | partitioning | {@link module:HashSet.partition}    | Splits into two sets by a predicate         | O(n)       |
 *
 * ## Notes
 *
 * ### Composability with the Effect Ecosystem:
 *
 * This `HashSet` is designed to work seamlessly within the Effect ecosystem. It
 * implements the {@link Iterable}, {@link Equal}, {@link Pipeable}, and
 * {@link Inspectable} traits from Effect. This ensures compatibility with other
 * Effect data structures and functionalities. For example, you can easily use
 * Effect's `pipe` method to chain operations on the `HashSet`.
 *
 * **Equality of Elements with Effect's {@link Equal `Equal`} Trait:**
 *
 * This `HashSet` relies on Effect's {@link Equal} trait to determine the
 * uniqueness of elements within the set. The way equality is checked depends on
 * the type of the elements:
 *
 * - **Primitive Values:** For primitive JavaScript values like strings, numbers,
 *   booleans, `null`, and `undefined`, equality is determined by their value
 *   (similar to the `===` operator).
 * - **Objects and Custom Types:** For objects and other custom types, equality is
 *   determined by whether those types implement the {@link Equal} interface
 *   themselves. If an element type implements `Equal`, the `HashSet` will
 *   delegate to that implementation to perform the equality check. This allows
 *   you to define custom logic for determining when two instances of your
 *   objects should be considered equal based on their properties, rather than
 *   just their object identity.
 *
 * ```ts
 * import { Equal, Hash, HashSet } from "effect"
 *
 * class Person implements Equal.Equal {
 *   constructor(
 *     readonly id: number, // Unique identifier
 *     readonly name: string,
 *     readonly age: number
 *   ) {}
 *
 *   // Define equality based on id, name, and age
 *   [Equal.symbol](that: Equal.Equal): boolean {
 *     if (that instanceof Person) {
 *       return (
 *         Equal.equals(this.id, that.id) &&
 *         Equal.equals(this.name, that.name) &&
 *         Equal.equals(this.age, that.age)
 *       )
 *     }
 *     return false
 *   }
 *
 *   // Generate a hash code based on the unique id
 *   [Hash.symbol](): number {
 *     return Hash.hash(this.id)
 *   }
 * }
 *
 * // Creating a HashSet with objects that implement the Equal interface
 * const set = HashSet.empty().pipe(
 *   HashSet.add(new Person(1, "Alice", 30)),
 *   HashSet.add(new Person(1, "Alice", 30))
 * )
 *
 * // HashSet recognizes them as equal, so only one element is stored
 * console.log(HashSet.size(set))
 * // Output: 1
 * ```
 *
 * **Simplifying Equality and Hashing with `Data` and `Schema`:**
 *
 * Effect's {@link Data} and {@link Schema `Schema.Data`} modules offer powerful
 * ways to automatically handle the implementation of both the {@link Equal} and
 * {@link Hash} traits for your custom data structures.
 *
 * - **`Data` Module:** By using constructors like `Data.struct`, `Data.tuple`,
 *   `Data.array`, or `Data.case` to define your data types, Effect
 *   automatically generates the necessary implementations for value-based
 *   equality and consistent hashing. This significantly reduces boilerplate and
 *   ensures correctness.
 *
 * ```ts
 * import { HashSet, Data, Equal } from "effect"
 * import assert from "node:assert/strict"
 *
 * // Data.* implements the `Equal` traits for us
 * const person1 = Data.struct({ id: 1, name: "Alice", age: 30 })
 * const person2 = Data.struct({ id: 1, name: "Alice", age: 30 })
 *
 * assert(Equal.equals(person1, person2))
 *
 * const set = HashSet.empty().pipe(
 *   HashSet.add(person1),
 *   HashSet.add(person2)
 * )
 *
 * // HashSet recognizes them as equal, so only one element is stored
 * console.log(HashSet.size(set)) // Output: 1
 * ```
 *
 * - **`Schema` Module:** When defining data schemas using the {@link Schema}
 *   module, you can use `Schema.Data` to automatically include the `Equal` and
 *   `Hash` traits in the decoded objects. This is particularly important when
 *   working with `HashSet`. **For decoded objects to be correctly recognized as
 *   equal within a `HashSet`, ensure that the schema for those objects is
 *   defined using `Schema.Data`.**
 *
 * ```ts
 * import { Equal, HashSet, Schema } from "effect"
 * import assert from "node:assert/strict"
 *
 * // Schema.Data implements the `Equal` traits for us
 * const PersonSchema = Schema.Data(
 *   Schema.Struct({
 *     id: Schema.Number,
 *     name: Schema.String,
 *     age: Schema.Number
 *   })
 * )
 *
 * const Person = Schema.decode(PersonSchema)
 *
 * const person1 = Person({ id: 1, name: "Alice", age: 30 })
 * const person2 = Person({ id: 1, name: "Alice", age: 30 })
 *
 * assert(Equal.equals(person1, person2)) // Output: true
 *
 * const set = HashSet.empty().pipe(
 *   HashSet.add(person1),
 *   HashSet.add(person2)
 * )
 *
 * // HashSet thanks to Schema.Data implementation of the `Equal` trait, recognizes the two Person as equal, so only one element is stored
 * console.log(HashSet.size(set)) // Output: 1
 * ```
 *
 * ### Interoperability with the JavaScript Runtime:
 *
 * To interoperate with the regular JavaScript runtime, Effect's `HashSet`
 * provides methods to access its elements in formats readily usable by
 * JavaScript APIs: {@link values `HashSet.values`},
 * {@link toValues `HashSet.toValues`}
 *
 * ```ts
 * import { HashSet } from "effect"
 *
 * const hashSet: HashSet.HashSet<number> = HashSet.make(1, 2, 3)
 *
 * // Using HashSet.values to convert HashSet.HashSet<A> to IterableIterator<A>
 * const iterable: IterableIterator<number> = HashSet.values(hashSet)
 *
 * console.log(...iterable) // Logs:  1 2 3
 *
 * // Using HashSet.toValues to convert HashSet.HashSet<A> to Array<A>
 * const array: Array<number> = HashSet.toValues(hashSet)
 *
 * console.log(array) // Logs: [ 1, 2, 3 ]
 * ```
 *
 * Be mindful of performance implications (both time and space complexity) when
 * frequently converting between Effect's immutable HashSet and mutable
 * JavaScript data structures, especially for large collections.
 *
 * @module HashSet
 * @since 2.0.0
 */ parcelHelpers.export(exports, "HashSet", ()=>_hashSetJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Inspectable", ()=>_inspectableJs);
/**
 * This module provides utility functions for working with Iterables in TypeScript.
 *
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Iterable", ()=>_iterableJs);
/**
 * @since 3.10.0
 */ parcelHelpers.export(exports, "JSONSchema", ()=>_jsonschemaJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "KeyedPool", ()=>_keyedPoolJs);
/**
 * A `Layer<ROut, E, RIn>` describes how to build one or more services in your
 * application. Services can be injected into effects via
 * `Effect.provideService`. Effects can require services via `Effect.service`.
 *
 * Layer can be thought of as recipes for producing bundles of services, given
 * their dependencies (other services).
 *
 * Construction of services can be effectful and utilize resources that must be
 * acquired and safely released when the services are done being utilized.
 *
 * By default layers are shared, meaning that if the same layer is used twice
 * the layer will only be allocated a single time.
 *
 * Because of their excellent composition properties, layers are the idiomatic
 * way in Effect-TS to create services that depend on other services.
 *
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Layer", ()=>_layerJs);
/**
 * @since 3.14.0
 * @experimental
 */ parcelHelpers.export(exports, "LayerMap", ()=>_layerMapJs);
/**
 * A data type for immutable linked lists representing ordered collections of elements of type `A`.
 *
 * This data type is optimal for last-in-first-out (LIFO), stack-like access patterns. If you need another access pattern, for example, random access or FIFO, consider using a collection more suited to this than `List`.
 *
 * **Performance**
 *
 * - Time: `List` has `O(1)` prepend and head/tail access. Most other operations are `O(n)` on the number of elements in the list. This includes the index-based lookup of elements, `length`, `append` and `reverse`.
 * - Space: `List` implements structural sharing of the tail list. This means that many operations are either zero- or constant-memory cost.
 *
 * @since 2.0.0
 */ parcelHelpers.export(exports, "List", ()=>_listJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "LogLevel", ()=>_logLevelJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "LogSpan", ()=>_logSpanJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Logger", ()=>_loggerJs);
/**
 * @since 3.8.0
 * @experimental
 */ parcelHelpers.export(exports, "Mailbox", ()=>_mailboxJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "ManagedRuntime", ()=>_managedRuntimeJs);
/**
 * The `effect/match` module provides a type-safe pattern matching system for
 * TypeScript. Inspired by functional programming, it simplifies conditional
 * logic by replacing verbose if/else or switch statements with a structured and
 * expressive API.
 *
 * This module supports matching against types, values, and discriminated unions
 * while enforcing exhaustiveness checking to ensure all cases are handled.
 *
 * Although pattern matching is not yet a native JavaScript feature,
 * `effect/match` offers a reliable implementation that is available today.
 *
 * **How Pattern Matching Works**
 *
 * Pattern matching follows a structured process:
 *
 * - **Creating a matcher**: Define a `Matcher` that operates on either a
 *   specific `Match.type` or `Match.value`.
 *
 * - **Defining patterns**: Use combinators such as `Match.when`, `Match.not`,
 *   and `Match.tag` to specify matching conditions.
 *
 * - **Completing the match**: Apply a finalizer such as `Match.exhaustive`,
 *   `Match.orElse`, or `Match.option` to determine how unmatched cases should
 *   be handled.
 *
 * @since 1.0.0
 */ parcelHelpers.export(exports, "Match", ()=>_matchJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "MergeDecision", ()=>_mergeDecisionJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "MergeState", ()=>_mergeStateJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "MergeStrategy", ()=>_mergeStrategyJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Metric", ()=>_metricJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "MetricBoundaries", ()=>_metricBoundariesJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "MetricHook", ()=>_metricHookJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "MetricKey", ()=>_metricKeyJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "MetricKeyType", ()=>_metricKeyTypeJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "MetricLabel", ()=>_metricLabelJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "MetricPair", ()=>_metricPairJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "MetricPolling", ()=>_metricPollingJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "MetricRegistry", ()=>_metricRegistryJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "MetricState", ()=>_metricStateJs);
/**
 * A lightweight alternative to the `Effect` data type, with a subset of the functionality.
 *
 * @since 3.4.0
 * @experimental
 */ parcelHelpers.export(exports, "Micro", ()=>_microJs);
/**
 * @since 2.0.0
 *
 * Enables low level framework authors to run on their own isolated effect version
 */ parcelHelpers.export(exports, "ModuleVersion", ()=>_moduleVersionJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "MutableHashMap", ()=>_mutableHashMapJs);
/**
 * # MutableHashSet
 *
 * A mutable `MutableHashSet` provides a collection of unique values with
 * efficient lookup, insertion and removal. Unlike its immutable sibling
 * {@link module:HashSet}, a `MutableHashSet` can be modified in-place;
 * operations like add, remove, and clear directly modify the original set
 * rather than creating a new one. This mutability offers benefits like improved
 * performance in scenarios where you need to build or modify a set
 * incrementally.
 *
 * ## What Problem Does It Solve?
 *
 * `MutableHashSet` solves the problem of maintaining an unsorted collection
 * where each value appears exactly once, with fast operations for checking
 * membership and adding/removing values, in contexts where mutability is
 * preferred for performance or implementation simplicity.
 *
 * ## When to Use
 *
 * Use `MutableHashSet` when you need:
 *
 * - A collection with no duplicate values
 * - Efficient membership testing (**`O(1)`** average complexity)
 * - In-place modifications for better performance
 * - A set that will be built or modified incrementally
 * - Local mutability in otherwise immutable code
 *
 * ## Advanced Features
 *
 * MutableHashSet provides operations for:
 *
 * - Adding and removing elements with direct mutation
 * - Checking for element existence
 * - Clearing all elements at once
 * - Converting to/from other collection types
 *
 * ## Performance Characteristics
 *
 * - **Lookup** operations ({@link module:MutableHashSet.has}): **`O(1)`** average
 *   time complexity
 * - **Insertion** operations ({@link module:MutableHashSet.add}): **`O(1)`**
 *   average time complexity
 * - **Removal** operations ({@link module:MutableHashSet.remove}): **`O(1)`**
 *   average time complexity
 * - **Iteration**: **`O(n)`** where n is the size of the set
 *
 * The MutableHashSet data structure implements the following traits:
 *
 * - {@link Iterable}: allows iterating over the values in the set
 * - {@link Pipeable}: allows chaining operations with the pipe operator
 * - {@link Inspectable}: allows inspecting the contents of the set
 *
 * ## Operations Reference
 *
 * | Category     | Operation                                  | Description                         | Complexity |
 * | ------------ | ------------------------------------------ | ----------------------------------- | ---------- |
 * | constructors | {@link module:MutableHashSet.empty}        | Creates an empty MutableHashSet     | O(1)       |
 * | constructors | {@link module:MutableHashSet.fromIterable} | Creates a set from an iterable      | O(n)       |
 * | constructors | {@link module:MutableHashSet.make}         | Creates a set from multiple values  | O(n)       |
 * |              |                                            |                                     |            |
 * | elements     | {@link module:MutableHashSet.has}          | Checks if a value exists in the set | O(1) avg   |
 * | elements     | {@link module:MutableHashSet.add}          | Adds a value to the set             | O(1) avg   |
 * | elements     | {@link module:MutableHashSet.remove}       | Removes a value from the set        | O(1) avg   |
 * | elements     | {@link module:MutableHashSet.size}         | Gets the number of elements         | O(1)       |
 * | elements     | {@link module:MutableHashSet.clear}        | Removes all values from the set     | O(1)       |
 *
 * ## Notes
 *
 * ### Mutability Considerations:
 *
 * Unlike most data structures in the Effect ecosystem, `MutableHashSet` is
 * mutable. This means that operations like `add`, `remove`, and `clear` modify
 * the original set rather than creating a new one. This can lead to more
 * efficient code in some scenarios, but requires careful handling to avoid
 * unexpected side effects.
 *
 * ### When to Choose `MutableHashSet` vs {@link module:HashSet}:
 *
 * - Use `MutableHashSet` when you need to build or modify a set incrementally and
 *   performance is a priority
 * - Use `HashSet` when you want immutability guarantees and functional
 *   programming patterns
 * - Consider using {@link module:HashSet}'s bounded mutation context (via
 *   {@link module:HashSet.beginMutation}, {@link module:HashSet.endMutation}, and
 *   {@link module:HashSet.mutate} methods) when you need temporary mutability
 *   within an otherwise immutable context - this approach might be sufficient
 *   for many use cases without requiring a separate `MutableHashSet`
 * - `MutableHashSet` is often useful for local operations where the mutability is
 *   contained and doesn't leak into the broader application
 *
 * @module MutableHashSet
 * @since 2.0.0
 */ parcelHelpers.export(exports, "MutableHashSet", ()=>_mutableHashSetJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "MutableList", ()=>_mutableListJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "MutableQueue", ()=>_mutableQueueJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "MutableRef", ()=>_mutableRefJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "NonEmptyIterable", ()=>_nonEmptyIterableJs);
/**
 * # Number
 *
 * This module provides utility functions and type class instances for working
 * with the `number` type in TypeScript. It includes functions for basic
 * arithmetic operations, as well as type class instances for `Equivalence` and
 * `Order`.
 *
 * ## Operations Reference
 *
 * | Category     | Operation                                  | Description                                             | Domain                         | Co-domain             |
 * | ------------ | ------------------------------------------ | ------------------------------------------------------- | ------------------------------ | --------------------- |
 * | constructors | {@link module:Number.parse}                | Safely parses a string to a number                      | `string`                       | `Option<number>`      |
 * |              |                                            |                                                         |                                |                       |
 * | math         | {@link module:Number.sum}                  | Adds two numbers                                        | `number`, `number`             | `number`              |
 * | math         | {@link module:Number.sumAll}               | Sums all numbers in a collection                        | `Iterable<number>`             | `number`              |
 * | math         | {@link module:Number.subtract}             | Subtracts one number from another                       | `number`, `number`             | `number`              |
 * | math         | {@link module:Number.multiply}             | Multiplies two numbers                                  | `number`, `number`             | `number`              |
 * | math         | {@link module:Number.multiplyAll}          | Multiplies all numbers in a collection                  | `Iterable<number>`             | `number`              |
 * | math         | {@link module:Number.divide}               | Safely divides handling division by zero                | `number`, `number`             | `Option<number>`      |
 * | math         | {@link module:Number.unsafeDivide}         | Divides but misbehaves for division by zero             | `number`, `number`             | `number`              |
 * | math         | {@link module:Number.remainder}            | Calculates remainder of division                        | `number`, `number`             | `number`              |
 * | math         | {@link module:Number.increment}            | Adds 1 to a number                                      | `number`                       | `number`              |
 * | math         | {@link module:Number.decrement}            | Subtracts 1 from a number                               | `number`                       | `number`              |
 * | math         | {@link module:Number.sign}                 | Determines the sign of a number                         | `number`                       | `Ordering`            |
 * | math         | {@link module:Number.nextPow2}             | Finds the next power of 2                               | `number`                       | `number`              |
 * | math         | {@link module:Number.round}                | Rounds a number with specified precision                | `number`, `number`             | `number`              |
 * |              |                                            |                                                         |                                |                       |
 * | predicates   | {@link module:Number.between}              | Checks if a number is in a range                        | `number`, `{minimum, maximum}` | `boolean`             |
 * | predicates   | {@link module:Number.lessThan}             | Checks if one number is less than another               | `number`, `number`             | `boolean`             |
 * | predicates   | {@link module:Number.lessThanOrEqualTo}    | Checks if one number is less than or equal              | `number`, `number`             | `boolean`             |
 * | predicates   | {@link module:Number.greaterThan}          | Checks if one number is greater than another            | `number`, `number`             | `boolean`             |
 * | predicates   | {@link module:Number.greaterThanOrEqualTo} | Checks if one number is greater or equal                | `number`, `number`             | `boolean`             |
 * |              |                                            |                                                         |                                |                       |
 * | guards       | {@link module:Number.isNumber}             | Type guard for JavaScript numbers                       | `unknown`                      | `boolean`             |
 * |              |                                            |                                                         |                                |                       |
 * | comparison   | {@link module:Number.min}                  | Returns the minimum of two numbers                      | `number`, `number`             | `number`              |
 * | comparison   | {@link module:Number.max}                  | Returns the maximum of two numbers                      | `number`, `number`             | `number`              |
 * | comparison   | {@link module:Number.clamp}                | Restricts a number to a range                           | `number`, `{minimum, maximum}` | `number`              |
 * |              |                                            |                                                         |                                |                       |
 * | instances    | {@link module:Number.Equivalence}          | Equivalence instance for numbers                        |                                | `Equivalence<number>` |
 * | instances    | {@link module:Number.Order}                | Order instance for numbers                              |                                | `Order<number>`       |
 * |              |                                            |                                                         |                                |                       |
 * | errors       | {@link module:Number.DivisionByZeroError}  | Error thrown by unsafeDivide                            |                                |                       |
 *
 * ## Composition Patterns and Type Safety
 *
 * When building function pipelines, understanding how types flow through
 * operations is critical:
 *
 * ### Composing with type-preserving operations
 *
 * Most operations in this module are type-preserving (`number → number`),
 * making them easily composable in pipelines:
 *
 * ```ts
 * import { pipe } from "effect"
 * import * as Number from "effect/Number"
 *
 * const result = pipe(
 *   10,
 *   Number.increment, // number → number
 *   Number.multiply(2), // number → number
 *   Number.round(1) // number → number
 * ) // Result: number (21)
 * ```
 *
 * ### Working with Option results
 *
 * Operations that might fail (like division by zero) return Option types and
 * require Option combinators:
 *
 * ```ts
 * import { pipe, Option } from "effect"
 * import * as Number from "effect/Number"
 *
 * const result = pipe(
 *   10,
 *   Number.divide(0), // number → Option<number>
 *   Option.getOrElse(() => 0) // Option<number> → number
 * ) // Result: number (0)
 * ```
 *
 * ### Composition best practices
 *
 * - Chain type-preserving operations for maximum composability
 * - Use Option combinators when working with potentially failing operations
 * - Consider using Effect for operations that might fail with specific errors
 * - Remember that all operations maintain JavaScript's floating-point precision
 *   limitations
 *
 * @module Number
 * @since 2.0.0
 * @see {@link module:BigInt} for more similar operations on `bigint` types
 * @see {@link module:BigDecimal} for more similar operations on `BigDecimal` types
 */ parcelHelpers.export(exports, "Number", ()=>_numberJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Option", ()=>_optionJs);
/**
 * This module provides an implementation of the `Order` type class which is used to define a total ordering on some type `A`.
 * An order is defined by a relation `<=`, which obeys the following laws:
 *
 * - either `x <= y` or `y <= x` (totality)
 * - if `x <= y` and `y <= x`, then `x == y` (antisymmetry)
 * - if `x <= y` and `y <= z`, then `x <= z` (transitivity)
 *
 * The truth table for compare is defined as follows:
 *
 * | `x <= y` | `x >= y` | Ordering |                       |
 * | -------- | -------- | -------- | --------------------- |
 * | `true`   | `true`   | `0`      | corresponds to x == y |
 * | `true`   | `false`  | `< 0`    | corresponds to x < y  |
 * | `false`  | `true`   | `> 0`    | corresponds to x > y  |
 *
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Order", ()=>_orderJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Ordering", ()=>_orderingJs);
/**
 * @since 3.10.0
 */ parcelHelpers.export(exports, "ParseResult", ()=>_parseResultJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Pipeable", ()=>_pipeableJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Pool", ()=>_poolJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Predicate", ()=>_predicateJs);
/**
 * @since 3.10.0
 */ parcelHelpers.export(exports, "Pretty", ()=>_prettyJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "PrimaryKey", ()=>_primaryKeyJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "PubSub", ()=>_pubSubJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Queue", ()=>_queueJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Random", ()=>_randomJs);
/**
 * Limits the number of calls to a resource to a maximum amount in some interval.
 *
 * @since 2.0.0
 */ parcelHelpers.export(exports, "RateLimiter", ()=>_rateLimiterJs);
/**
 * @since 3.5.0
 */ parcelHelpers.export(exports, "RcMap", ()=>_rcMapJs);
/**
 * @since 3.5.0
 */ parcelHelpers.export(exports, "RcRef", ()=>_rcRefJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Readable", ()=>_readableJs);
/**
 * This module provides utility functions for working with records in TypeScript.
 *
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Record", ()=>_recordJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "RedBlackTree", ()=>_redBlackTreeJs);
/**
 * The Redacted module provides functionality for handling sensitive information
 * securely within your application. By using the `Redacted` data type, you can
 * ensure that sensitive values are not accidentally exposed in logs or error
 * messages.
 *
 * @since 3.3.0
 */ parcelHelpers.export(exports, "Redacted", ()=>_redactedJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Ref", ()=>_refJs);
/**
 * This module provides utility functions for working with RegExp in TypeScript.
 *
 * @since 2.0.0
 */ parcelHelpers.export(exports, "RegExp", ()=>_regExpJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Reloadable", ()=>_reloadableJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Request", ()=>_requestJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "RequestBlock", ()=>_requestBlockJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "RequestResolver", ()=>_requestResolverJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Resource", ()=>_resourceJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Runtime", ()=>_runtimeJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "RuntimeFlags", ()=>_runtimeFlagsJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "RuntimeFlagsPatch", ()=>_runtimeFlagsPatchJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "STM", ()=>_stmJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Schedule", ()=>_scheduleJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "ScheduleDecision", ()=>_scheduleDecisionJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "ScheduleInterval", ()=>_scheduleIntervalJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "ScheduleIntervals", ()=>_scheduleIntervalsJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Scheduler", ()=>_schedulerJs);
/**
 * @since 3.10.0
 */ parcelHelpers.export(exports, "Schema", ()=>_schemaJs);
/**
 * @since 3.10.0
 */ parcelHelpers.export(exports, "SchemaAST", ()=>_schemaASTJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Scope", ()=>_scopeJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "ScopedCache", ()=>_scopedCacheJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "ScopedRef", ()=>_scopedRefJs);
/**
 * @since 2.0.0
 * @deprecated
 */ parcelHelpers.export(exports, "Secret", ()=>_secretJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "SingleProducerAsyncInput", ()=>_singleProducerAsyncInputJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Sink", ()=>_sinkJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "SortedMap", ()=>_sortedMapJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "SortedSet", ()=>_sortedSetJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Stream", ()=>_streamJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "StreamEmit", ()=>_streamEmitJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "StreamHaltStrategy", ()=>_streamHaltStrategyJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Streamable", ()=>_streamableJs);
/**
 * This module provides utility functions and type class instances for working with the `string` type in TypeScript.
 * It includes functions for basic string manipulation, as well as type class instances for
 * `Equivalence` and `Order`.
 *
 * @since 2.0.0
 */ parcelHelpers.export(exports, "String", ()=>_stringJs);
/**
 * This module provides utility functions for working with structs in TypeScript.
 *
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Struct", ()=>_structJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Subscribable", ()=>_subscribableJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "SubscriptionRef", ()=>_subscriptionRefJs);
/**
 * A `Supervisor<T>` is allowed to supervise the launching and termination of
 * fibers, producing some visible value of type `T` from the supervision.
 *
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Supervisor", ()=>_supervisorJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Symbol", ()=>_symbolJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "SynchronizedRef", ()=>_synchronizedRefJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "TArray", ()=>_tarrayJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "TDeferred", ()=>_tdeferredJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "TMap", ()=>_tmapJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "TPriorityQueue", ()=>_tpriorityQueueJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "TPubSub", ()=>_tpubSubJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "TQueue", ()=>_tqueueJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "TRandom", ()=>_trandomJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "TReentrantLock", ()=>_treentrantLockJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "TRef", ()=>_trefJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "TSemaphore", ()=>_tsemaphoreJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "TSet", ()=>_tsetJs);
/**
 * @since 3.10.0
 */ parcelHelpers.export(exports, "TSubscriptionRef", ()=>_tsubscriptionRefJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Take", ()=>_takeJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "TestAnnotation", ()=>_testAnnotationJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "TestAnnotationMap", ()=>_testAnnotationMapJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "TestAnnotations", ()=>_testAnnotationsJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "TestClock", ()=>_testClockJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "TestConfig", ()=>_testConfigJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "TestContext", ()=>_testContextJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "TestLive", ()=>_testLiveJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "TestServices", ()=>_testServicesJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "TestSized", ()=>_testSizedJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Tracer", ()=>_tracerJs);
/**
 * A `Trie` is used for locating specific `string` keys from within a set.
 *
 * It works similar to `HashMap`, but with keys required to be `string`.
 * This constraint unlocks some performance optimizations and new methods to get string prefixes (e.g. `keysWithPrefix`, `longestPrefixOf`).
 *
 * Prefix search is also the main feature that makes a `Trie` more suited than `HashMap` for certain usecases.
 *
 * A `Trie` is often used to store a dictionary (list of words) that can be searched
 * in a manner that allows for efficient generation of completion lists
 * (e.g. predict the rest of a word a user is typing).
 *
 * A `Trie` has O(n) lookup time where `n` is the size of the key,
 * or even less than `n` on search misses.
 *
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Trie", ()=>_trieJs);
/**
 * This module provides utility functions for working with tuples in TypeScript.
 *
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Tuple", ()=>_tupleJs);
/**
 * A collection of types that are commonly used types.
 *
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Types", ()=>_typesJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Unify", ()=>_unifyJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "UpstreamPullRequest", ()=>_upstreamPullRequestJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "UpstreamPullStrategy", ()=>_upstreamPullStrategyJs);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Utils", ()=>_utilsJs);
var _functionJs = require("./Function.js");
var _arbitraryJs = require("./Arbitrary.js");
var _arrayJs = require("./Array.js");
var _bigDecimalJs = require("./BigDecimal.js");
var _bigIntJs = require("./BigInt.js");
var _booleanJs = require("./Boolean.js");
var _brandJs = require("./Brand.js");
var _cacheJs = require("./Cache.js");
var _causeJs = require("./Cause.js");
var _channelJs = require("./Channel.js");
var _childExecutorDecisionJs = require("./ChildExecutorDecision.js");
var _chunkJs = require("./Chunk.js");
var _clockJs = require("./Clock.js");
var _configJs = require("./Config.js");
var _configErrorJs = require("./ConfigError.js");
var _configProviderJs = require("./ConfigProvider.js");
var _configProviderPathPatchJs = require("./ConfigProviderPathPatch.js");
var _consoleJs = require("./Console.js");
var _contextJs = require("./Context.js");
var _cronJs = require("./Cron.js");
var _dataJs = require("./Data.js");
var _dateTimeJs = require("./DateTime.js");
var _defaultServicesJs = require("./DefaultServices.js");
var _deferredJs = require("./Deferred.js");
var _differJs = require("./Differ.js");
var _durationJs = require("./Duration.js");
var _effectJs = require("./Effect.js");
var _effectableJs = require("./Effectable.js");
var _eitherJs = require("./Either.js");
var _encodingJs = require("./Encoding.js");
var _equalJs = require("./Equal.js");
var _equivalenceJs = require("./Equivalence.js");
var _executionStrategyJs = require("./ExecutionStrategy.js");
var _exitJs = require("./Exit.js");
var _fastCheckJs = require("./FastCheck.js");
var _fiberJs = require("./Fiber.js");
var _fiberHandleJs = require("./FiberHandle.js");
var _fiberIdJs = require("./FiberId.js");
var _fiberMapJs = require("./FiberMap.js");
var _fiberRefJs = require("./FiberRef.js");
var _fiberRefsJs = require("./FiberRefs.js");
var _fiberRefsPatchJs = require("./FiberRefsPatch.js");
var _fiberSetJs = require("./FiberSet.js");
var _fiberStatusJs = require("./FiberStatus.js");
var _globalValueJs = require("./GlobalValue.js");
var _groupByJs = require("./GroupBy.js");
var _hktJs = require("./HKT.js");
var _hashJs = require("./Hash.js");
var _hashMapJs = require("./HashMap.js");
var _hashSetJs = require("./HashSet.js");
var _inspectableJs = require("./Inspectable.js");
var _iterableJs = require("./Iterable.js");
var _jsonschemaJs = require("./JSONSchema.js");
var _keyedPoolJs = require("./KeyedPool.js");
var _layerJs = require("./Layer.js");
var _layerMapJs = require("./LayerMap.js");
var _listJs = require("./List.js");
var _logLevelJs = require("./LogLevel.js");
var _logSpanJs = require("./LogSpan.js");
var _loggerJs = require("./Logger.js");
var _mailboxJs = require("./Mailbox.js");
var _managedRuntimeJs = require("./ManagedRuntime.js");
var _matchJs = require("./Match.js");
var _mergeDecisionJs = require("./MergeDecision.js");
var _mergeStateJs = require("./MergeState.js");
var _mergeStrategyJs = require("./MergeStrategy.js");
var _metricJs = require("./Metric.js");
var _metricBoundariesJs = require("./MetricBoundaries.js");
var _metricHookJs = require("./MetricHook.js");
var _metricKeyJs = require("./MetricKey.js");
var _metricKeyTypeJs = require("./MetricKeyType.js");
var _metricLabelJs = require("./MetricLabel.js");
var _metricPairJs = require("./MetricPair.js");
var _metricPollingJs = require("./MetricPolling.js");
var _metricRegistryJs = require("./MetricRegistry.js");
var _metricStateJs = require("./MetricState.js");
var _microJs = require("./Micro.js");
var _moduleVersionJs = require("./ModuleVersion.js");
var _mutableHashMapJs = require("./MutableHashMap.js");
var _mutableHashSetJs = require("./MutableHashSet.js");
var _mutableListJs = require("./MutableList.js");
var _mutableQueueJs = require("./MutableQueue.js");
var _mutableRefJs = require("./MutableRef.js");
var _nonEmptyIterableJs = require("./NonEmptyIterable.js");
var _numberJs = require("./Number.js");
var _optionJs = require("./Option.js");
var _orderJs = require("./Order.js");
var _orderingJs = require("./Ordering.js");
var _parseResultJs = require("./ParseResult.js");
var _pipeableJs = require("./Pipeable.js");
var _poolJs = require("./Pool.js");
var _predicateJs = require("./Predicate.js");
var _prettyJs = require("./Pretty.js");
var _primaryKeyJs = require("./PrimaryKey.js");
var _pubSubJs = require("./PubSub.js");
var _queueJs = require("./Queue.js");
var _randomJs = require("./Random.js");
var _rateLimiterJs = require("./RateLimiter.js");
var _rcMapJs = require("./RcMap.js");
var _rcRefJs = require("./RcRef.js");
var _readableJs = require("./Readable.js");
var _recordJs = require("./Record.js");
var _redBlackTreeJs = require("./RedBlackTree.js");
var _redactedJs = require("./Redacted.js");
var _refJs = require("./Ref.js");
var _regExpJs = require("./RegExp.js");
var _reloadableJs = require("./Reloadable.js");
var _requestJs = require("./Request.js");
var _requestBlockJs = require("./RequestBlock.js");
var _requestResolverJs = require("./RequestResolver.js");
var _resourceJs = require("./Resource.js");
var _runtimeJs = require("./Runtime.js");
var _runtimeFlagsJs = require("./RuntimeFlags.js");
var _runtimeFlagsPatchJs = require("./RuntimeFlagsPatch.js");
var _stmJs = require("./STM.js");
var _scheduleJs = require("./Schedule.js");
var _scheduleDecisionJs = require("./ScheduleDecision.js");
var _scheduleIntervalJs = require("./ScheduleInterval.js");
var _scheduleIntervalsJs = require("./ScheduleIntervals.js");
var _schedulerJs = require("./Scheduler.js");
var _schemaJs = require("./Schema.js");
var _schemaASTJs = require("./SchemaAST.js");
var _scopeJs = require("./Scope.js");
var _scopedCacheJs = require("./ScopedCache.js");
var _scopedRefJs = require("./ScopedRef.js");
var _secretJs = require("./Secret.js");
var _singleProducerAsyncInputJs = require("./SingleProducerAsyncInput.js");
var _sinkJs = require("./Sink.js");
var _sortedMapJs = require("./SortedMap.js");
var _sortedSetJs = require("./SortedSet.js");
var _streamJs = require("./Stream.js");
var _streamEmitJs = require("./StreamEmit.js");
var _streamHaltStrategyJs = require("./StreamHaltStrategy.js");
var _streamableJs = require("./Streamable.js");
var _stringJs = require("./String.js");
var _structJs = require("./Struct.js");
var _subscribableJs = require("./Subscribable.js");
var _subscriptionRefJs = require("./SubscriptionRef.js");
var _supervisorJs = require("./Supervisor.js");
var _symbolJs = require("./Symbol.js");
var _synchronizedRefJs = require("./SynchronizedRef.js");
var _tarrayJs = require("./TArray.js");
var _tdeferredJs = require("./TDeferred.js");
var _tmapJs = require("./TMap.js");
var _tpriorityQueueJs = require("./TPriorityQueue.js");
var _tpubSubJs = require("./TPubSub.js");
var _tqueueJs = require("./TQueue.js");
var _trandomJs = require("./TRandom.js");
var _treentrantLockJs = require("./TReentrantLock.js");
var _trefJs = require("./TRef.js");
var _tsemaphoreJs = require("./TSemaphore.js");
var _tsetJs = require("./TSet.js");
var _tsubscriptionRefJs = require("./TSubscriptionRef.js");
var _takeJs = require("./Take.js");
var _testAnnotationJs = require("./TestAnnotation.js");
var _testAnnotationMapJs = require("./TestAnnotationMap.js");
var _testAnnotationsJs = require("./TestAnnotations.js");
var _testClockJs = require("./TestClock.js");
var _testConfigJs = require("./TestConfig.js");
var _testContextJs = require("./TestContext.js");
var _testLiveJs = require("./TestLive.js");
var _testServicesJs = require("./TestServices.js");
var _testSizedJs = require("./TestSized.js");
var _tracerJs = require("./Tracer.js");
var _trieJs = require("./Trie.js");
var _tupleJs = require("./Tuple.js");
var _typesJs = require("./Types.js");
var _unifyJs = require("./Unify.js");
var _upstreamPullRequestJs = require("./UpstreamPullRequest.js");
var _upstreamPullStrategyJs = require("./UpstreamPullStrategy.js");
var _utilsJs = require("./Utils.js");

},{"./Function.js":"21gOL","./Arbitrary.js":false,"./Array.js":"8L2Gk","./BigDecimal.js":false,"./BigInt.js":false,"./Boolean.js":false,"./Brand.js":false,"./Cache.js":false,"./Cause.js":false,"./Channel.js":false,"./ChildExecutorDecision.js":false,"./Chunk.js":false,"./Clock.js":false,"./Config.js":false,"./ConfigError.js":false,"./ConfigProvider.js":false,"./ConfigProviderPathPatch.js":false,"./Console.js":false,"./Context.js":false,"./Cron.js":false,"./Data.js":false,"./DateTime.js":false,"./DefaultServices.js":false,"./Deferred.js":false,"./Differ.js":false,"./Duration.js":false,"./Effect.js":"j5L8O","./Effectable.js":false,"./Either.js":false,"./Encoding.js":false,"./Equal.js":false,"./Equivalence.js":false,"./ExecutionStrategy.js":false,"./Exit.js":false,"./FastCheck.js":false,"./Fiber.js":false,"./FiberHandle.js":false,"./FiberId.js":false,"./FiberMap.js":false,"./FiberRef.js":false,"./FiberRefs.js":false,"./FiberRefsPatch.js":false,"./FiberSet.js":false,"./FiberStatus.js":false,"./GlobalValue.js":false,"./GroupBy.js":false,"./HKT.js":false,"./Hash.js":false,"./HashMap.js":false,"./HashSet.js":false,"./Inspectable.js":false,"./Iterable.js":false,"./JSONSchema.js":false,"./KeyedPool.js":false,"./Layer.js":false,"./LayerMap.js":false,"./List.js":false,"./LogLevel.js":false,"./LogSpan.js":false,"./Logger.js":false,"./Mailbox.js":false,"./ManagedRuntime.js":false,"./Match.js":"4Kq0F","./MergeDecision.js":false,"./MergeState.js":false,"./MergeStrategy.js":false,"./Metric.js":false,"./MetricBoundaries.js":false,"./MetricHook.js":false,"./MetricKey.js":false,"./MetricKeyType.js":false,"./MetricLabel.js":false,"./MetricPair.js":false,"./MetricPolling.js":false,"./MetricRegistry.js":false,"./MetricState.js":false,"./Micro.js":false,"./ModuleVersion.js":false,"./MutableHashMap.js":false,"./MutableHashSet.js":false,"./MutableList.js":false,"./MutableQueue.js":false,"./MutableRef.js":false,"./NonEmptyIterable.js":false,"./Number.js":false,"./Option.js":false,"./Order.js":false,"./Ordering.js":false,"./ParseResult.js":false,"./Pipeable.js":false,"./Pool.js":false,"./Predicate.js":false,"./Pretty.js":false,"./PrimaryKey.js":false,"./PubSub.js":false,"./Queue.js":false,"./Random.js":false,"./RateLimiter.js":false,"./RcMap.js":false,"./RcRef.js":false,"./Readable.js":false,"./Record.js":false,"./RedBlackTree.js":false,"./Redacted.js":false,"./Ref.js":false,"./RegExp.js":false,"./Reloadable.js":false,"./Request.js":false,"./RequestBlock.js":false,"./RequestResolver.js":false,"./Resource.js":false,"./Runtime.js":false,"./RuntimeFlags.js":false,"./RuntimeFlagsPatch.js":false,"./STM.js":false,"./Schedule.js":false,"./ScheduleDecision.js":false,"./ScheduleInterval.js":false,"./ScheduleIntervals.js":false,"./Scheduler.js":false,"./Schema.js":"1qGF0","./SchemaAST.js":false,"./Scope.js":false,"./ScopedCache.js":false,"./ScopedRef.js":false,"./Secret.js":false,"./SingleProducerAsyncInput.js":false,"./Sink.js":false,"./SortedMap.js":false,"./SortedSet.js":false,"./Stream.js":false,"./StreamEmit.js":false,"./StreamHaltStrategy.js":false,"./Streamable.js":false,"./String.js":"606wn","./Struct.js":false,"./Subscribable.js":false,"./SubscriptionRef.js":false,"./Supervisor.js":false,"./Symbol.js":false,"./SynchronizedRef.js":false,"./TArray.js":false,"./TDeferred.js":false,"./TMap.js":false,"./TPriorityQueue.js":false,"./TPubSub.js":false,"./TQueue.js":false,"./TRandom.js":false,"./TReentrantLock.js":false,"./TRef.js":false,"./TSemaphore.js":false,"./TSet.js":false,"./TSubscriptionRef.js":false,"./Take.js":false,"./TestAnnotation.js":false,"./TestAnnotationMap.js":false,"./TestAnnotations.js":false,"./TestClock.js":false,"./TestConfig.js":false,"./TestContext.js":false,"./TestLive.js":false,"./TestServices.js":false,"./TestSized.js":false,"./Tracer.js":false,"./Trie.js":false,"./Tuple.js":false,"./Types.js":false,"./Unify.js":false,"./UpstreamPullRequest.js":false,"./UpstreamPullStrategy.js":false,"./Utils.js":false,"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"21gOL":[function(require,module,exports,__globalThis) {
/**
 * Tests if a value is a `function`.
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import { isFunction } from "effect/Predicate"
 *
 * assert.deepStrictEqual(isFunction(isFunction), true)
 * assert.deepStrictEqual(isFunction("function"), false)
 * ```
 *
 * @category guards
 * @since 2.0.0
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isFunction", ()=>isFunction);
parcelHelpers.export(exports, "dual", ()=>dual);
parcelHelpers.export(exports, "apply", ()=>apply);
parcelHelpers.export(exports, "identity", ()=>identity);
parcelHelpers.export(exports, "satisfies", ()=>satisfies);
parcelHelpers.export(exports, "unsafeCoerce", ()=>unsafeCoerce);
parcelHelpers.export(exports, "constant", ()=>constant);
parcelHelpers.export(exports, "constTrue", ()=>constTrue);
parcelHelpers.export(exports, "constFalse", ()=>constFalse);
parcelHelpers.export(exports, "constNull", ()=>constNull);
parcelHelpers.export(exports, "constUndefined", ()=>constUndefined);
parcelHelpers.export(exports, "constVoid", ()=>constVoid);
parcelHelpers.export(exports, "flip", ()=>flip);
parcelHelpers.export(exports, "compose", ()=>compose);
parcelHelpers.export(exports, "absurd", ()=>absurd);
parcelHelpers.export(exports, "tupled", ()=>tupled);
parcelHelpers.export(exports, "untupled", ()=>untupled);
parcelHelpers.export(exports, "pipe", ()=>pipe);
parcelHelpers.export(exports, "flow", ()=>flow);
parcelHelpers.export(exports, "hole", ()=>hole);
parcelHelpers.export(exports, "SK", ()=>SK);
const isFunction = (input)=>typeof input === "function";
const dual = function(arity, body) {
    if (typeof arity === "function") return function() {
        if (arity(arguments)) // @ts-expect-error
        return body.apply(this, arguments);
        return (self)=>body(self, ...arguments);
    };
    switch(arity){
        case 0:
        case 1:
            throw new RangeError(`Invalid arity ${arity}`);
        case 2:
            return function(a, b) {
                if (arguments.length >= 2) return body(a, b);
                return function(self) {
                    return body(self, a);
                };
            };
        case 3:
            return function(a, b, c) {
                if (arguments.length >= 3) return body(a, b, c);
                return function(self) {
                    return body(self, a, b);
                };
            };
        case 4:
            return function(a, b, c, d) {
                if (arguments.length >= 4) return body(a, b, c, d);
                return function(self) {
                    return body(self, a, b, c);
                };
            };
        case 5:
            return function(a, b, c, d, e) {
                if (arguments.length >= 5) return body(a, b, c, d, e);
                return function(self) {
                    return body(self, a, b, c, d);
                };
            };
        default:
            return function() {
                if (arguments.length >= arity) // @ts-expect-error
                return body.apply(this, arguments);
                const args = arguments;
                return function(self) {
                    return body(self, ...args);
                };
            };
    }
};
const apply = (a)=>(self)=>self(a);
const identity = (a)=>a;
const satisfies = ()=>(b)=>b;
const unsafeCoerce = identity;
const constant = (value)=>()=>value;
const constTrue = /*#__PURE__*/ constant(true);
const constFalse = /*#__PURE__*/ constant(false);
const constNull = /*#__PURE__*/ constant(null);
const constUndefined = /*#__PURE__*/ constant(undefined);
const constVoid = constUndefined;
const flip = (f)=>(...b)=>(...a)=>f(...a)(...b);
const compose = /*#__PURE__*/ dual(2, (ab, bc)=>(a)=>bc(ab(a)));
const absurd = (_)=>{
    throw new Error("Called `absurd` function which should be uncallable");
};
const tupled = (f)=>(a)=>f(...a);
const untupled = (f)=>(...a)=>f(a);
function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {
    switch(arguments.length){
        case 1:
            return a;
        case 2:
            return ab(a);
        case 3:
            return bc(ab(a));
        case 4:
            return cd(bc(ab(a)));
        case 5:
            return de(cd(bc(ab(a))));
        case 6:
            return ef(de(cd(bc(ab(a)))));
        case 7:
            return fg(ef(de(cd(bc(ab(a))))));
        case 8:
            return gh(fg(ef(de(cd(bc(ab(a)))))));
        case 9:
            return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
        default:
            {
                let ret = arguments[0];
                for(let i = 1; i < arguments.length; i++)ret = arguments[i](ret);
                return ret;
            }
    }
}
function flow(ab, bc, cd, de, ef, fg, gh, hi, ij) {
    switch(arguments.length){
        case 1:
            return ab;
        case 2:
            return function() {
                return bc(ab.apply(this, arguments));
            };
        case 3:
            return function() {
                return cd(bc(ab.apply(this, arguments)));
            };
        case 4:
            return function() {
                return de(cd(bc(ab.apply(this, arguments))));
            };
        case 5:
            return function() {
                return ef(de(cd(bc(ab.apply(this, arguments)))));
            };
        case 6:
            return function() {
                return fg(ef(de(cd(bc(ab.apply(this, arguments))))));
            };
        case 7:
            return function() {
                return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));
            };
        case 8:
            return function() {
                return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));
            };
        case 9:
            return function() {
                return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));
            };
    }
    return;
}
const hole = /*#__PURE__*/ unsafeCoerce(absurd);
const SK = (_, b)=>b;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"fF6sh":[function(require,module,exports,__globalThis) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, '__esModule', {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === 'default' || key === '__esModule' || Object.prototype.hasOwnProperty.call(dest, key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"8L2Gk":[function(require,module,exports,__globalThis) {
/**
 * This module provides utility functions for working with arrays in TypeScript.
 *
 * @since 2.0.0
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "make", ()=>make);
parcelHelpers.export(exports, "allocate", ()=>allocate);
parcelHelpers.export(exports, "makeBy", ()=>makeBy);
parcelHelpers.export(exports, "range", ()=>range);
parcelHelpers.export(exports, "replicate", ()=>replicate);
parcelHelpers.export(exports, "fromIterable", ()=>fromIterable);
parcelHelpers.export(exports, "ensure", ()=>ensure);
parcelHelpers.export(exports, "fromRecord", ()=>fromRecord);
parcelHelpers.export(exports, "fromOption", ()=>fromOption);
parcelHelpers.export(exports, "match", ()=>match);
parcelHelpers.export(exports, "matchLeft", ()=>matchLeft);
parcelHelpers.export(exports, "matchRight", ()=>matchRight);
parcelHelpers.export(exports, "prepend", ()=>prepend);
parcelHelpers.export(exports, "prependAll", ()=>prependAll);
parcelHelpers.export(exports, "append", ()=>append);
parcelHelpers.export(exports, "appendAll", ()=>appendAll);
parcelHelpers.export(exports, "scan", ()=>scan);
parcelHelpers.export(exports, "scanRight", ()=>scanRight);
parcelHelpers.export(exports, "isArray", ()=>isArray);
parcelHelpers.export(exports, "isEmptyArray", ()=>isEmptyArray);
parcelHelpers.export(exports, "isEmptyReadonlyArray", ()=>isEmptyReadonlyArray);
parcelHelpers.export(exports, "isNonEmptyArray", ()=>isNonEmptyArray);
parcelHelpers.export(exports, "isNonEmptyReadonlyArray", ()=>isNonEmptyReadonlyArray);
parcelHelpers.export(exports, "length", ()=>length);
parcelHelpers.export(exports, "get", ()=>get);
parcelHelpers.export(exports, "unsafeGet", ()=>unsafeGet);
parcelHelpers.export(exports, "unprepend", ()=>unprepend);
parcelHelpers.export(exports, "unappend", ()=>unappend);
parcelHelpers.export(exports, "head", ()=>head);
parcelHelpers.export(exports, "headNonEmpty", ()=>headNonEmpty);
parcelHelpers.export(exports, "last", ()=>last);
parcelHelpers.export(exports, "lastNonEmpty", ()=>lastNonEmpty);
parcelHelpers.export(exports, "tail", ()=>tail);
parcelHelpers.export(exports, "tailNonEmpty", ()=>tailNonEmpty);
parcelHelpers.export(exports, "init", ()=>init);
parcelHelpers.export(exports, "initNonEmpty", ()=>initNonEmpty);
parcelHelpers.export(exports, "take", ()=>take);
parcelHelpers.export(exports, "takeRight", ()=>takeRight);
parcelHelpers.export(exports, "takeWhile", ()=>takeWhile);
parcelHelpers.export(exports, "span", ()=>span);
parcelHelpers.export(exports, "drop", ()=>drop);
parcelHelpers.export(exports, "dropRight", ()=>dropRight);
parcelHelpers.export(exports, "dropWhile", ()=>dropWhile);
parcelHelpers.export(exports, "findFirstIndex", ()=>findFirstIndex);
parcelHelpers.export(exports, "findLastIndex", ()=>findLastIndex);
parcelHelpers.export(exports, "findFirst", ()=>findFirst);
parcelHelpers.export(exports, "findLast", ()=>findLast);
parcelHelpers.export(exports, "insertAt", ()=>insertAt);
parcelHelpers.export(exports, "replace", ()=>replace);
parcelHelpers.export(exports, "replaceOption", ()=>replaceOption);
parcelHelpers.export(exports, "modify", ()=>modify);
parcelHelpers.export(exports, "modifyOption", ()=>modifyOption);
parcelHelpers.export(exports, "remove", ()=>remove);
parcelHelpers.export(exports, "reverse", ()=>reverse);
parcelHelpers.export(exports, "sort", ()=>sort);
parcelHelpers.export(exports, "sortWith", ()=>sortWith);
parcelHelpers.export(exports, "sortBy", ()=>sortBy);
parcelHelpers.export(exports, "zip", ()=>zip);
parcelHelpers.export(exports, "zipWith", ()=>zipWith);
parcelHelpers.export(exports, "unzip", ()=>unzip);
parcelHelpers.export(exports, "intersperse", ()=>intersperse);
parcelHelpers.export(exports, "modifyNonEmptyHead", ()=>modifyNonEmptyHead);
parcelHelpers.export(exports, "setNonEmptyHead", ()=>setNonEmptyHead);
parcelHelpers.export(exports, "modifyNonEmptyLast", ()=>modifyNonEmptyLast);
parcelHelpers.export(exports, "setNonEmptyLast", ()=>setNonEmptyLast);
parcelHelpers.export(exports, "rotate", ()=>rotate);
parcelHelpers.export(exports, "containsWith", ()=>containsWith);
parcelHelpers.export(exports, "contains", ()=>contains);
parcelHelpers.export(exports, "chop", ()=>chop);
parcelHelpers.export(exports, "splitAt", ()=>splitAt);
parcelHelpers.export(exports, "splitNonEmptyAt", ()=>splitNonEmptyAt);
parcelHelpers.export(exports, "split", ()=>split);
parcelHelpers.export(exports, "splitWhere", ()=>splitWhere);
parcelHelpers.export(exports, "copy", ()=>copy);
parcelHelpers.export(exports, "pad", ()=>pad);
parcelHelpers.export(exports, "chunksOf", ()=>chunksOf);
parcelHelpers.export(exports, "window", ()=>window);
parcelHelpers.export(exports, "groupWith", ()=>groupWith);
parcelHelpers.export(exports, "group", ()=>group);
parcelHelpers.export(exports, "groupBy", ()=>groupBy);
parcelHelpers.export(exports, "unionWith", ()=>unionWith);
parcelHelpers.export(exports, "union", ()=>union);
parcelHelpers.export(exports, "intersectionWith", ()=>intersectionWith);
parcelHelpers.export(exports, "intersection", ()=>intersection);
parcelHelpers.export(exports, "differenceWith", ()=>differenceWith);
parcelHelpers.export(exports, "difference", ()=>difference);
parcelHelpers.export(exports, "empty", ()=>empty);
parcelHelpers.export(exports, "of", ()=>of);
parcelHelpers.export(exports, "map", ()=>map);
parcelHelpers.export(exports, "flatMap", ()=>flatMap);
parcelHelpers.export(exports, "flatten", ()=>flatten);
parcelHelpers.export(exports, "filterMap", ()=>filterMap);
parcelHelpers.export(exports, "filterMapWhile", ()=>filterMapWhile);
parcelHelpers.export(exports, "partitionMap", ()=>partitionMap);
parcelHelpers.export(exports, "getSomes", ()=>getSomes);
parcelHelpers.export(exports, "getLefts", ()=>getLefts);
parcelHelpers.export(exports, "getRights", ()=>getRights);
parcelHelpers.export(exports, "filter", ()=>filter);
parcelHelpers.export(exports, "partition", ()=>partition);
parcelHelpers.export(exports, "separate", ()=>separate);
parcelHelpers.export(exports, "reduce", ()=>reduce);
parcelHelpers.export(exports, "reduceRight", ()=>reduceRight);
parcelHelpers.export(exports, "liftPredicate", ()=>liftPredicate);
parcelHelpers.export(exports, "liftOption", ()=>liftOption);
parcelHelpers.export(exports, "fromNullable", ()=>fromNullable);
parcelHelpers.export(exports, "liftNullable", ()=>liftNullable);
parcelHelpers.export(exports, "flatMapNullable", ()=>flatMapNullable);
parcelHelpers.export(exports, "liftEither", ()=>liftEither);
parcelHelpers.export(exports, "every", ()=>every);
parcelHelpers.export(exports, "some", ()=>some);
parcelHelpers.export(exports, "extend", ()=>extend);
parcelHelpers.export(exports, "min", ()=>min);
parcelHelpers.export(exports, "max", ()=>max);
parcelHelpers.export(exports, "unfold", ()=>unfold);
parcelHelpers.export(exports, "getOrder", ()=>getOrder);
parcelHelpers.export(exports, "getEquivalence", ()=>getEquivalence);
parcelHelpers.export(exports, "forEach", ()=>forEach);
parcelHelpers.export(exports, "dedupeWith", ()=>dedupeWith);
parcelHelpers.export(exports, "dedupe", ()=>dedupe);
parcelHelpers.export(exports, "dedupeAdjacentWith", ()=>dedupeAdjacentWith);
parcelHelpers.export(exports, "dedupeAdjacent", ()=>dedupeAdjacent);
parcelHelpers.export(exports, "join", ()=>join);
parcelHelpers.export(exports, "mapAccum", ()=>mapAccum);
parcelHelpers.export(exports, "cartesianWith", ()=>cartesianWith);
parcelHelpers.export(exports, "cartesian", ()=>cartesian);
parcelHelpers.export(exports, "Do", ()=>Do);
parcelHelpers.export(exports, "bind", ()=>bind);
parcelHelpers.export(exports, "bindTo", ()=>bindTo);
parcelHelpers.export(exports, "let", ()=>/**
 * The "do simulation" for array allows you to sequentially apply operations to the elements of arrays, just as nested loops allow you to go through all combinations of elements in an arrays.
 *
 * It can be used to simulate "array comprehension".
 * It's a technique that allows you to create new arrays by iterating over existing ones and applying specific **conditions** or **transformations** to the elements. It's like assembling a new collection from pieces of other collections based on certain rules.
 *
 * Here's how the do simulation works:
 *
 * 1. Start the do simulation using the `Do` value
 * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Array` values
 * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope
 * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values
 * 5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope
 *
 * **Example**
 *
 * ```ts
 * import { Array, pipe } from "effect"
 *
 * const doResult = pipe(
 *   Array.Do,
 *   Array.bind("x", () => [1, 3, 5]),
 *   Array.bind("y", () => [2, 4, 6]),
 *   Array.filter(({ x, y }) => x < y), // condition
 *   Array.map(({ x, y }) => [x, y] as const) // transformation
 * )
 * console.log(doResult) // [[1, 2], [1, 4], [1, 6], [3, 4], [3, 6], [5, 6]]
 *
 * // equivalent
 * const x = [1, 3, 5],
 *       y = [2, 4, 6],
 *       result = [];
 * for(let i = 0; i < x.length; i++) {
 *   for(let j = 0; j < y.length; j++) {
 *     const _x = x[i], _y = y[j];
 *     if(_x < _y) result.push([_x, _y] as const)
 *   }
 * }
 *
 * ```
 *
 * @see {@link bindTo}
 * @see {@link bind}
 * @see {@link Do}
 *
 * @category do notation
 * @since 3.2.0
 */ let_);
var _eitherJs = require("./Either.js");
var _equalJs = require("./Equal.js");
var _equivalenceJs = require("./Equivalence.js");
var _functionJs = require("./Function.js");
var _arrayJs = require("./internal/array.js");
var _doNotationJs = require("./internal/doNotation.js");
var _iterableJs = require("./Iterable.js");
var _optionJs = require("./Option.js");
var _orderJs = require("./Order.js");
var _predicateJs = require("./Predicate.js");
var _recordJs = require("./Record.js");
var _tupleJs = require("./Tuple.js");
const make = (...elements)=>elements;
const allocate = (n)=>new Array(n);
const makeBy = /*#__PURE__*/ (0, _functionJs.dual)(2, (n, f)=>{
    const max = Math.max(1, Math.floor(n));
    const out = new Array(max);
    for(let i = 0; i < max; i++)out[i] = f(i);
    return out;
});
const range = (start, end)=>start <= end ? makeBy(end - start + 1, (i)=>start + i) : [
        start
    ];
const replicate = /*#__PURE__*/ (0, _functionJs.dual)(2, (a, n)=>makeBy(n, ()=>a));
const fromIterable = (collection)=>Array.isArray(collection) ? collection : Array.from(collection);
const ensure = (self)=>Array.isArray(self) ? self : [
        self
    ];
const fromRecord = _recordJs.toEntries;
const fromOption = _optionJs.toArray;
const match = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, { onEmpty, onNonEmpty })=>isNonEmptyReadonlyArray(self) ? onNonEmpty(self) : onEmpty());
const matchLeft = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, { onEmpty, onNonEmpty })=>isNonEmptyReadonlyArray(self) ? onNonEmpty(headNonEmpty(self), tailNonEmpty(self)) : onEmpty());
const matchRight = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, { onEmpty, onNonEmpty })=>isNonEmptyReadonlyArray(self) ? onNonEmpty(initNonEmpty(self), lastNonEmpty(self)) : onEmpty());
const prepend = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, head)=>[
        head,
        ...self
    ]);
const prependAll = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>fromIterable(that).concat(fromIterable(self)));
const append = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, last)=>[
        ...self,
        last
    ]);
const appendAll = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>fromIterable(self).concat(fromIterable(that)));
const scan = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, b, f)=>{
    const out = [
        b
    ];
    let i = 0;
    for (const a of self){
        out[i + 1] = f(out[i], a);
        i++;
    }
    return out;
});
const scanRight = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, b, f)=>{
    const input = fromIterable(self);
    const out = new Array(input.length + 1);
    out[input.length] = b;
    for(let i = input.length - 1; i >= 0; i--)out[i] = f(out[i + 1], input[i]);
    return out;
});
const isArray = Array.isArray;
const isEmptyArray = (self)=>self.length === 0;
const isEmptyReadonlyArray = isEmptyArray;
const isNonEmptyArray = _arrayJs.isNonEmptyArray;
const isNonEmptyReadonlyArray = _arrayJs.isNonEmptyArray;
const length = (self)=>self.length;
const isOutOfBounds = (i, as)=>i < 0 || i >= as.length;
const clamp = (i, as)=>Math.floor(Math.min(Math.max(0, i), as.length));
const get = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, index)=>{
    const i = Math.floor(index);
    return isOutOfBounds(i, self) ? _optionJs.none() : _optionJs.some(self[i]);
});
const unsafeGet = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, index)=>{
    const i = Math.floor(index);
    if (isOutOfBounds(i, self)) throw new Error(`Index ${i} out of bounds`);
    return self[i];
});
const unprepend = (self)=>[
        headNonEmpty(self),
        tailNonEmpty(self)
    ];
const unappend = (self)=>[
        initNonEmpty(self),
        lastNonEmpty(self)
    ];
const head = /*#__PURE__*/ get(0);
const headNonEmpty = /*#__PURE__*/ unsafeGet(0);
const last = (self)=>isNonEmptyReadonlyArray(self) ? _optionJs.some(lastNonEmpty(self)) : _optionJs.none();
const lastNonEmpty = (self)=>self[self.length - 1];
const tail = (self)=>{
    const input = fromIterable(self);
    return isNonEmptyReadonlyArray(input) ? _optionJs.some(tailNonEmpty(input)) : _optionJs.none();
};
const tailNonEmpty = (self)=>self.slice(1);
const init = (self)=>{
    const input = fromIterable(self);
    return isNonEmptyReadonlyArray(input) ? _optionJs.some(initNonEmpty(input)) : _optionJs.none();
};
const initNonEmpty = (self)=>self.slice(0, -1);
const take = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, n)=>{
    const input = fromIterable(self);
    return input.slice(0, clamp(n, input));
});
const takeRight = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, n)=>{
    const input = fromIterable(self);
    const i = clamp(n, input);
    return i === 0 ? [] : input.slice(-i);
});
const takeWhile = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, predicate)=>{
    let i = 0;
    const out = [];
    for (const a of self){
        if (!predicate(a, i)) break;
        out.push(a);
        i++;
    }
    return out;
});
const spanIndex = (self, predicate)=>{
    let i = 0;
    for (const a of self){
        if (!predicate(a, i)) break;
        i++;
    }
    return i;
};
const span = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, predicate)=>splitAt(self, spanIndex(self, predicate)));
const drop = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, n)=>{
    const input = fromIterable(self);
    return input.slice(clamp(n, input), input.length);
});
const dropRight = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, n)=>{
    const input = fromIterable(self);
    return input.slice(0, input.length - clamp(n, input));
});
const dropWhile = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, predicate)=>fromIterable(self).slice(spanIndex(self, predicate)));
const findFirstIndex = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, predicate)=>{
    let i = 0;
    for (const a of self){
        if (predicate(a, i)) return _optionJs.some(i);
        i++;
    }
    return _optionJs.none();
});
const findLastIndex = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, predicate)=>{
    const input = fromIterable(self);
    for(let i = input.length - 1; i >= 0; i--){
        if (predicate(input[i], i)) return _optionJs.some(i);
    }
    return _optionJs.none();
});
const findFirst = _iterableJs.findFirst;
const findLast = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>{
    const input = fromIterable(self);
    for(let i = input.length - 1; i >= 0; i--){
        const a = input[i];
        const o = f(a, i);
        if (_predicateJs.isBoolean(o)) {
            if (o) return _optionJs.some(a);
        } else {
            if (_optionJs.isSome(o)) return o;
        }
    }
    return _optionJs.none();
});
const insertAt = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, i, b)=>{
    const out = Array.from(self);
    //             v--- `= self.length` is ok, it means inserting in last position
    if (i < 0 || i > out.length) return _optionJs.none();
    out.splice(i, 0, b);
    return _optionJs.some(out);
});
const replace = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, i, b)=>modify(self, i, ()=>b));
const replaceOption = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, i, b)=>modifyOption(self, i, ()=>b));
const modify = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, i, f)=>_optionJs.getOrElse(modifyOption(self, i, f), ()=>Array.from(self)));
const modifyOption = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, i, f)=>{
    const arr = Array.from(self);
    if (isOutOfBounds(i, arr)) return _optionJs.none();
    const out = arr;
    const b = f(arr[i]);
    out[i] = b;
    return _optionJs.some(out);
});
const remove = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, i)=>{
    const out = Array.from(self);
    if (isOutOfBounds(i, out)) return out;
    out.splice(i, 1);
    return out;
});
const reverse = (self)=>Array.from(self).reverse();
const sort = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, O)=>{
    const out = Array.from(self);
    out.sort(O);
    return out;
});
const sortWith = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, f, order)=>Array.from(self).map((a)=>[
            a,
            f(a)
        ]).sort(([, a], [, b])=>order(a, b)).map(([_])=>_));
const sortBy = (...orders)=>{
    const sortByAll = sort(_orderJs.combineAll(orders));
    return (self)=>{
        const input = fromIterable(self);
        if (isNonEmptyReadonlyArray(input)) return sortByAll(input);
        return [];
    };
};
const zip = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>zipWith(self, that, _tupleJs.make));
const zipWith = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, that, f)=>{
    const as = fromIterable(self);
    const bs = fromIterable(that);
    if (isNonEmptyReadonlyArray(as) && isNonEmptyReadonlyArray(bs)) {
        const out = [
            f(headNonEmpty(as), headNonEmpty(bs))
        ];
        const len = Math.min(as.length, bs.length);
        for(let i = 1; i < len; i++)out[i] = f(as[i], bs[i]);
        return out;
    }
    return [];
});
const unzip = (self)=>{
    const input = fromIterable(self);
    if (isNonEmptyReadonlyArray(input)) {
        const fa = [
            input[0][0]
        ];
        const fb = [
            input[0][1]
        ];
        for(let i = 1; i < input.length; i++){
            fa[i] = input[i][0];
            fb[i] = input[i][1];
        }
        return [
            fa,
            fb
        ];
    }
    return [
        [],
        []
    ];
};
const intersperse = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, middle)=>{
    const input = fromIterable(self);
    if (isNonEmptyReadonlyArray(input)) {
        const out = [
            headNonEmpty(input)
        ];
        const tail = tailNonEmpty(input);
        for(let i = 0; i < tail.length; i++){
            if (i < tail.length) out.push(middle);
            out.push(tail[i]);
        }
        return out;
    }
    return [];
});
const modifyNonEmptyHead = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>[
        f(headNonEmpty(self)),
        ...tailNonEmpty(self)
    ]);
const setNonEmptyHead = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, b)=>modifyNonEmptyHead(self, ()=>b));
const modifyNonEmptyLast = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>append(initNonEmpty(self), f(lastNonEmpty(self))));
const setNonEmptyLast = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, b)=>modifyNonEmptyLast(self, ()=>b));
const rotate = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, n)=>{
    const input = fromIterable(self);
    if (isNonEmptyReadonlyArray(input)) {
        const len = input.length;
        const m = Math.round(n) % len;
        if (isOutOfBounds(Math.abs(m), input) || m === 0) return copy(input);
        if (m < 0) {
            const [f, s] = splitNonEmptyAt(input, -m);
            return appendAll(s, f);
        } else return rotate(self, m - len);
    }
    return [];
});
const containsWith = (isEquivalent)=>(0, _functionJs.dual)(2, (self, a)=>{
        for (const i of self){
            if (isEquivalent(a, i)) return true;
        }
        return false;
    });
const _equivalence = /*#__PURE__*/ _equalJs.equivalence();
const contains = /*#__PURE__*/ containsWith(_equivalence);
const chop = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>{
    const input = fromIterable(self);
    if (isNonEmptyReadonlyArray(input)) {
        const [b, rest] = f(input);
        const out = [
            b
        ];
        let next = rest;
        while(_arrayJs.isNonEmptyArray(next)){
            const [b, rest] = f(next);
            out.push(b);
            next = rest;
        }
        return out;
    }
    return [];
});
const splitAt = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, n)=>{
    const input = Array.from(self);
    const _n = Math.floor(n);
    if (isNonEmptyReadonlyArray(input)) {
        if (_n >= 1) return splitNonEmptyAt(input, _n);
        return [
            [],
            input
        ];
    }
    return [
        input,
        []
    ];
});
const splitNonEmptyAt = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, n)=>{
    const _n = Math.max(1, Math.floor(n));
    return _n >= self.length ? [
        copy(self),
        []
    ] : [
        prepend(self.slice(1, _n), headNonEmpty(self)),
        self.slice(_n)
    ];
});
const split = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, n)=>{
    const input = fromIterable(self);
    return chunksOf(input, Math.ceil(input.length / Math.floor(n)));
});
const splitWhere = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, predicate)=>span(self, (a, i)=>!predicate(a, i)));
const copy = (self)=>self.slice();
const pad = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, n, fill)=>{
    if (self.length >= n) return take(self, n);
    return appendAll(self, makeBy(n - self.length, ()=>fill));
});
const chunksOf = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, n)=>{
    const input = fromIterable(self);
    if (isNonEmptyReadonlyArray(input)) return chop(input, splitNonEmptyAt(n));
    return [];
});
const window = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, n)=>{
    const input = fromIterable(self);
    if (n > 0 && isNonEmptyReadonlyArray(input)) return Array.from({
        length: input.length - (n - 1)
    }, (_, index)=>input.slice(index, index + n));
    return [];
});
const groupWith = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, isEquivalent)=>chop(self, (as)=>{
        const h = headNonEmpty(as);
        const out = [
            h
        ];
        let i = 1;
        for(; i < as.length; i++){
            const a = as[i];
            if (isEquivalent(a, h)) out.push(a);
            else break;
        }
        return [
            out,
            as.slice(i)
        ];
    }));
const group = /*#__PURE__*/ groupWith(/*#__PURE__*/ _equalJs.equivalence());
const groupBy = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>{
    const out = {};
    for (const a of self){
        const k = f(a);
        if (Object.prototype.hasOwnProperty.call(out, k)) out[k].push(a);
        else out[k] = [
            a
        ];
    }
    return out;
});
const unionWith = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, that, isEquivalent)=>{
    const a = fromIterable(self);
    const b = fromIterable(that);
    if (isNonEmptyReadonlyArray(a)) {
        if (isNonEmptyReadonlyArray(b)) {
            const dedupe = dedupeWith(isEquivalent);
            return dedupe(appendAll(a, b));
        }
        return a;
    }
    return b;
});
const union = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>unionWith(self, that, _equivalence));
const intersectionWith = (isEquivalent)=>{
    const has = containsWith(isEquivalent);
    return (0, _functionJs.dual)(2, (self, that)=>fromIterable(self).filter((a)=>has(that, a)));
};
const intersection = /*#__PURE__*/ intersectionWith(_equivalence);
const differenceWith = (isEquivalent)=>{
    const has = containsWith(isEquivalent);
    return (0, _functionJs.dual)(2, (self, that)=>fromIterable(self).filter((a)=>!has(that, a)));
};
const difference = /*#__PURE__*/ differenceWith(_equivalence);
const empty = ()=>[];
const of = (a)=>[
        a
    ];
const map = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>self.map(f));
const flatMap = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>{
    if (isEmptyReadonlyArray(self)) return [];
    const out = [];
    for(let i = 0; i < self.length; i++){
        const inner = f(self[i], i);
        for(let j = 0; j < inner.length; j++)out.push(inner[j]);
    }
    return out;
});
const flatten = /*#__PURE__*/ flatMap((0, _functionJs.identity));
const filterMap = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>{
    const as = fromIterable(self);
    const out = [];
    for(let i = 0; i < as.length; i++){
        const o = f(as[i], i);
        if (_optionJs.isSome(o)) out.push(o.value);
    }
    return out;
});
const filterMapWhile = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>{
    let i = 0;
    const out = [];
    for (const a of self){
        const b = f(a, i);
        if (_optionJs.isSome(b)) out.push(b.value);
        else break;
        i++;
    }
    return out;
});
const partitionMap = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>{
    const left = [];
    const right = [];
    const as = fromIterable(self);
    for(let i = 0; i < as.length; i++){
        const e = f(as[i], i);
        if (_eitherJs.isLeft(e)) left.push(e.left);
        else right.push(e.right);
    }
    return [
        left,
        right
    ];
});
const getSomes = /*#__PURE__*/ filterMap((0, _functionJs.identity));
const getLefts = (self)=>{
    const out = [];
    for (const a of self)if (_eitherJs.isLeft(a)) out.push(a.left);
    return out;
};
const getRights = (self)=>{
    const out = [];
    for (const a of self)if (_eitherJs.isRight(a)) out.push(a.right);
    return out;
};
const filter = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, predicate)=>{
    const as = fromIterable(self);
    const out = [];
    for(let i = 0; i < as.length; i++)if (predicate(as[i], i)) out.push(as[i]);
    return out;
});
const partition = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, predicate)=>{
    const left = [];
    const right = [];
    const as = fromIterable(self);
    for(let i = 0; i < as.length; i++)if (predicate(as[i], i)) right.push(as[i]);
    else left.push(as[i]);
    return [
        left,
        right
    ];
});
const separate = /*#__PURE__*/ partitionMap((0, _functionJs.identity));
const reduce = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, b, f)=>fromIterable(self).reduce((b, a, i)=>f(b, a, i), b));
const reduceRight = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, b, f)=>fromIterable(self).reduceRight((b, a, i)=>f(b, a, i), b));
const liftPredicate = (predicate)=>(b)=>predicate(b) ? [
            b
        ] : [];
const liftOption = (f)=>(...a)=>fromOption(f(...a));
const fromNullable = (a)=>a == null ? empty() : [
        a
    ];
const liftNullable = (f)=>(...a)=>fromNullable(f(...a));
const flatMapNullable = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>flatMap(self, (a)=>fromNullable(f(a))));
const liftEither = (f)=>(...a)=>{
        const e = f(...a);
        return _eitherJs.isLeft(e) ? [] : [
            e.right
        ];
    };
const every = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, refinement)=>self.every(refinement));
const some = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, predicate)=>self.some(predicate));
const extend = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>self.map((_, i, as)=>f(as.slice(i))));
const min = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, O)=>self.reduce(_orderJs.min(O)));
const max = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, O)=>self.reduce(_orderJs.max(O)));
const unfold = (b, f)=>{
    const out = [];
    let next = b;
    let o;
    while(_optionJs.isSome(o = f(next))){
        const [a, b] = o.value;
        out.push(a);
        next = b;
    }
    return out;
};
const getOrder = _orderJs.array;
const getEquivalence = _equivalenceJs.array;
const forEach = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>fromIterable(self).forEach((a, i)=>f(a, i)));
const dedupeWith = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, isEquivalent)=>{
    const input = fromIterable(self);
    if (isNonEmptyReadonlyArray(input)) {
        const out = [
            headNonEmpty(input)
        ];
        const rest = tailNonEmpty(input);
        for (const r of rest)if (out.every((a)=>!isEquivalent(r, a))) out.push(r);
        return out;
    }
    return [];
});
const dedupe = (self)=>dedupeWith(self, _equalJs.equivalence());
const dedupeAdjacentWith = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, isEquivalent)=>{
    const out = [];
    let lastA = _optionJs.none();
    for (const a of self)if (_optionJs.isNone(lastA) || !isEquivalent(a, lastA.value)) {
        out.push(a);
        lastA = _optionJs.some(a);
    }
    return out;
});
const dedupeAdjacent = /*#__PURE__*/ dedupeAdjacentWith(/*#__PURE__*/ _equalJs.equivalence());
const join = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, sep)=>fromIterable(self).join(sep));
const mapAccum = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, s, f)=>{
    let i = 0;
    let s1 = s;
    const out = [];
    for (const a of self){
        const r = f(s1, a, i);
        s1 = r[0];
        out.push(r[1]);
        i++;
    }
    return [
        s1,
        out
    ];
});
const cartesianWith = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, that, f)=>flatMap(self, (a)=>map(that, (b)=>f(a, b))));
const cartesian = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>cartesianWith(self, that, (a, b)=>[
            a,
            b
        ]));
const Do = /*#__PURE__*/ of({});
const bind = /*#__PURE__*/ _doNotationJs.bind(map, flatMap);
const bindTo = /*#__PURE__*/ _doNotationJs.bindTo(map);
const let_ = /*#__PURE__*/ _doNotationJs.let_(map);

},{"./Either.js":"4amnT","./Equal.js":"gA0qD","./Equivalence.js":"1WBUa","./Function.js":"21gOL","./internal/array.js":"a5YhT","./internal/doNotation.js":"6eyzd","./Iterable.js":"dJ2mI","./Option.js":"6sHA7","./Order.js":"lQMwD","./Predicate.js":"gW5pd","./Record.js":"0LNUL","./Tuple.js":"j6dAo","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"4amnT":[function(require,module,exports,__globalThis) {
/**
 * @since 2.0.0
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TypeId", ()=>TypeId);
parcelHelpers.export(exports, "right", ()=>right);
parcelHelpers.export(exports, "void", ()=>/**
 * @category constructors
 * @since 3.13.0
 */ void_);
parcelHelpers.export(exports, "left", ()=>left);
parcelHelpers.export(exports, "fromNullable", ()=>fromNullable);
parcelHelpers.export(exports, "fromOption", ()=>fromOption);
parcelHelpers.export(exports, "try", ()=>/**
 * Imports a synchronous side-effect into a pure `Either` value, translating any
 * thrown exceptions into typed failed eithers creating with `Either.left`.
 *
 * @category constructors
 * @since 2.0.0
 */ try_);
parcelHelpers.export(exports, "isEither", ()=>isEither);
parcelHelpers.export(exports, "isLeft", ()=>isLeft);
parcelHelpers.export(exports, "isRight", ()=>isRight);
parcelHelpers.export(exports, "getRight", ()=>getRight);
parcelHelpers.export(exports, "getLeft", ()=>getLeft);
parcelHelpers.export(exports, "getEquivalence", ()=>getEquivalence);
parcelHelpers.export(exports, "mapBoth", ()=>mapBoth);
parcelHelpers.export(exports, "mapLeft", ()=>mapLeft);
parcelHelpers.export(exports, "map", ()=>map);
parcelHelpers.export(exports, "match", ()=>match);
parcelHelpers.export(exports, "liftPredicate", ()=>liftPredicate);
parcelHelpers.export(exports, "filterOrLeft", ()=>filterOrLeft);
parcelHelpers.export(exports, "merge", ()=>merge);
parcelHelpers.export(exports, "getOrElse", ()=>getOrElse);
parcelHelpers.export(exports, "getOrNull", ()=>getOrNull);
parcelHelpers.export(exports, "getOrUndefined", ()=>getOrUndefined);
parcelHelpers.export(exports, "getOrThrowWith", ()=>getOrThrowWith);
parcelHelpers.export(exports, "getOrThrow", ()=>getOrThrow);
parcelHelpers.export(exports, "orElse", ()=>orElse);
parcelHelpers.export(exports, "flatMap", ()=>flatMap);
parcelHelpers.export(exports, "andThen", ()=>andThen);
parcelHelpers.export(exports, "zipWith", ()=>zipWith);
parcelHelpers.export(exports, "ap", ()=>ap);
parcelHelpers.export(exports, "all", ()=>all);
parcelHelpers.export(exports, "flip", ()=>flip);
parcelHelpers.export(exports, "gen", ()=>gen);
parcelHelpers.export(exports, "Do", ()=>Do);
parcelHelpers.export(exports, "bind", ()=>bind);
parcelHelpers.export(exports, "bindTo", ()=>bindTo);
parcelHelpers.export(exports, "let", ()=>/**
 * The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.
 *
 * Here's how the do simulation works:
 *
 * 1. Start the do simulation using the `Do` value
 * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Either` values
 * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope
 * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import { Either, pipe } from "effect"
 *
 * const result = pipe(
 *   Either.Do,
 *   Either.bind("x", () => Either.right(2)),
 *   Either.bind("y", () => Either.right(3)),
 *   Either.let("sum", ({ x, y }) => x + y)
 * )
 * assert.deepStrictEqual(result, Either.right({ x: 2, y: 3, sum: 5 }))
 * ```
 *
 * @see {@link Do}
 * @see {@link bindTo}
 * @see {@link bind}
 *
 * @category do notation
 * @since 2.0.0
 */ let_);
parcelHelpers.export(exports, "transposeOption", ()=>transposeOption);
var _equivalenceJs = require("./Equivalence.js");
var _functionJs = require("./Function.js");
var _doNotationJs = require("./internal/doNotation.js");
var _eitherJs = require("./internal/either.js");
var _optionJs = require("./internal/option.js");
var _predicateJs = require("./Predicate.js");
var _utilsJs = require("./Utils.js");
const TypeId = _eitherJs.TypeId;
const right = _eitherJs.right;
const void_ = /*#__PURE__*/ right(void 0);
const left = _eitherJs.left;
const fromNullable = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, onNullable)=>self == null ? left(onNullable(self)) : right(self));
const fromOption = _eitherJs.fromOption;
const try_ = (evaluate)=>{
    if ((0, _predicateJs.isFunction)(evaluate)) try {
        return right(evaluate());
    } catch (e) {
        return left(e);
    }
    else try {
        return right(evaluate.try());
    } catch (e) {
        return left(evaluate.catch(e));
    }
};
const isEither = _eitherJs.isEither;
const isLeft = _eitherJs.isLeft;
const isRight = _eitherJs.isRight;
const getRight = _eitherJs.getRight;
const getLeft = _eitherJs.getLeft;
const getEquivalence = ({ left, right })=>_equivalenceJs.make((x, y)=>isLeft(x) ? isLeft(y) && left(x.left, y.left) : isRight(y) && right(x.right, y.right));
const mapBoth = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, { onLeft, onRight })=>isLeft(self) ? left(onLeft(self.left)) : right(onRight(self.right)));
const mapLeft = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>isLeft(self) ? left(f(self.left)) : right(self.right));
const map = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>isRight(self) ? right(f(self.right)) : left(self.left));
const match = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, { onLeft, onRight })=>isLeft(self) ? onLeft(self.left) : onRight(self.right));
const liftPredicate = /*#__PURE__*/ (0, _functionJs.dual)(3, (a, predicate, orLeftWith)=>predicate(a) ? right(a) : left(orLeftWith(a)));
const filterOrLeft = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, predicate, orLeftWith)=>flatMap(self, (r)=>predicate(r) ? right(r) : left(orLeftWith(r))));
const merge = /*#__PURE__*/ match({
    onLeft: (0, _functionJs.identity),
    onRight: (0, _functionJs.identity)
});
const getOrElse = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, onLeft)=>isLeft(self) ? onLeft(self.left) : self.right);
const getOrNull = /*#__PURE__*/ getOrElse((0, _functionJs.constNull));
const getOrUndefined = /*#__PURE__*/ getOrElse((0, _functionJs.constUndefined));
const getOrThrowWith = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, onLeft)=>{
    if (isRight(self)) return self.right;
    throw onLeft(self.left);
});
const getOrThrow = /*#__PURE__*/ getOrThrowWith(()=>new Error("getOrThrow called on a Left"));
const orElse = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>isLeft(self) ? that(self.left) : right(self.right));
const flatMap = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>isLeft(self) ? left(self.left) : f(self.right));
const andThen = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>flatMap(self, (a)=>{
        const b = (0, _predicateJs.isFunction)(f) ? f(a) : f;
        return isEither(b) ? b : right(b);
    }));
const zipWith = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, that, f)=>flatMap(self, (r)=>map(that, (r2)=>f(r, r2))));
const ap = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>zipWith(self, that, (f, a)=>f(a)));
const all = (input)=>{
    if (Symbol.iterator in input) {
        const out = [];
        for (const e of input){
            if (isLeft(e)) return e;
            out.push(e.right);
        }
        return right(out);
    }
    const out = {};
    for (const key of Object.keys(input)){
        const e = input[key];
        if (isLeft(e)) return e;
        out[key] = e.right;
    }
    return right(out);
};
const flip = (self)=>isLeft(self) ? right(self.left) : left(self.right);
const adapter = /*#__PURE__*/ _utilsJs.adapter();
const gen = (...args)=>{
    const f = args.length === 1 ? args[0] : args[1].bind(args[0]);
    const iterator = f(adapter);
    let state = iterator.next();
    while(!state.done){
        const current = _utilsJs.isGenKind(state.value) ? state.value.value : _utilsJs.yieldWrapGet(state.value);
        if (isLeft(current)) return current;
        state = iterator.next(current.right);
    }
    return right(state.value);
};
const Do = /*#__PURE__*/ right({});
const bind = /*#__PURE__*/ _doNotationJs.bind(map, flatMap);
const bindTo = /*#__PURE__*/ _doNotationJs.bindTo(map);
const let_ = /*#__PURE__*/ _doNotationJs.let_(map);
const transposeOption = (self)=>{
    return _optionJs.isNone(self) ? right(_optionJs.none) : map(self.value, _optionJs.some);
};

},{"./Equivalence.js":"1WBUa","./Function.js":"21gOL","./internal/doNotation.js":"6eyzd","./internal/either.js":"8gD6z","./internal/option.js":"c4fL5","./Predicate.js":"gW5pd","./Utils.js":"dYvz1","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"1WBUa":[function(require,module,exports,__globalThis) {
/**
 * This module provides an implementation of the `Equivalence` type class, which defines a binary relation
 * that is reflexive, symmetric, and transitive. In other words, it defines a notion of equivalence between values of a certain type.
 * These properties are also known in mathematics as an "equivalence relation".
 *
 * @since 2.0.0
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "make", ()=>make);
parcelHelpers.export(exports, "strict", ()=>strict);
parcelHelpers.export(exports, "string", ()=>string);
parcelHelpers.export(exports, "number", ()=>number);
parcelHelpers.export(exports, "boolean", ()=>boolean);
parcelHelpers.export(exports, "bigint", ()=>bigint);
parcelHelpers.export(exports, "symbol", ()=>symbol);
parcelHelpers.export(exports, "combine", ()=>combine);
parcelHelpers.export(exports, "combineMany", ()=>combineMany);
parcelHelpers.export(exports, "combineAll", ()=>combineAll);
parcelHelpers.export(exports, "mapInput", ()=>mapInput);
parcelHelpers.export(exports, "Date", ()=>Date);
parcelHelpers.export(exports, "product", ()=>product);
parcelHelpers.export(exports, "all", ()=>all);
parcelHelpers.export(exports, "productMany", ()=>productMany);
parcelHelpers.export(exports, "tuple", ()=>tuple);
parcelHelpers.export(exports, "array", ()=>array);
parcelHelpers.export(exports, "struct", ()=>struct);
var _functionJs = require("./Function.js");
const make = (isEquivalent)=>(self, that)=>self === that || isEquivalent(self, that);
const isStrictEquivalent = (x, y)=>x === y;
const strict = ()=>isStrictEquivalent;
const string = /*#__PURE__*/ strict();
const number = /*#__PURE__*/ strict();
const boolean = /*#__PURE__*/ strict();
const bigint = /*#__PURE__*/ strict();
const symbol = /*#__PURE__*/ strict();
const combine = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>make((x, y)=>self(x, y) && that(x, y)));
const combineMany = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, collection)=>make((x, y)=>{
        if (!self(x, y)) return false;
        for (const equivalence of collection){
            if (!equivalence(x, y)) return false;
        }
        return true;
    }));
const isAlwaysEquivalent = (_x, _y)=>true;
const combineAll = (collection)=>combineMany(isAlwaysEquivalent, collection);
const mapInput = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>make((x, y)=>self(f(x), f(y))));
const Date = /*#__PURE__*/ mapInput(number, (date)=>date.getTime());
const product = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>make(([xa, xb], [ya, yb])=>self(xa, ya) && that(xb, yb)));
const all = (collection)=>{
    return make((x, y)=>{
        const len = Math.min(x.length, y.length);
        let collectionLength = 0;
        for (const equivalence of collection){
            if (collectionLength >= len) break;
            if (!equivalence(x[collectionLength], y[collectionLength])) return false;
            collectionLength++;
        }
        return true;
    });
};
const productMany = (self, collection)=>{
    const equivalence = all(collection);
    return make((x, y)=>!self(x[0], y[0]) ? false : equivalence(x.slice(1), y.slice(1)));
};
const tuple = (...elements)=>all(elements);
const array = (item)=>make((self, that)=>{
        if (self.length !== that.length) return false;
        for(let i = 0; i < self.length; i++){
            const isEq = item(self[i], that[i]);
            if (!isEq) return false;
        }
        return true;
    });
const struct = (fields)=>{
    const keys = Object.keys(fields);
    return make((self, that)=>{
        for (const key of keys){
            if (!fields[key](self[key], that[key])) return false;
        }
        return true;
    });
};

},{"./Function.js":"21gOL","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"6eyzd":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "let_", ()=>let_);
parcelHelpers.export(exports, "bindTo", ()=>bindTo);
parcelHelpers.export(exports, "bind", ()=>bind);
var _functionJs = require("../Function.js");
const let_ = (map)=>(0, _functionJs.dual)(3, (self, name, f)=>map(self, (a)=>Object.assign({}, a, {
                [name]: f(a)
            })));
const bindTo = (map)=>(0, _functionJs.dual)(2, (self, name)=>map(self, (a)=>({
                [name]: a
            })));
const bind = (map, flatMap)=>(0, _functionJs.dual)(3, (self, name, f)=>flatMap(self, (a)=>map(f(a), (b)=>Object.assign({}, a, {
                    [name]: b
                }))));

},{"../Function.js":"21gOL","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"8gD6z":[function(require,module,exports,__globalThis) {
/**
 * @since 2.0.0
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TypeId", ()=>TypeId);
parcelHelpers.export(exports, "isEither", ()=>isEither);
parcelHelpers.export(exports, "isLeft", ()=>isLeft);
parcelHelpers.export(exports, "isRight", ()=>isRight);
parcelHelpers.export(exports, "left", ()=>left);
parcelHelpers.export(exports, "right", ()=>right);
parcelHelpers.export(exports, "getLeft", ()=>getLeft);
parcelHelpers.export(exports, "getRight", ()=>getRight);
parcelHelpers.export(exports, "fromOption", ()=>fromOption);
var _equalJs = require("../Equal.js");
var _functionJs = require("../Function.js");
var _hashJs = require("../Hash.js");
var _inspectableJs = require("../Inspectable.js");
var _predicateJs = require("../Predicate.js");
var _effectableJs = require("./effectable.js");
var _optionJs = require("./option.js");
const TypeId = /*#__PURE__*/ Symbol.for("effect/Either");
const CommonProto = {
    ...(0, _effectableJs.EffectPrototype),
    [TypeId]: {
        _R: (_)=>_
    },
    [(0, _inspectableJs.NodeInspectSymbol)] () {
        return this.toJSON();
    },
    toString () {
        return (0, _inspectableJs.format)(this.toJSON());
    }
};
const RightProto = /*#__PURE__*/ Object.assign(/*#__PURE__*/ Object.create(CommonProto), {
    _tag: "Right",
    _op: "Right",
    [_equalJs.symbol] (that) {
        return isEither(that) && isRight(that) && _equalJs.equals(this.right, that.right);
    },
    [_hashJs.symbol] () {
        return _hashJs.combine(_hashJs.hash(this._tag))(_hashJs.hash(this.right));
    },
    toJSON () {
        return {
            _id: "Either",
            _tag: this._tag,
            right: (0, _inspectableJs.toJSON)(this.right)
        };
    }
});
const LeftProto = /*#__PURE__*/ Object.assign(/*#__PURE__*/ Object.create(CommonProto), {
    _tag: "Left",
    _op: "Left",
    [_equalJs.symbol] (that) {
        return isEither(that) && isLeft(that) && _equalJs.equals(this.left, that.left);
    },
    [_hashJs.symbol] () {
        return _hashJs.combine(_hashJs.hash(this._tag))(_hashJs.hash(this.left));
    },
    toJSON () {
        return {
            _id: "Either",
            _tag: this._tag,
            left: (0, _inspectableJs.toJSON)(this.left)
        };
    }
});
const isEither = (input)=>(0, _predicateJs.hasProperty)(input, TypeId);
const isLeft = (ma)=>ma._tag === "Left";
const isRight = (ma)=>ma._tag === "Right";
const left = (left)=>{
    const a = Object.create(LeftProto);
    a.left = left;
    return a;
};
const right = (right)=>{
    const a = Object.create(RightProto);
    a.right = right;
    return a;
};
const getLeft = (self)=>isRight(self) ? _optionJs.none : _optionJs.some(self.left);
const getRight = (self)=>isLeft(self) ? _optionJs.none : _optionJs.some(self.right);
const fromOption = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, onNone)=>_optionJs.isNone(self) ? left(onNone()) : right(self.value));

},{"../Equal.js":"gA0qD","../Function.js":"21gOL","../Hash.js":"gFMwE","../Inspectable.js":"1Ur70","../Predicate.js":"gW5pd","./effectable.js":"8EvvU","./option.js":"c4fL5","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"gA0qD":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "symbol", ()=>symbol);
parcelHelpers.export(exports, "equals", ()=>equals);
parcelHelpers.export(exports, "isEqual", ()=>isEqual);
parcelHelpers.export(exports, "equivalence", ()=>equivalence);
var _hashJs = require("./Hash.js");
var _predicateJs = require("./Predicate.js");
var _utilsJs = require("./Utils.js");
const symbol = /*#__PURE__*/ Symbol.for("effect/Equal");
function equals() {
    if (arguments.length === 1) return (self)=>compareBoth(self, arguments[0]);
    return compareBoth(arguments[0], arguments[1]);
}
function compareBoth(self, that) {
    if (self === that) return true;
    const selfType = typeof self;
    if (selfType !== typeof that) return false;
    if (selfType === "object" || selfType === "function") {
        if (self !== null && that !== null) {
            if (isEqual(self) && isEqual(that)) {
                if (_hashJs.hash(self) === _hashJs.hash(that) && self[symbol](that)) return true;
                else return (0, _utilsJs.structuralRegionState).enabled && (0, _utilsJs.structuralRegionState).tester ? (0, _utilsJs.structuralRegionState).tester(self, that) : false;
            } else if (self instanceof Date && that instanceof Date) return self.toISOString() === that.toISOString();
            else if (self instanceof URL && that instanceof URL) return self.href === that.href;
        }
        if ((0, _utilsJs.structuralRegionState).enabled) {
            if (Array.isArray(self) && Array.isArray(that)) return self.length === that.length && self.every((v, i)=>compareBoth(v, that[i]));
            if (Object.getPrototypeOf(self) === Object.prototype && Object.getPrototypeOf(self) === Object.prototype) {
                const keysSelf = Object.keys(self);
                const keysThat = Object.keys(that);
                if (keysSelf.length === keysThat.length) {
                    for (const key of keysSelf){
                        // @ts-expect-error
                        if (!(key in that && compareBoth(self[key], that[key]))) return (0, _utilsJs.structuralRegionState).tester ? (0, _utilsJs.structuralRegionState).tester(self, that) : false;
                    }
                    return true;
                }
            }
            return (0, _utilsJs.structuralRegionState).tester ? (0, _utilsJs.structuralRegionState).tester(self, that) : false;
        }
    }
    return (0, _utilsJs.structuralRegionState).enabled && (0, _utilsJs.structuralRegionState).tester ? (0, _utilsJs.structuralRegionState).tester(self, that) : false;
}
const isEqual = (u)=>(0, _predicateJs.hasProperty)(u, symbol);
const equivalence = ()=>equals;

},{"./Hash.js":"gFMwE","./Predicate.js":"gW5pd","./Utils.js":"dYvz1","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"gFMwE":[function(require,module,exports,__globalThis) {
/**
 * @since 2.0.0
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "symbol", ()=>symbol);
parcelHelpers.export(exports, "hash", ()=>hash);
parcelHelpers.export(exports, "random", ()=>random);
parcelHelpers.export(exports, "combine", ()=>combine);
parcelHelpers.export(exports, "optimize", ()=>optimize);
parcelHelpers.export(exports, "isHash", ()=>isHash);
parcelHelpers.export(exports, "number", ()=>number);
parcelHelpers.export(exports, "string", ()=>string);
parcelHelpers.export(exports, "structureKeys", ()=>structureKeys);
parcelHelpers.export(exports, "structure", ()=>structure);
parcelHelpers.export(exports, "array", ()=>array);
parcelHelpers.export(exports, "cached", ()=>cached);
var _functionJs = require("./Function.js");
var _globalValueJs = require("./GlobalValue.js");
var _predicateJs = require("./Predicate.js");
var _utilsJs = require("./Utils.js");
/** @internal */ const randomHashCache = /*#__PURE__*/ (0, _globalValueJs.globalValue)(/*#__PURE__*/ Symbol.for("effect/Hash/randomHashCache"), ()=>new WeakMap());
const symbol = /*#__PURE__*/ Symbol.for("effect/Hash");
const hash = (self)=>{
    if ((0, _utilsJs.structuralRegionState).enabled === true) return 0;
    switch(typeof self){
        case "number":
            return number(self);
        case "bigint":
            return string(self.toString(10));
        case "boolean":
            return string(String(self));
        case "symbol":
            return string(String(self));
        case "string":
            return string(self);
        case "undefined":
            return string("undefined");
        case "function":
        case "object":
            if (self === null) return string("null");
            else if (self instanceof Date) return hash(self.toISOString());
            else if (self instanceof URL) return hash(self.href);
            else if (isHash(self)) return self[symbol]();
            else return random(self);
        default:
            throw new Error(`BUG: unhandled typeof ${typeof self} - please report an issue at https://github.com/Effect-TS/effect/issues`);
    }
};
const random = (self)=>{
    if (!randomHashCache.has(self)) randomHashCache.set(self, number(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER)));
    return randomHashCache.get(self);
};
const combine = (b)=>(self)=>self * 53 ^ b;
const optimize = (n)=>n & 0xbfffffff | n >>> 1 & 0x40000000;
const isHash = (u)=>(0, _predicateJs.hasProperty)(u, symbol);
const number = (n)=>{
    if (n !== n || n === Infinity) return 0;
    let h = n | 0;
    if (h !== n) h ^= n * 0xffffffff;
    while(n > 0xffffffff)h ^= n /= 0xffffffff;
    return optimize(h);
};
const string = (str)=>{
    let h = 5381, i = str.length;
    while(i)h = h * 33 ^ str.charCodeAt(--i);
    return optimize(h);
};
const structureKeys = (o, keys)=>{
    let h = 12289;
    for(let i = 0; i < keys.length; i++)h ^= (0, _functionJs.pipe)(string(keys[i]), combine(hash(o[keys[i]])));
    return optimize(h);
};
const structure = (o)=>structureKeys(o, Object.keys(o));
const array = (arr)=>{
    let h = 6151;
    for(let i = 0; i < arr.length; i++)h = (0, _functionJs.pipe)(h, combine(hash(arr[i])));
    return optimize(h);
};
const cached = function() {
    if (arguments.length === 1) {
        const self = arguments[0];
        return function(hash) {
            Object.defineProperty(self, symbol, {
                value () {
                    return hash;
                },
                enumerable: false
            });
            return hash;
        };
    }
    const self = arguments[0];
    const hash = arguments[1];
    Object.defineProperty(self, symbol, {
        value () {
            return hash;
        },
        enumerable: false
    });
    return hash;
};

},{"./Function.js":"21gOL","./GlobalValue.js":"5w3Hn","./Predicate.js":"gW5pd","./Utils.js":"dYvz1","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"5w3Hn":[function(require,module,exports,__globalThis) {
/**
 * The `GlobalValue` module ensures that a single instance of a value is created globally,
 * even when modules are imported multiple times (e.g., due to mixing CommonJS and ESM builds)
 * or during hot-reloading in development environments like Next.js or Remix.
 *
 * It achieves this by using a versioned global store, identified by a unique `Symbol` tied to
 * the current version of the `effect` library. The store holds values that are keyed by an identifier,
 * allowing the reuse of previously computed instances across imports or reloads.
 *
 * This pattern is particularly useful in scenarios where frequent reloading can cause services or
 * single-instance objects to be recreated unnecessarily, such as in development environments with hot-reloading.
 *
 * @since 2.0.0
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "globalValue", ()=>globalValue);
var _versionJs = require("./internal/version.js");
const globalStoreId = `effect/GlobalValue/globalStoreId/${_versionJs.getCurrentVersion()}`;
let globalStore;
const globalValue = (id, compute)=>{
    if (!globalStore) {
        // @ts-expect-error
        globalThis[globalStoreId] ??= new Map();
        // @ts-expect-error
        globalStore = globalThis[globalStoreId];
    }
    if (!globalStore.has(id)) globalStore.set(id, compute());
    return globalStore.get(id);
};

},{"./internal/version.js":"euXJO","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"euXJO":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getCurrentVersion", ()=>getCurrentVersion);
parcelHelpers.export(exports, "setCurrentVersion", ()=>setCurrentVersion);
let moduleVersion = "3.14.22";
const getCurrentVersion = ()=>moduleVersion;
const setCurrentVersion = (version)=>{
    moduleVersion = version;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"gW5pd":[function(require,module,exports,__globalThis) {
/**
 * @since 2.0.0
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mapInput", ()=>mapInput);
parcelHelpers.export(exports, "isTupleOf", ()=>isTupleOf);
parcelHelpers.export(exports, "isTupleOfAtLeast", ()=>isTupleOfAtLeast);
parcelHelpers.export(exports, "isTruthy", ()=>isTruthy);
parcelHelpers.export(exports, "isSet", ()=>isSet);
parcelHelpers.export(exports, "isMap", ()=>isMap);
parcelHelpers.export(exports, "isString", ()=>isString);
parcelHelpers.export(exports, "isNumber", ()=>isNumber);
parcelHelpers.export(exports, "isBoolean", ()=>isBoolean);
parcelHelpers.export(exports, "isBigInt", ()=>isBigInt);
parcelHelpers.export(exports, "isSymbol", ()=>isSymbol);
parcelHelpers.export(exports, "isPropertyKey", ()=>isPropertyKey);
parcelHelpers.export(exports, "isFunction", ()=>isFunction);
parcelHelpers.export(exports, "isUndefined", ()=>isUndefined);
parcelHelpers.export(exports, "isNotUndefined", ()=>isNotUndefined);
parcelHelpers.export(exports, "isNull", ()=>isNull);
parcelHelpers.export(exports, "isNotNull", ()=>isNotNull);
parcelHelpers.export(exports, "isNever", ()=>isNever);
parcelHelpers.export(exports, "isUnknown", ()=>isUnknown);
parcelHelpers.export(exports, "isRecordOrArray", ()=>isRecordOrArray);
parcelHelpers.export(exports, "isObject", ()=>isObject);
parcelHelpers.export(exports, "hasProperty", ()=>hasProperty);
parcelHelpers.export(exports, "isTagged", ()=>isTagged);
parcelHelpers.export(exports, "isNullable", ()=>isNullable);
parcelHelpers.export(exports, "isNotNullable", ()=>isNotNullable);
parcelHelpers.export(exports, "isError", ()=>isError);
parcelHelpers.export(exports, "isUint8Array", ()=>isUint8Array);
parcelHelpers.export(exports, "isDate", ()=>isDate);
parcelHelpers.export(exports, "isIterable", ()=>isIterable);
parcelHelpers.export(exports, "isRecord", ()=>isRecord);
parcelHelpers.export(exports, "isReadonlyRecord", ()=>isReadonlyRecord);
parcelHelpers.export(exports, "isPromise", ()=>isPromise);
parcelHelpers.export(exports, "isPromiseLike", ()=>isPromiseLike);
parcelHelpers.export(exports, "isRegExp", ()=>isRegExp);
parcelHelpers.export(exports, "compose", ()=>compose);
parcelHelpers.export(exports, "product", ()=>product);
parcelHelpers.export(exports, "all", ()=>all);
parcelHelpers.export(exports, "productMany", ()=>productMany);
parcelHelpers.export(exports, "tuple", ()=>tuple);
parcelHelpers.export(exports, "struct", ()=>struct);
parcelHelpers.export(exports, "not", ()=>not);
parcelHelpers.export(exports, "or", ()=>or);
parcelHelpers.export(exports, "and", ()=>and);
parcelHelpers.export(exports, "xor", ()=>xor);
parcelHelpers.export(exports, "eqv", ()=>eqv);
parcelHelpers.export(exports, "implies", ()=>implies);
parcelHelpers.export(exports, "nor", ()=>nor);
parcelHelpers.export(exports, "nand", ()=>nand);
parcelHelpers.export(exports, "every", ()=>every);
parcelHelpers.export(exports, "some", ()=>some);
var _functionJs = require("./Function.js");
const mapInput = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>(b)=>self(f(b)));
const isTupleOf = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, n)=>self.length === n);
const isTupleOfAtLeast = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, n)=>self.length >= n);
const isTruthy = (input)=>!!input;
const isSet = (input)=>input instanceof Set;
const isMap = (input)=>input instanceof Map;
const isString = (input)=>typeof input === "string";
const isNumber = (input)=>typeof input === "number";
const isBoolean = (input)=>typeof input === "boolean";
const isBigInt = (input)=>typeof input === "bigint";
const isSymbol = (input)=>typeof input === "symbol";
const isPropertyKey = (u)=>isString(u) || isNumber(u) || isSymbol(u);
const isFunction = (0, _functionJs.isFunction);
const isUndefined = (input)=>input === undefined;
const isNotUndefined = (input)=>input !== undefined;
const isNull = (input)=>input === null;
const isNotNull = (input)=>input !== null;
const isNever = (_)=>false;
const isUnknown = (_)=>true;
const isRecordOrArray = (input)=>typeof input === "object" && input !== null;
const isObject = (input)=>isRecordOrArray(input) || isFunction(input);
const hasProperty = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, property)=>isObject(self) && property in self);
const isTagged = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, tag)=>hasProperty(self, "_tag") && self["_tag"] === tag);
const isNullable = (input)=>input === null || input === undefined;
const isNotNullable = (input)=>input !== null && input !== undefined;
const isError = (input)=>input instanceof Error;
const isUint8Array = (input)=>input instanceof Uint8Array;
const isDate = (input)=>input instanceof Date;
const isIterable = (input)=>hasProperty(input, Symbol.iterator);
const isRecord = (input)=>isRecordOrArray(input) && !Array.isArray(input);
const isReadonlyRecord = isRecord;
const isPromise = (input)=>hasProperty(input, "then") && "catch" in input && isFunction(input.then) && isFunction(input.catch);
const isPromiseLike = (input)=>hasProperty(input, "then") && isFunction(input.then);
const isRegExp = (input)=>input instanceof RegExp;
const compose = /*#__PURE__*/ (0, _functionJs.dual)(2, (ab, bc)=>(a)=>ab(a) && bc(a));
const product = (self, that)=>([a, b])=>self(a) && that(b);
const all = (collection)=>{
    return (as)=>{
        let collectionIndex = 0;
        for (const p of collection){
            if (collectionIndex >= as.length) break;
            if (p(as[collectionIndex]) === false) return false;
            collectionIndex++;
        }
        return true;
    };
};
const productMany = (self, collection)=>{
    const rest = all(collection);
    return ([head, ...tail])=>self(head) === false ? false : rest(tail);
};
const tuple = (...elements)=>all(elements);
const struct = (fields)=>{
    const keys = Object.keys(fields);
    return (a)=>{
        for (const key of keys){
            if (!fields[key](a[key])) return false;
        }
        return true;
    };
};
const not = (self)=>(a)=>!self(a);
const or = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>(a)=>self(a) || that(a));
const and = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>(a)=>self(a) && that(a));
const xor = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>(a)=>self(a) !== that(a));
const eqv = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>(a)=>self(a) === that(a));
const implies = /*#__PURE__*/ (0, _functionJs.dual)(2, (antecedent, consequent)=>(a)=>antecedent(a) ? consequent(a) : true);
const nor = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>(a)=>!(self(a) || that(a)));
const nand = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>(a)=>!(self(a) && that(a)));
const every = (collection)=>(a)=>{
        for (const p of collection){
            if (!p(a)) return false;
        }
        return true;
    };
const some = (collection)=>(a)=>{
        for (const p of collection){
            if (p(a)) return true;
        }
        return false;
    };

},{"./Function.js":"21gOL","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"dYvz1":[function(require,module,exports,__globalThis) {
/**
 * @since 2.0.0
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "GenKindTypeId", ()=>GenKindTypeId);
parcelHelpers.export(exports, "isGenKind", ()=>isGenKind);
/**
 * @category constructors
 * @since 2.0.0
 */ parcelHelpers.export(exports, "GenKindImpl", ()=>GenKindImpl);
/**
 * @category constructors
 * @since 2.0.0
 */ parcelHelpers.export(exports, "SingleShotGen", ()=>SingleShotGen);
parcelHelpers.export(exports, "makeGenKind", ()=>makeGenKind);
parcelHelpers.export(exports, "adapter", ()=>adapter);
/**
 * PCG is a family of simple fast space-efficient statistically good algorithms
 * for random number generation. Unlike many general-purpose RNGs, they are also
 * hard to predict.
 *
 * @category model
 * @since 2.0.0
 */ parcelHelpers.export(exports, "PCGRandom", ()=>PCGRandom);
parcelHelpers.export(exports, "YieldWrapTypeId", ()=>YieldWrapTypeId);
/**
 * @since 3.0.6
 */ parcelHelpers.export(exports, "YieldWrap", ()=>YieldWrap);
/**
 * @since 3.0.6
 */ parcelHelpers.export(exports, "yieldWrapGet", ()=>yieldWrapGet);
parcelHelpers.export(exports, "structuralRegionState", ()=>structuralRegionState);
parcelHelpers.export(exports, "structuralRegion", ()=>structuralRegion);
parcelHelpers.export(exports, "internalCall", ()=>internalCall);
parcelHelpers.export(exports, "isGeneratorFunction", ()=>isGeneratorFunction);
var _functionJs = require("./Function.js");
var _globalValueJs = require("./GlobalValue.js");
var _errorsJs = require("./internal/errors.js");
var _predicateJs = require("./Predicate.js");
const GenKindTypeId = /*#__PURE__*/ Symbol.for("effect/Gen/GenKind");
const isGenKind = (u)=>(0, _predicateJs.isObject)(u) && GenKindTypeId in u;
class GenKindImpl {
    value;
    constructor(/**
   * @since 2.0.0
   */ value){
        this.value = value;
    }
    /**
   * @since 2.0.0
   */ get _F() {
        return 0, _functionJs.identity;
    }
    /**
   * @since 2.0.0
   */ get _R() {
        return (_)=>_;
    }
    /**
   * @since 2.0.0
   */ get _O() {
        return (_)=>_;
    }
    /**
   * @since 2.0.0
   */ get _E() {
        return (_)=>_;
    }
    /**
   * @since 2.0.0
   */ [GenKindTypeId] = GenKindTypeId;
    /**
   * @since 2.0.0
   */ [Symbol.iterator]() {
        return new SingleShotGen(this);
    }
}
class SingleShotGen {
    self;
    called = false;
    constructor(self){
        this.self = self;
    }
    /**
   * @since 2.0.0
   */ next(a) {
        return this.called ? {
            value: a,
            done: true
        } : (this.called = true, {
            value: this.self,
            done: false
        });
    }
    /**
   * @since 2.0.0
   */ return(a) {
        return {
            value: a,
            done: true
        };
    }
    /**
   * @since 2.0.0
   */ throw(e) {
        throw e;
    }
    /**
   * @since 2.0.0
   */ [Symbol.iterator]() {
        return new SingleShotGen(this.self);
    }
}
const makeGenKind = (kind)=>new GenKindImpl(kind);
const adapter = ()=>function() {
        let x = arguments[0];
        for(let i = 1; i < arguments.length; i++)x = arguments[i](x);
        return new GenKindImpl(x);
    };
const defaultIncHi = 0x14057b7e;
const defaultIncLo = 0xf767814f;
const MUL_HI = 1481765933;
const MUL_LO = 1284865837;
const BIT_53 = 9007199254740992.0;
const BIT_27 = 134217728.0;
class PCGRandom {
    _state;
    constructor(seedHi, seedLo, incHi, incLo){
        if ((0, _predicateJs.isNullable)(seedLo) && (0, _predicateJs.isNullable)(seedHi)) {
            seedLo = Math.random() * 0xffffffff >>> 0;
            seedHi = 0;
        } else if ((0, _predicateJs.isNullable)(seedLo)) {
            seedLo = seedHi;
            seedHi = 0;
        }
        if ((0, _predicateJs.isNullable)(incLo) && (0, _predicateJs.isNullable)(incHi)) {
            incLo = this._state ? this._state[3] : defaultIncLo;
            incHi = this._state ? this._state[2] : defaultIncHi;
        } else if ((0, _predicateJs.isNullable)(incLo)) {
            incLo = incHi;
            incHi = 0;
        }
        this._state = new Int32Array([
            0,
            0,
            incHi >>> 0,
            ((incLo || 0) | 1) >>> 0
        ]);
        this._next();
        add64(this._state, this._state[0], this._state[1], seedHi >>> 0, seedLo >>> 0);
        this._next();
        return this;
    }
    /**
   * Returns a copy of the internal state of this random number generator as a
   * JavaScript Array.
   *
   * @category getters
   * @since 2.0.0
   */ getState() {
        return [
            this._state[0],
            this._state[1],
            this._state[2],
            this._state[3]
        ];
    }
    /**
   * Restore state previously retrieved using `getState()`.
   *
   * @since 2.0.0
   */ setState(state) {
        this._state[0] = state[0];
        this._state[1] = state[1];
        this._state[2] = state[2];
        this._state[3] = state[3] | 1;
    }
    /**
   * Get a uniformly distributed 32 bit integer between [0, max).
   *
   * @category getter
   * @since 2.0.0
   */ integer(max) {
        return Math.round(this.number() * Number.MAX_SAFE_INTEGER) % max;
    }
    /**
   * Get a uniformly distributed IEEE-754 double between 0.0 and 1.0, with
   * 53 bits of precision (every bit of the mantissa is randomized).
   *
   * @category getters
   * @since 2.0.0
   */ number() {
        const hi = (this._next() & 0x03ffffff) * 1.0;
        const lo = (this._next() & 0x07ffffff) * 1.0;
        return (hi * BIT_27 + lo) / BIT_53;
    }
    /** @internal */ _next() {
        // save current state (what we'll use for this number)
        const oldHi = this._state[0] >>> 0;
        const oldLo = this._state[1] >>> 0;
        // churn LCG.
        mul64(this._state, oldHi, oldLo, MUL_HI, MUL_LO);
        add64(this._state, this._state[0], this._state[1], this._state[2], this._state[3]);
        // get least sig. 32 bits of ((oldstate >> 18) ^ oldstate) >> 27
        let xsHi = oldHi >>> 18;
        let xsLo = (oldLo >>> 18 | oldHi << 14) >>> 0;
        xsHi = (xsHi ^ oldHi) >>> 0;
        xsLo = (xsLo ^ oldLo) >>> 0;
        const xorshifted = (xsLo >>> 27 | xsHi << 5) >>> 0;
        // rotate xorshifted right a random amount, based on the most sig. 5 bits
        // bits of the old state.
        const rot = oldHi >>> 27;
        const rot2 = (-rot >>> 0 & 31) >>> 0;
        return (xorshifted >>> rot | xorshifted << rot2) >>> 0;
    }
}
function mul64(out, aHi, aLo, bHi, bLo) {
    let c1 = (aLo >>> 16) * (bLo & 0xffff) >>> 0;
    let c0 = (aLo & 0xffff) * (bLo >>> 16) >>> 0;
    let lo = (aLo & 0xffff) * (bLo & 0xffff) >>> 0;
    let hi = (aLo >>> 16) * (bLo >>> 16) + ((c0 >>> 16) + (c1 >>> 16)) >>> 0;
    c0 = c0 << 16 >>> 0;
    lo = lo + c0 >>> 0;
    if (lo >>> 0 < c0 >>> 0) hi = hi + 1 >>> 0;
    c1 = c1 << 16 >>> 0;
    lo = lo + c1 >>> 0;
    if (lo >>> 0 < c1 >>> 0) hi = hi + 1 >>> 0;
    hi = hi + Math.imul(aLo, bHi) >>> 0;
    hi = hi + Math.imul(aHi, bLo) >>> 0;
    out[0] = hi;
    out[1] = lo;
}
// add two 64 bit numbers (given in parts), and store the result in `out`.
function add64(out, aHi, aLo, bHi, bLo) {
    let hi = aHi + bHi >>> 0;
    const lo = aLo + bLo >>> 0;
    if (lo >>> 0 < aLo >>> 0) hi = hi + 1 | 0;
    out[0] = hi;
    out[1] = lo;
}
const YieldWrapTypeId = /*#__PURE__*/ Symbol.for("effect/Utils/YieldWrap");
class YieldWrap {
    /**
   * @since 3.0.6
   */ #value;
    constructor(value){
        this.#value = value;
    }
    /**
   * @since 3.0.6
   */ [YieldWrapTypeId]() {
        return this.#value;
    }
}
function yieldWrapGet(self) {
    if (typeof self === "object" && self !== null && YieldWrapTypeId in self) return self[YieldWrapTypeId]();
    throw new Error((0, _errorsJs.getBugErrorMessage)("yieldWrapGet"));
}
const structuralRegionState = /*#__PURE__*/ (0, _globalValueJs.globalValue)("effect/Utils/isStructuralRegion", ()=>({
        enabled: false,
        tester: undefined
    }));
const structuralRegion = (body, tester)=>{
    const current = structuralRegionState.enabled;
    const currentTester = structuralRegionState.tester;
    structuralRegionState.enabled = true;
    if (tester) structuralRegionState.tester = tester;
    try {
        return body();
    } finally{
        structuralRegionState.enabled = current;
        structuralRegionState.tester = currentTester;
    }
};
const standard = {
    effect_internal_function: (body)=>{
        return body();
    }
};
const forced = {
    effect_internal_function: (body)=>{
        return body();
    }
};
const isNotOptimizedAway = /*#__PURE__*/ standard.effect_internal_function(()=>new Error().stack)?.includes("effect_internal_function") === true;
const internalCall = isNotOptimizedAway ? standard.effect_internal_function : forced.effect_internal_function;
const genConstructor = (function*() {}).constructor;
const isGeneratorFunction = (u)=>(0, _predicateJs.isObject)(u) && u.constructor === genConstructor;

},{"./Function.js":"21gOL","./GlobalValue.js":"5w3Hn","./internal/errors.js":"2Q5er","./Predicate.js":"gW5pd","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"2Q5er":[function(require,module,exports,__globalThis) {
/**
 * @since 2.0.0
 */ /** @internal */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getBugErrorMessage", ()=>getBugErrorMessage);
const getBugErrorMessage = (message)=>`BUG: ${message} - please report an issue at https://github.com/Effect-TS/effect/issues`;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"1Ur70":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "NodeInspectSymbol", ()=>NodeInspectSymbol);
parcelHelpers.export(exports, "toJSON", ()=>toJSON);
parcelHelpers.export(exports, "format", ()=>format);
parcelHelpers.export(exports, "BaseProto", ()=>BaseProto);
/**
 * @since 2.0.0
 */ parcelHelpers.export(exports, "Class", ()=>Class);
parcelHelpers.export(exports, "toStringUnknown", ()=>toStringUnknown);
parcelHelpers.export(exports, "stringifyCircular", ()=>stringifyCircular);
parcelHelpers.export(exports, "symbolRedactable", ()=>symbolRedactable);
parcelHelpers.export(exports, "isRedactable", ()=>isRedactable);
parcelHelpers.export(exports, "withRedactableContext", ()=>withRedactableContext);
parcelHelpers.export(exports, "redact", ()=>redact);
var _globalValueJs = require("./GlobalValue.js");
var _predicateJs = require("./Predicate.js");
const NodeInspectSymbol = /*#__PURE__*/ Symbol.for("nodejs.util.inspect.custom");
const toJSON = (x)=>{
    try {
        if ((0, _predicateJs.hasProperty)(x, "toJSON") && (0, _predicateJs.isFunction)(x["toJSON"]) && x["toJSON"].length === 0) return x.toJSON();
        else if (Array.isArray(x)) return x.map(toJSON);
    } catch (_) {
        return {};
    }
    return redact(x);
};
const format = (x)=>JSON.stringify(x, null, 2);
const BaseProto = {
    toJSON () {
        return toJSON(this);
    },
    [NodeInspectSymbol] () {
        return this.toJSON();
    },
    toString () {
        return format(this.toJSON());
    }
};
class Class {
    /**
   * @since 2.0.0
   */ [NodeInspectSymbol]() {
        return this.toJSON();
    }
    /**
   * @since 2.0.0
   */ toString() {
        return format(this.toJSON());
    }
}
const toStringUnknown = (u, whitespace = 2)=>{
    if (typeof u === "string") return u;
    try {
        return typeof u === "object" ? stringifyCircular(u, whitespace) : String(u);
    } catch (_) {
        return String(u);
    }
};
const stringifyCircular = (obj, whitespace)=>{
    let cache = [];
    const retVal = JSON.stringify(obj, (_key, value)=>typeof value === "object" && value !== null ? cache.includes(value) ? undefined // circular reference
         : cache.push(value) && (redactableState.fiberRefs !== undefined && isRedactable(value) ? value[symbolRedactable](redactableState.fiberRefs) : value) : value, whitespace);
    cache = undefined;
    return retVal;
};
const symbolRedactable = /*#__PURE__*/ Symbol.for("effect/Inspectable/Redactable");
const isRedactable = (u)=>typeof u === "object" && u !== null && symbolRedactable in u;
const redactableState = /*#__PURE__*/ (0, _globalValueJs.globalValue)("effect/Inspectable/redactableState", ()=>({
        fiberRefs: undefined
    }));
const withRedactableContext = (context, f)=>{
    const prev = redactableState.fiberRefs;
    redactableState.fiberRefs = context;
    try {
        return f();
    } finally{
        redactableState.fiberRefs = prev;
    }
};
const redact = (u)=>{
    if (isRedactable(u) && redactableState.fiberRefs !== undefined) return u[symbolRedactable](redactableState.fiberRefs);
    return u;
};

},{"./GlobalValue.js":"5w3Hn","./Predicate.js":"gW5pd","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"8EvvU":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EffectTypeId", ()=>EffectTypeId);
parcelHelpers.export(exports, "StreamTypeId", ()=>StreamTypeId);
parcelHelpers.export(exports, "SinkTypeId", ()=>SinkTypeId);
parcelHelpers.export(exports, "ChannelTypeId", ()=>ChannelTypeId);
parcelHelpers.export(exports, "effectVariance", ()=>effectVariance);
parcelHelpers.export(exports, "EffectPrototype", ()=>EffectPrototype);
parcelHelpers.export(exports, "StructuralPrototype", ()=>StructuralPrototype);
parcelHelpers.export(exports, "CommitPrototype", ()=>CommitPrototype);
parcelHelpers.export(exports, "StructuralCommitPrototype", ()=>StructuralCommitPrototype);
parcelHelpers.export(exports, "Base", ()=>Base);
parcelHelpers.export(exports, "StructuralBase", ()=>StructuralBase);
var _equalJs = require("../Equal.js");
var _hashJs = require("../Hash.js");
var _pipeableJs = require("../Pipeable.js");
var _utilsJs = require("../Utils.js");
var _effectJs = require("./opCodes/effect.js");
var _versionJs = require("./version.js");
const EffectTypeId = /*#__PURE__*/ Symbol.for("effect/Effect");
const StreamTypeId = /*#__PURE__*/ Symbol.for("effect/Stream");
const SinkTypeId = /*#__PURE__*/ Symbol.for("effect/Sink");
const ChannelTypeId = /*#__PURE__*/ Symbol.for("effect/Channel");
const effectVariance = {
    /* c8 ignore next */ _R: (_)=>_,
    /* c8 ignore next */ _E: (_)=>_,
    /* c8 ignore next */ _A: (_)=>_,
    _V: /*#__PURE__*/ _versionJs.getCurrentVersion()
};
const sinkVariance = {
    /* c8 ignore next */ _A: (_)=>_,
    /* c8 ignore next */ _In: (_)=>_,
    /* c8 ignore next */ _L: (_)=>_,
    /* c8 ignore next */ _E: (_)=>_,
    /* c8 ignore next */ _R: (_)=>_
};
const channelVariance = {
    /* c8 ignore next */ _Env: (_)=>_,
    /* c8 ignore next */ _InErr: (_)=>_,
    /* c8 ignore next */ _InElem: (_)=>_,
    /* c8 ignore next */ _InDone: (_)=>_,
    /* c8 ignore next */ _OutErr: (_)=>_,
    /* c8 ignore next */ _OutElem: (_)=>_,
    /* c8 ignore next */ _OutDone: (_)=>_
};
const EffectPrototype = {
    [EffectTypeId]: effectVariance,
    [StreamTypeId]: effectVariance,
    [SinkTypeId]: sinkVariance,
    [ChannelTypeId]: channelVariance,
    [_equalJs.symbol] (that) {
        return this === that;
    },
    [_hashJs.symbol] () {
        return _hashJs.cached(this, _hashJs.random(this));
    },
    [Symbol.iterator] () {
        return new (0, _utilsJs.SingleShotGen)(new (0, _utilsJs.YieldWrap)(this));
    },
    pipe () {
        return (0, _pipeableJs.pipeArguments)(this, arguments);
    }
};
const StructuralPrototype = {
    [_hashJs.symbol] () {
        return _hashJs.cached(this, _hashJs.structure(this));
    },
    [_equalJs.symbol] (that) {
        const selfKeys = Object.keys(this);
        const thatKeys = Object.keys(that);
        if (selfKeys.length !== thatKeys.length) return false;
        for (const key of selfKeys){
            if (!(key in that && _equalJs.equals(this[key], that[key]))) return false;
        }
        return true;
    }
};
const CommitPrototype = {
    ...EffectPrototype,
    _op: _effectJs.OP_COMMIT
};
const StructuralCommitPrototype = {
    ...CommitPrototype,
    ...StructuralPrototype
};
const Base = /*#__PURE__*/ function() {
    function Base() {}
    Base.prototype = CommitPrototype;
    return Base;
}();
const StructuralBase = /*#__PURE__*/ function() {
    function Base() {}
    Base.prototype = StructuralCommitPrototype;
    return Base;
}();

},{"../Equal.js":"gA0qD","../Hash.js":"gFMwE","../Pipeable.js":"b5RU2","../Utils.js":"dYvz1","./opCodes/effect.js":"9RoDl","./version.js":"euXJO","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"b5RU2":[function(require,module,exports,__globalThis) {
/**
 * @since 2.0.0
 */ /**
 * @since 2.0.0
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "pipeArguments", ()=>pipeArguments);
const pipeArguments = (self, args)=>{
    switch(args.length){
        case 0:
            return self;
        case 1:
            return args[0](self);
        case 2:
            return args[1](args[0](self));
        case 3:
            return args[2](args[1](args[0](self)));
        case 4:
            return args[3](args[2](args[1](args[0](self))));
        case 5:
            return args[4](args[3](args[2](args[1](args[0](self)))));
        case 6:
            return args[5](args[4](args[3](args[2](args[1](args[0](self))))));
        case 7:
            return args[6](args[5](args[4](args[3](args[2](args[1](args[0](self)))))));
        case 8:
            return args[7](args[6](args[5](args[4](args[3](args[2](args[1](args[0](self))))))));
        case 9:
            return args[8](args[7](args[6](args[5](args[4](args[3](args[2](args[1](args[0](self)))))))));
        default:
            {
                let ret = self;
                for(let i = 0, len = args.length; i < len; i++)ret = args[i](ret);
                return ret;
            }
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"9RoDl":[function(require,module,exports,__globalThis) {
/** @internal */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "OP_ASYNC", ()=>OP_ASYNC);
parcelHelpers.export(exports, "OP_COMMIT", ()=>OP_COMMIT);
parcelHelpers.export(exports, "OP_FAILURE", ()=>OP_FAILURE);
parcelHelpers.export(exports, "OP_ON_FAILURE", ()=>OP_ON_FAILURE);
parcelHelpers.export(exports, "OP_ON_SUCCESS", ()=>OP_ON_SUCCESS);
parcelHelpers.export(exports, "OP_ON_SUCCESS_AND_FAILURE", ()=>OP_ON_SUCCESS_AND_FAILURE);
parcelHelpers.export(exports, "OP_SUCCESS", ()=>OP_SUCCESS);
parcelHelpers.export(exports, "OP_SYNC", ()=>OP_SYNC);
parcelHelpers.export(exports, "OP_TAG", ()=>OP_TAG);
parcelHelpers.export(exports, "OP_UPDATE_RUNTIME_FLAGS", ()=>OP_UPDATE_RUNTIME_FLAGS);
parcelHelpers.export(exports, "OP_WHILE", ()=>OP_WHILE);
parcelHelpers.export(exports, "OP_ITERATOR", ()=>OP_ITERATOR);
parcelHelpers.export(exports, "OP_WITH_RUNTIME", ()=>OP_WITH_RUNTIME);
parcelHelpers.export(exports, "OP_YIELD", ()=>OP_YIELD);
parcelHelpers.export(exports, "OP_REVERT_FLAGS", ()=>OP_REVERT_FLAGS);
const OP_ASYNC = "Async";
const OP_COMMIT = "Commit";
const OP_FAILURE = "Failure";
const OP_ON_FAILURE = "OnFailure";
const OP_ON_SUCCESS = "OnSuccess";
const OP_ON_SUCCESS_AND_FAILURE = "OnSuccessAndFailure";
const OP_SUCCESS = "Success";
const OP_SYNC = "Sync";
const OP_TAG = "Tag";
const OP_UPDATE_RUNTIME_FLAGS = "UpdateRuntimeFlags";
const OP_WHILE = "While";
const OP_ITERATOR = "Iterator";
const OP_WITH_RUNTIME = "WithRuntime";
const OP_YIELD = "Yield";
const OP_REVERT_FLAGS = "RevertFlags";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"c4fL5":[function(require,module,exports,__globalThis) {
/**
 * @since 2.0.0
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isOption", ()=>isOption);
parcelHelpers.export(exports, "isNone", ()=>isNone);
parcelHelpers.export(exports, "isSome", ()=>isSome);
parcelHelpers.export(exports, "none", ()=>none);
parcelHelpers.export(exports, "some", ()=>some);
var _equalJs = require("../Equal.js");
var _hashJs = require("../Hash.js");
var _inspectableJs = require("../Inspectable.js");
var _predicateJs = require("../Predicate.js");
var _effectableJs = require("./effectable.js");
const TypeId = /*#__PURE__*/ Symbol.for("effect/Option");
const CommonProto = {
    ...(0, _effectableJs.EffectPrototype),
    [TypeId]: {
        _A: (_)=>_
    },
    [(0, _inspectableJs.NodeInspectSymbol)] () {
        return this.toJSON();
    },
    toString () {
        return (0, _inspectableJs.format)(this.toJSON());
    }
};
const SomeProto = /*#__PURE__*/ Object.assign(/*#__PURE__*/ Object.create(CommonProto), {
    _tag: "Some",
    _op: "Some",
    [_equalJs.symbol] (that) {
        return isOption(that) && isSome(that) && _equalJs.equals(this.value, that.value);
    },
    [_hashJs.symbol] () {
        return _hashJs.cached(this, _hashJs.combine(_hashJs.hash(this._tag))(_hashJs.hash(this.value)));
    },
    toJSON () {
        return {
            _id: "Option",
            _tag: this._tag,
            value: (0, _inspectableJs.toJSON)(this.value)
        };
    }
});
const NoneHash = /*#__PURE__*/ _hashJs.hash("None");
const NoneProto = /*#__PURE__*/ Object.assign(/*#__PURE__*/ Object.create(CommonProto), {
    _tag: "None",
    _op: "None",
    [_equalJs.symbol] (that) {
        return isOption(that) && isNone(that);
    },
    [_hashJs.symbol] () {
        return NoneHash;
    },
    toJSON () {
        return {
            _id: "Option",
            _tag: this._tag
        };
    }
});
const isOption = (input)=>(0, _predicateJs.hasProperty)(input, TypeId);
const isNone = (fa)=>fa._tag === "None";
const isSome = (fa)=>fa._tag === "Some";
const none = /*#__PURE__*/ Object.create(NoneProto);
const some = (value)=>{
    const a = Object.create(SomeProto);
    a.value = value;
    return a;
};

},{"../Equal.js":"gA0qD","../Hash.js":"gFMwE","../Inspectable.js":"1Ur70","../Predicate.js":"gW5pd","./effectable.js":"8EvvU","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"a5YhT":[function(require,module,exports,__globalThis) {
/**
 * @since 2.0.0
 */ /** @internal */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isNonEmptyArray", ()=>isNonEmptyArray);
const isNonEmptyArray = (self)=>self.length > 0;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"dJ2mI":[function(require,module,exports,__globalThis) {
/**
 * This module provides utility functions for working with Iterables in TypeScript.
 *
 * @since 2.0.0
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeBy", ()=>makeBy);
parcelHelpers.export(exports, "range", ()=>range);
parcelHelpers.export(exports, "replicate", ()=>replicate);
parcelHelpers.export(exports, "fromRecord", ()=>fromRecord);
parcelHelpers.export(exports, "prepend", ()=>prepend);
parcelHelpers.export(exports, "prependAll", ()=>prependAll);
parcelHelpers.export(exports, "append", ()=>append);
parcelHelpers.export(exports, "appendAll", ()=>appendAll);
parcelHelpers.export(exports, "scan", ()=>scan);
parcelHelpers.export(exports, "isEmpty", ()=>isEmpty);
parcelHelpers.export(exports, "size", ()=>size);
parcelHelpers.export(exports, "head", ()=>head);
parcelHelpers.export(exports, "unsafeHead", ()=>unsafeHead);
parcelHelpers.export(exports, "take", ()=>take);
parcelHelpers.export(exports, "takeWhile", ()=>takeWhile);
parcelHelpers.export(exports, "drop", ()=>drop);
parcelHelpers.export(exports, "findFirst", ()=>findFirst);
parcelHelpers.export(exports, "findLast", ()=>findLast);
parcelHelpers.export(exports, "zip", ()=>zip);
parcelHelpers.export(exports, "zipWith", ()=>zipWith);
parcelHelpers.export(exports, "intersperse", ()=>intersperse);
parcelHelpers.export(exports, "containsWith", ()=>containsWith);
parcelHelpers.export(exports, "contains", ()=>contains);
parcelHelpers.export(exports, "chunksOf", ()=>chunksOf);
parcelHelpers.export(exports, "groupWith", ()=>groupWith);
parcelHelpers.export(exports, "group", ()=>group);
parcelHelpers.export(exports, "groupBy", ()=>groupBy);
parcelHelpers.export(exports, "empty", ()=>empty);
parcelHelpers.export(exports, "of", ()=>of);
parcelHelpers.export(exports, "map", ()=>map);
parcelHelpers.export(exports, "flatMap", ()=>flatMap);
parcelHelpers.export(exports, "flatten", ()=>flatten);
parcelHelpers.export(exports, "filterMap", ()=>filterMap);
parcelHelpers.export(exports, "filterMapWhile", ()=>filterMapWhile);
parcelHelpers.export(exports, "getSomes", ()=>getSomes);
parcelHelpers.export(exports, "getLefts", ()=>getLefts);
parcelHelpers.export(exports, "getRights", ()=>getRights);
parcelHelpers.export(exports, "filter", ()=>filter);
parcelHelpers.export(exports, "flatMapNullable", ()=>flatMapNullable);
parcelHelpers.export(exports, "some", ()=>some);
parcelHelpers.export(exports, "unfold", ()=>unfold);
parcelHelpers.export(exports, "forEach", ()=>forEach);
parcelHelpers.export(exports, "reduce", ()=>reduce);
parcelHelpers.export(exports, "dedupeAdjacentWith", ()=>dedupeAdjacentWith);
parcelHelpers.export(exports, "dedupeAdjacent", ()=>dedupeAdjacent);
parcelHelpers.export(exports, "cartesianWith", ()=>cartesianWith);
parcelHelpers.export(exports, "cartesian", ()=>cartesian);
var _eitherJs = require("./Either.js");
var _equalJs = require("./Equal.js");
var _functionJs = require("./Function.js");
var _optionJs = require("./Option.js");
var _predicateJs = require("./Predicate.js");
var _tupleJs = require("./Tuple.js");
const makeBy = (f, options)=>{
    const max = options?.length !== undefined ? Math.max(1, Math.floor(options.length)) : Infinity;
    return {
        [Symbol.iterator] () {
            let i = 0;
            return {
                next () {
                    if (i < max) return {
                        value: f(i++),
                        done: false
                    };
                    return {
                        done: true,
                        value: undefined
                    };
                }
            };
        }
    };
};
const range = (start, end)=>{
    if (end === undefined) return makeBy((i)=>start + i);
    return makeBy((i)=>start + i, {
        length: start <= end ? end - start + 1 : 1
    });
};
const replicate = /*#__PURE__*/ (0, _functionJs.dual)(2, (a, n)=>makeBy(()=>a, {
        length: n
    }));
const fromRecord = (self)=>({
        *[Symbol.iterator] () {
            for(const key in self)if (Object.prototype.hasOwnProperty.call(self, key)) yield [
                key,
                self[key]
            ];
        }
    });
const prepend = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, head)=>prependAll(self, [
        head
    ]));
const prependAll = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>appendAll(that, self));
const append = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, last)=>appendAll(self, [
        last
    ]));
const appendAll = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>({
        [Symbol.iterator] () {
            const iterA = self[Symbol.iterator]();
            let doneA = false;
            let iterB;
            return {
                next () {
                    if (!doneA) {
                        const r = iterA.next();
                        if (r.done) {
                            doneA = true;
                            iterB = that[Symbol.iterator]();
                            return iterB.next();
                        }
                        return r;
                    }
                    return iterB.next();
                }
            };
        }
    }));
const scan = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, b, f)=>({
        [Symbol.iterator] () {
            let acc = b;
            let iterator;
            function next() {
                if (iterator === undefined) {
                    iterator = self[Symbol.iterator]();
                    return {
                        done: false,
                        value: acc
                    };
                }
                const result = iterator.next();
                if (result.done) return result;
                acc = f(acc, result.value);
                return {
                    done: false,
                    value: acc
                };
            }
            return {
                next
            };
        }
    }));
const isEmpty = (self)=>{
    const iterator = self[Symbol.iterator]();
    return iterator.next().done === true;
};
const size = (self)=>{
    const iterator = self[Symbol.iterator]();
    let count = 0;
    while(!iterator.next().done)count++;
    return count;
};
const head = (self)=>{
    const iterator = self[Symbol.iterator]();
    const result = iterator.next();
    return result.done ? _optionJs.none() : _optionJs.some(result.value);
};
const unsafeHead = (self)=>{
    const iterator = self[Symbol.iterator]();
    const result = iterator.next();
    if (result.done) throw new Error("unsafeHead: empty iterable");
    return result.value;
};
const take = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, n)=>({
        [Symbol.iterator] () {
            let i = 0;
            const iterator = self[Symbol.iterator]();
            return {
                next () {
                    if (i < n) {
                        i++;
                        return iterator.next();
                    }
                    return {
                        done: true,
                        value: undefined
                    };
                }
            };
        }
    }));
const takeWhile = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, predicate)=>({
        [Symbol.iterator] () {
            const iterator = self[Symbol.iterator]();
            let i = 0;
            return {
                next () {
                    const result = iterator.next();
                    if (result.done || !predicate(result.value, i++)) return {
                        done: true,
                        value: undefined
                    };
                    return result;
                }
            };
        }
    }));
const drop = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, n)=>({
        [Symbol.iterator] () {
            const iterator = self[Symbol.iterator]();
            let i = 0;
            return {
                next () {
                    while(i < n){
                        const result = iterator.next();
                        if (result.done) return {
                            done: true,
                            value: undefined
                        };
                        i++;
                    }
                    return iterator.next();
                }
            };
        }
    }));
const findFirst = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>{
    let i = 0;
    for (const a of self){
        const o = f(a, i);
        if ((0, _predicateJs.isBoolean)(o)) {
            if (o) return _optionJs.some(a);
        } else {
            if (_optionJs.isSome(o)) return o;
        }
        i++;
    }
    return _optionJs.none();
});
const findLast = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>{
    let i = 0;
    let last = _optionJs.none();
    for (const a of self){
        const o = f(a, i);
        if ((0, _predicateJs.isBoolean)(o)) {
            if (o) last = _optionJs.some(a);
        } else if (_optionJs.isSome(o)) last = o;
        i++;
    }
    return last;
});
const zip = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>zipWith(self, that, _tupleJs.make));
const zipWith = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, that, f)=>({
        [Symbol.iterator] () {
            const selfIterator = self[Symbol.iterator]();
            const thatIterator = that[Symbol.iterator]();
            return {
                next () {
                    const selfResult = selfIterator.next();
                    const thatResult = thatIterator.next();
                    if (selfResult.done || thatResult.done) return {
                        done: true,
                        value: undefined
                    };
                    return {
                        done: false,
                        value: f(selfResult.value, thatResult.value)
                    };
                }
            };
        }
    }));
const intersperse = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, middle)=>({
        [Symbol.iterator] () {
            const iterator = self[Symbol.iterator]();
            let next = iterator.next();
            let emitted = false;
            return {
                next () {
                    if (next.done) return next;
                    else if (emitted) {
                        emitted = false;
                        return {
                            done: false,
                            value: middle
                        };
                    }
                    emitted = true;
                    const result = next;
                    next = iterator.next();
                    return result;
                }
            };
        }
    }));
const containsWith = (isEquivalent)=>(0, _functionJs.dual)(2, (self, a)=>{
        for (const i of self){
            if (isEquivalent(a, i)) return true;
        }
        return false;
    });
const _equivalence = /*#__PURE__*/ _equalJs.equivalence();
const contains = /*#__PURE__*/ containsWith(_equivalence);
const chunksOf = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, n)=>{
    const safeN = Math.max(1, Math.floor(n));
    return {
        [Symbol.iterator] () {
            let iterator = self[Symbol.iterator]();
            return {
                next () {
                    if (iterator === undefined) return {
                        done: true,
                        value: undefined
                    };
                    const chunk = [];
                    for(let i = 0; i < safeN; i++){
                        const result = iterator.next();
                        if (result.done) {
                            iterator = undefined;
                            return chunk.length === 0 ? {
                                done: true,
                                value: undefined
                            } : {
                                done: false,
                                value: chunk
                            };
                        }
                        chunk.push(result.value);
                    }
                    return {
                        done: false,
                        value: chunk
                    };
                }
            };
        }
    };
});
const groupWith = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, isEquivalent)=>({
        [Symbol.iterator] () {
            const iterator = self[Symbol.iterator]();
            let nextResult;
            return {
                next () {
                    let result;
                    if (nextResult !== undefined) {
                        if (nextResult.done) return {
                            done: true,
                            value: undefined
                        };
                        result = nextResult;
                        nextResult = undefined;
                    } else {
                        result = iterator.next();
                        if (result.done) return {
                            done: true,
                            value: undefined
                        };
                    }
                    const chunk = [
                        result.value
                    ];
                    while(true){
                        const next = iterator.next();
                        if (next.done || !isEquivalent(result.value, next.value)) {
                            nextResult = next;
                            return {
                                done: false,
                                value: chunk
                            };
                        }
                        chunk.push(next.value);
                    }
                }
            };
        }
    }));
const group = /*#__PURE__*/ groupWith(/*#__PURE__*/ _equalJs.equivalence());
const groupBy = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>{
    const out = {};
    for (const a of self){
        const k = f(a);
        if (Object.prototype.hasOwnProperty.call(out, k)) out[k].push(a);
        else out[k] = [
            a
        ];
    }
    return out;
});
const constEmpty = {
    [Symbol.iterator] () {
        return constEmptyIterator;
    }
};
const constEmptyIterator = {
    next () {
        return {
            done: true,
            value: undefined
        };
    }
};
const empty = ()=>constEmpty;
const of = (a)=>[
        a
    ];
const map = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>({
        [Symbol.iterator] () {
            const iterator = self[Symbol.iterator]();
            let i = 0;
            return {
                next () {
                    const result = iterator.next();
                    if (result.done) return {
                        done: true,
                        value: undefined
                    };
                    return {
                        done: false,
                        value: f(result.value, i++)
                    };
                }
            };
        }
    }));
const flatMap = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>flatten(map(self, f)));
const flatten = (self)=>({
        [Symbol.iterator] () {
            const outerIterator = self[Symbol.iterator]();
            let innerIterator;
            function next() {
                if (innerIterator === undefined) {
                    const next = outerIterator.next();
                    if (next.done) return next;
                    innerIterator = next.value[Symbol.iterator]();
                }
                const result = innerIterator.next();
                if (result.done) {
                    innerIterator = undefined;
                    return next();
                }
                return result;
            }
            return {
                next
            };
        }
    });
const filterMap = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>({
        [Symbol.iterator] () {
            const iterator = self[Symbol.iterator]();
            let i = 0;
            return {
                next () {
                    let result = iterator.next();
                    while(!result.done){
                        const b = f(result.value, i++);
                        if (_optionJs.isSome(b)) return {
                            done: false,
                            value: b.value
                        };
                        result = iterator.next();
                    }
                    return {
                        done: true,
                        value: undefined
                    };
                }
            };
        }
    }));
const filterMapWhile = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>({
        [Symbol.iterator] () {
            const iterator = self[Symbol.iterator]();
            let i = 0;
            return {
                next () {
                    const result = iterator.next();
                    if (result.done) return {
                        done: true,
                        value: undefined
                    };
                    const b = f(result.value, i++);
                    if (_optionJs.isSome(b)) return {
                        done: false,
                        value: b.value
                    };
                    return {
                        done: true,
                        value: undefined
                    };
                }
            };
        }
    }));
const getSomes = /*#__PURE__*/ filterMap((0, _functionJs.identity));
const getLefts = (self)=>filterMap(self, _eitherJs.getLeft);
const getRights = (self)=>filterMap(self, _eitherJs.getRight);
const filter = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, predicate)=>({
        [Symbol.iterator] () {
            const iterator = self[Symbol.iterator]();
            let i = 0;
            return {
                next () {
                    let result = iterator.next();
                    while(!result.done){
                        if (predicate(result.value, i++)) return {
                            done: false,
                            value: result.value
                        };
                        result = iterator.next();
                    }
                    return {
                        done: true,
                        value: undefined
                    };
                }
            };
        }
    }));
const flatMapNullable = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>filterMap(self, (a)=>{
        const b = f(a);
        return b == null ? _optionJs.none() : _optionJs.some(b);
    }));
const some = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, predicate)=>{
    let i = 0;
    for (const a of self){
        if (predicate(a, i++)) return true;
    }
    return false;
});
const unfold = (b, f)=>({
        [Symbol.iterator] () {
            let next = b;
            return {
                next () {
                    const o = f(next);
                    if (_optionJs.isNone(o)) return {
                        done: true,
                        value: undefined
                    };
                    const [a, b] = o.value;
                    next = b;
                    return {
                        done: false,
                        value: a
                    };
                }
            };
        }
    });
const forEach = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>{
    let i = 0;
    for (const a of self)f(a, i++);
});
const reduce = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, b, f)=>{
    if (Array.isArray(self)) return self.reduce(f, b);
    let i = 0;
    let result = b;
    for (const n of self)result = f(result, n, i++);
    return result;
});
const dedupeAdjacentWith = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, isEquivalent)=>({
        [Symbol.iterator] () {
            const iterator = self[Symbol.iterator]();
            let first = true;
            let last;
            function next() {
                const result = iterator.next();
                if (result.done) return {
                    done: true,
                    value: undefined
                };
                if (first) {
                    first = false;
                    last = result.value;
                    return result;
                }
                const current = result.value;
                if (isEquivalent(last, current)) return next();
                last = current;
                return result;
            }
            return {
                next
            };
        }
    }));
const dedupeAdjacent = /*#__PURE__*/ dedupeAdjacentWith(/*#__PURE__*/ _equalJs.equivalence());
const cartesianWith = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, that, f)=>flatMap(self, (a)=>map(that, (b)=>f(a, b))));
const cartesian = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>cartesianWith(self, that, (a, b)=>[
            a,
            b
        ]));

},{"./Either.js":"4amnT","./Equal.js":"gA0qD","./Function.js":"21gOL","./Option.js":"6sHA7","./Predicate.js":"gW5pd","./Tuple.js":"j6dAo","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"6sHA7":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TypeId", ()=>TypeId);
parcelHelpers.export(exports, "none", ()=>none);
parcelHelpers.export(exports, "some", ()=>some);
parcelHelpers.export(exports, "isOption", ()=>isOption);
parcelHelpers.export(exports, "isNone", ()=>isNone);
parcelHelpers.export(exports, "isSome", ()=>isSome);
parcelHelpers.export(exports, "match", ()=>match);
parcelHelpers.export(exports, "toRefinement", ()=>toRefinement);
parcelHelpers.export(exports, "fromIterable", ()=>fromIterable);
parcelHelpers.export(exports, "getRight", ()=>getRight);
parcelHelpers.export(exports, "getLeft", ()=>getLeft);
parcelHelpers.export(exports, "getOrElse", ()=>getOrElse);
parcelHelpers.export(exports, "orElse", ()=>orElse);
parcelHelpers.export(exports, "orElseSome", ()=>orElseSome);
parcelHelpers.export(exports, "orElseEither", ()=>orElseEither);
parcelHelpers.export(exports, "firstSomeOf", ()=>firstSomeOf);
parcelHelpers.export(exports, "fromNullable", ()=>fromNullable);
parcelHelpers.export(exports, "liftNullable", ()=>liftNullable);
parcelHelpers.export(exports, "getOrNull", ()=>getOrNull);
parcelHelpers.export(exports, "getOrUndefined", ()=>getOrUndefined);
parcelHelpers.export(exports, "liftThrowable", ()=>liftThrowable);
parcelHelpers.export(exports, "getOrThrowWith", ()=>getOrThrowWith);
parcelHelpers.export(exports, "getOrThrow", ()=>getOrThrow);
parcelHelpers.export(exports, "map", ()=>map);
parcelHelpers.export(exports, "as", ()=>as);
parcelHelpers.export(exports, "asVoid", ()=>asVoid);
parcelHelpers.export(exports, "void", ()=>/**
 * @since 2.0.0
 */ void_);
parcelHelpers.export(exports, "flatMap", ()=>flatMap);
parcelHelpers.export(exports, "andThen", ()=>andThen);
parcelHelpers.export(exports, "flatMapNullable", ()=>flatMapNullable);
parcelHelpers.export(exports, "flatten", ()=>flatten);
parcelHelpers.export(exports, "zipRight", ()=>zipRight);
parcelHelpers.export(exports, "zipLeft", ()=>zipLeft);
parcelHelpers.export(exports, "composeK", ()=>composeK);
parcelHelpers.export(exports, "tap", ()=>tap);
parcelHelpers.export(exports, "product", ()=>product);
parcelHelpers.export(exports, "productMany", ()=>productMany);
parcelHelpers.export(exports, "all", ()=>all);
parcelHelpers.export(exports, "zipWith", ()=>zipWith);
parcelHelpers.export(exports, "ap", ()=>ap);
parcelHelpers.export(exports, "reduceCompact", ()=>reduceCompact);
parcelHelpers.export(exports, "toArray", ()=>toArray);
parcelHelpers.export(exports, "partitionMap", ()=>partitionMap);
parcelHelpers.export(exports, "filterMap", ()=>filterMap);
parcelHelpers.export(exports, "filter", ()=>filter);
parcelHelpers.export(exports, "getEquivalence", ()=>getEquivalence);
parcelHelpers.export(exports, "getOrder", ()=>getOrder);
parcelHelpers.export(exports, "lift2", ()=>lift2);
parcelHelpers.export(exports, "liftPredicate", ()=>liftPredicate);
parcelHelpers.export(exports, "containsWith", ()=>containsWith);
parcelHelpers.export(exports, "contains", ()=>contains);
parcelHelpers.export(exports, "exists", ()=>exists);
parcelHelpers.export(exports, "bindTo", ()=>bindTo);
parcelHelpers.export(exports, "let", ()=>/**
 * The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.
 *
 * Here's how the do simulation works:
 *
 * 1. Start the do simulation using the `Do` value
 * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Option` values
 * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope
 * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values
 * 5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import { Option, pipe } from "effect"
 *
 * const result = pipe(
 *   Option.Do,
 *   Option.bind("x", () => Option.some(2)),
 *   Option.bind("y", () => Option.some(3)),
 *   Option.let("sum", ({ x, y }) => x + y),
 *   Option.filter(({ x, y }) => x * y > 5)
 * )
 * assert.deepStrictEqual(result, Option.some({ x: 2, y: 3, sum: 5 }))
 * ```
 *
 * @see {@link Do}
 * @see {@link bind}
 * @see {@link bindTo}
 *
 * @category Do notation
 * @since 2.0.0
 */ let_);
parcelHelpers.export(exports, "bind", ()=>bind);
parcelHelpers.export(exports, "Do", ()=>Do);
parcelHelpers.export(exports, "gen", ()=>gen);
parcelHelpers.export(exports, "mergeWith", ()=>mergeWith);
var _equalJs = require("./Equal.js");
var _equivalenceJs = require("./Equivalence.js");
var _functionJs = require("./Function.js");
var _doNotationJs = require("./internal/doNotation.js");
var _eitherJs = require("./internal/either.js");
var _optionJs = require("./internal/option.js");
var _orderJs = require("./Order.js");
var _utilsJs = require("./Utils.js");
const TypeId = /*#__PURE__*/ Symbol.for("effect/Option");
const none = ()=>_optionJs.none;
const some = _optionJs.some;
const isOption = _optionJs.isOption;
const isNone = _optionJs.isNone;
const isSome = _optionJs.isSome;
const match = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, { onNone, onSome })=>isNone(self) ? onNone() : onSome(self.value));
const toRefinement = (f)=>(a)=>isSome(f(a));
const fromIterable = (collection)=>{
    for (const a of collection)return some(a);
    return none();
};
const getRight = _eitherJs.getRight;
const getLeft = _eitherJs.getLeft;
const getOrElse = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, onNone)=>isNone(self) ? onNone() : self.value);
const orElse = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>isNone(self) ? that() : self);
const orElseSome = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, onNone)=>isNone(self) ? some(onNone()) : self);
const orElseEither = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>isNone(self) ? map(that(), _eitherJs.right) : map(self, _eitherJs.left));
const firstSomeOf = (collection)=>{
    let out = none();
    for (out of collection){
        if (isSome(out)) return out;
    }
    return out;
};
const fromNullable = (nullableValue)=>nullableValue == null ? none() : some(nullableValue);
const liftNullable = (f)=>(...a)=>fromNullable(f(...a));
const getOrNull = /*#__PURE__*/ getOrElse((0, _functionJs.constNull));
const getOrUndefined = /*#__PURE__*/ getOrElse((0, _functionJs.constUndefined));
const liftThrowable = (f)=>(...a)=>{
        try {
            return some(f(...a));
        } catch (e) {
            return none();
        }
    };
const getOrThrowWith = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, onNone)=>{
    if (isSome(self)) return self.value;
    throw onNone();
});
const getOrThrow = /*#__PURE__*/ getOrThrowWith(()=>new Error("getOrThrow called on a None"));
const map = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>isNone(self) ? none() : some(f(self.value)));
const as = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, b)=>map(self, ()=>b));
const asVoid = /*#__PURE__*/ as(undefined);
const void_ = /*#__PURE__*/ some(undefined);
const flatMap = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>isNone(self) ? none() : f(self.value));
const andThen = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>flatMap(self, (a)=>{
        const b = (0, _functionJs.isFunction)(f) ? f(a) : f;
        return isOption(b) ? b : some(b);
    }));
const flatMapNullable = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>isNone(self) ? none() : fromNullable(f(self.value)));
const flatten = /*#__PURE__*/ flatMap((0, _functionJs.identity));
const zipRight = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>flatMap(self, ()=>that));
const zipLeft = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>tap(self, ()=>that));
const composeK = /*#__PURE__*/ (0, _functionJs.dual)(2, (afb, bfc)=>(a)=>flatMap(afb(a), bfc));
const tap = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>flatMap(self, (a)=>map(f(a), ()=>a)));
const product = (self, that)=>isSome(self) && isSome(that) ? some([
        self.value,
        that.value
    ]) : none();
const productMany = (self, collection)=>{
    if (isNone(self)) return none();
    const out = [
        self.value
    ];
    for (const o of collection){
        if (isNone(o)) return none();
        out.push(o.value);
    }
    return some(out);
};
const all = (input)=>{
    if (Symbol.iterator in input) {
        const out = [];
        for (const o of input){
            if (isNone(o)) return none();
            out.push(o.value);
        }
        return some(out);
    }
    const out = {};
    for (const key of Object.keys(input)){
        const o = input[key];
        if (isNone(o)) return none();
        out[key] = o.value;
    }
    return some(out);
};
const zipWith = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, that, f)=>map(product(self, that), ([a, b])=>f(a, b)));
const ap = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>zipWith(self, that, (f, a)=>f(a)));
const reduceCompact = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, b, f)=>{
    let out = b;
    for (const oa of self)if (isSome(oa)) out = f(out, oa.value);
    return out;
});
const toArray = (self)=>isNone(self) ? [] : [
        self.value
    ];
const partitionMap = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>{
    if (isNone(self)) return [
        none(),
        none()
    ];
    const e = f(self.value);
    return _eitherJs.isLeft(e) ? [
        some(e.left),
        none()
    ] : [
        none(),
        some(e.right)
    ];
});
const filterMap = flatMap;
const filter = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, predicate)=>filterMap(self, (b)=>predicate(b) ? _optionJs.some(b) : _optionJs.none));
const getEquivalence = (isEquivalent)=>_equivalenceJs.make((x, y)=>isNone(x) ? isNone(y) : isNone(y) ? false : isEquivalent(x.value, y.value));
const getOrder = (O)=>_orderJs.make((self, that)=>isSome(self) ? isSome(that) ? O(self.value, that.value) : 1 : -1);
const lift2 = (f)=>(0, _functionJs.dual)(2, (self, that)=>zipWith(self, that, f));
const liftPredicate = /*#__PURE__*/ (0, _functionJs.dual)(2, (b, predicate)=>predicate(b) ? some(b) : none());
const containsWith = (isEquivalent)=>(0, _functionJs.dual)(2, (self, a)=>isNone(self) ? false : isEquivalent(self.value, a));
const _equivalence = /*#__PURE__*/ _equalJs.equivalence();
const contains = /*#__PURE__*/ containsWith(_equivalence);
const exists = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, refinement)=>isNone(self) ? false : refinement(self.value));
const bindTo = /*#__PURE__*/ _doNotationJs.bindTo(map);
const let_ = /*#__PURE__*/ _doNotationJs.let_(map);
const bind = /*#__PURE__*/ _doNotationJs.bind(map, flatMap);
const Do = /*#__PURE__*/ some({});
const adapter = /*#__PURE__*/ _utilsJs.adapter();
const gen = (...args)=>{
    const f = args.length === 1 ? args[0] : args[1].bind(args[0]);
    const iterator = f(adapter);
    let state = iterator.next();
    while(!state.done){
        const current = _utilsJs.isGenKind(state.value) ? state.value.value : _utilsJs.yieldWrapGet(state.value);
        if (isNone(current)) return current;
        state = iterator.next(current.value);
    }
    return some(state.value);
};
const mergeWith = (f)=>(o1, o2)=>{
        if (isNone(o1)) return o2;
        else if (isNone(o2)) return o1;
        return some(f(o1.value, o2.value));
    };

},{"./Equal.js":"gA0qD","./Equivalence.js":"1WBUa","./Function.js":"21gOL","./internal/doNotation.js":"6eyzd","./internal/either.js":"8gD6z","./internal/option.js":"c4fL5","./Order.js":"lQMwD","./Utils.js":"dYvz1","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"lQMwD":[function(require,module,exports,__globalThis) {
/**
 * This module provides an implementation of the `Order` type class which is used to define a total ordering on some type `A`.
 * An order is defined by a relation `<=`, which obeys the following laws:
 *
 * - either `x <= y` or `y <= x` (totality)
 * - if `x <= y` and `y <= x`, then `x == y` (antisymmetry)
 * - if `x <= y` and `y <= z`, then `x <= z` (transitivity)
 *
 * The truth table for compare is defined as follows:
 *
 * | `x <= y` | `x >= y` | Ordering |                       |
 * | -------- | -------- | -------- | --------------------- |
 * | `true`   | `true`   | `0`      | corresponds to x == y |
 * | `true`   | `false`  | `< 0`    | corresponds to x < y  |
 * | `false`  | `true`   | `> 0`    | corresponds to x > y  |
 *
 * @since 2.0.0
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "make", ()=>make);
parcelHelpers.export(exports, "string", ()=>string);
parcelHelpers.export(exports, "number", ()=>number);
parcelHelpers.export(exports, "boolean", ()=>boolean);
parcelHelpers.export(exports, "bigint", ()=>bigint);
parcelHelpers.export(exports, "reverse", ()=>reverse);
parcelHelpers.export(exports, "combine", ()=>combine);
parcelHelpers.export(exports, "combineMany", ()=>combineMany);
parcelHelpers.export(exports, "empty", ()=>empty);
parcelHelpers.export(exports, "combineAll", ()=>combineAll);
parcelHelpers.export(exports, "mapInput", ()=>mapInput);
parcelHelpers.export(exports, "Date", ()=>Date);
parcelHelpers.export(exports, "product", ()=>product);
parcelHelpers.export(exports, "all", ()=>all);
parcelHelpers.export(exports, "productMany", ()=>productMany);
parcelHelpers.export(exports, "tuple", ()=>tuple);
parcelHelpers.export(exports, "array", ()=>array);
parcelHelpers.export(exports, "struct", ()=>struct);
parcelHelpers.export(exports, "lessThan", ()=>lessThan);
parcelHelpers.export(exports, "greaterThan", ()=>greaterThan);
parcelHelpers.export(exports, "lessThanOrEqualTo", ()=>lessThanOrEqualTo);
parcelHelpers.export(exports, "greaterThanOrEqualTo", ()=>greaterThanOrEqualTo);
parcelHelpers.export(exports, "min", ()=>min);
parcelHelpers.export(exports, "max", ()=>max);
parcelHelpers.export(exports, "clamp", ()=>clamp);
parcelHelpers.export(exports, "between", ()=>between);
var _functionJs = require("./Function.js");
const make = (compare)=>(self, that)=>self === that ? 0 : compare(self, that);
const string = /*#__PURE__*/ make((self, that)=>self < that ? -1 : 1);
const number = /*#__PURE__*/ make((self, that)=>self < that ? -1 : 1);
const boolean = /*#__PURE__*/ make((self, that)=>self < that ? -1 : 1);
const bigint = /*#__PURE__*/ make((self, that)=>self < that ? -1 : 1);
const reverse = (O)=>make((self, that)=>O(that, self));
const combine = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>make((a1, a2)=>{
        const out = self(a1, a2);
        if (out !== 0) return out;
        return that(a1, a2);
    }));
const combineMany = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, collection)=>make((a1, a2)=>{
        let out = self(a1, a2);
        if (out !== 0) return out;
        for (const O of collection){
            out = O(a1, a2);
            if (out !== 0) return out;
        }
        return out;
    }));
const empty = ()=>make(()=>0);
const combineAll = (collection)=>combineMany(empty(), collection);
const mapInput = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>make((b1, b2)=>self(f(b1), f(b2))));
const Date = /*#__PURE__*/ mapInput(number, (date)=>date.getTime());
const product = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>make(([xa, xb], [ya, yb])=>{
        const o = self(xa, ya);
        return o !== 0 ? o : that(xb, yb);
    }));
const all = (collection)=>{
    return make((x, y)=>{
        const len = Math.min(x.length, y.length);
        let collectionLength = 0;
        for (const O of collection){
            if (collectionLength >= len) break;
            const o = O(x[collectionLength], y[collectionLength]);
            if (o !== 0) return o;
            collectionLength++;
        }
        return 0;
    });
};
const productMany = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, collection)=>{
    const O = all(collection);
    return make((x, y)=>{
        const o = self(x[0], y[0]);
        return o !== 0 ? o : O(x.slice(1), y.slice(1));
    });
});
const tuple = (...elements)=>all(elements);
const array = (O)=>make((self, that)=>{
        const aLen = self.length;
        const bLen = that.length;
        const len = Math.min(aLen, bLen);
        for(let i = 0; i < len; i++){
            const o = O(self[i], that[i]);
            if (o !== 0) return o;
        }
        return number(aLen, bLen);
    });
const struct = (fields)=>{
    const keys = Object.keys(fields);
    return make((self, that)=>{
        for (const key of keys){
            const o = fields[key](self[key], that[key]);
            if (o !== 0) return o;
        }
        return 0;
    });
};
const lessThan = (O)=>(0, _functionJs.dual)(2, (self, that)=>O(self, that) === -1);
const greaterThan = (O)=>(0, _functionJs.dual)(2, (self, that)=>O(self, that) === 1);
const lessThanOrEqualTo = (O)=>(0, _functionJs.dual)(2, (self, that)=>O(self, that) !== 1);
const greaterThanOrEqualTo = (O)=>(0, _functionJs.dual)(2, (self, that)=>O(self, that) !== -1);
const min = (O)=>(0, _functionJs.dual)(2, (self, that)=>self === that || O(self, that) < 1 ? self : that);
const max = (O)=>(0, _functionJs.dual)(2, (self, that)=>self === that || O(self, that) > -1 ? self : that);
const clamp = (O)=>(0, _functionJs.dual)(2, (self, options)=>min(O)(options.maximum, max(O)(options.minimum, self)));
const between = (O)=>(0, _functionJs.dual)(2, (self, options)=>!lessThan(O)(self, options.minimum) && !greaterThan(O)(self, options.maximum));

},{"./Function.js":"21gOL","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"j6dAo":[function(require,module,exports,__globalThis) {
/**
 * This module provides utility functions for working with tuples in TypeScript.
 *
 * @since 2.0.0
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isTupleOf", ()=>(0, _predicateJs.isTupleOf));
parcelHelpers.export(exports, "isTupleOfAtLeast", ()=>(0, _predicateJs.isTupleOfAtLeast));
parcelHelpers.export(exports, "make", ()=>make);
parcelHelpers.export(exports, "getFirst", ()=>getFirst);
parcelHelpers.export(exports, "getSecond", ()=>getSecond);
parcelHelpers.export(exports, "map", ()=>map);
parcelHelpers.export(exports, "mapBoth", ()=>mapBoth);
parcelHelpers.export(exports, "mapFirst", ()=>mapFirst);
parcelHelpers.export(exports, "mapSecond", ()=>mapSecond);
parcelHelpers.export(exports, "swap", ()=>swap);
parcelHelpers.export(exports, "getEquivalence", ()=>getEquivalence);
parcelHelpers.export(exports, "getOrder", ()=>getOrder);
parcelHelpers.export(exports, "appendElement", ()=>appendElement);
parcelHelpers.export(exports, "at", ()=>at);
var _equivalenceJs = require("./Equivalence.js");
var _functionJs = require("./Function.js");
var _orderJs = require("./Order.js");
var _predicateJs = require("./Predicate.js");
const make = (...elements)=>elements;
const getFirst = (self)=>self[0];
const getSecond = (self)=>self[1];
const map = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, fn)=>self.map((element)=>fn(element)));
const mapBoth = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, { onFirst, onSecond })=>[
        onFirst(self[0]),
        onSecond(self[1])
    ]);
const mapFirst = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>[
        f(self[0]),
        self[1]
    ]);
const mapSecond = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>[
        self[0],
        f(self[1])
    ]);
const swap = (self)=>[
        self[1],
        self[0]
    ];
const getEquivalence = _equivalenceJs.tuple;
const getOrder = _orderJs.tuple;
const appendElement = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>[
        ...self,
        that
    ]);
const at = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, index)=>self[index]);

},{"./Equivalence.js":"1WBUa","./Function.js":"21gOL","./Order.js":"lQMwD","./Predicate.js":"gW5pd","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"0LNUL":[function(require,module,exports,__globalThis) {
/**
 * This module provides utility functions for working with records in TypeScript.
 *
 * @since 2.0.0
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "empty", ()=>empty);
parcelHelpers.export(exports, "isEmptyRecord", ()=>isEmptyRecord);
parcelHelpers.export(exports, "isEmptyReadonlyRecord", ()=>isEmptyReadonlyRecord);
parcelHelpers.export(exports, "fromIterableWith", ()=>fromIterableWith);
parcelHelpers.export(exports, "fromIterableBy", ()=>fromIterableBy);
parcelHelpers.export(exports, "fromEntries", ()=>fromEntries);
parcelHelpers.export(exports, "collect", ()=>collect);
parcelHelpers.export(exports, "toEntries", ()=>toEntries);
parcelHelpers.export(exports, "size", ()=>size);
parcelHelpers.export(exports, "has", ()=>has);
parcelHelpers.export(exports, "get", ()=>get);
parcelHelpers.export(exports, "modify", ()=>modify);
parcelHelpers.export(exports, "modifyOption", ()=>modifyOption);
parcelHelpers.export(exports, "replaceOption", ()=>replaceOption);
parcelHelpers.export(exports, "remove", ()=>remove);
parcelHelpers.export(exports, "pop", ()=>pop);
parcelHelpers.export(exports, "map", ()=>map);
parcelHelpers.export(exports, "mapKeys", ()=>mapKeys);
parcelHelpers.export(exports, "mapEntries", ()=>mapEntries);
parcelHelpers.export(exports, "filterMap", ()=>filterMap);
parcelHelpers.export(exports, "filter", ()=>filter);
parcelHelpers.export(exports, "getSomes", ()=>getSomes);
parcelHelpers.export(exports, "getLefts", ()=>getLefts);
parcelHelpers.export(exports, "getRights", ()=>getRights);
parcelHelpers.export(exports, "partitionMap", ()=>partitionMap);
parcelHelpers.export(exports, "separate", ()=>separate);
parcelHelpers.export(exports, "partition", ()=>partition);
parcelHelpers.export(exports, "keys", ()=>keys);
parcelHelpers.export(exports, "values", ()=>values);
parcelHelpers.export(exports, "set", ()=>set);
parcelHelpers.export(exports, "replace", ()=>replace);
parcelHelpers.export(exports, "isSubrecordBy", ()=>isSubrecordBy);
parcelHelpers.export(exports, "isSubrecord", ()=>isSubrecord);
parcelHelpers.export(exports, "reduce", ()=>reduce);
parcelHelpers.export(exports, "every", ()=>every);
parcelHelpers.export(exports, "some", ()=>some);
parcelHelpers.export(exports, "union", ()=>union);
parcelHelpers.export(exports, "intersection", ()=>intersection);
parcelHelpers.export(exports, "difference", ()=>difference);
parcelHelpers.export(exports, "getEquivalence", ()=>getEquivalence);
parcelHelpers.export(exports, "singleton", ()=>singleton);
var _eitherJs = require("./Either.js");
var _equalJs = require("./Equal.js");
var _functionJs = require("./Function.js");
var _optionJs = require("./Option.js");
const empty = ()=>({});
const isEmptyRecord = (self)=>keys(self).length === 0;
const isEmptyReadonlyRecord = isEmptyRecord;
const fromIterableWith = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>{
    const out = empty();
    for (const a of self){
        const [k, b] = f(a);
        out[k] = b;
    }
    return out;
});
const fromIterableBy = (items, f)=>fromIterableWith(items, (a)=>[
            f(a),
            a
        ]);
const fromEntries = Object.fromEntries;
const collect = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>{
    const out = [];
    for (const key of keys(self))out.push(f(key, self[key]));
    return out;
});
const toEntries = /*#__PURE__*/ collect((key, value)=>[
        key,
        value
    ]);
const size = (self)=>keys(self).length;
const has = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, key)=>Object.prototype.hasOwnProperty.call(self, key));
const get = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, key)=>has(self, key) ? _optionJs.some(self[key]) : _optionJs.none());
const modify = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, key, f)=>{
    if (!has(self, key)) return {
        ...self
    };
    return {
        ...self,
        [key]: f(self[key])
    };
});
const modifyOption = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, key, f)=>{
    if (!has(self, key)) return _optionJs.none();
    return _optionJs.some({
        ...self,
        [key]: f(self[key])
    });
});
const replaceOption = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, key, b)=>modifyOption(self, key, ()=>b));
const remove = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, key)=>{
    if (!has(self, key)) return {
        ...self
    };
    const out = {
        ...self
    };
    delete out[key];
    return out;
});
const pop = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, key)=>has(self, key) ? _optionJs.some([
        self[key],
        remove(self, key)
    ]) : _optionJs.none());
const map = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>{
    const out = {
        ...self
    };
    for (const key of keys(self))out[key] = f(self[key], key);
    return out;
});
const mapKeys = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>{
    const out = {};
    for (const key of keys(self)){
        const a = self[key];
        out[f(key, a)] = a;
    }
    return out;
});
const mapEntries = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>{
    const out = {};
    for (const key of keys(self)){
        const [k, b] = f(self[key], key);
        out[k] = b;
    }
    return out;
});
const filterMap = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>{
    const out = empty();
    for (const key of keys(self)){
        const o = f(self[key], key);
        if (_optionJs.isSome(o)) out[key] = o.value;
    }
    return out;
});
const filter = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, predicate)=>{
    const out = empty();
    for (const key of keys(self))if (predicate(self[key], key)) out[key] = self[key];
    return out;
});
const getSomes = /*#__PURE__*/ filterMap((0, _functionJs.identity));
const getLefts = (self)=>{
    const out = empty();
    for (const key of keys(self)){
        const value = self[key];
        if (_eitherJs.isLeft(value)) out[key] = value.left;
    }
    return out;
};
const getRights = (self)=>{
    const out = empty();
    for (const key of keys(self)){
        const value = self[key];
        if (_eitherJs.isRight(value)) out[key] = value.right;
    }
    return out;
};
const partitionMap = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>{
    const left = empty();
    const right = empty();
    for (const key of keys(self)){
        const e = f(self[key], key);
        if (_eitherJs.isLeft(e)) left[key] = e.left;
        else right[key] = e.right;
    }
    return [
        left,
        right
    ];
});
const separate = /*#__PURE__*/ partitionMap((0, _functionJs.identity));
const partition = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, predicate)=>{
    const left = empty();
    const right = empty();
    for (const key of keys(self))if (predicate(self[key], key)) right[key] = self[key];
    else left[key] = self[key];
    return [
        left,
        right
    ];
});
const keys = (self)=>Object.keys(self);
const values = (self)=>collect(self, (_, a)=>a);
const set = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, key, value)=>{
    return {
        ...self,
        [key]: value
    };
});
const replace = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, key, value)=>{
    if (has(self, key)) return {
        ...self,
        [key]: value
    };
    return {
        ...self
    };
});
const isSubrecordBy = (equivalence)=>(0, _functionJs.dual)(2, (self, that)=>{
        for (const key of keys(self)){
            if (!has(that, key) || !equivalence(self[key], that[key])) return false;
        }
        return true;
    });
const isSubrecord = /*#__PURE__*/ isSubrecordBy(/*#__PURE__*/ _equalJs.equivalence());
const reduce = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, zero, f)=>{
    let out = zero;
    for (const key of keys(self))out = f(out, self[key], key);
    return out;
});
const every = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, refinement)=>{
    for (const key of keys(self)){
        if (!refinement(self[key], key)) return false;
    }
    return true;
});
const some = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, predicate)=>{
    for (const key of keys(self)){
        if (predicate(self[key], key)) return true;
    }
    return false;
});
const union = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, that, combine)=>{
    if (isEmptyRecord(self)) return {
        ...that
    };
    if (isEmptyRecord(that)) return {
        ...self
    };
    const out = empty();
    for (const key of keys(self))if (has(that, key)) out[key] = combine(self[key], that[key]);
    else out[key] = self[key];
    for (const key of keys(that))if (!has(out, key)) out[key] = that[key];
    return out;
});
const intersection = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, that, combine)=>{
    const out = empty();
    if (isEmptyRecord(self) || isEmptyRecord(that)) return out;
    for (const key of keys(self))if (has(that, key)) out[key] = combine(self[key], that[key]);
    return out;
});
const difference = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>{
    if (isEmptyRecord(self)) return {
        ...that
    };
    if (isEmptyRecord(that)) return {
        ...self
    };
    const out = {};
    for (const key of keys(self))if (!has(that, key)) out[key] = self[key];
    for (const key of keys(that))if (!has(self, key)) out[key] = that[key];
    return out;
});
const getEquivalence = (equivalence)=>{
    const is = isSubrecordBy(equivalence);
    return (self, that)=>is(self, that) && is(that, self);
};
const singleton = (key, value)=>({
        [key]: value
    });

},{"./Either.js":"4amnT","./Equal.js":"gA0qD","./Function.js":"21gOL","./Option.js":"6sHA7","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"jtl5B":[function(require,module,exports,__globalThis) {
/**
 * This module provides utility functions and type class instances for working with the `BigDecimal` type in TypeScript.
 * It includes functions for basic arithmetic operations, as well as type class instances for `Equivalence` and `Order`.
 *
 * A `BigDecimal` allows storing any real number to arbitrary precision; which avoids common floating point errors
 * (such as 0.1 + 0.2 ≠ 0.3) at the cost of complexity.
 *
 * Internally, `BigDecimal` uses a `BigInt` object, paired with a 64-bit integer which determines the position of the
 * decimal point. Therefore, the precision *is not* actually arbitrary, but limited to 2<sup>63</sup> decimal places.
 *
 * It is not recommended to convert a floating point number to a decimal directly, as the floating point representation
 * may be unexpected.
 *
 * @module BigDecimal
 * @since 2.0.0
 * @see {@link module:BigInt} for more similar operations on `bigint` types
 * @see {@link module:Number} for more similar operations on `number` types
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TypeId", ()=>TypeId);
parcelHelpers.export(exports, "isBigDecimal", ()=>isBigDecimal);
parcelHelpers.export(exports, "make", ()=>make);
parcelHelpers.export(exports, "unsafeMakeNormalized", ()=>unsafeMakeNormalized);
parcelHelpers.export(exports, "normalize", ()=>normalize);
parcelHelpers.export(exports, "scale", ()=>scale);
parcelHelpers.export(exports, "sum", ()=>sum);
parcelHelpers.export(exports, "multiply", ()=>multiply);
parcelHelpers.export(exports, "subtract", ()=>subtract);
parcelHelpers.export(exports, "roundTerminal", ()=>roundTerminal);
parcelHelpers.export(exports, "divide", ()=>divide);
parcelHelpers.export(exports, "unsafeDivide", ()=>unsafeDivide);
parcelHelpers.export(exports, "Order", ()=>Order);
parcelHelpers.export(exports, "lessThan", ()=>lessThan);
parcelHelpers.export(exports, "lessThanOrEqualTo", ()=>lessThanOrEqualTo);
parcelHelpers.export(exports, "greaterThan", ()=>greaterThan);
parcelHelpers.export(exports, "greaterThanOrEqualTo", ()=>greaterThanOrEqualTo);
parcelHelpers.export(exports, "between", ()=>between);
parcelHelpers.export(exports, "clamp", ()=>clamp);
parcelHelpers.export(exports, "min", ()=>min);
parcelHelpers.export(exports, "max", ()=>max);
parcelHelpers.export(exports, "sign", ()=>sign);
parcelHelpers.export(exports, "abs", ()=>abs);
parcelHelpers.export(exports, "negate", ()=>negate);
parcelHelpers.export(exports, "remainder", ()=>remainder);
parcelHelpers.export(exports, "unsafeRemainder", ()=>unsafeRemainder);
parcelHelpers.export(exports, "Equivalence", ()=>Equivalence);
parcelHelpers.export(exports, "equals", ()=>equals);
parcelHelpers.export(exports, "fromBigInt", ()=>fromBigInt);
parcelHelpers.export(exports, "unsafeFromNumber", ()=>unsafeFromNumber);
parcelHelpers.export(exports, "fromNumber", ()=>fromNumber);
parcelHelpers.export(exports, "safeFromNumber", ()=>safeFromNumber);
parcelHelpers.export(exports, "fromString", ()=>fromString);
parcelHelpers.export(exports, "unsafeFromString", ()=>unsafeFromString);
parcelHelpers.export(exports, "format", ()=>format);
parcelHelpers.export(exports, "toExponential", ()=>toExponential);
parcelHelpers.export(exports, "unsafeToNumber", ()=>unsafeToNumber);
parcelHelpers.export(exports, "isInteger", ()=>isInteger);
parcelHelpers.export(exports, "isZero", ()=>isZero);
parcelHelpers.export(exports, "isNegative", ()=>isNegative);
parcelHelpers.export(exports, "isPositive", ()=>isPositive);
var _equalJs = require("./Equal.js");
var _equivalenceJs = require("./Equivalence.js");
var _functionJs = require("./Function.js");
var _hashJs = require("./Hash.js");
var _inspectableJs = require("./Inspectable.js");
var _optionJs = require("./Option.js");
var _orderJs = require("./Order.js");
var _pipeableJs = require("./Pipeable.js");
var _predicateJs = require("./Predicate.js");
const DEFAULT_PRECISION = 100;
const FINITE_INT_REGEX = /^[+-]?\d+$/;
const TypeId = /*#__PURE__*/ Symbol.for("effect/BigDecimal");
const BigDecimalProto = {
    [TypeId]: TypeId,
    [_hashJs.symbol] () {
        const normalized = normalize(this);
        return (0, _functionJs.pipe)(_hashJs.hash(normalized.value), _hashJs.combine(_hashJs.number(normalized.scale)), _hashJs.cached(this));
    },
    [_equalJs.symbol] (that) {
        return isBigDecimal(that) && equals(this, that);
    },
    toString () {
        return `BigDecimal(${format(this)})`;
    },
    toJSON () {
        return {
            _id: "BigDecimal",
            value: String(this.value),
            scale: this.scale
        };
    },
    [(0, _inspectableJs.NodeInspectSymbol)] () {
        return this.toJSON();
    },
    pipe () {
        return (0, _pipeableJs.pipeArguments)(this, arguments);
    }
};
const isBigDecimal = (u)=>(0, _predicateJs.hasProperty)(u, TypeId);
const make = (value, scale)=>{
    const o = Object.create(BigDecimalProto);
    o.value = value;
    o.scale = scale;
    return o;
};
const unsafeMakeNormalized = (value, scale)=>{
    if (value !== bigint0 && value % bigint10 === bigint0) throw new RangeError("Value must be normalized");
    const o = make(value, scale);
    o.normalized = o;
    return o;
};
const bigint0 = /*#__PURE__*/ BigInt(0);
const bigint1 = /*#__PURE__*/ BigInt(1);
const bigint10 = /*#__PURE__*/ BigInt(10);
const zero = /*#__PURE__*/ unsafeMakeNormalized(bigint0, 0);
const normalize = (self)=>{
    if (self.normalized === undefined) {
        if (self.value === bigint0) self.normalized = zero;
        else {
            const digits = `${self.value}`;
            let trail = 0;
            for(let i = digits.length - 1; i >= 0; i--){
                if (digits[i] === "0") trail++;
                else break;
            }
            if (trail === 0) self.normalized = self;
            const value = BigInt(digits.substring(0, digits.length - trail));
            const scale = self.scale - trail;
            self.normalized = unsafeMakeNormalized(value, scale);
        }
    }
    return self.normalized;
};
const scale = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, scale)=>{
    if (scale > self.scale) return make(self.value * bigint10 ** BigInt(scale - self.scale), scale);
    if (scale < self.scale) return make(self.value / bigint10 ** BigInt(self.scale - scale), scale);
    return self;
});
const sum = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>{
    if (that.value === bigint0) return self;
    if (self.value === bigint0) return that;
    if (self.scale > that.scale) return make(scale(that, self.scale).value + self.value, self.scale);
    if (self.scale < that.scale) return make(scale(self, that.scale).value + that.value, that.scale);
    return make(self.value + that.value, self.scale);
});
const multiply = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>{
    if (that.value === bigint0 || self.value === bigint0) return zero;
    return make(self.value * that.value, self.scale + that.scale);
});
const subtract = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>{
    if (that.value === bigint0) return self;
    if (self.value === bigint0) return make(-that.value, that.scale);
    if (self.scale > that.scale) return make(self.value - scale(that, self.scale).value, self.scale);
    if (self.scale < that.scale) return make(scale(self, that.scale).value - that.value, that.scale);
    return make(self.value - that.value, self.scale);
});
/**
 * Internal function used for arbitrary precision division.
 */ const divideWithPrecision = (num, den, scale, precision)=>{
    const numNegative = num < bigint0;
    const denNegative = den < bigint0;
    const negateResult = numNegative !== denNegative;
    num = numNegative ? -num : num;
    den = denNegative ? -den : den;
    // Shift digits until numerator is larger than denominator (set scale appropriately).
    while(num < den){
        num *= bigint10;
        scale++;
    }
    // First division.
    let quotient = num / den;
    let remainder = num % den;
    if (remainder === bigint0) // No remainder, return immediately.
    return make(negateResult ? -quotient : quotient, scale);
    // The quotient is guaranteed to be non-negative at this point. No need to consider sign.
    let count = `${quotient}`.length;
    // Shift the remainder by 1 decimal; The quotient will be 1 digit upon next division.
    remainder *= bigint10;
    while(remainder !== bigint0 && count < precision){
        const q = remainder / den;
        const r = remainder % den;
        quotient = quotient * bigint10 + q;
        remainder = r * bigint10;
        count++;
        scale++;
    }
    if (remainder !== bigint0) // Round final number with remainder.
    quotient += roundTerminal(remainder / den);
    return make(negateResult ? -quotient : quotient, scale);
};
const roundTerminal = (n)=>{
    const pos = n >= bigint0 ? 0 : 1;
    return Number(`${n}`[pos]) < 5 ? bigint0 : bigint1;
};
const divide = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>{
    if (that.value === bigint0) return _optionJs.none();
    if (self.value === bigint0) return _optionJs.some(zero);
    const scale = self.scale - that.scale;
    if (self.value === that.value) return _optionJs.some(make(bigint1, scale));
    return _optionJs.some(divideWithPrecision(self.value, that.value, scale, DEFAULT_PRECISION));
});
const unsafeDivide = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>{
    if (that.value === bigint0) throw new RangeError("Division by zero");
    if (self.value === bigint0) return zero;
    const scale = self.scale - that.scale;
    if (self.value === that.value) return make(bigint1, scale);
    return divideWithPrecision(self.value, that.value, scale, DEFAULT_PRECISION);
});
const Order = /*#__PURE__*/ _orderJs.make((self, that)=>{
    const scmp = _orderJs.number(sign(self), sign(that));
    if (scmp !== 0) return scmp;
    if (self.scale > that.scale) return _orderJs.bigint(self.value, scale(that, self.scale).value);
    if (self.scale < that.scale) return _orderJs.bigint(scale(self, that.scale).value, that.value);
    return _orderJs.bigint(self.value, that.value);
});
const lessThan = /*#__PURE__*/ _orderJs.lessThan(Order);
const lessThanOrEqualTo = /*#__PURE__*/ _orderJs.lessThanOrEqualTo(Order);
const greaterThan = /*#__PURE__*/ _orderJs.greaterThan(Order);
const greaterThanOrEqualTo = /*#__PURE__*/ _orderJs.greaterThanOrEqualTo(Order);
const between = /*#__PURE__*/ _orderJs.between(Order);
const clamp = /*#__PURE__*/ _orderJs.clamp(Order);
const min = /*#__PURE__*/ _orderJs.min(Order);
const max = /*#__PURE__*/ _orderJs.max(Order);
const sign = (n)=>n.value === bigint0 ? 0 : n.value < bigint0 ? -1 : 1;
const abs = (n)=>n.value < bigint0 ? make(-n.value, n.scale) : n;
const negate = (n)=>make(-n.value, n.scale);
const remainder = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, divisor)=>{
    if (divisor.value === bigint0) return _optionJs.none();
    const max = Math.max(self.scale, divisor.scale);
    return _optionJs.some(make(scale(self, max).value % scale(divisor, max).value, max));
});
const unsafeRemainder = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, divisor)=>{
    if (divisor.value === bigint0) throw new RangeError("Division by zero");
    const max = Math.max(self.scale, divisor.scale);
    return make(scale(self, max).value % scale(divisor, max).value, max);
});
const Equivalence = /*#__PURE__*/ _equivalenceJs.make((self, that)=>{
    if (self.scale > that.scale) return scale(that, self.scale).value === self.value;
    if (self.scale < that.scale) return scale(self, that.scale).value === that.value;
    return self.value === that.value;
});
const equals = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>Equivalence(self, that));
const fromBigInt = (n)=>make(n, 0);
const unsafeFromNumber = (n)=>_optionJs.getOrThrowWith(safeFromNumber(n), ()=>new RangeError(`Number must be finite, got ${n}`));
const fromNumber = unsafeFromNumber;
const safeFromNumber = (n)=>{
    if (!Number.isFinite(n)) return _optionJs.none();
    const string = `${n}`;
    if (string.includes("e")) return fromString(string);
    const [lead, trail = ""] = string.split(".");
    return _optionJs.some(make(BigInt(`${lead}${trail}`), trail.length));
};
const fromString = (s)=>{
    if (s === "") return _optionJs.some(zero);
    let base;
    let exp;
    const seperator = s.search(/[eE]/);
    if (seperator !== -1) {
        const trail = s.slice(seperator + 1);
        base = s.slice(0, seperator);
        exp = Number(trail);
        if (base === "" || !Number.isSafeInteger(exp) || !FINITE_INT_REGEX.test(trail)) return _optionJs.none();
    } else {
        base = s;
        exp = 0;
    }
    let digits;
    let offset;
    const dot = base.search(/\./);
    if (dot !== -1) {
        const lead = base.slice(0, dot);
        const trail = base.slice(dot + 1);
        digits = `${lead}${trail}`;
        offset = trail.length;
    } else {
        digits = base;
        offset = 0;
    }
    if (!FINITE_INT_REGEX.test(digits)) return _optionJs.none();
    const scale = offset - exp;
    if (!Number.isSafeInteger(scale)) return _optionJs.none();
    return _optionJs.some(make(BigInt(digits), scale));
};
const unsafeFromString = (s)=>_optionJs.getOrThrowWith(fromString(s), ()=>new Error("Invalid numerical string"));
const format = (n)=>{
    const normalized = normalize(n);
    if (Math.abs(normalized.scale) >= 16) return toExponential(normalized);
    const negative = normalized.value < bigint0;
    const absolute = negative ? `${normalized.value}`.substring(1) : `${normalized.value}`;
    let before;
    let after;
    if (normalized.scale >= absolute.length) {
        before = "0";
        after = "0".repeat(normalized.scale - absolute.length) + absolute;
    } else {
        const location = absolute.length - normalized.scale;
        if (location > absolute.length) {
            const zeros = location - absolute.length;
            before = `${absolute}${"0".repeat(zeros)}`;
            after = "";
        } else {
            after = absolute.slice(location);
            before = absolute.slice(0, location);
        }
    }
    const complete = after === "" ? before : `${before}.${after}`;
    return negative ? `-${complete}` : complete;
};
const toExponential = (n)=>{
    if (isZero(n)) return "0e+0";
    const normalized = normalize(n);
    const digits = `${abs(normalized).value}`;
    const head = digits.slice(0, 1);
    const tail = digits.slice(1);
    let output = `${isNegative(normalized) ? "-" : ""}${head}`;
    if (tail !== "") output += `.${tail}`;
    const exp = tail.length - normalized.scale;
    return `${output}e${exp >= 0 ? "+" : ""}${exp}`;
};
const unsafeToNumber = (n)=>Number(format(n));
const isInteger = (n)=>normalize(n).scale <= 0;
const isZero = (n)=>n.value === bigint0;
const isNegative = (n)=>n.value < bigint0;
const isPositive = (n)=>n.value > bigint0;

},{"./Equal.js":"gA0qD","./Equivalence.js":"1WBUa","./Function.js":"21gOL","./Hash.js":"gFMwE","./Inspectable.js":"1Ur70","./Option.js":"6sHA7","./Order.js":"lQMwD","./Pipeable.js":"b5RU2","./Predicate.js":"gW5pd","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"4pVTc":[function(require,module,exports,__globalThis) {
/**
 * This module provides utility functions and type class instances for working with the `bigint` type in TypeScript.
 * It includes functions for basic arithmetic operations, as well as type class instances for
 * `Equivalence` and `Order`.
 *
 * @module BigInt
 * @since 2.0.0
 * @see {@link module:BigDecimal} for more similar operations on `BigDecimal` types
 * @see {@link module:Number} for more similar operations on `number` types
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isBigInt", ()=>isBigInt);
parcelHelpers.export(exports, "sum", ()=>sum);
parcelHelpers.export(exports, "multiply", ()=>multiply);
parcelHelpers.export(exports, "subtract", ()=>subtract);
parcelHelpers.export(exports, "divide", ()=>divide);
parcelHelpers.export(exports, "unsafeDivide", ()=>unsafeDivide);
parcelHelpers.export(exports, "increment", ()=>increment);
parcelHelpers.export(exports, "decrement", ()=>decrement);
parcelHelpers.export(exports, "Equivalence", ()=>Equivalence);
parcelHelpers.export(exports, "Order", ()=>Order);
parcelHelpers.export(exports, "lessThan", ()=>lessThan);
parcelHelpers.export(exports, "lessThanOrEqualTo", ()=>lessThanOrEqualTo);
parcelHelpers.export(exports, "greaterThan", ()=>greaterThan);
parcelHelpers.export(exports, "greaterThanOrEqualTo", ()=>greaterThanOrEqualTo);
parcelHelpers.export(exports, "between", ()=>between);
parcelHelpers.export(exports, "clamp", ()=>clamp);
parcelHelpers.export(exports, "min", ()=>min);
parcelHelpers.export(exports, "max", ()=>max);
parcelHelpers.export(exports, "sign", ()=>sign);
parcelHelpers.export(exports, "abs", ()=>abs);
parcelHelpers.export(exports, "gcd", ()=>gcd);
parcelHelpers.export(exports, "lcm", ()=>lcm);
parcelHelpers.export(exports, "unsafeSqrt", ()=>unsafeSqrt);
parcelHelpers.export(exports, "sqrt", ()=>sqrt);
parcelHelpers.export(exports, "sumAll", ()=>sumAll);
parcelHelpers.export(exports, "multiplyAll", ()=>multiplyAll);
parcelHelpers.export(exports, "toNumber", ()=>toNumber);
parcelHelpers.export(exports, "fromString", ()=>fromString);
parcelHelpers.export(exports, "fromNumber", ()=>fromNumber);
var _equivalenceJs = require("./Equivalence.js");
var _functionJs = require("./Function.js");
var _optionJs = require("./Option.js");
var _orderJs = require("./Order.js");
var _predicateJs = require("./Predicate.js");
const bigint0 = /*#__PURE__*/ BigInt(0);
const bigint1 = /*#__PURE__*/ BigInt(1);
const bigint2 = /*#__PURE__*/ BigInt(2);
const isBigInt = _predicateJs.isBigInt;
const sum = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>self + that);
const multiply = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>self * that);
const subtract = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>self - that);
const divide = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>that === bigint0 ? _optionJs.none() : _optionJs.some(self / that));
const unsafeDivide = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>self / that);
const increment = (n)=>n + bigint1;
const decrement = (n)=>n - bigint1;
const Equivalence = _equivalenceJs.bigint;
const Order = _orderJs.bigint;
const lessThan = /*#__PURE__*/ _orderJs.lessThan(Order);
const lessThanOrEqualTo = /*#__PURE__*/ _orderJs.lessThanOrEqualTo(Order);
const greaterThan = /*#__PURE__*/ _orderJs.greaterThan(Order);
const greaterThanOrEqualTo = /*#__PURE__*/ _orderJs.greaterThanOrEqualTo(Order);
const between = /*#__PURE__*/ _orderJs.between(Order);
const clamp = /*#__PURE__*/ _orderJs.clamp(Order);
const min = /*#__PURE__*/ _orderJs.min(Order);
const max = /*#__PURE__*/ _orderJs.max(Order);
const sign = (n)=>Order(n, bigint0);
const abs = (n)=>n < bigint0 ? -n : n;
const gcd = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>{
    while(that !== bigint0){
        const t = that;
        that = self % that;
        self = t;
    }
    return self;
});
const lcm = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>self * that / gcd(self, that));
const unsafeSqrt = (n)=>{
    if (n < bigint0) throw new RangeError("Cannot take the square root of a negative number");
    if (n < bigint2) return n;
    let x = n / bigint2;
    while(x * x > n)x = (n / x + x) / bigint2;
    return x;
};
const sqrt = (n)=>greaterThanOrEqualTo(n, bigint0) ? _optionJs.some(unsafeSqrt(n)) : _optionJs.none();
const sumAll = (collection)=>{
    let out = bigint0;
    for (const n of collection)out += n;
    return out;
};
const multiplyAll = (collection)=>{
    let out = bigint1;
    for (const n of collection){
        if (n === bigint0) return bigint0;
        out *= n;
    }
    return out;
};
const toNumber = (b)=>{
    if (b > BigInt(Number.MAX_SAFE_INTEGER) || b < BigInt(Number.MIN_SAFE_INTEGER)) return _optionJs.none();
    return _optionJs.some(Number(b));
};
const fromString = (s)=>{
    try {
        return s.trim() === "" ? _optionJs.none() : _optionJs.some(BigInt(s));
    } catch (_) {
        return _optionJs.none();
    }
};
const fromNumber = (n)=>{
    if (n > Number.MAX_SAFE_INTEGER || n < Number.MIN_SAFE_INTEGER) return _optionJs.none();
    try {
        return _optionJs.some(BigInt(n));
    } catch (_) {
        return _optionJs.none();
    }
};

},{"./Equivalence.js":"1WBUa","./Function.js":"21gOL","./Option.js":"6sHA7","./Order.js":"lQMwD","./Predicate.js":"gW5pd","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"40R3H":[function(require,module,exports,__globalThis) {
/**
 * This module provides utility functions and type class instances for working with the `boolean` type in TypeScript.
 * It includes functions for basic boolean operations, as well as type class instances for
 * `Equivalence` and `Order`.
 *
 * @since 2.0.0
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isBoolean", ()=>isBoolean);
parcelHelpers.export(exports, "match", ()=>match);
parcelHelpers.export(exports, "Equivalence", ()=>Equivalence);
parcelHelpers.export(exports, "Order", ()=>Order);
parcelHelpers.export(exports, "not", ()=>not);
parcelHelpers.export(exports, "and", ()=>and);
parcelHelpers.export(exports, "nand", ()=>nand);
parcelHelpers.export(exports, "or", ()=>or);
parcelHelpers.export(exports, "nor", ()=>nor);
parcelHelpers.export(exports, "xor", ()=>xor);
parcelHelpers.export(exports, "eqv", ()=>eqv);
parcelHelpers.export(exports, "implies", ()=>implies);
parcelHelpers.export(exports, "every", ()=>every);
parcelHelpers.export(exports, "some", ()=>some);
var _equivalenceJs = require("./Equivalence.js");
var _functionJs = require("./Function.js");
var _orderJs = require("./Order.js");
var _predicateJs = require("./Predicate.js");
const isBoolean = _predicateJs.isBoolean;
const match = /*#__PURE__*/ (0, _functionJs.dual)(2, (value, options)=>value ? options.onTrue() : options.onFalse());
const Equivalence = _equivalenceJs.boolean;
const Order = _orderJs.boolean;
const not = (self)=>!self;
const and = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>self && that);
const nand = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>!(self && that));
const or = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>self || that);
const nor = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>!(self || that));
const xor = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>!self && that || self && !that);
const eqv = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>!xor(self, that));
const implies = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>self ? that : true);
const every = (collection)=>{
    for (const b of collection){
        if (!b) return false;
    }
    return true;
};
const some = (collection)=>{
    for (const b of collection){
        if (b) return true;
    }
    return false;
};

},{"./Equivalence.js":"1WBUa","./Function.js":"21gOL","./Order.js":"lQMwD","./Predicate.js":"gW5pd","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"gQcQI":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CauseTypeId", ()=>CauseTypeId);
parcelHelpers.export(exports, "RuntimeExceptionTypeId", ()=>RuntimeExceptionTypeId);
parcelHelpers.export(exports, "InterruptedExceptionTypeId", ()=>InterruptedExceptionTypeId);
parcelHelpers.export(exports, "IllegalArgumentExceptionTypeId", ()=>IllegalArgumentExceptionTypeId);
parcelHelpers.export(exports, "NoSuchElementExceptionTypeId", ()=>NoSuchElementExceptionTypeId);
parcelHelpers.export(exports, "InvalidPubSubCapacityExceptionTypeId", ()=>InvalidPubSubCapacityExceptionTypeId);
parcelHelpers.export(exports, "ExceededCapacityExceptionTypeId", ()=>ExceededCapacityExceptionTypeId);
parcelHelpers.export(exports, "TimeoutExceptionTypeId", ()=>TimeoutExceptionTypeId);
parcelHelpers.export(exports, "UnknownExceptionTypeId", ()=>UnknownExceptionTypeId);
parcelHelpers.export(exports, "YieldableError", ()=>YieldableError);
parcelHelpers.export(exports, "empty", ()=>empty);
parcelHelpers.export(exports, "fail", ()=>fail);
parcelHelpers.export(exports, "die", ()=>die);
parcelHelpers.export(exports, "interrupt", ()=>interrupt);
parcelHelpers.export(exports, "parallel", ()=>parallel);
parcelHelpers.export(exports, "sequential", ()=>sequential);
parcelHelpers.export(exports, "isCause", ()=>isCause);
parcelHelpers.export(exports, "isEmptyType", ()=>isEmptyType);
parcelHelpers.export(exports, "isFailType", ()=>isFailType);
parcelHelpers.export(exports, "isDieType", ()=>isDieType);
parcelHelpers.export(exports, "isInterruptType", ()=>isInterruptType);
parcelHelpers.export(exports, "isSequentialType", ()=>isSequentialType);
parcelHelpers.export(exports, "isParallelType", ()=>isParallelType);
parcelHelpers.export(exports, "size", ()=>size);
parcelHelpers.export(exports, "isEmpty", ()=>isEmpty);
parcelHelpers.export(exports, "isFailure", ()=>isFailure);
parcelHelpers.export(exports, "isDie", ()=>isDie);
parcelHelpers.export(exports, "isInterrupted", ()=>isInterrupted);
parcelHelpers.export(exports, "isInterruptedOnly", ()=>isInterruptedOnly);
parcelHelpers.export(exports, "failures", ()=>failures);
parcelHelpers.export(exports, "defects", ()=>defects);
parcelHelpers.export(exports, "interruptors", ()=>interruptors);
parcelHelpers.export(exports, "failureOption", ()=>failureOption);
parcelHelpers.export(exports, "failureOrCause", ()=>failureOrCause);
parcelHelpers.export(exports, "flipCauseOption", ()=>flipCauseOption);
parcelHelpers.export(exports, "dieOption", ()=>dieOption);
parcelHelpers.export(exports, "interruptOption", ()=>interruptOption);
parcelHelpers.export(exports, "keepDefects", ()=>keepDefects);
parcelHelpers.export(exports, "linearize", ()=>linearize);
parcelHelpers.export(exports, "stripFailures", ()=>stripFailures);
parcelHelpers.export(exports, "stripSomeDefects", ()=>stripSomeDefects);
parcelHelpers.export(exports, "as", ()=>as);
parcelHelpers.export(exports, "map", ()=>map);
parcelHelpers.export(exports, "flatMap", ()=>flatMap);
parcelHelpers.export(exports, "andThen", ()=>andThen);
parcelHelpers.export(exports, "flatten", ()=>flatten);
parcelHelpers.export(exports, "contains", ()=>contains);
parcelHelpers.export(exports, "squash", ()=>squash);
parcelHelpers.export(exports, "squashWith", ()=>squashWith);
parcelHelpers.export(exports, "find", ()=>find);
parcelHelpers.export(exports, "filter", ()=>filter);
parcelHelpers.export(exports, "match", ()=>match);
parcelHelpers.export(exports, "reduce", ()=>reduce);
parcelHelpers.export(exports, "reduceWithContext", ()=>reduceWithContext);
parcelHelpers.export(exports, "InterruptedException", ()=>InterruptedException);
parcelHelpers.export(exports, "isInterruptedException", ()=>isInterruptedException);
parcelHelpers.export(exports, "IllegalArgumentException", ()=>IllegalArgumentException);
parcelHelpers.export(exports, "isIllegalArgumentException", ()=>isIllegalArgumentException);
parcelHelpers.export(exports, "NoSuchElementException", ()=>NoSuchElementException);
parcelHelpers.export(exports, "isNoSuchElementException", ()=>isNoSuchElementException);
parcelHelpers.export(exports, "RuntimeException", ()=>RuntimeException);
parcelHelpers.export(exports, "isRuntimeException", ()=>isRuntimeException);
parcelHelpers.export(exports, "TimeoutException", ()=>TimeoutException);
parcelHelpers.export(exports, "UnknownException", ()=>UnknownException);
parcelHelpers.export(exports, "isUnknownException", ()=>isUnknownException);
parcelHelpers.export(exports, "ExceededCapacityException", ()=>ExceededCapacityException);
parcelHelpers.export(exports, "isExceededCapacityException", ()=>isExceededCapacityException);
parcelHelpers.export(exports, "pretty", ()=>pretty);
parcelHelpers.export(exports, "prettyErrors", ()=>prettyErrors);
parcelHelpers.export(exports, "originalError", ()=>originalError);
var _causeJs = require("./internal/cause.js");
var _coreJs = require("./internal/core.js");
const CauseTypeId = _causeJs.CauseTypeId;
const RuntimeExceptionTypeId = _coreJs.RuntimeExceptionTypeId;
const InterruptedExceptionTypeId = _coreJs.InterruptedExceptionTypeId;
const IllegalArgumentExceptionTypeId = _coreJs.IllegalArgumentExceptionTypeId;
const NoSuchElementExceptionTypeId = _coreJs.NoSuchElementExceptionTypeId;
const InvalidPubSubCapacityExceptionTypeId = _coreJs.InvalidPubSubCapacityExceptionTypeId;
const ExceededCapacityExceptionTypeId = _coreJs.ExceededCapacityExceptionTypeId;
const TimeoutExceptionTypeId = _coreJs.TimeoutExceptionTypeId;
const UnknownExceptionTypeId = _coreJs.UnknownExceptionTypeId;
const YieldableError = _coreJs.YieldableError;
const empty = _causeJs.empty;
const fail = _causeJs.fail;
const die = _causeJs.die;
const interrupt = _causeJs.interrupt;
const parallel = _causeJs.parallel;
const sequential = _causeJs.sequential;
const isCause = _causeJs.isCause;
const isEmptyType = _causeJs.isEmptyType;
const isFailType = _causeJs.isFailType;
const isDieType = _causeJs.isDieType;
const isInterruptType = _causeJs.isInterruptType;
const isSequentialType = _causeJs.isSequentialType;
const isParallelType = _causeJs.isParallelType;
const size = _causeJs.size;
const isEmpty = _causeJs.isEmpty;
const isFailure = _causeJs.isFailure;
const isDie = _causeJs.isDie;
const isInterrupted = _causeJs.isInterrupted;
const isInterruptedOnly = _causeJs.isInterruptedOnly;
const failures = _causeJs.failures;
const defects = _causeJs.defects;
const interruptors = _causeJs.interruptors;
const failureOption = _causeJs.failureOption;
const failureOrCause = _causeJs.failureOrCause;
const flipCauseOption = _causeJs.flipCauseOption;
const dieOption = _causeJs.dieOption;
const interruptOption = _causeJs.interruptOption;
const keepDefects = _causeJs.keepDefects;
const linearize = _causeJs.linearize;
const stripFailures = _causeJs.stripFailures;
const stripSomeDefects = _causeJs.stripSomeDefects;
const as = _causeJs.as;
const map = _causeJs.map;
const flatMap = _causeJs.flatMap;
const andThen = _causeJs.andThen;
const flatten = _causeJs.flatten;
const contains = _causeJs.contains;
const squash = _coreJs.causeSquash;
const squashWith = _coreJs.causeSquashWith;
const find = _causeJs.find;
const filter = _causeJs.filter;
const match = _causeJs.match;
const reduce = _causeJs.reduce;
const reduceWithContext = _causeJs.reduceWithContext;
const InterruptedException = _coreJs.InterruptedException;
const isInterruptedException = _coreJs.isInterruptedException;
const IllegalArgumentException = _coreJs.IllegalArgumentException;
const isIllegalArgumentException = _coreJs.isIllegalArgumentException;
const NoSuchElementException = _coreJs.NoSuchElementException;
const isNoSuchElementException = _coreJs.isNoSuchElementException;
const RuntimeException = _coreJs.RuntimeException;
const isRuntimeException = _coreJs.isRuntimeException;
const TimeoutException = _coreJs.TimeoutException;
const UnknownException = _coreJs.UnknownException;
const isUnknownException = _coreJs.isUnknownException;
const ExceededCapacityException = _coreJs.ExceededCapacityException;
const isExceededCapacityException = _coreJs.isExceededCapacityException;
const pretty = _causeJs.pretty;
const prettyErrors = _causeJs.prettyErrors;
const originalError = _coreJs.originalInstance;

},{"./internal/cause.js":"l3ev0","./internal/core.js":"cr3YV","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"l3ev0":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CauseTypeId", ()=>CauseTypeId);
parcelHelpers.export(exports, "empty", ()=>empty);
parcelHelpers.export(exports, "fail", ()=>fail);
parcelHelpers.export(exports, "die", ()=>die);
parcelHelpers.export(exports, "interrupt", ()=>interrupt);
parcelHelpers.export(exports, "parallel", ()=>parallel);
parcelHelpers.export(exports, "sequential", ()=>sequential);
parcelHelpers.export(exports, "isCause", ()=>isCause);
parcelHelpers.export(exports, "isEmptyType", ()=>isEmptyType);
parcelHelpers.export(exports, "isFailType", ()=>isFailType);
parcelHelpers.export(exports, "isDieType", ()=>isDieType);
parcelHelpers.export(exports, "isInterruptType", ()=>isInterruptType);
parcelHelpers.export(exports, "isSequentialType", ()=>isSequentialType);
parcelHelpers.export(exports, "isParallelType", ()=>isParallelType);
parcelHelpers.export(exports, "size", ()=>size);
parcelHelpers.export(exports, "isEmpty", ()=>isEmpty);
parcelHelpers.export(exports, "isFailure", ()=>isFailure);
parcelHelpers.export(exports, "isDie", ()=>isDie);
parcelHelpers.export(exports, "isInterrupted", ()=>isInterrupted);
parcelHelpers.export(exports, "isInterruptedOnly", ()=>isInterruptedOnly);
parcelHelpers.export(exports, "failures", ()=>failures);
parcelHelpers.export(exports, "defects", ()=>defects);
parcelHelpers.export(exports, "interruptors", ()=>interruptors);
parcelHelpers.export(exports, "failureOption", ()=>failureOption);
parcelHelpers.export(exports, "failureOrCause", ()=>failureOrCause);
parcelHelpers.export(exports, "dieOption", ()=>dieOption);
parcelHelpers.export(exports, "flipCauseOption", ()=>flipCauseOption);
parcelHelpers.export(exports, "interruptOption", ()=>interruptOption);
parcelHelpers.export(exports, "keepDefects", ()=>keepDefects);
parcelHelpers.export(exports, "keepDefectsAndElectFailures", ()=>keepDefectsAndElectFailures);
parcelHelpers.export(exports, "linearize", ()=>linearize);
parcelHelpers.export(exports, "stripFailures", ()=>stripFailures);
parcelHelpers.export(exports, "electFailures", ()=>electFailures);
parcelHelpers.export(exports, "stripSomeDefects", ()=>stripSomeDefects);
parcelHelpers.export(exports, "as", ()=>as);
parcelHelpers.export(exports, "map", ()=>map);
parcelHelpers.export(exports, "flatMap", ()=>flatMap);
parcelHelpers.export(exports, "flatten", ()=>flatten);
parcelHelpers.export(exports, "andThen", ()=>andThen);
parcelHelpers.export(exports, "contains", ()=>contains);
parcelHelpers.export(exports, "find", ()=>find);
parcelHelpers.export(exports, "filter", ()=>filter);
parcelHelpers.export(exports, "match", ()=>match);
parcelHelpers.export(exports, "reduce", ()=>reduce);
parcelHelpers.export(exports, "reduceWithContext", ()=>reduceWithContext);
parcelHelpers.export(exports, "pretty", ()=>pretty);
/** @internal */ parcelHelpers.export(exports, "PrettyError", ()=>PrettyError);
parcelHelpers.export(exports, "prettyErrorMessage", ()=>prettyErrorMessage);
parcelHelpers.export(exports, "spanToTrace", ()=>spanToTrace);
parcelHelpers.export(exports, "spanSymbol", ()=>spanSymbol);
parcelHelpers.export(exports, "prettyErrors", ()=>prettyErrors);
var _arrayJs = require("../Array.js");
var _chunkJs = require("../Chunk.js");
var _eitherJs = require("../Either.js");
var _equalJs = require("../Equal.js");
var _functionJs = require("../Function.js");
var _globalValueJs = require("../GlobalValue.js");
var _hashJs = require("../Hash.js");
var _hashSetJs = require("../HashSet.js");
var _inspectableJs = require("../Inspectable.js");
var _optionJs = require("../Option.js");
var _pipeableJs = require("../Pipeable.js");
var _predicateJs = require("../Predicate.js");
var _errorsJs = require("./errors.js");
var _causeJs = require("./opCodes/cause.js");
// -----------------------------------------------------------------------------
// Models
// -----------------------------------------------------------------------------
/** @internal */ const CauseSymbolKey = "effect/Cause";
const CauseTypeId = /*#__PURE__*/ Symbol.for(CauseSymbolKey);
const variance = {
    /* c8 ignore next */ _E: (_)=>_
};
/** @internal */ const proto = {
    [CauseTypeId]: variance,
    [_hashJs.symbol] () {
        return (0, _functionJs.pipe)(_hashJs.hash(CauseSymbolKey), _hashJs.combine(_hashJs.hash(flattenCause(this))), _hashJs.cached(this));
    },
    [_equalJs.symbol] (that) {
        return isCause(that) && causeEquals(this, that);
    },
    pipe () {
        return (0, _pipeableJs.pipeArguments)(this, arguments);
    },
    toJSON () {
        switch(this._tag){
            case "Empty":
                return {
                    _id: "Cause",
                    _tag: this._tag
                };
            case "Die":
                return {
                    _id: "Cause",
                    _tag: this._tag,
                    defect: (0, _inspectableJs.toJSON)(this.defect)
                };
            case "Interrupt":
                return {
                    _id: "Cause",
                    _tag: this._tag,
                    fiberId: this.fiberId.toJSON()
                };
            case "Fail":
                return {
                    _id: "Cause",
                    _tag: this._tag,
                    failure: (0, _inspectableJs.toJSON)(this.error)
                };
            case "Sequential":
            case "Parallel":
                return {
                    _id: "Cause",
                    _tag: this._tag,
                    left: (0, _inspectableJs.toJSON)(this.left),
                    right: (0, _inspectableJs.toJSON)(this.right)
                };
        }
    },
    toString () {
        return pretty(this);
    },
    [(0, _inspectableJs.NodeInspectSymbol)] () {
        return this.toJSON();
    }
};
const empty = /*#__PURE__*/ (()=>{
    const o = /*#__PURE__*/ Object.create(proto);
    o._tag = _causeJs.OP_EMPTY;
    return o;
})();
const fail = (error)=>{
    const o = Object.create(proto);
    o._tag = _causeJs.OP_FAIL;
    o.error = error;
    return o;
};
const die = (defect)=>{
    const o = Object.create(proto);
    o._tag = _causeJs.OP_DIE;
    o.defect = defect;
    return o;
};
const interrupt = (fiberId)=>{
    const o = Object.create(proto);
    o._tag = _causeJs.OP_INTERRUPT;
    o.fiberId = fiberId;
    return o;
};
const parallel = (left, right)=>{
    const o = Object.create(proto);
    o._tag = _causeJs.OP_PARALLEL;
    o.left = left;
    o.right = right;
    return o;
};
const sequential = (left, right)=>{
    const o = Object.create(proto);
    o._tag = _causeJs.OP_SEQUENTIAL;
    o.left = left;
    o.right = right;
    return o;
};
const isCause = (u)=>(0, _predicateJs.hasProperty)(u, CauseTypeId);
const isEmptyType = (self)=>self._tag === _causeJs.OP_EMPTY;
const isFailType = (self)=>self._tag === _causeJs.OP_FAIL;
const isDieType = (self)=>self._tag === _causeJs.OP_DIE;
const isInterruptType = (self)=>self._tag === _causeJs.OP_INTERRUPT;
const isSequentialType = (self)=>self._tag === _causeJs.OP_SEQUENTIAL;
const isParallelType = (self)=>self._tag === _causeJs.OP_PARALLEL;
const size = (self)=>reduceWithContext(self, void 0, SizeCauseReducer);
const isEmpty = (self)=>{
    if (self._tag === _causeJs.OP_EMPTY) return true;
    return reduce(self, true, (acc, cause)=>{
        switch(cause._tag){
            case _causeJs.OP_EMPTY:
                return _optionJs.some(acc);
            case _causeJs.OP_DIE:
            case _causeJs.OP_FAIL:
            case _causeJs.OP_INTERRUPT:
                return _optionJs.some(false);
            default:
                return _optionJs.none();
        }
    });
};
const isFailure = (self)=>_optionJs.isSome(failureOption(self));
const isDie = (self)=>_optionJs.isSome(dieOption(self));
const isInterrupted = (self)=>_optionJs.isSome(interruptOption(self));
const isInterruptedOnly = (self)=>reduceWithContext(undefined, IsInterruptedOnlyCauseReducer)(self);
const failures = (self)=>_chunkJs.reverse(reduce(self, _chunkJs.empty(), (list, cause)=>cause._tag === _causeJs.OP_FAIL ? _optionJs.some((0, _functionJs.pipe)(list, _chunkJs.prepend(cause.error))) : _optionJs.none()));
const defects = (self)=>_chunkJs.reverse(reduce(self, _chunkJs.empty(), (list, cause)=>cause._tag === _causeJs.OP_DIE ? _optionJs.some((0, _functionJs.pipe)(list, _chunkJs.prepend(cause.defect))) : _optionJs.none()));
const interruptors = (self)=>reduce(self, _hashSetJs.empty(), (set, cause)=>cause._tag === _causeJs.OP_INTERRUPT ? _optionJs.some((0, _functionJs.pipe)(set, _hashSetJs.add(cause.fiberId))) : _optionJs.none());
const failureOption = (self)=>find(self, (cause)=>cause._tag === _causeJs.OP_FAIL ? _optionJs.some(cause.error) : _optionJs.none());
const failureOrCause = (self)=>{
    const option = failureOption(self);
    switch(option._tag){
        case "None":
            // no `E` inside this `Cause`, so it can be safely cast to `never`
            return _eitherJs.right(self);
        case "Some":
            return _eitherJs.left(option.value);
    }
};
const dieOption = (self)=>find(self, (cause)=>cause._tag === _causeJs.OP_DIE ? _optionJs.some(cause.defect) : _optionJs.none());
const flipCauseOption = (self)=>match(self, {
        onEmpty: _optionJs.some(empty),
        onFail: _optionJs.map(fail),
        onDie: (defect)=>_optionJs.some(die(defect)),
        onInterrupt: (fiberId)=>_optionJs.some(interrupt(fiberId)),
        onSequential: _optionJs.mergeWith(sequential),
        onParallel: _optionJs.mergeWith(parallel)
    });
const interruptOption = (self)=>find(self, (cause)=>cause._tag === _causeJs.OP_INTERRUPT ? _optionJs.some(cause.fiberId) : _optionJs.none());
const keepDefects = (self)=>match(self, {
        onEmpty: _optionJs.none(),
        onFail: ()=>_optionJs.none(),
        onDie: (defect)=>_optionJs.some(die(defect)),
        onInterrupt: ()=>_optionJs.none(),
        onSequential: _optionJs.mergeWith(sequential),
        onParallel: _optionJs.mergeWith(parallel)
    });
const keepDefectsAndElectFailures = (self)=>match(self, {
        onEmpty: _optionJs.none(),
        onFail: (failure)=>_optionJs.some(die(failure)),
        onDie: (defect)=>_optionJs.some(die(defect)),
        onInterrupt: ()=>_optionJs.none(),
        onSequential: _optionJs.mergeWith(sequential),
        onParallel: _optionJs.mergeWith(parallel)
    });
const linearize = (self)=>match(self, {
        onEmpty: _hashSetJs.empty(),
        onFail: (error)=>_hashSetJs.make(fail(error)),
        onDie: (defect)=>_hashSetJs.make(die(defect)),
        onInterrupt: (fiberId)=>_hashSetJs.make(interrupt(fiberId)),
        onSequential: (leftSet, rightSet)=>_hashSetJs.flatMap(leftSet, (leftCause)=>_hashSetJs.map(rightSet, (rightCause)=>sequential(leftCause, rightCause))),
        onParallel: (leftSet, rightSet)=>_hashSetJs.flatMap(leftSet, (leftCause)=>_hashSetJs.map(rightSet, (rightCause)=>parallel(leftCause, rightCause)))
    });
const stripFailures = (self)=>match(self, {
        onEmpty: empty,
        onFail: ()=>empty,
        onDie: die,
        onInterrupt: interrupt,
        onSequential: sequential,
        onParallel: parallel
    });
const electFailures = (self)=>match(self, {
        onEmpty: empty,
        onFail: die,
        onDie: die,
        onInterrupt: interrupt,
        onSequential: sequential,
        onParallel: parallel
    });
const stripSomeDefects = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, pf)=>match(self, {
        onEmpty: _optionJs.some(empty),
        onFail: (error)=>_optionJs.some(fail(error)),
        onDie: (defect)=>{
            const option = pf(defect);
            return _optionJs.isSome(option) ? _optionJs.none() : _optionJs.some(die(defect));
        },
        onInterrupt: (fiberId)=>_optionJs.some(interrupt(fiberId)),
        onSequential: _optionJs.mergeWith(sequential),
        onParallel: _optionJs.mergeWith(parallel)
    }));
const as = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, error)=>map(self, ()=>error));
const map = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>flatMap(self, (e)=>fail(f(e))));
const flatMap = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>match(self, {
        onEmpty: empty,
        onFail: (error)=>f(error),
        onDie: (defect)=>die(defect),
        onInterrupt: (fiberId)=>interrupt(fiberId),
        onSequential: (left, right)=>sequential(left, right),
        onParallel: (left, right)=>parallel(left, right)
    }));
const flatten = (self)=>flatMap(self, (0, _functionJs.identity));
const andThen = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>(0, _predicateJs.isFunction)(f) ? flatMap(self, f) : flatMap(self, ()=>f));
const contains = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>{
    if (that._tag === _causeJs.OP_EMPTY || self === that) return true;
    return reduce(self, false, (accumulator, cause)=>{
        return _optionJs.some(accumulator || causeEquals(cause, that));
    });
});
/** @internal */ const causeEquals = (left, right)=>{
    let leftStack = _chunkJs.of(left);
    let rightStack = _chunkJs.of(right);
    while(_chunkJs.isNonEmpty(leftStack) && _chunkJs.isNonEmpty(rightStack)){
        const [leftParallel, leftSequential] = (0, _functionJs.pipe)(_chunkJs.headNonEmpty(leftStack), reduce([
            _hashSetJs.empty(),
            _chunkJs.empty()
        ], ([parallel, sequential], cause)=>{
            const [par, seq] = evaluateCause(cause);
            return _optionJs.some([
                (0, _functionJs.pipe)(parallel, _hashSetJs.union(par)),
                (0, _functionJs.pipe)(sequential, _chunkJs.appendAll(seq))
            ]);
        }));
        const [rightParallel, rightSequential] = (0, _functionJs.pipe)(_chunkJs.headNonEmpty(rightStack), reduce([
            _hashSetJs.empty(),
            _chunkJs.empty()
        ], ([parallel, sequential], cause)=>{
            const [par, seq] = evaluateCause(cause);
            return _optionJs.some([
                (0, _functionJs.pipe)(parallel, _hashSetJs.union(par)),
                (0, _functionJs.pipe)(sequential, _chunkJs.appendAll(seq))
            ]);
        }));
        if (!_equalJs.equals(leftParallel, rightParallel)) return false;
        leftStack = leftSequential;
        rightStack = rightSequential;
    }
    return true;
};
// -----------------------------------------------------------------------------
// Flattening
// -----------------------------------------------------------------------------
/**
 * Flattens a cause to a sequence of sets of causes, where each set represents
 * causes that fail in parallel and sequential sets represent causes that fail
 * after each other.
 *
 * @internal
 */ const flattenCause = (cause)=>{
    return flattenCauseLoop(_chunkJs.of(cause), _chunkJs.empty());
};
/** @internal */ const flattenCauseLoop = (causes, flattened)=>{
    // eslint-disable-next-line no-constant-condition
    while(true){
        const [parallel, sequential] = (0, _functionJs.pipe)(causes, _arrayJs.reduce([
            _hashSetJs.empty(),
            _chunkJs.empty()
        ], ([parallel, sequential], cause)=>{
            const [par, seq] = evaluateCause(cause);
            return [
                (0, _functionJs.pipe)(parallel, _hashSetJs.union(par)),
                (0, _functionJs.pipe)(sequential, _chunkJs.appendAll(seq))
            ];
        }));
        const updated = _hashSetJs.size(parallel) > 0 ? (0, _functionJs.pipe)(flattened, _chunkJs.prepend(parallel)) : flattened;
        if (_chunkJs.isEmpty(sequential)) return _chunkJs.reverse(updated);
        causes = sequential;
        flattened = updated;
    }
    throw new Error((0, _errorsJs.getBugErrorMessage)("Cause.flattenCauseLoop"));
};
const find = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, pf)=>{
    const stack = [
        self
    ];
    while(stack.length > 0){
        const item = stack.pop();
        const option = pf(item);
        switch(option._tag){
            case "None":
                switch(item._tag){
                    case _causeJs.OP_SEQUENTIAL:
                    case _causeJs.OP_PARALLEL:
                        stack.push(item.right);
                        stack.push(item.left);
                        break;
                }
                break;
            case "Some":
                return option;
        }
    }
    return _optionJs.none();
});
const filter = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, predicate)=>reduceWithContext(self, void 0, FilterCauseReducer(predicate)));
// -----------------------------------------------------------------------------
// Evaluation
// -----------------------------------------------------------------------------
/**
 * Takes one step in evaluating a cause, returning a set of causes that fail
 * in parallel and a list of causes that fail sequentially after those causes.
 *
 * @internal
 */ const evaluateCause = (self)=>{
    let cause = self;
    const stack = [];
    let _parallel = _hashSetJs.empty();
    let _sequential = _chunkJs.empty();
    while(cause !== undefined)switch(cause._tag){
        case _causeJs.OP_EMPTY:
            if (stack.length === 0) return [
                _parallel,
                _sequential
            ];
            cause = stack.pop();
            break;
        case _causeJs.OP_FAIL:
            _parallel = _hashSetJs.add(_parallel, _chunkJs.make(cause._tag, cause.error));
            if (stack.length === 0) return [
                _parallel,
                _sequential
            ];
            cause = stack.pop();
            break;
        case _causeJs.OP_DIE:
            _parallel = _hashSetJs.add(_parallel, _chunkJs.make(cause._tag, cause.defect));
            if (stack.length === 0) return [
                _parallel,
                _sequential
            ];
            cause = stack.pop();
            break;
        case _causeJs.OP_INTERRUPT:
            _parallel = _hashSetJs.add(_parallel, _chunkJs.make(cause._tag, cause.fiberId));
            if (stack.length === 0) return [
                _parallel,
                _sequential
            ];
            cause = stack.pop();
            break;
        case _causeJs.OP_SEQUENTIAL:
            switch(cause.left._tag){
                case _causeJs.OP_EMPTY:
                    cause = cause.right;
                    break;
                case _causeJs.OP_SEQUENTIAL:
                    cause = sequential(cause.left.left, sequential(cause.left.right, cause.right));
                    break;
                case _causeJs.OP_PARALLEL:
                    cause = parallel(sequential(cause.left.left, cause.right), sequential(cause.left.right, cause.right));
                    break;
                default:
                    _sequential = _chunkJs.prepend(_sequential, cause.right);
                    cause = cause.left;
                    break;
            }
            break;
        case _causeJs.OP_PARALLEL:
            stack.push(cause.right);
            cause = cause.left;
            break;
    }
    throw new Error((0, _errorsJs.getBugErrorMessage)("Cause.evaluateCauseLoop"));
};
// -----------------------------------------------------------------------------
// Reducing
// -----------------------------------------------------------------------------
/** @internal */ const SizeCauseReducer = {
    emptyCase: ()=>0,
    failCase: ()=>1,
    dieCase: ()=>1,
    interruptCase: ()=>1,
    sequentialCase: (_, left, right)=>left + right,
    parallelCase: (_, left, right)=>left + right
};
/** @internal */ const IsInterruptedOnlyCauseReducer = {
    emptyCase: (0, _functionJs.constTrue),
    failCase: (0, _functionJs.constFalse),
    dieCase: (0, _functionJs.constFalse),
    interruptCase: (0, _functionJs.constTrue),
    sequentialCase: (_, left, right)=>left && right,
    parallelCase: (_, left, right)=>left && right
};
/** @internal */ const FilterCauseReducer = (predicate)=>({
        emptyCase: ()=>empty,
        failCase: (_, error)=>fail(error),
        dieCase: (_, defect)=>die(defect),
        interruptCase: (_, fiberId)=>interrupt(fiberId),
        sequentialCase: (_, left, right)=>{
            if (predicate(left)) {
                if (predicate(right)) return sequential(left, right);
                return left;
            }
            if (predicate(right)) return right;
            return empty;
        },
        parallelCase: (_, left, right)=>{
            if (predicate(left)) {
                if (predicate(right)) return parallel(left, right);
                return left;
            }
            if (predicate(right)) return right;
            return empty;
        }
    });
const OP_SEQUENTIAL_CASE = "SequentialCase";
const OP_PARALLEL_CASE = "ParallelCase";
const match = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, { onDie, onEmpty, onFail, onInterrupt, onParallel, onSequential })=>{
    return reduceWithContext(self, void 0, {
        emptyCase: ()=>onEmpty,
        failCase: (_, error)=>onFail(error),
        dieCase: (_, defect)=>onDie(defect),
        interruptCase: (_, fiberId)=>onInterrupt(fiberId),
        sequentialCase: (_, left, right)=>onSequential(left, right),
        parallelCase: (_, left, right)=>onParallel(left, right)
    });
});
const reduce = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, zero, pf)=>{
    let accumulator = zero;
    let cause = self;
    const causes = [];
    while(cause !== undefined){
        const option = pf(accumulator, cause);
        accumulator = _optionJs.isSome(option) ? option.value : accumulator;
        switch(cause._tag){
            case _causeJs.OP_SEQUENTIAL:
                causes.push(cause.right);
                cause = cause.left;
                break;
            case _causeJs.OP_PARALLEL:
                causes.push(cause.right);
                cause = cause.left;
                break;
            default:
                cause = undefined;
                break;
        }
        if (cause === undefined && causes.length > 0) cause = causes.pop();
    }
    return accumulator;
});
const reduceWithContext = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, context, reducer)=>{
    const input = [
        self
    ];
    const output = [];
    while(input.length > 0){
        const cause = input.pop();
        switch(cause._tag){
            case _causeJs.OP_EMPTY:
                output.push(_eitherJs.right(reducer.emptyCase(context)));
                break;
            case _causeJs.OP_FAIL:
                output.push(_eitherJs.right(reducer.failCase(context, cause.error)));
                break;
            case _causeJs.OP_DIE:
                output.push(_eitherJs.right(reducer.dieCase(context, cause.defect)));
                break;
            case _causeJs.OP_INTERRUPT:
                output.push(_eitherJs.right(reducer.interruptCase(context, cause.fiberId)));
                break;
            case _causeJs.OP_SEQUENTIAL:
                input.push(cause.right);
                input.push(cause.left);
                output.push(_eitherJs.left({
                    _tag: OP_SEQUENTIAL_CASE
                }));
                break;
            case _causeJs.OP_PARALLEL:
                input.push(cause.right);
                input.push(cause.left);
                output.push(_eitherJs.left({
                    _tag: OP_PARALLEL_CASE
                }));
                break;
        }
    }
    const accumulator = [];
    while(output.length > 0){
        const either = output.pop();
        switch(either._tag){
            case "Left":
                switch(either.left._tag){
                    case OP_SEQUENTIAL_CASE:
                        {
                            const left = accumulator.pop();
                            const right = accumulator.pop();
                            const value = reducer.sequentialCase(context, left, right);
                            accumulator.push(value);
                            break;
                        }
                    case OP_PARALLEL_CASE:
                        {
                            const left = accumulator.pop();
                            const right = accumulator.pop();
                            const value = reducer.parallelCase(context, left, right);
                            accumulator.push(value);
                            break;
                        }
                }
                break;
            case "Right":
                accumulator.push(either.right);
                break;
        }
    }
    if (accumulator.length === 0) throw new Error("BUG: Cause.reduceWithContext - please report an issue at https://github.com/Effect-TS/effect/issues");
    return accumulator.pop();
});
const pretty = (cause, options)=>{
    if (isInterruptedOnly(cause)) return "All fibers interrupted without errors.";
    return prettyErrors(cause).map(function(e) {
        if (options?.renderErrorCause !== true || e.cause === undefined) return e.stack;
        return `${e.stack} {\n${renderErrorCause(e.cause, "  ")}\n}`;
    }).join("\n");
};
const renderErrorCause = (cause, prefix)=>{
    const lines = cause.stack.split("\n");
    let stack = `${prefix}[cause]: ${lines[0]}`;
    for(let i = 1, len = lines.length; i < len; i++)stack += `\n${prefix}${lines[i]}`;
    if (cause.cause) stack += ` {\n${renderErrorCause(cause.cause, `${prefix}  `)}\n${prefix}}`;
    return stack;
};
class PrettyError extends globalThis.Error {
    span = undefined;
    constructor(originalError){
        const originalErrorIsObject = typeof originalError === "object" && originalError !== null;
        const prevLimit = Error.stackTraceLimit;
        Error.stackTraceLimit = 1;
        super(prettyErrorMessage(originalError), originalErrorIsObject && "cause" in originalError && typeof originalError.cause !== "undefined" ? {
            cause: new PrettyError(originalError.cause)
        } : undefined);
        if (this.message === "") this.message = "An error has occurred";
        Error.stackTraceLimit = prevLimit;
        this.name = originalError instanceof Error ? originalError.name : "Error";
        if (originalErrorIsObject) {
            if (spanSymbol in originalError) this.span = originalError[spanSymbol];
            Object.keys(originalError).forEach((key)=>{
                if (!(key in this)) // @ts-expect-error
                this[key] = originalError[key];
            });
        }
        this.stack = prettyErrorStack(`${this.name}: ${this.message}`, originalError instanceof Error && originalError.stack ? originalError.stack : "", this.span);
    }
}
const prettyErrorMessage = (u)=>{
    // 1)
    if (typeof u === "string") return u;
    // 2)
    if (typeof u === "object" && u !== null && u instanceof Error) return u.message;
    // 3)
    try {
        if ((0, _predicateJs.hasProperty)(u, "toString") && (0, _predicateJs.isFunction)(u["toString"]) && u["toString"] !== Object.prototype.toString && u["toString"] !== globalThis.Array.prototype.toString) return u["toString"]();
    } catch  {
    // something's off, rollback to json
    }
    // 4)
    return (0, _inspectableJs.stringifyCircular)(u);
};
const locationRegex = /\((.*)\)/g;
const spanToTrace = /*#__PURE__*/ (0, _globalValueJs.globalValue)("effect/Tracer/spanToTrace", ()=>new WeakMap());
const prettyErrorStack = (message, stack, span)=>{
    const out = [
        message
    ];
    const lines = stack.startsWith(message) ? stack.slice(message.length).split("\n") : stack.split("\n");
    for(let i = 1; i < lines.length; i++){
        if (lines[i].includes(" at new BaseEffectError") || lines[i].includes(" at new YieldableError")) {
            i++;
            continue;
        }
        if (lines[i].includes("Generator.next")) break;
        if (lines[i].includes("effect_internal_function")) break;
        out.push(lines[i].replace(/at .*effect_instruction_i.*\((.*)\)/, "at $1").replace(/EffectPrimitive\.\w+/, "<anonymous>"));
    }
    if (span) {
        let current = span;
        let i = 0;
        while(current && current._tag === "Span" && i < 10){
            const stackFn = spanToTrace.get(current);
            if (typeof stackFn === "function") {
                const stack = stackFn();
                if (typeof stack === "string") {
                    const locationMatchAll = stack.matchAll(locationRegex);
                    let match = false;
                    for (const [, location] of locationMatchAll){
                        match = true;
                        out.push(`    at ${current.name} (${location})`);
                    }
                    if (!match) out.push(`    at ${current.name} (${stack.replace(/^at /, "")})`);
                } else out.push(`    at ${current.name}`);
            } else out.push(`    at ${current.name}`);
            current = _optionJs.getOrUndefined(current.parent);
            i++;
        }
    }
    return out.join("\n");
};
const spanSymbol = /*#__PURE__*/ Symbol.for("effect/SpanAnnotation");
const prettyErrors = (cause)=>reduceWithContext(cause, void 0, {
        emptyCase: ()=>[],
        dieCase: (_, unknownError)=>{
            return [
                new PrettyError(unknownError)
            ];
        },
        failCase: (_, error)=>{
            return [
                new PrettyError(error)
            ];
        },
        interruptCase: ()=>[],
        parallelCase: (_, l, r)=>[
                ...l,
                ...r
            ],
        sequentialCase: (_, l, r)=>[
                ...l,
                ...r
            ]
    });

},{"../Array.js":"8L2Gk","../Chunk.js":"dL1OO","../Either.js":"4amnT","../Equal.js":"gA0qD","../Function.js":"21gOL","../GlobalValue.js":"5w3Hn","../Hash.js":"gFMwE","../HashSet.js":"aKFFV","../Inspectable.js":"1Ur70","../Option.js":"6sHA7","../Pipeable.js":"b5RU2","../Predicate.js":"gW5pd","./errors.js":"2Q5er","./opCodes/cause.js":"2Mw9X","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"dL1OO":[function(require,module,exports,__globalThis) {
/**
 * @since 2.0.0
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getEquivalence", ()=>getEquivalence);
parcelHelpers.export(exports, "isChunk", ()=>isChunk);
parcelHelpers.export(exports, "empty", ()=>empty);
parcelHelpers.export(exports, "make", ()=>make);
parcelHelpers.export(exports, "of", ()=>of);
parcelHelpers.export(exports, "fromIterable", ()=>fromIterable);
parcelHelpers.export(exports, "toArray", ()=>toArray);
parcelHelpers.export(exports, "toReadonlyArray", ()=>toReadonlyArray);
parcelHelpers.export(exports, "reverse", ()=>reverse);
parcelHelpers.export(exports, "get", ()=>get);
parcelHelpers.export(exports, "unsafeFromArray", ()=>unsafeFromArray);
parcelHelpers.export(exports, "unsafeFromNonEmptyArray", ()=>unsafeFromNonEmptyArray);
parcelHelpers.export(exports, "unsafeGet", ()=>unsafeGet);
parcelHelpers.export(exports, "append", ()=>append);
parcelHelpers.export(exports, "prepend", ()=>prepend);
parcelHelpers.export(exports, "take", ()=>take);
parcelHelpers.export(exports, "drop", ()=>drop);
parcelHelpers.export(exports, "dropRight", ()=>dropRight);
parcelHelpers.export(exports, "dropWhile", ()=>dropWhile);
parcelHelpers.export(exports, "prependAll", ()=>prependAll);
parcelHelpers.export(exports, "appendAll", ()=>appendAll);
parcelHelpers.export(exports, "filterMap", ()=>filterMap);
parcelHelpers.export(exports, "filter", ()=>filter);
parcelHelpers.export(exports, "filterMapWhile", ()=>filterMapWhile);
parcelHelpers.export(exports, "compact", ()=>compact);
parcelHelpers.export(exports, "flatMap", ()=>flatMap);
parcelHelpers.export(exports, "forEach", ()=>forEach);
parcelHelpers.export(exports, "flatten", ()=>flatten);
parcelHelpers.export(exports, "chunksOf", ()=>chunksOf);
parcelHelpers.export(exports, "intersection", ()=>intersection);
parcelHelpers.export(exports, "isEmpty", ()=>isEmpty);
parcelHelpers.export(exports, "isNonEmpty", ()=>isNonEmpty);
parcelHelpers.export(exports, "head", ()=>head);
parcelHelpers.export(exports, "unsafeHead", ()=>unsafeHead);
parcelHelpers.export(exports, "headNonEmpty", ()=>headNonEmpty);
parcelHelpers.export(exports, "last", ()=>last);
parcelHelpers.export(exports, "unsafeLast", ()=>unsafeLast);
parcelHelpers.export(exports, "lastNonEmpty", ()=>lastNonEmpty);
parcelHelpers.export(exports, "map", ()=>map);
parcelHelpers.export(exports, "mapAccum", ()=>mapAccum);
parcelHelpers.export(exports, "partition", ()=>partition);
parcelHelpers.export(exports, "partitionMap", ()=>partitionMap);
parcelHelpers.export(exports, "separate", ()=>separate);
parcelHelpers.export(exports, "size", ()=>size);
parcelHelpers.export(exports, "sort", ()=>sort);
parcelHelpers.export(exports, "sortWith", ()=>sortWith);
parcelHelpers.export(exports, "splitAt", ()=>splitAt);
parcelHelpers.export(exports, "splitNonEmptyAt", ()=>splitNonEmptyAt);
parcelHelpers.export(exports, "split", ()=>split);
parcelHelpers.export(exports, "splitWhere", ()=>splitWhere);
parcelHelpers.export(exports, "tail", ()=>tail);
parcelHelpers.export(exports, "tailNonEmpty", ()=>tailNonEmpty);
parcelHelpers.export(exports, "takeRight", ()=>takeRight);
parcelHelpers.export(exports, "takeWhile", ()=>takeWhile);
parcelHelpers.export(exports, "union", ()=>union);
parcelHelpers.export(exports, "dedupe", ()=>dedupe);
parcelHelpers.export(exports, "dedupeAdjacent", ()=>dedupeAdjacent);
parcelHelpers.export(exports, "unzip", ()=>unzip);
parcelHelpers.export(exports, "zipWith", ()=>zipWith);
parcelHelpers.export(exports, "zip", ()=>zip);
parcelHelpers.export(exports, "remove", ()=>remove);
parcelHelpers.export(exports, "modifyOption", ()=>modifyOption);
parcelHelpers.export(exports, "modify", ()=>modify);
parcelHelpers.export(exports, "replace", ()=>replace);
parcelHelpers.export(exports, "replaceOption", ()=>replaceOption);
parcelHelpers.export(exports, "makeBy", ()=>makeBy);
parcelHelpers.export(exports, "range", ()=>range);
parcelHelpers.export(exports, "contains", ()=>contains);
parcelHelpers.export(exports, "containsWith", ()=>containsWith);
parcelHelpers.export(exports, "findFirst", ()=>findFirst);
parcelHelpers.export(exports, "findFirstIndex", ()=>findFirstIndex);
parcelHelpers.export(exports, "findLast", ()=>findLast);
parcelHelpers.export(exports, "findLastIndex", ()=>findLastIndex);
parcelHelpers.export(exports, "every", ()=>every);
parcelHelpers.export(exports, "some", ()=>some);
parcelHelpers.export(exports, "join", ()=>join);
parcelHelpers.export(exports, "reduce", ()=>reduce);
parcelHelpers.export(exports, "reduceRight", ()=>reduceRight);
parcelHelpers.export(exports, "differenceWith", ()=>differenceWith);
parcelHelpers.export(exports, "difference", ()=>difference);
var _arrayJs = require("./Array.js");
var _equalJs = require("./Equal.js");
var _equivalenceJs = require("./Equivalence.js");
var _functionJs = require("./Function.js");
var _hashJs = require("./Hash.js");
var _inspectableJs = require("./Inspectable.js");
var _optionJs = require("./Option.js");
var _orderJs = require("./Order.js");
var _pipeableJs = require("./Pipeable.js");
var _predicateJs = require("./Predicate.js");
const TypeId = /*#__PURE__*/ Symbol.for("effect/Chunk");
function copy(src, srcPos, dest, destPos, len) {
    for(let i = srcPos; i < Math.min(src.length, srcPos + len); i++)dest[destPos + i - srcPos] = src[i];
    return dest;
}
const emptyArray = [];
const getEquivalence = (isEquivalent)=>_equivalenceJs.make((self, that)=>self.length === that.length && toReadonlyArray(self).every((value, i)=>isEquivalent(value, unsafeGet(that, i))));
const _equivalence = /*#__PURE__*/ getEquivalence(_equalJs.equals);
const ChunkProto = {
    [TypeId]: {
        _A: (_)=>_
    },
    toString () {
        return (0, _inspectableJs.format)(this.toJSON());
    },
    toJSON () {
        return {
            _id: "Chunk",
            values: toReadonlyArray(this).map((0, _inspectableJs.toJSON))
        };
    },
    [(0, _inspectableJs.NodeInspectSymbol)] () {
        return this.toJSON();
    },
    [_equalJs.symbol] (that) {
        return isChunk(that) && _equivalence(this, that);
    },
    [_hashJs.symbol] () {
        return _hashJs.cached(this, _hashJs.array(toReadonlyArray(this)));
    },
    [Symbol.iterator] () {
        switch(this.backing._tag){
            case "IArray":
                return this.backing.array[Symbol.iterator]();
            case "IEmpty":
                return emptyArray[Symbol.iterator]();
            default:
                return toReadonlyArray(this)[Symbol.iterator]();
        }
    },
    pipe () {
        return (0, _pipeableJs.pipeArguments)(this, arguments);
    }
};
const makeChunk = (backing)=>{
    const chunk = Object.create(ChunkProto);
    chunk.backing = backing;
    switch(backing._tag){
        case "IEmpty":
            chunk.length = 0;
            chunk.depth = 0;
            chunk.left = chunk;
            chunk.right = chunk;
            break;
        case "IConcat":
            chunk.length = backing.left.length + backing.right.length;
            chunk.depth = 1 + Math.max(backing.left.depth, backing.right.depth);
            chunk.left = backing.left;
            chunk.right = backing.right;
            break;
        case "IArray":
            chunk.length = backing.array.length;
            chunk.depth = 0;
            chunk.left = _empty;
            chunk.right = _empty;
            break;
        case "ISingleton":
            chunk.length = 1;
            chunk.depth = 0;
            chunk.left = _empty;
            chunk.right = _empty;
            break;
        case "ISlice":
            chunk.length = backing.length;
            chunk.depth = backing.chunk.depth + 1;
            chunk.left = _empty;
            chunk.right = _empty;
            break;
    }
    return chunk;
};
const isChunk = (u)=>(0, _predicateJs.hasProperty)(u, TypeId);
const _empty = /*#__PURE__*/ makeChunk({
    _tag: "IEmpty"
});
const empty = ()=>_empty;
const make = (...as)=>unsafeFromNonEmptyArray(as);
const of = (a)=>makeChunk({
        _tag: "ISingleton",
        a
    });
const fromIterable = (self)=>isChunk(self) ? self : unsafeFromArray(_arrayJs.fromIterable(self));
const copyToArray = (self, array, initial)=>{
    switch(self.backing._tag){
        case "IArray":
            copy(self.backing.array, 0, array, initial, self.length);
            break;
        case "IConcat":
            copyToArray(self.left, array, initial);
            copyToArray(self.right, array, initial + self.left.length);
            break;
        case "ISingleton":
            array[initial] = self.backing.a;
            break;
        case "ISlice":
            {
                let i = 0;
                let j = initial;
                while(i < self.length){
                    array[j] = unsafeGet(self, i);
                    i += 1;
                    j += 1;
                }
                break;
            }
    }
};
const toArray_ = (self)=>toReadonlyArray(self).slice();
const toArray = toArray_;
const toReadonlyArray_ = (self)=>{
    switch(self.backing._tag){
        case "IEmpty":
            return emptyArray;
        case "IArray":
            return self.backing.array;
        default:
            {
                const arr = new Array(self.length);
                copyToArray(self, arr, 0);
                self.backing = {
                    _tag: "IArray",
                    array: arr
                };
                self.left = _empty;
                self.right = _empty;
                self.depth = 0;
                return arr;
            }
    }
};
const toReadonlyArray = toReadonlyArray_;
const reverseChunk = (self)=>{
    switch(self.backing._tag){
        case "IEmpty":
        case "ISingleton":
            return self;
        case "IArray":
            return makeChunk({
                _tag: "IArray",
                array: _arrayJs.reverse(self.backing.array)
            });
        case "IConcat":
            return makeChunk({
                _tag: "IConcat",
                left: reverse(self.backing.right),
                right: reverse(self.backing.left)
            });
        case "ISlice":
            return unsafeFromArray(_arrayJs.reverse(toReadonlyArray(self)));
    }
};
const reverse = reverseChunk;
const get = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, index)=>index < 0 || index >= self.length ? _optionJs.none() : _optionJs.some(unsafeGet(self, index)));
const unsafeFromArray = (self)=>self.length === 0 ? empty() : self.length === 1 ? of(self[0]) : makeChunk({
        _tag: "IArray",
        array: self
    });
const unsafeFromNonEmptyArray = (self)=>unsafeFromArray(self);
const unsafeGet = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, index)=>{
    switch(self.backing._tag){
        case "IEmpty":
            throw new Error(`Index out of bounds`);
        case "ISingleton":
            if (index !== 0) throw new Error(`Index out of bounds`);
            return self.backing.a;
        case "IArray":
            if (index >= self.length || index < 0) throw new Error(`Index out of bounds`);
            return self.backing.array[index];
        case "IConcat":
            return index < self.left.length ? unsafeGet(self.left, index) : unsafeGet(self.right, index - self.left.length);
        case "ISlice":
            return unsafeGet(self.backing.chunk, index + self.backing.offset);
    }
});
const append = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, a)=>appendAll(self, of(a)));
const prepend = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, elem)=>appendAll(of(elem), self));
const take = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, n)=>{
    if (n <= 0) return _empty;
    else if (n >= self.length) return self;
    else switch(self.backing._tag){
        case "ISlice":
            return makeChunk({
                _tag: "ISlice",
                chunk: self.backing.chunk,
                length: n,
                offset: self.backing.offset
            });
        case "IConcat":
            if (n > self.left.length) return makeChunk({
                _tag: "IConcat",
                left: self.left,
                right: take(self.right, n - self.left.length)
            });
            return take(self.left, n);
        default:
            return makeChunk({
                _tag: "ISlice",
                chunk: self,
                offset: 0,
                length: n
            });
    }
});
const drop = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, n)=>{
    if (n <= 0) return self;
    else if (n >= self.length) return _empty;
    else switch(self.backing._tag){
        case "ISlice":
            return makeChunk({
                _tag: "ISlice",
                chunk: self.backing.chunk,
                offset: self.backing.offset + n,
                length: self.backing.length - n
            });
        case "IConcat":
            if (n > self.left.length) return drop(self.right, n - self.left.length);
            return makeChunk({
                _tag: "IConcat",
                left: drop(self.left, n),
                right: self.right
            });
        default:
            return makeChunk({
                _tag: "ISlice",
                chunk: self,
                offset: n,
                length: self.length - n
            });
    }
});
const dropRight = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, n)=>take(self, Math.max(0, self.length - n)));
const dropWhile = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, predicate)=>{
    const arr = toReadonlyArray(self);
    const len = arr.length;
    let i = 0;
    while(i < len && predicate(arr[i]))i++;
    return drop(self, i);
});
const prependAll = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>appendAll(that, self));
const appendAll = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>{
    if (self.backing._tag === "IEmpty") return that;
    if (that.backing._tag === "IEmpty") return self;
    const diff = that.depth - self.depth;
    if (Math.abs(diff) <= 1) return makeChunk({
        _tag: "IConcat",
        left: self,
        right: that
    });
    else if (diff < -1) {
        if (self.left.depth >= self.right.depth) {
            const nr = appendAll(self.right, that);
            return makeChunk({
                _tag: "IConcat",
                left: self.left,
                right: nr
            });
        } else {
            const nrr = appendAll(self.right.right, that);
            if (nrr.depth === self.depth - 3) {
                const nr = makeChunk({
                    _tag: "IConcat",
                    left: self.right.left,
                    right: nrr
                });
                return makeChunk({
                    _tag: "IConcat",
                    left: self.left,
                    right: nr
                });
            } else {
                const nl = makeChunk({
                    _tag: "IConcat",
                    left: self.left,
                    right: self.right.left
                });
                return makeChunk({
                    _tag: "IConcat",
                    left: nl,
                    right: nrr
                });
            }
        }
    } else if (that.right.depth >= that.left.depth) {
        const nl = appendAll(self, that.left);
        return makeChunk({
            _tag: "IConcat",
            left: nl,
            right: that.right
        });
    } else {
        const nll = appendAll(self, that.left.left);
        if (nll.depth === that.depth - 3) {
            const nl = makeChunk({
                _tag: "IConcat",
                left: nll,
                right: that.left.right
            });
            return makeChunk({
                _tag: "IConcat",
                left: nl,
                right: that.right
            });
        } else {
            const nr = makeChunk({
                _tag: "IConcat",
                left: that.left.right,
                right: that.right
            });
            return makeChunk({
                _tag: "IConcat",
                left: nll,
                right: nr
            });
        }
    }
});
const filterMap = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>unsafeFromArray(_arrayJs.filterMap(self, f)));
const filter = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, predicate)=>unsafeFromArray(_arrayJs.filter(self, predicate)));
const filterMapWhile = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>unsafeFromArray(_arrayJs.filterMapWhile(self, f)));
const compact = (self)=>filterMap(self, (0, _functionJs.identity));
const flatMap = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>{
    if (self.backing._tag === "ISingleton") return f(self.backing.a, 0);
    let out = _empty;
    let i = 0;
    for (const k of self)out = appendAll(out, f(k, i++));
    return out;
});
const forEach = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>toReadonlyArray(self).forEach(f));
const flatten = /*#__PURE__*/ flatMap((0, _functionJs.identity));
const chunksOf = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, n)=>{
    const gr = [];
    let current = [];
    toReadonlyArray(self).forEach((a)=>{
        current.push(a);
        if (current.length >= n) {
            gr.push(unsafeFromArray(current));
            current = [];
        }
    });
    if (current.length > 0) gr.push(unsafeFromArray(current));
    return unsafeFromArray(gr);
});
const intersection = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>unsafeFromArray(_arrayJs.intersection(toReadonlyArray(self), toReadonlyArray(that))));
const isEmpty = (self)=>self.length === 0;
const isNonEmpty = (self)=>self.length > 0;
const head = /*#__PURE__*/ get(0);
const unsafeHead = (self)=>unsafeGet(self, 0);
const headNonEmpty = unsafeHead;
const last = (self)=>get(self, self.length - 1);
const unsafeLast = (self)=>unsafeGet(self, self.length - 1);
const lastNonEmpty = unsafeLast;
const map = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>self.backing._tag === "ISingleton" ? of(f(self.backing.a, 0)) : unsafeFromArray((0, _functionJs.pipe)(toReadonlyArray(self), _arrayJs.map((a, i)=>f(a, i)))));
const mapAccum = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, s, f)=>{
    const [s1, as] = _arrayJs.mapAccum(self, s, f);
    return [
        s1,
        unsafeFromArray(as)
    ];
});
const partition = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, predicate)=>(0, _functionJs.pipe)(_arrayJs.partition(toReadonlyArray(self), predicate), ([l, r])=>[
            unsafeFromArray(l),
            unsafeFromArray(r)
        ]));
const partitionMap = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>(0, _functionJs.pipe)(_arrayJs.partitionMap(toReadonlyArray(self), f), ([l, r])=>[
            unsafeFromArray(l),
            unsafeFromArray(r)
        ]));
const separate = (self)=>(0, _functionJs.pipe)(_arrayJs.separate(toReadonlyArray(self)), ([l, r])=>[
            unsafeFromArray(l),
            unsafeFromArray(r)
        ]);
const size = (self)=>self.length;
const sort = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, O)=>unsafeFromArray(_arrayJs.sort(toReadonlyArray(self), O)));
const sortWith = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, f, order)=>sort(self, _orderJs.mapInput(order, f)));
const splitAt = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, n)=>[
        take(self, n),
        drop(self, n)
    ]);
const splitNonEmptyAt = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, n)=>{
    const _n = Math.max(1, Math.floor(n));
    return _n >= self.length ? [
        self,
        empty()
    ] : [
        take(self, _n),
        drop(self, _n)
    ];
});
const split = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, n)=>chunksOf(self, Math.ceil(self.length / Math.floor(n))));
const splitWhere = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, predicate)=>{
    let i = 0;
    for (const a of toReadonlyArray(self)){
        if (predicate(a)) break;
        else i++;
    }
    return splitAt(self, i);
});
const tail = (self)=>self.length > 0 ? _optionJs.some(drop(self, 1)) : _optionJs.none();
const tailNonEmpty = (self)=>drop(self, 1);
const takeRight = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, n)=>drop(self, self.length - n));
const takeWhile = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, predicate)=>{
    const out = [];
    for (const a of toReadonlyArray(self)){
        if (predicate(a)) out.push(a);
        else break;
    }
    return unsafeFromArray(out);
});
const union = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>unsafeFromArray(_arrayJs.union(toReadonlyArray(self), toReadonlyArray(that))));
const dedupe = (self)=>unsafeFromArray(_arrayJs.dedupe(toReadonlyArray(self)));
const dedupeAdjacent = (self)=>unsafeFromArray(_arrayJs.dedupeAdjacent(self));
const unzip = (self)=>{
    const [left, right] = _arrayJs.unzip(self);
    return [
        unsafeFromArray(left),
        unsafeFromArray(right)
    ];
};
const zipWith = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, that, f)=>unsafeFromArray(_arrayJs.zipWith(self, that, f)));
const zip = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>zipWith(self, that, (a, b)=>[
            a,
            b
        ]));
const remove = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, i)=>unsafeFromArray(_arrayJs.remove(toReadonlyArray(self), i)));
const modifyOption = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, i, f)=>_optionJs.map(_arrayJs.modifyOption(toReadonlyArray(self), i, f), unsafeFromArray));
const modify = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, i, f)=>_optionJs.getOrElse(modifyOption(self, i, f), ()=>self));
const replace = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, i, b)=>modify(self, i, ()=>b));
const replaceOption = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, i, b)=>modifyOption(self, i, ()=>b));
const makeBy = /*#__PURE__*/ (0, _functionJs.dual)(2, (n, f)=>fromIterable(_arrayJs.makeBy(n, f)));
const range = (start, end)=>start <= end ? makeBy(end - start + 1, (i)=>start + i) : of(start);
const contains = _arrayJs.contains;
const containsWith = _arrayJs.containsWith;
const findFirst = _arrayJs.findFirst;
const findFirstIndex = _arrayJs.findFirstIndex;
const findLast = _arrayJs.findLast;
const findLastIndex = _arrayJs.findLastIndex;
const every = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, refinement)=>_arrayJs.fromIterable(self).every(refinement));
const some = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, predicate)=>_arrayJs.fromIterable(self).some(predicate));
const join = _arrayJs.join;
const reduce = _arrayJs.reduce;
const reduceRight = _arrayJs.reduceRight;
const differenceWith = (isEquivalent)=>{
    return (0, _functionJs.dual)(2, (self, that)=>unsafeFromArray(_arrayJs.differenceWith(isEquivalent)(that, self)));
};
const difference = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>unsafeFromArray(_arrayJs.difference(that, self)));

},{"./Array.js":"8L2Gk","./Equal.js":"gA0qD","./Equivalence.js":"1WBUa","./Function.js":"21gOL","./Hash.js":"gFMwE","./Inspectable.js":"1Ur70","./Option.js":"6sHA7","./Order.js":"lQMwD","./Pipeable.js":"b5RU2","./Predicate.js":"gW5pd","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"aKFFV":[function(require,module,exports,__globalThis) {
/**
 * # HashSet
 *
 * An immutable `HashSet` provides a collection of unique values with efficient
 * lookup, insertion and removal. Once created, a `HashSet` cannot be modified;
 * any operation that would alter the set instead returns a new `HashSet` with
 * the changes. This immutability offers benefits like predictable state
 * management and easier reasoning about your code.
 *
 * ## What Problem Does It Solve?
 *
 * `HashSet` solves the problem of maintaining an unsorted collection where each
 * value appears exactly once, with fast operations for checking membership and
 * adding/removing values.
 *
 * ## When to Use
 *
 * Use `HashSet` when you need:
 *
 * - A collection with no duplicate values
 * - Efficient membership testing (**`O(1)`** average complexity)
 * - Set operations like union, intersection, and difference
 * - An immutable data structure that preserves functional programming patterns
 *
 * ## Advanced Features
 *
 * HashSet provides operations for:
 *
 * - Transforming sets with map and flatMap
 * - Filtering elements with filter
 * - Combining sets with union, intersection and difference
 * - Performance optimizations via mutable operations in controlled contexts
 *
 * ## Performance Characteristics
 *
 * - **Lookup** operations ({@link module:HashSet.has}): **`O(1)`** average time
 *   complexity
 * - **Insertion** operations ({@link module:HashSet.add}): **`O(1)`** average time
 *   complexity
 * - **Removal** operations ({@link module:HashSet.remove}): **`O(1)`** average
 *   time complexity
 * - **Set** operations ({@link module:HashSet.union},
 *   {@link module:HashSet.intersection}): **`O(n)`** where n is the size of the
 *   smaller set
 * - **Iteration**: **`O(n)`** where n is the size of the set
 *
 * The HashSet data structure implements the following traits:
 *
 * - {@link Iterable}: allows iterating over the values in the set
 * - {@link Equal}: allows comparing two sets for value-based equality
 * - {@link Pipeable}: allows chaining operations with the pipe operator
 * - {@link Inspectable}: allows inspecting the contents of the set
 *
 * ## Operations Reference
 *
 * | Category     | Operation                           | Description                                 | Complexity |
 * | ------------ | ----------------------------------- | ------------------------------------------- | ---------- |
 * | constructors | {@link module:HashSet.empty}        | Creates an empty HashSet                    | O(1)       |
 * | constructors | {@link module:HashSet.fromIterable} | Creates a HashSet from an iterable          | O(n)       |
 * | constructors | {@link module:HashSet.make}         | Creates a HashSet from multiple values      | O(n)       |
 * |              |                                     |                                             |            |
 * | elements     | {@link module:HashSet.has}          | Checks if a value exists in the set         | O(1) avg   |
 * | elements     | {@link module:HashSet.some}         | Checks if any element satisfies a predicate | O(n)       |
 * | elements     | {@link module:HashSet.every}        | Checks if all elements satisfy a predicate  | O(n)       |
 * | elements     | {@link module:HashSet.isSubset}     | Checks if a set is a subset of another      | O(n)       |
 * |              |                                     |                                             |            |
 * | getters      | {@link module:HashSet.values}       | Gets an iterator of all values              | O(1)       |
 * | getters      | {@link module:HashSet.toValues}     | Gets an array of all values                 | O(n)       |
 * | getters      | {@link module:HashSet.size}         | Gets the number of elements                 | O(1)       |
 * |              |                                     |                                             |            |
 * | mutations    | {@link module:HashSet.add}          | Adds a value to the set                     | O(1) avg   |
 * | mutations    | {@link module:HashSet.remove}       | Removes a value from the set                | O(1) avg   |
 * | mutations    | {@link module:HashSet.toggle}       | Toggles a value's presence                  | O(1) avg   |
 * |              |                                     |                                             |            |
 * | operations   | {@link module:HashSet.difference}   | Computes set difference (A - B)             | O(n)       |
 * | operations   | {@link module:HashSet.intersection} | Computes set intersection (A ∩ B)           | O(n)       |
 * | operations   | {@link module:HashSet.union}        | Computes set union (A ∪ B)                  | O(n)       |
 * |              |                                     |                                             |            |
 * | mapping      | {@link module:HashSet.map}          | Transforms each element                     | O(n)       |
 * |              |                                     |                                             |            |
 * | sequencing   | {@link module:HashSet.flatMap}      | Transforms and flattens elements            | O(n)       |
 * |              |                                     |                                             |            |
 * | traversing   | {@link module:HashSet.forEach}      | Applies a function to each element          | O(n)       |
 * |              |                                     |                                             |            |
 * | folding      | {@link module:HashSet.reduce}       | Reduces the set to a single value           | O(n)       |
 * |              |                                     |                                             |            |
 * | filtering    | {@link module:HashSet.filter}       | Keeps elements that satisfy a predicate     | O(n)       |
 * |              |                                     |                                             |            |
 * | partitioning | {@link module:HashSet.partition}    | Splits into two sets by a predicate         | O(n)       |
 *
 * ## Notes
 *
 * ### Composability with the Effect Ecosystem:
 *
 * This `HashSet` is designed to work seamlessly within the Effect ecosystem. It
 * implements the {@link Iterable}, {@link Equal}, {@link Pipeable}, and
 * {@link Inspectable} traits from Effect. This ensures compatibility with other
 * Effect data structures and functionalities. For example, you can easily use
 * Effect's `pipe` method to chain operations on the `HashSet`.
 *
 * **Equality of Elements with Effect's {@link Equal `Equal`} Trait:**
 *
 * This `HashSet` relies on Effect's {@link Equal} trait to determine the
 * uniqueness of elements within the set. The way equality is checked depends on
 * the type of the elements:
 *
 * - **Primitive Values:** For primitive JavaScript values like strings, numbers,
 *   booleans, `null`, and `undefined`, equality is determined by their value
 *   (similar to the `===` operator).
 * - **Objects and Custom Types:** For objects and other custom types, equality is
 *   determined by whether those types implement the {@link Equal} interface
 *   themselves. If an element type implements `Equal`, the `HashSet` will
 *   delegate to that implementation to perform the equality check. This allows
 *   you to define custom logic for determining when two instances of your
 *   objects should be considered equal based on their properties, rather than
 *   just their object identity.
 *
 * ```ts
 * import { Equal, Hash, HashSet } from "effect"
 *
 * class Person implements Equal.Equal {
 *   constructor(
 *     readonly id: number, // Unique identifier
 *     readonly name: string,
 *     readonly age: number
 *   ) {}
 *
 *   // Define equality based on id, name, and age
 *   [Equal.symbol](that: Equal.Equal): boolean {
 *     if (that instanceof Person) {
 *       return (
 *         Equal.equals(this.id, that.id) &&
 *         Equal.equals(this.name, that.name) &&
 *         Equal.equals(this.age, that.age)
 *       )
 *     }
 *     return false
 *   }
 *
 *   // Generate a hash code based on the unique id
 *   [Hash.symbol](): number {
 *     return Hash.hash(this.id)
 *   }
 * }
 *
 * // Creating a HashSet with objects that implement the Equal interface
 * const set = HashSet.empty().pipe(
 *   HashSet.add(new Person(1, "Alice", 30)),
 *   HashSet.add(new Person(1, "Alice", 30))
 * )
 *
 * // HashSet recognizes them as equal, so only one element is stored
 * console.log(HashSet.size(set))
 * // Output: 1
 * ```
 *
 * **Simplifying Equality and Hashing with `Data` and `Schema`:**
 *
 * Effect's {@link Data} and {@link Schema `Schema.Data`} modules offer powerful
 * ways to automatically handle the implementation of both the {@link Equal} and
 * {@link Hash} traits for your custom data structures.
 *
 * - **`Data` Module:** By using constructors like `Data.struct`, `Data.tuple`,
 *   `Data.array`, or `Data.case` to define your data types, Effect
 *   automatically generates the necessary implementations for value-based
 *   equality and consistent hashing. This significantly reduces boilerplate and
 *   ensures correctness.
 *
 * ```ts
 * import { HashSet, Data, Equal } from "effect"
 * import assert from "node:assert/strict"
 *
 * // Data.* implements the `Equal` traits for us
 * const person1 = Data.struct({ id: 1, name: "Alice", age: 30 })
 * const person2 = Data.struct({ id: 1, name: "Alice", age: 30 })
 *
 * assert(Equal.equals(person1, person2))
 *
 * const set = HashSet.empty().pipe(
 *   HashSet.add(person1),
 *   HashSet.add(person2)
 * )
 *
 * // HashSet recognizes them as equal, so only one element is stored
 * console.log(HashSet.size(set)) // Output: 1
 * ```
 *
 * - **`Schema` Module:** When defining data schemas using the {@link Schema}
 *   module, you can use `Schema.Data` to automatically include the `Equal` and
 *   `Hash` traits in the decoded objects. This is particularly important when
 *   working with `HashSet`. **For decoded objects to be correctly recognized as
 *   equal within a `HashSet`, ensure that the schema for those objects is
 *   defined using `Schema.Data`.**
 *
 * ```ts
 * import { Equal, HashSet, Schema } from "effect"
 * import assert from "node:assert/strict"
 *
 * // Schema.Data implements the `Equal` traits for us
 * const PersonSchema = Schema.Data(
 *   Schema.Struct({
 *     id: Schema.Number,
 *     name: Schema.String,
 *     age: Schema.Number
 *   })
 * )
 *
 * const Person = Schema.decode(PersonSchema)
 *
 * const person1 = Person({ id: 1, name: "Alice", age: 30 })
 * const person2 = Person({ id: 1, name: "Alice", age: 30 })
 *
 * assert(Equal.equals(person1, person2)) // Output: true
 *
 * const set = HashSet.empty().pipe(
 *   HashSet.add(person1),
 *   HashSet.add(person2)
 * )
 *
 * // HashSet thanks to Schema.Data implementation of the `Equal` trait, recognizes the two Person as equal, so only one element is stored
 * console.log(HashSet.size(set)) // Output: 1
 * ```
 *
 * ### Interoperability with the JavaScript Runtime:
 *
 * To interoperate with the regular JavaScript runtime, Effect's `HashSet`
 * provides methods to access its elements in formats readily usable by
 * JavaScript APIs: {@link values `HashSet.values`},
 * {@link toValues `HashSet.toValues`}
 *
 * ```ts
 * import { HashSet } from "effect"
 *
 * const hashSet: HashSet.HashSet<number> = HashSet.make(1, 2, 3)
 *
 * // Using HashSet.values to convert HashSet.HashSet<A> to IterableIterator<A>
 * const iterable: IterableIterator<number> = HashSet.values(hashSet)
 *
 * console.log(...iterable) // Logs:  1 2 3
 *
 * // Using HashSet.toValues to convert HashSet.HashSet<A> to Array<A>
 * const array: Array<number> = HashSet.toValues(hashSet)
 *
 * console.log(array) // Logs: [ 1, 2, 3 ]
 * ```
 *
 * Be mindful of performance implications (both time and space complexity) when
 * frequently converting between Effect's immutable HashSet and mutable
 * JavaScript data structures, especially for large collections.
 *
 * @module HashSet
 * @since 2.0.0
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isHashSet", ()=>isHashSet);
parcelHelpers.export(exports, "empty", ()=>empty);
parcelHelpers.export(exports, "fromIterable", ()=>fromIterable);
parcelHelpers.export(exports, "make", ()=>make);
parcelHelpers.export(exports, "has", ()=>has);
parcelHelpers.export(exports, "some", ()=>some);
parcelHelpers.export(exports, "every", ()=>every);
parcelHelpers.export(exports, "isSubset", ()=>isSubset);
parcelHelpers.export(exports, "values", ()=>values);
parcelHelpers.export(exports, "toValues", ()=>toValues);
parcelHelpers.export(exports, "size", ()=>size);
parcelHelpers.export(exports, "beginMutation", ()=>beginMutation);
parcelHelpers.export(exports, "endMutation", ()=>endMutation);
parcelHelpers.export(exports, "mutate", ()=>mutate);
parcelHelpers.export(exports, "add", ()=>add);
parcelHelpers.export(exports, "remove", ()=>remove);
parcelHelpers.export(exports, "difference", ()=>difference);
parcelHelpers.export(exports, "intersection", ()=>intersection);
parcelHelpers.export(exports, "union", ()=>union);
parcelHelpers.export(exports, "toggle", ()=>toggle);
parcelHelpers.export(exports, "map", ()=>map);
parcelHelpers.export(exports, "flatMap", ()=>flatMap);
parcelHelpers.export(exports, "forEach", ()=>forEach);
parcelHelpers.export(exports, "reduce", ()=>reduce);
parcelHelpers.export(exports, "filter", ()=>filter);
parcelHelpers.export(exports, "partition", ()=>partition);
var _hashSetJs = require("./internal/hashSet.js");
const TypeId = _hashSetJs.HashSetTypeId;
const isHashSet = _hashSetJs.isHashSet;
const empty = _hashSetJs.empty;
const fromIterable = _hashSetJs.fromIterable;
const make = _hashSetJs.make;
const has = _hashSetJs.has;
const some = _hashSetJs.some;
const every = _hashSetJs.every;
const isSubset = _hashSetJs.isSubset;
const values = _hashSetJs.values;
const toValues = (self)=>Array.from(values(self));
const size = _hashSetJs.size;
const beginMutation = _hashSetJs.beginMutation;
const endMutation = _hashSetJs.endMutation;
const mutate = _hashSetJs.mutate;
const add = _hashSetJs.add;
const remove = _hashSetJs.remove;
const difference = _hashSetJs.difference;
const intersection = _hashSetJs.intersection;
const union = _hashSetJs.union;
const toggle = _hashSetJs.toggle;
const map = _hashSetJs.map;
const flatMap = _hashSetJs.flatMap;
const forEach = _hashSetJs.forEach;
const reduce = _hashSetJs.reduce;
const filter = _hashSetJs.filter;
const partition = _hashSetJs.partition;

},{"./internal/hashSet.js":"9DZmM","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"9DZmM":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "HashSetTypeId", ()=>HashSetTypeId);
parcelHelpers.export(exports, "makeImpl", ()=>makeImpl);
parcelHelpers.export(exports, "isHashSet", ()=>isHashSet);
parcelHelpers.export(exports, "empty", ()=>empty);
parcelHelpers.export(exports, "fromIterable", ()=>fromIterable);
parcelHelpers.export(exports, "make", ()=>make);
parcelHelpers.export(exports, "has", ()=>has);
parcelHelpers.export(exports, "some", ()=>some);
parcelHelpers.export(exports, "every", ()=>every);
parcelHelpers.export(exports, "isSubset", ()=>isSubset);
parcelHelpers.export(exports, "values", ()=>values);
parcelHelpers.export(exports, "size", ()=>size);
parcelHelpers.export(exports, "beginMutation", ()=>beginMutation);
parcelHelpers.export(exports, "endMutation", ()=>endMutation);
parcelHelpers.export(exports, "mutate", ()=>mutate);
parcelHelpers.export(exports, "add", ()=>add);
parcelHelpers.export(exports, "remove", ()=>remove);
parcelHelpers.export(exports, "difference", ()=>difference);
parcelHelpers.export(exports, "intersection", ()=>intersection);
parcelHelpers.export(exports, "union", ()=>union);
parcelHelpers.export(exports, "toggle", ()=>toggle);
parcelHelpers.export(exports, "map", ()=>map);
parcelHelpers.export(exports, "flatMap", ()=>flatMap);
parcelHelpers.export(exports, "forEach", ()=>forEach);
parcelHelpers.export(exports, "reduce", ()=>reduce);
parcelHelpers.export(exports, "filter", ()=>filter);
parcelHelpers.export(exports, "partition", ()=>partition);
var _equalJs = require("../Equal.js");
var _functionJs = require("../Function.js");
var _hashJs = require("../Hash.js");
var _inspectableJs = require("../Inspectable.js");
var _pipeableJs = require("../Pipeable.js");
var _predicateJs = require("../Predicate.js");
var _hashMapJs = require("./hashMap.js");
const HashSetSymbolKey = "effect/HashSet";
const HashSetTypeId = /*#__PURE__*/ Symbol.for(HashSetSymbolKey);
const HashSetProto = {
    [HashSetTypeId]: HashSetTypeId,
    [Symbol.iterator] () {
        return _hashMapJs.keys(this._keyMap);
    },
    [_hashJs.symbol] () {
        return _hashJs.cached(this, _hashJs.combine(_hashJs.hash(this._keyMap))(_hashJs.hash(HashSetSymbolKey)));
    },
    [_equalJs.symbol] (that) {
        if (isHashSet(that)) return _hashMapJs.size(this._keyMap) === _hashMapJs.size(that._keyMap) && _equalJs.equals(this._keyMap, that._keyMap);
        return false;
    },
    toString () {
        return (0, _inspectableJs.format)(this.toJSON());
    },
    toJSON () {
        return {
            _id: "HashSet",
            values: Array.from(this).map((0, _inspectableJs.toJSON))
        };
    },
    [(0, _inspectableJs.NodeInspectSymbol)] () {
        return this.toJSON();
    },
    pipe () {
        return (0, _pipeableJs.pipeArguments)(this, arguments);
    }
};
const makeImpl = (keyMap)=>{
    const set = Object.create(HashSetProto);
    set._keyMap = keyMap;
    return set;
};
const isHashSet = (u)=>(0, _predicateJs.hasProperty)(u, HashSetTypeId);
const _empty = /*#__PURE__*/ makeImpl(/*#__PURE__*/ _hashMapJs.empty());
const empty = ()=>_empty;
const fromIterable = (elements)=>{
    const set = beginMutation(empty());
    for (const value of elements)add(set, value);
    return endMutation(set);
};
const make = (...elements)=>{
    const set = beginMutation(empty());
    for (const value of elements)add(set, value);
    return endMutation(set);
};
const has = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, value)=>_hashMapJs.has(self._keyMap, value));
const some = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>{
    let found = false;
    for (const value of self){
        found = f(value);
        if (found) break;
    }
    return found;
});
const every = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, refinement)=>!some(self, (a)=>!refinement(a)));
const isSubset = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>every(self, (value)=>has(that, value)));
const values = (self)=>_hashMapJs.keys(self._keyMap);
const size = (self)=>_hashMapJs.size(self._keyMap);
const beginMutation = (self)=>makeImpl(_hashMapJs.beginMutation(self._keyMap));
const endMutation = (self)=>{
    self._keyMap._editable = false;
    return self;
};
const mutate = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>{
    const transient = beginMutation(self);
    f(transient);
    return endMutation(transient);
});
const add = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, value)=>self._keyMap._editable ? (_hashMapJs.set(value, true)(self._keyMap), self) : makeImpl(_hashMapJs.set(value, true)(self._keyMap)));
const remove = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, value)=>self._keyMap._editable ? (_hashMapJs.remove(value)(self._keyMap), self) : makeImpl(_hashMapJs.remove(value)(self._keyMap)));
const difference = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>mutate(self, (set)=>{
        for (const value of that)remove(set, value);
    }));
const intersection = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>mutate(empty(), (set)=>{
        for (const value of that)if (has(value)(self)) add(value)(set);
    }));
const union = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>mutate(empty(), (set)=>{
        forEach(self, (value)=>add(set, value));
        for (const value of that)add(set, value);
    }));
const toggle = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, value)=>has(self, value) ? remove(self, value) : add(self, value));
const map = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>mutate(empty(), (set)=>{
        forEach(self, (a)=>{
            const b = f(a);
            if (!has(set, b)) add(set, b);
        });
    }));
const flatMap = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>mutate(empty(), (set)=>{
        forEach(self, (a)=>{
            for (const b of f(a))if (!has(set, b)) add(set, b);
        });
    }));
const forEach = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>_hashMapJs.forEach(self._keyMap, (_, k)=>f(k)));
const reduce = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, zero, f)=>_hashMapJs.reduce(self._keyMap, zero, (z, _, a)=>f(z, a)));
const filter = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>{
    return mutate(empty(), (set)=>{
        const iterator = values(self);
        let next;
        while(!(next = iterator.next()).done){
            const value = next.value;
            if (f(value)) add(set, value);
        }
    });
});
const partition = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, predicate)=>{
    const iterator = values(self);
    let next;
    const right = beginMutation(empty());
    const left = beginMutation(empty());
    while(!(next = iterator.next()).done){
        const value = next.value;
        if (predicate(value)) add(right, value);
        else add(left, value);
    }
    return [
        endMutation(left),
        endMutation(right)
    ];
});

},{"../Equal.js":"gA0qD","../Function.js":"21gOL","../Hash.js":"gFMwE","../Inspectable.js":"1Ur70","../Pipeable.js":"b5RU2","../Predicate.js":"gW5pd","./hashMap.js":"ckTQ5","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"ckTQ5":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "HashMapTypeId", ()=>HashMapTypeId);
parcelHelpers.export(exports, "empty", ()=>empty);
parcelHelpers.export(exports, "make", ()=>make);
parcelHelpers.export(exports, "fromIterable", ()=>fromIterable);
parcelHelpers.export(exports, "isHashMap", ()=>isHashMap);
parcelHelpers.export(exports, "isEmpty", ()=>isEmpty);
parcelHelpers.export(exports, "get", ()=>get);
parcelHelpers.export(exports, "getHash", ()=>getHash);
parcelHelpers.export(exports, "unsafeGet", ()=>unsafeGet);
parcelHelpers.export(exports, "has", ()=>has);
parcelHelpers.export(exports, "hasHash", ()=>hasHash);
parcelHelpers.export(exports, "set", ()=>set);
parcelHelpers.export(exports, "setTree", ()=>setTree);
parcelHelpers.export(exports, "keys", ()=>keys);
parcelHelpers.export(exports, "values", ()=>values);
parcelHelpers.export(exports, "entries", ()=>entries);
parcelHelpers.export(exports, "size", ()=>size);
parcelHelpers.export(exports, "beginMutation", ()=>beginMutation);
parcelHelpers.export(exports, "endMutation", ()=>endMutation);
parcelHelpers.export(exports, "mutate", ()=>mutate);
parcelHelpers.export(exports, "modifyAt", ()=>modifyAt);
parcelHelpers.export(exports, "modifyHash", ()=>modifyHash);
parcelHelpers.export(exports, "modify", ()=>modify);
parcelHelpers.export(exports, "union", ()=>union);
parcelHelpers.export(exports, "remove", ()=>remove);
parcelHelpers.export(exports, "removeMany", ()=>removeMany);
parcelHelpers.export(exports, "map", ()=>map);
parcelHelpers.export(exports, "flatMap", ()=>flatMap);
parcelHelpers.export(exports, "forEach", ()=>forEach);
parcelHelpers.export(exports, "reduce", ()=>reduce);
parcelHelpers.export(exports, "filter", ()=>filter);
parcelHelpers.export(exports, "compact", ()=>compact);
parcelHelpers.export(exports, "filterMap", ()=>filterMap);
parcelHelpers.export(exports, "findFirst", ()=>findFirst);
parcelHelpers.export(exports, "some", ()=>some);
parcelHelpers.export(exports, "every", ()=>every);
var _equalJs = require("../Equal.js");
var _functionJs = require("../Function.js");
var _hashJs = require("../Hash.js");
var _inspectableJs = require("../Inspectable.js");
var _optionJs = require("../Option.js");
var _pipeableJs = require("../Pipeable.js");
var _predicateJs = require("../Predicate.js");
var _bitwiseJs = require("./hashMap/bitwise.js");
var _configJs = require("./hashMap/config.js");
var _nodeJs = require("./hashMap/node.js");
const HashMapSymbolKey = "effect/HashMap";
const HashMapTypeId = /*#__PURE__*/ Symbol.for(HashMapSymbolKey);
const HashMapProto = {
    [HashMapTypeId]: HashMapTypeId,
    [Symbol.iterator] () {
        return new HashMapIterator(this, (k, v)=>[
                k,
                v
            ]);
    },
    [_hashJs.symbol] () {
        let hash = _hashJs.hash(HashMapSymbolKey);
        for (const item of this)hash ^= (0, _functionJs.pipe)(_hashJs.hash(item[0]), _hashJs.combine(_hashJs.hash(item[1])));
        return _hashJs.cached(this, hash);
    },
    [_equalJs.symbol] (that) {
        if (isHashMap(that)) {
            if (that._size !== this._size) return false;
            for (const item of this){
                const elem = (0, _functionJs.pipe)(that, getHash(item[0], _hashJs.hash(item[0])));
                if (_optionJs.isNone(elem)) return false;
                else {
                    if (!_equalJs.equals(item[1], elem.value)) return false;
                }
            }
            return true;
        }
        return false;
    },
    toString () {
        return (0, _inspectableJs.format)(this.toJSON());
    },
    toJSON () {
        return {
            _id: "HashMap",
            values: Array.from(this).map((0, _inspectableJs.toJSON))
        };
    },
    [(0, _inspectableJs.NodeInspectSymbol)] () {
        return this.toJSON();
    },
    pipe () {
        return (0, _pipeableJs.pipeArguments)(this, arguments);
    }
};
const makeImpl = (editable, edit, root, size)=>{
    const map = Object.create(HashMapProto);
    map._editable = editable;
    map._edit = edit;
    map._root = root;
    map._size = size;
    return map;
};
class HashMapIterator {
    map;
    f;
    v;
    constructor(map, f){
        this.map = map;
        this.f = f;
        this.v = visitLazy(this.map._root, this.f, undefined);
    }
    next() {
        if (_optionJs.isNone(this.v)) return {
            done: true,
            value: undefined
        };
        const v0 = this.v.value;
        this.v = applyCont(v0.cont);
        return {
            done: false,
            value: v0.value
        };
    }
    [Symbol.iterator]() {
        return new HashMapIterator(this.map, this.f);
    }
}
const applyCont = (cont)=>cont ? visitLazyChildren(cont[0], cont[1], cont[2], cont[3], cont[4]) : _optionJs.none();
const visitLazy = (node, f, cont)=>{
    switch(node._tag){
        case "LeafNode":
            if (_optionJs.isSome(node.value)) return _optionJs.some({
                value: f(node.key, node.value.value),
                cont
            });
            return applyCont(cont);
        case "CollisionNode":
        case "ArrayNode":
        case "IndexedNode":
            {
                const children = node.children;
                return visitLazyChildren(children.length, children, 0, f, cont);
            }
        default:
            return applyCont(cont);
    }
};
const visitLazyChildren = (len, children, i, f, cont)=>{
    while(i < len){
        const child = children[i++];
        if (child && !_nodeJs.isEmptyNode(child)) return visitLazy(child, f, [
            len,
            children,
            i,
            f,
            cont
        ]);
    }
    return applyCont(cont);
};
const _empty = /*#__PURE__*/ makeImpl(false, 0, /*#__PURE__*/ new _nodeJs.EmptyNode(), 0);
const empty = ()=>_empty;
const make = (...entries)=>fromIterable(entries);
const fromIterable = (entries)=>{
    const map = beginMutation(empty());
    for (const entry of entries)set(map, entry[0], entry[1]);
    return endMutation(map);
};
const isHashMap = (u)=>(0, _predicateJs.hasProperty)(u, HashMapTypeId);
const isEmpty = (self)=>self && _nodeJs.isEmptyNode(self._root);
const get = /*#__PURE__*/ _functionJs.dual(2, (self, key)=>getHash(self, key, _hashJs.hash(key)));
const getHash = /*#__PURE__*/ _functionJs.dual(3, (self, key, hash)=>{
    let node = self._root;
    let shift = 0;
    while(true)switch(node._tag){
        case "LeafNode":
            return _equalJs.equals(key, node.key) ? node.value : _optionJs.none();
        case "CollisionNode":
            if (hash === node.hash) {
                const children = node.children;
                for(let i = 0, len = children.length; i < len; ++i){
                    const child = children[i];
                    if ("key" in child && _equalJs.equals(key, child.key)) return child.value;
                }
            }
            return _optionJs.none();
        case "IndexedNode":
            {
                const frag = (0, _bitwiseJs.hashFragment)(shift, hash);
                const bit = (0, _bitwiseJs.toBitmap)(frag);
                if (node.mask & bit) {
                    node = node.children[(0, _bitwiseJs.fromBitmap)(node.mask, bit)];
                    shift += (0, _configJs.SIZE);
                    break;
                }
                return _optionJs.none();
            }
        case "ArrayNode":
            node = node.children[(0, _bitwiseJs.hashFragment)(shift, hash)];
            if (node) {
                shift += (0, _configJs.SIZE);
                break;
            }
            return _optionJs.none();
        default:
            return _optionJs.none();
    }
});
const unsafeGet = /*#__PURE__*/ _functionJs.dual(2, (self, key)=>{
    const element = getHash(self, key, _hashJs.hash(key));
    if (_optionJs.isNone(element)) throw new Error("Expected map to contain key");
    return element.value;
});
const has = /*#__PURE__*/ _functionJs.dual(2, (self, key)=>_optionJs.isSome(getHash(self, key, _hashJs.hash(key))));
const hasHash = /*#__PURE__*/ _functionJs.dual(3, (self, key, hash)=>_optionJs.isSome(getHash(self, key, hash)));
const set = /*#__PURE__*/ _functionJs.dual(3, (self, key, value)=>modifyAt(self, key, ()=>_optionJs.some(value)));
const setTree = /*#__PURE__*/ _functionJs.dual(3, (self, newRoot, newSize)=>{
    if (self._editable) {
        self._root = newRoot;
        self._size = newSize;
        return self;
    }
    return newRoot === self._root ? self : makeImpl(self._editable, self._edit, newRoot, newSize);
});
const keys = (self)=>new HashMapIterator(self, (key)=>key);
const values = (self)=>new HashMapIterator(self, (_, value)=>value);
const entries = (self)=>new HashMapIterator(self, (key, value)=>[
            key,
            value
        ]);
const size = (self)=>self._size;
const beginMutation = (self)=>makeImpl(true, self._edit + 1, self._root, self._size);
const endMutation = (self)=>{
    self._editable = false;
    return self;
};
const mutate = /*#__PURE__*/ _functionJs.dual(2, (self, f)=>{
    const transient = beginMutation(self);
    f(transient);
    return endMutation(transient);
});
const modifyAt = /*#__PURE__*/ _functionJs.dual(3, (self, key, f)=>modifyHash(self, key, _hashJs.hash(key), f));
const modifyHash = /*#__PURE__*/ _functionJs.dual(4, (self, key, hash, f)=>{
    const size = {
        value: self._size
    };
    const newRoot = self._root.modify(self._editable ? self._edit : NaN, 0, f, hash, key, size);
    return (0, _functionJs.pipe)(self, setTree(newRoot, size.value));
});
const modify = /*#__PURE__*/ _functionJs.dual(3, (self, key, f)=>modifyAt(self, key, _optionJs.map(f)));
const union = /*#__PURE__*/ _functionJs.dual(2, (self, that)=>{
    const result = beginMutation(self);
    forEach(that, (v, k)=>set(result, k, v));
    return endMutation(result);
});
const remove = /*#__PURE__*/ _functionJs.dual(2, (self, key)=>modifyAt(self, key, _optionJs.none));
const removeMany = /*#__PURE__*/ _functionJs.dual(2, (self, keys)=>mutate(self, (map)=>{
        for (const key of keys)remove(key)(map);
    }));
const map = /*#__PURE__*/ _functionJs.dual(2, (self, f)=>reduce(self, empty(), (map, value, key)=>set(map, key, f(value, key))));
const flatMap = /*#__PURE__*/ _functionJs.dual(2, (self, f)=>reduce(self, empty(), (zero, value, key)=>mutate(zero, (map)=>forEach(f(value, key), (value, key)=>set(map, key, value)))));
const forEach = /*#__PURE__*/ _functionJs.dual(2, (self, f)=>reduce(self, void 0, (_, value, key)=>f(value, key)));
const reduce = /*#__PURE__*/ _functionJs.dual(3, (self, zero, f)=>{
    const root = self._root;
    if (root._tag === "LeafNode") return _optionJs.isSome(root.value) ? f(zero, root.value.value, root.key) : zero;
    if (root._tag === "EmptyNode") return zero;
    const toVisit = [
        root.children
    ];
    let children;
    while(children = toVisit.pop())for(let i = 0, len = children.length; i < len;){
        const child = children[i++];
        if (child && !_nodeJs.isEmptyNode(child)) {
            if (child._tag === "LeafNode") {
                if (_optionJs.isSome(child.value)) zero = f(zero, child.value.value, child.key);
            } else toVisit.push(child.children);
        }
    }
    return zero;
});
const filter = /*#__PURE__*/ _functionJs.dual(2, (self, f)=>mutate(empty(), (map)=>{
        for (const [k, a] of self)if (f(a, k)) set(map, k, a);
    }));
const compact = (self)=>filterMap(self, (0, _functionJs.identity));
const filterMap = /*#__PURE__*/ _functionJs.dual(2, (self, f)=>mutate(empty(), (map)=>{
        for (const [k, a] of self){
            const option = f(a, k);
            if (_optionJs.isSome(option)) set(map, k, option.value);
        }
    }));
const findFirst = /*#__PURE__*/ _functionJs.dual(2, (self, predicate)=>{
    for (const ka of self){
        if (predicate(ka[1], ka[0])) return _optionJs.some(ka);
    }
    return _optionJs.none();
});
const some = /*#__PURE__*/ _functionJs.dual(2, (self, predicate)=>{
    for (const ka of self){
        if (predicate(ka[1], ka[0])) return true;
    }
    return false;
});
const every = /*#__PURE__*/ _functionJs.dual(2, (self, predicate)=>!some(self, (a, k)=>!predicate(a, k)));

},{"../Equal.js":"gA0qD","../Function.js":"21gOL","../Hash.js":"gFMwE","../Inspectable.js":"1Ur70","../Option.js":"6sHA7","../Pipeable.js":"b5RU2","../Predicate.js":"gW5pd","./hashMap/bitwise.js":"l5e7d","./hashMap/config.js":"6O36C","./hashMap/node.js":"fAjjI","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"l5e7d":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Hamming weight.
 *
 * Taken from: http://jsperf.com/hamming-weight
 *
 * @internal
 */ parcelHelpers.export(exports, "popcount", ()=>popcount);
/** @internal */ parcelHelpers.export(exports, "hashFragment", ()=>hashFragment);
/** @internal */ parcelHelpers.export(exports, "toBitmap", ()=>toBitmap);
/** @internal */ parcelHelpers.export(exports, "fromBitmap", ()=>fromBitmap);
var _configJs = require("./config.js");
function popcount(x) {
    x -= x >> 1 & 0x55555555;
    x = (x & 0x33333333) + (x >> 2 & 0x33333333);
    x = x + (x >> 4) & 0x0f0f0f0f;
    x += x >> 8;
    x += x >> 16;
    return x & 0x7f;
}
function hashFragment(shift, h) {
    return h >>> shift & (0, _configJs.MASK);
}
function toBitmap(x) {
    return 1 << x;
}
function fromBitmap(bitmap, bit) {
    return popcount(bitmap & bit - 1);
}

},{"./config.js":"6O36C","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"6O36C":[function(require,module,exports,__globalThis) {
/** @internal */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SIZE", ()=>SIZE);
parcelHelpers.export(exports, "BUCKET_SIZE", ()=>BUCKET_SIZE);
parcelHelpers.export(exports, "MASK", ()=>MASK);
parcelHelpers.export(exports, "MAX_INDEX_NODE", ()=>MAX_INDEX_NODE);
parcelHelpers.export(exports, "MIN_ARRAY_NODE", ()=>MIN_ARRAY_NODE);
const SIZE = 5;
const BUCKET_SIZE = /*#__PURE__*/ Math.pow(2, SIZE);
const MASK = BUCKET_SIZE - 1;
const MAX_INDEX_NODE = BUCKET_SIZE / 2;
const MIN_ARRAY_NODE = BUCKET_SIZE / 4;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"fAjjI":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** @internal */ parcelHelpers.export(exports, "EmptyNode", ()=>EmptyNode);
/** @internal */ parcelHelpers.export(exports, "isEmptyNode", ()=>isEmptyNode);
/** @internal */ parcelHelpers.export(exports, "isLeafNode", ()=>isLeafNode);
/** @internal */ parcelHelpers.export(exports, "canEditNode", ()=>canEditNode);
/** @internal */ parcelHelpers.export(exports, "LeafNode", ()=>LeafNode);
/** @internal */ parcelHelpers.export(exports, "CollisionNode", ()=>CollisionNode);
/** @internal */ parcelHelpers.export(exports, "IndexedNode", ()=>IndexedNode);
/** @internal */ parcelHelpers.export(exports, "ArrayNode", ()=>ArrayNode);
var _equalJs = require("../../Equal.js");
var _optionJs = require("../../Option.js");
var _predicateJs = require("../../Predicate.js");
var _stackJs = require("../stack.js");
var _arrayJs = require("./array.js");
var _bitwiseJs = require("./bitwise.js");
var _configJs = require("./config.js");
class EmptyNode {
    _tag = "EmptyNode";
    modify(edit, _shift, f, hash, key, size) {
        const v = f(_optionJs.none());
        if (_optionJs.isNone(v)) return new EmptyNode();
        ++size.value;
        return new LeafNode(edit, hash, key, v);
    }
}
function isEmptyNode(a) {
    return (0, _predicateJs.isTagged)(a, "EmptyNode");
}
function isLeafNode(node) {
    return isEmptyNode(node) || node._tag === "LeafNode" || node._tag === "CollisionNode";
}
function canEditNode(node, edit) {
    return isEmptyNode(node) ? false : edit === node.edit;
}
class LeafNode {
    edit;
    hash;
    key;
    value;
    _tag = "LeafNode";
    constructor(edit, hash, key, value){
        this.edit = edit;
        this.hash = hash;
        this.key = key;
        this.value = value;
    }
    modify(edit, shift, f, hash, key, size) {
        if ((0, _equalJs.equals)(key, this.key)) {
            const v = f(this.value);
            if (v === this.value) return this;
            else if (_optionJs.isNone(v)) {
                --size.value;
                return new EmptyNode();
            }
            if (canEditNode(this, edit)) {
                this.value = v;
                return this;
            }
            return new LeafNode(edit, hash, key, v);
        }
        const v = f(_optionJs.none());
        if (_optionJs.isNone(v)) return this;
        ++size.value;
        return mergeLeaves(edit, shift, this.hash, this, hash, new LeafNode(edit, hash, key, v));
    }
}
class CollisionNode {
    edit;
    hash;
    children;
    _tag = "CollisionNode";
    constructor(edit, hash, children){
        this.edit = edit;
        this.hash = hash;
        this.children = children;
    }
    modify(edit, shift, f, hash, key, size) {
        if (hash === this.hash) {
            const canEdit = canEditNode(this, edit);
            const list = this.updateCollisionList(canEdit, edit, this.hash, this.children, f, key, size);
            if (list === this.children) return this;
            return list.length > 1 ? new CollisionNode(edit, this.hash, list) : list[0]; // collapse single element collision list
        }
        const v = f(_optionJs.none());
        if (_optionJs.isNone(v)) return this;
        ++size.value;
        return mergeLeaves(edit, shift, this.hash, this, hash, new LeafNode(edit, hash, key, v));
    }
    updateCollisionList(mutate, edit, hash, list, f, key, size) {
        const len = list.length;
        for(let i = 0; i < len; ++i){
            const child = list[i];
            if ("key" in child && (0, _equalJs.equals)(key, child.key)) {
                const value = child.value;
                const newValue = f(value);
                if (newValue === value) return list;
                if (_optionJs.isNone(newValue)) {
                    --size.value;
                    return (0, _arrayJs.arraySpliceOut)(mutate, i, list);
                }
                return (0, _arrayJs.arrayUpdate)(mutate, i, new LeafNode(edit, hash, key, newValue), list);
            }
        }
        const newValue = f(_optionJs.none());
        if (_optionJs.isNone(newValue)) return list;
        ++size.value;
        return (0, _arrayJs.arrayUpdate)(mutate, len, new LeafNode(edit, hash, key, newValue), list);
    }
}
class IndexedNode {
    edit;
    mask;
    children;
    _tag = "IndexedNode";
    constructor(edit, mask, children){
        this.edit = edit;
        this.mask = mask;
        this.children = children;
    }
    modify(edit, shift, f, hash, key, size) {
        const mask = this.mask;
        const children = this.children;
        const frag = (0, _bitwiseJs.hashFragment)(shift, hash);
        const bit = (0, _bitwiseJs.toBitmap)(frag);
        const indx = (0, _bitwiseJs.fromBitmap)(mask, bit);
        const exists = mask & bit;
        const canEdit = canEditNode(this, edit);
        if (!exists) {
            const _newChild = new EmptyNode().modify(edit, shift + (0, _configJs.SIZE), f, hash, key, size);
            if (!_newChild) return this;
            return children.length >= (0, _configJs.MAX_INDEX_NODE) ? expand(edit, frag, _newChild, mask, children) : new IndexedNode(edit, mask | bit, (0, _arrayJs.arraySpliceIn)(canEdit, indx, _newChild, children));
        }
        const current = children[indx];
        const child = current.modify(edit, shift + (0, _configJs.SIZE), f, hash, key, size);
        if (current === child) return this;
        let bitmap = mask;
        let newChildren;
        if (isEmptyNode(child)) {
            // remove
            bitmap &= ~bit;
            if (!bitmap) return new EmptyNode();
            if (children.length <= 2 && isLeafNode(children[indx ^ 1])) return children[indx ^ 1]; // collapse
            newChildren = (0, _arrayJs.arraySpliceOut)(canEdit, indx, children);
        } else // modify
        newChildren = (0, _arrayJs.arrayUpdate)(canEdit, indx, child, children);
        if (canEdit) {
            this.mask = bitmap;
            this.children = newChildren;
            return this;
        }
        return new IndexedNode(edit, bitmap, newChildren);
    }
}
class ArrayNode {
    edit;
    size;
    children;
    _tag = "ArrayNode";
    constructor(edit, size, children){
        this.edit = edit;
        this.size = size;
        this.children = children;
    }
    modify(edit, shift, f, hash, key, size) {
        let count = this.size;
        const children = this.children;
        const frag = (0, _bitwiseJs.hashFragment)(shift, hash);
        const child = children[frag];
        const newChild = (child || new EmptyNode()).modify(edit, shift + (0, _configJs.SIZE), f, hash, key, size);
        if (child === newChild) return this;
        const canEdit = canEditNode(this, edit);
        let newChildren;
        if (isEmptyNode(child) && !isEmptyNode(newChild)) {
            ++count;
            newChildren = (0, _arrayJs.arrayUpdate)(canEdit, frag, newChild, children);
        } else if (!isEmptyNode(child) && isEmptyNode(newChild)) {
            --count;
            if (count <= (0, _configJs.MIN_ARRAY_NODE)) return pack(edit, count, frag, children);
            newChildren = (0, _arrayJs.arrayUpdate)(canEdit, frag, new EmptyNode(), children);
        } else // modify
        newChildren = (0, _arrayJs.arrayUpdate)(canEdit, frag, newChild, children);
        if (canEdit) {
            this.size = count;
            this.children = newChildren;
            return this;
        }
        return new ArrayNode(edit, count, newChildren);
    }
}
function pack(edit, count, removed, elements) {
    const children = new Array(count - 1);
    let g = 0;
    let bitmap = 0;
    for(let i = 0, len = elements.length; i < len; ++i)if (i !== removed) {
        const elem = elements[i];
        if (elem && !isEmptyNode(elem)) {
            children[g++] = elem;
            bitmap |= 1 << i;
        }
    }
    return new IndexedNode(edit, bitmap, children);
}
function expand(edit, frag, child, bitmap, subNodes) {
    const arr = [];
    let bit = bitmap;
    let count = 0;
    for(let i = 0; bit; ++i){
        if (bit & 1) arr[i] = subNodes[count++];
        bit >>>= 1;
    }
    arr[frag] = child;
    return new ArrayNode(edit, count + 1, arr);
}
function mergeLeavesInner(edit, shift, h1, n1, h2, n2) {
    if (h1 === h2) return new CollisionNode(edit, h1, [
        n2,
        n1
    ]);
    const subH1 = (0, _bitwiseJs.hashFragment)(shift, h1);
    const subH2 = (0, _bitwiseJs.hashFragment)(shift, h2);
    if (subH1 === subH2) return (child)=>new IndexedNode(edit, (0, _bitwiseJs.toBitmap)(subH1) | (0, _bitwiseJs.toBitmap)(subH2), [
            child
        ]);
    else {
        const children = subH1 < subH2 ? [
            n1,
            n2
        ] : [
            n2,
            n1
        ];
        return new IndexedNode(edit, (0, _bitwiseJs.toBitmap)(subH1) | (0, _bitwiseJs.toBitmap)(subH2), children);
    }
}
function mergeLeaves(edit, shift, h1, n1, h2, n2) {
    let stack = undefined;
    let currentShift = shift;
    while(true){
        const res = mergeLeavesInner(edit, currentShift, h1, n1, h2, n2);
        if (typeof res === "function") {
            stack = _stackJs.make(res, stack);
            currentShift = currentShift + (0, _configJs.SIZE);
        } else {
            let final = res;
            while(stack != null){
                final = stack.value(final);
                stack = stack.previous;
            }
            return final;
        }
    }
}

},{"../../Equal.js":"gA0qD","../../Option.js":"6sHA7","../../Predicate.js":"gW5pd","../stack.js":"Pt170","./array.js":"eeCEG","./bitwise.js":"l5e7d","./config.js":"6O36C","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"Pt170":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "make", ()=>make);
const make = (value, previous)=>({
        value,
        previous
    });

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"eeCEG":[function(require,module,exports,__globalThis) {
/** @internal */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "arrayUpdate", ()=>arrayUpdate);
/** @internal */ parcelHelpers.export(exports, "arraySpliceOut", ()=>arraySpliceOut);
/** @internal */ parcelHelpers.export(exports, "arraySpliceIn", ()=>arraySpliceIn);
function arrayUpdate(mutate, at, v, arr) {
    let out = arr;
    if (!mutate) {
        const len = arr.length;
        out = new Array(len);
        for(let i = 0; i < len; ++i)out[i] = arr[i];
    }
    out[at] = v;
    return out;
}
function arraySpliceOut(mutate, at, arr) {
    const newLen = arr.length - 1;
    let i = 0;
    let g = 0;
    let out = arr;
    if (mutate) i = g = at;
    else {
        out = new Array(newLen);
        while(i < at)out[g++] = arr[i++];
    }
    ++i;
    while(i <= newLen)out[g++] = arr[i++];
    if (mutate) out.length = newLen;
    return out;
}
function arraySpliceIn(mutate, at, v, arr) {
    const len = arr.length;
    if (mutate) {
        let i = len;
        while(i >= at)arr[i--] = arr[i];
        arr[at] = v;
        return arr;
    }
    let i = 0, g = 0;
    const out = new Array(len + 1);
    while(i < at)out[g++] = arr[i++];
    out[at] = v;
    while(i < len)out[++g] = arr[i++];
    return out;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"2Mw9X":[function(require,module,exports,__globalThis) {
/** @internal */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "OP_DIE", ()=>OP_DIE);
parcelHelpers.export(exports, "OP_EMPTY", ()=>OP_EMPTY);
parcelHelpers.export(exports, "OP_FAIL", ()=>OP_FAIL);
parcelHelpers.export(exports, "OP_INTERRUPT", ()=>OP_INTERRUPT);
parcelHelpers.export(exports, "OP_PARALLEL", ()=>OP_PARALLEL);
parcelHelpers.export(exports, "OP_SEQUENTIAL", ()=>OP_SEQUENTIAL);
const OP_DIE = "Die";
const OP_EMPTY = "Empty";
const OP_FAIL = "Fail";
const OP_INTERRUPT = "Interrupt";
const OP_PARALLEL = "Parallel";
const OP_SEQUENTIAL = "Sequential";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"cr3YV":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "blocked", ()=>blocked);
parcelHelpers.export(exports, "runRequestBlock", ()=>runRequestBlock);
parcelHelpers.export(exports, "EffectTypeId", ()=>EffectTypeId);
/** @internal */ parcelHelpers.export(exports, "RevertFlags", ()=>RevertFlags);
parcelHelpers.export(exports, "isEffect", ()=>isEffect);
parcelHelpers.export(exports, "withFiberRuntime", ()=>withFiberRuntime);
parcelHelpers.export(exports, "acquireUseRelease", ()=>acquireUseRelease);
parcelHelpers.export(exports, "as", ()=>as);
parcelHelpers.export(exports, "asVoid", ()=>asVoid);
parcelHelpers.export(exports, "custom", ()=>custom);
parcelHelpers.export(exports, "unsafeAsync", ()=>unsafeAsync);
parcelHelpers.export(exports, "asyncInterrupt", ()=>asyncInterrupt);
parcelHelpers.export(exports, "async", ()=>async_);
parcelHelpers.export(exports, "catchAllCause", ()=>catchAllCause);
parcelHelpers.export(exports, "catchAll", ()=>catchAll);
parcelHelpers.export(exports, "catchIf", ()=>catchIf);
parcelHelpers.export(exports, "catchSome", ()=>catchSome);
parcelHelpers.export(exports, "checkInterruptible", ()=>checkInterruptible);
parcelHelpers.export(exports, "originalInstance", ()=>originalInstance);
parcelHelpers.export(exports, "capture", ()=>capture);
parcelHelpers.export(exports, "die", ()=>die);
parcelHelpers.export(exports, "dieMessage", ()=>dieMessage);
parcelHelpers.export(exports, "dieSync", ()=>dieSync);
parcelHelpers.export(exports, "either", ()=>either);
parcelHelpers.export(exports, "exit", ()=>exit);
parcelHelpers.export(exports, "fail", ()=>fail);
parcelHelpers.export(exports, "failSync", ()=>failSync);
parcelHelpers.export(exports, "failCause", ()=>failCause);
parcelHelpers.export(exports, "failCauseSync", ()=>failCauseSync);
parcelHelpers.export(exports, "fiberId", ()=>fiberId);
parcelHelpers.export(exports, "fiberIdWith", ()=>fiberIdWith);
parcelHelpers.export(exports, "flatMap", ()=>flatMap);
parcelHelpers.export(exports, "andThen", ()=>andThen);
parcelHelpers.export(exports, "step", ()=>step);
parcelHelpers.export(exports, "flatten", ()=>flatten);
parcelHelpers.export(exports, "flip", ()=>flip);
parcelHelpers.export(exports, "matchCause", ()=>matchCause);
parcelHelpers.export(exports, "matchCauseEffect", ()=>matchCauseEffect);
parcelHelpers.export(exports, "matchEffect", ()=>matchEffect);
parcelHelpers.export(exports, "forEachSequential", ()=>forEachSequential);
parcelHelpers.export(exports, "forEachSequentialDiscard", ()=>forEachSequentialDiscard);
parcelHelpers.export(exports, "if_", ()=>if_);
parcelHelpers.export(exports, "interrupt", ()=>interrupt);
parcelHelpers.export(exports, "interruptWith", ()=>interruptWith);
parcelHelpers.export(exports, "interruptible", ()=>interruptible);
parcelHelpers.export(exports, "interruptibleMask", ()=>interruptibleMask);
parcelHelpers.export(exports, "intoDeferred", ()=>intoDeferred);
parcelHelpers.export(exports, "map", ()=>map);
parcelHelpers.export(exports, "mapBoth", ()=>mapBoth);
parcelHelpers.export(exports, "mapError", ()=>mapError);
parcelHelpers.export(exports, "onError", ()=>onError);
parcelHelpers.export(exports, "onExit", ()=>onExit);
parcelHelpers.export(exports, "onInterrupt", ()=>onInterrupt);
parcelHelpers.export(exports, "orElse", ()=>orElse);
parcelHelpers.export(exports, "orDie", ()=>orDie);
parcelHelpers.export(exports, "orDieWith", ()=>orDieWith);
parcelHelpers.export(exports, "partitionMap", ()=>partitionMap);
parcelHelpers.export(exports, "runtimeFlags", ()=>runtimeFlags);
parcelHelpers.export(exports, "succeed", ()=>succeed);
parcelHelpers.export(exports, "suspend", ()=>suspend);
parcelHelpers.export(exports, "sync", ()=>sync);
parcelHelpers.export(exports, "tap", ()=>tap);
parcelHelpers.export(exports, "transplant", ()=>transplant);
parcelHelpers.export(exports, "attemptOrElse", ()=>attemptOrElse);
parcelHelpers.export(exports, "uninterruptible", ()=>uninterruptible);
parcelHelpers.export(exports, "uninterruptibleMask", ()=>uninterruptibleMask);
parcelHelpers.export(exports, "void", ()=>void_);
parcelHelpers.export(exports, "updateRuntimeFlags", ()=>updateRuntimeFlags);
parcelHelpers.export(exports, "whenEffect", ()=>whenEffect);
parcelHelpers.export(exports, "whileLoop", ()=>whileLoop);
parcelHelpers.export(exports, "fromIterator", ()=>fromIterator);
parcelHelpers.export(exports, "gen", ()=>gen);
parcelHelpers.export(exports, "fnUntraced", ()=>fnUntraced);
parcelHelpers.export(exports, "withConcurrency", ()=>withConcurrency);
parcelHelpers.export(exports, "withRequestBatching", ()=>withRequestBatching);
parcelHelpers.export(exports, "withRuntimeFlags", ()=>withRuntimeFlags);
parcelHelpers.export(exports, "withTracerEnabled", ()=>withTracerEnabled);
parcelHelpers.export(exports, "withTracerTiming", ()=>withTracerTiming);
parcelHelpers.export(exports, "yieldNow", ()=>yieldNow);
parcelHelpers.export(exports, "zip", ()=>zip);
parcelHelpers.export(exports, "zipFlatten", ()=>zipFlatten);
parcelHelpers.export(exports, "zipLeft", ()=>zipLeft);
parcelHelpers.export(exports, "zipRight", ()=>zipRight);
parcelHelpers.export(exports, "zipWith", ()=>zipWith);
parcelHelpers.export(exports, "never", ()=>never);
parcelHelpers.export(exports, "interruptFiber", ()=>interruptFiber);
parcelHelpers.export(exports, "interruptAsFiber", ()=>interruptAsFiber);
parcelHelpers.export(exports, "logLevelAll", ()=>logLevelAll);
parcelHelpers.export(exports, "logLevelFatal", ()=>logLevelFatal);
parcelHelpers.export(exports, "logLevelError", ()=>logLevelError);
parcelHelpers.export(exports, "logLevelWarning", ()=>logLevelWarning);
parcelHelpers.export(exports, "logLevelInfo", ()=>logLevelInfo);
parcelHelpers.export(exports, "logLevelDebug", ()=>logLevelDebug);
parcelHelpers.export(exports, "logLevelTrace", ()=>logLevelTrace);
parcelHelpers.export(exports, "logLevelNone", ()=>logLevelNone);
parcelHelpers.export(exports, "allLogLevels", ()=>allLogLevels);
parcelHelpers.export(exports, "FiberRefTypeId", ()=>FiberRefTypeId);
parcelHelpers.export(exports, "fiberRefGet", ()=>fiberRefGet);
parcelHelpers.export(exports, "fiberRefGetAndSet", ()=>fiberRefGetAndSet);
parcelHelpers.export(exports, "fiberRefGetAndUpdate", ()=>fiberRefGetAndUpdate);
parcelHelpers.export(exports, "fiberRefGetAndUpdateSome", ()=>fiberRefGetAndUpdateSome);
parcelHelpers.export(exports, "fiberRefGetWith", ()=>fiberRefGetWith);
parcelHelpers.export(exports, "fiberRefSet", ()=>fiberRefSet);
parcelHelpers.export(exports, "fiberRefDelete", ()=>fiberRefDelete);
parcelHelpers.export(exports, "fiberRefReset", ()=>fiberRefReset);
parcelHelpers.export(exports, "fiberRefModify", ()=>fiberRefModify);
parcelHelpers.export(exports, "fiberRefModifySome", ()=>fiberRefModifySome);
parcelHelpers.export(exports, "fiberRefUpdate", ()=>fiberRefUpdate);
parcelHelpers.export(exports, "fiberRefUpdateSome", ()=>fiberRefUpdateSome);
parcelHelpers.export(exports, "fiberRefUpdateAndGet", ()=>fiberRefUpdateAndGet);
parcelHelpers.export(exports, "fiberRefUpdateSomeAndGet", ()=>fiberRefUpdateSomeAndGet);
parcelHelpers.export(exports, "RequestResolverTypeId", ()=>RequestResolverTypeId);
/** @internal */ parcelHelpers.export(exports, "RequestResolverImpl", ()=>RequestResolverImpl);
parcelHelpers.export(exports, "isRequestResolver", ()=>isRequestResolver);
parcelHelpers.export(exports, "resolverLocally", ()=>resolverLocally);
parcelHelpers.export(exports, "requestBlockLocally", ()=>requestBlockLocally);
parcelHelpers.export(exports, "fiberRefLocally", ()=>fiberRefLocally);
parcelHelpers.export(exports, "fiberRefLocallyWith", ()=>fiberRefLocallyWith);
parcelHelpers.export(exports, "fiberRefUnsafeMake", ()=>fiberRefUnsafeMake);
parcelHelpers.export(exports, "fiberRefUnsafeMakeHashSet", ()=>fiberRefUnsafeMakeHashSet);
parcelHelpers.export(exports, "fiberRefUnsafeMakeReadonlyArray", ()=>fiberRefUnsafeMakeReadonlyArray);
parcelHelpers.export(exports, "fiberRefUnsafeMakeContext", ()=>fiberRefUnsafeMakeContext);
parcelHelpers.export(exports, "fiberRefUnsafeMakePatch", ()=>fiberRefUnsafeMakePatch);
parcelHelpers.export(exports, "fiberRefUnsafeMakeRuntimeFlags", ()=>fiberRefUnsafeMakeRuntimeFlags);
parcelHelpers.export(exports, "currentContext", ()=>currentContext);
parcelHelpers.export(exports, "currentSchedulingPriority", ()=>currentSchedulingPriority);
parcelHelpers.export(exports, "currentMaxOpsBeforeYield", ()=>currentMaxOpsBeforeYield);
parcelHelpers.export(exports, "currentLogAnnotations", ()=>currentLogAnnotations);
parcelHelpers.export(exports, "currentLogLevel", ()=>currentLogLevel);
parcelHelpers.export(exports, "currentLogSpan", ()=>currentLogSpan);
parcelHelpers.export(exports, "withSchedulingPriority", ()=>withSchedulingPriority);
parcelHelpers.export(exports, "withMaxOpsBeforeYield", ()=>withMaxOpsBeforeYield);
parcelHelpers.export(exports, "currentConcurrency", ()=>currentConcurrency);
parcelHelpers.export(exports, "currentRequestBatching", ()=>currentRequestBatching);
parcelHelpers.export(exports, "currentUnhandledErrorLogLevel", ()=>currentUnhandledErrorLogLevel);
parcelHelpers.export(exports, "withUnhandledErrorLogLevel", ()=>withUnhandledErrorLogLevel);
parcelHelpers.export(exports, "currentMetricLabels", ()=>currentMetricLabels);
parcelHelpers.export(exports, "metricLabels", ()=>metricLabels);
parcelHelpers.export(exports, "currentForkScopeOverride", ()=>currentForkScopeOverride);
parcelHelpers.export(exports, "currentInterruptedCause", ()=>currentInterruptedCause);
parcelHelpers.export(exports, "currentTracerEnabled", ()=>currentTracerEnabled);
parcelHelpers.export(exports, "currentTracerTimingEnabled", ()=>currentTracerTimingEnabled);
parcelHelpers.export(exports, "currentTracerSpanAnnotations", ()=>currentTracerSpanAnnotations);
parcelHelpers.export(exports, "currentTracerSpanLinks", ()=>currentTracerSpanLinks);
parcelHelpers.export(exports, "ScopeTypeId", ()=>ScopeTypeId);
parcelHelpers.export(exports, "CloseableScopeTypeId", ()=>CloseableScopeTypeId);
parcelHelpers.export(exports, "scopeAddFinalizer", ()=>scopeAddFinalizer);
parcelHelpers.export(exports, "scopeAddFinalizerExit", ()=>scopeAddFinalizerExit);
parcelHelpers.export(exports, "scopeClose", ()=>scopeClose);
parcelHelpers.export(exports, "scopeFork", ()=>scopeFork);
parcelHelpers.export(exports, "causeSquash", ()=>causeSquash);
parcelHelpers.export(exports, "causeSquashWith", ()=>causeSquashWith);
parcelHelpers.export(exports, "YieldableError", ()=>YieldableError);
parcelHelpers.export(exports, "RuntimeExceptionTypeId", ()=>RuntimeExceptionTypeId);
parcelHelpers.export(exports, "RuntimeException", ()=>RuntimeException);
parcelHelpers.export(exports, "isRuntimeException", ()=>isRuntimeException);
parcelHelpers.export(exports, "InterruptedExceptionTypeId", ()=>InterruptedExceptionTypeId);
parcelHelpers.export(exports, "InterruptedException", ()=>InterruptedException);
parcelHelpers.export(exports, "isInterruptedException", ()=>isInterruptedException);
parcelHelpers.export(exports, "IllegalArgumentExceptionTypeId", ()=>IllegalArgumentExceptionTypeId);
parcelHelpers.export(exports, "IllegalArgumentException", ()=>IllegalArgumentException);
parcelHelpers.export(exports, "isIllegalArgumentException", ()=>isIllegalArgumentException);
parcelHelpers.export(exports, "NoSuchElementExceptionTypeId", ()=>NoSuchElementExceptionTypeId);
parcelHelpers.export(exports, "NoSuchElementException", ()=>NoSuchElementException);
parcelHelpers.export(exports, "isNoSuchElementException", ()=>isNoSuchElementException);
parcelHelpers.export(exports, "InvalidPubSubCapacityExceptionTypeId", ()=>InvalidPubSubCapacityExceptionTypeId);
parcelHelpers.export(exports, "InvalidPubSubCapacityException", ()=>InvalidPubSubCapacityException);
parcelHelpers.export(exports, "ExceededCapacityExceptionTypeId", ()=>ExceededCapacityExceptionTypeId);
parcelHelpers.export(exports, "ExceededCapacityException", ()=>ExceededCapacityException);
parcelHelpers.export(exports, "isExceededCapacityException", ()=>isExceededCapacityException);
parcelHelpers.export(exports, "isInvalidCapacityError", ()=>isInvalidCapacityError);
parcelHelpers.export(exports, "TimeoutExceptionTypeId", ()=>TimeoutExceptionTypeId);
parcelHelpers.export(exports, "TimeoutException", ()=>TimeoutException);
parcelHelpers.export(exports, "timeoutExceptionFromDuration", ()=>timeoutExceptionFromDuration);
parcelHelpers.export(exports, "isTimeoutException", ()=>isTimeoutException);
parcelHelpers.export(exports, "UnknownExceptionTypeId", ()=>UnknownExceptionTypeId);
parcelHelpers.export(exports, "UnknownException", ()=>UnknownException);
parcelHelpers.export(exports, "isUnknownException", ()=>isUnknownException);
parcelHelpers.export(exports, "exitIsExit", ()=>exitIsExit);
parcelHelpers.export(exports, "exitIsFailure", ()=>exitIsFailure);
parcelHelpers.export(exports, "exitIsSuccess", ()=>exitIsSuccess);
parcelHelpers.export(exports, "exitIsInterrupted", ()=>exitIsInterrupted);
parcelHelpers.export(exports, "exitAs", ()=>exitAs);
parcelHelpers.export(exports, "exitAsVoid", ()=>exitAsVoid);
parcelHelpers.export(exports, "exitCauseOption", ()=>exitCauseOption);
parcelHelpers.export(exports, "exitCollectAll", ()=>exitCollectAll);
parcelHelpers.export(exports, "exitDie", ()=>exitDie);
parcelHelpers.export(exports, "exitExists", ()=>exitExists);
parcelHelpers.export(exports, "exitFail", ()=>exitFail);
parcelHelpers.export(exports, "exitFailCause", ()=>exitFailCause);
parcelHelpers.export(exports, "exitFlatMap", ()=>exitFlatMap);
parcelHelpers.export(exports, "exitFlatMapEffect", ()=>exitFlatMapEffect);
parcelHelpers.export(exports, "exitFlatten", ()=>exitFlatten);
parcelHelpers.export(exports, "exitForEachEffect", ()=>exitForEachEffect);
parcelHelpers.export(exports, "exitFromEither", ()=>exitFromEither);
parcelHelpers.export(exports, "exitFromOption", ()=>exitFromOption);
parcelHelpers.export(exports, "exitGetOrElse", ()=>exitGetOrElse);
parcelHelpers.export(exports, "exitInterrupt", ()=>exitInterrupt);
parcelHelpers.export(exports, "exitMap", ()=>exitMap);
parcelHelpers.export(exports, "exitMapBoth", ()=>exitMapBoth);
parcelHelpers.export(exports, "exitMapError", ()=>exitMapError);
parcelHelpers.export(exports, "exitMapErrorCause", ()=>exitMapErrorCause);
parcelHelpers.export(exports, "exitMatch", ()=>exitMatch);
parcelHelpers.export(exports, "exitMatchEffect", ()=>exitMatchEffect);
parcelHelpers.export(exports, "exitSucceed", ()=>exitSucceed);
parcelHelpers.export(exports, "exitVoid", ()=>exitVoid);
parcelHelpers.export(exports, "exitZip", ()=>exitZip);
parcelHelpers.export(exports, "exitZipLeft", ()=>exitZipLeft);
parcelHelpers.export(exports, "exitZipRight", ()=>exitZipRight);
parcelHelpers.export(exports, "exitZipPar", ()=>exitZipPar);
parcelHelpers.export(exports, "exitZipParLeft", ()=>exitZipParLeft);
parcelHelpers.export(exports, "exitZipParRight", ()=>exitZipParRight);
parcelHelpers.export(exports, "exitZipWith", ()=>exitZipWith);
parcelHelpers.export(exports, "deferredUnsafeMake", ()=>deferredUnsafeMake);
parcelHelpers.export(exports, "deferredMake", ()=>deferredMake);
parcelHelpers.export(exports, "deferredMakeAs", ()=>deferredMakeAs);
parcelHelpers.export(exports, "deferredAwait", ()=>deferredAwait);
parcelHelpers.export(exports, "deferredComplete", ()=>deferredComplete);
parcelHelpers.export(exports, "deferredCompleteWith", ()=>deferredCompleteWith);
parcelHelpers.export(exports, "deferredDone", ()=>deferredDone);
parcelHelpers.export(exports, "deferredFail", ()=>deferredFail);
parcelHelpers.export(exports, "deferredFailSync", ()=>deferredFailSync);
parcelHelpers.export(exports, "deferredFailCause", ()=>deferredFailCause);
parcelHelpers.export(exports, "deferredFailCauseSync", ()=>deferredFailCauseSync);
parcelHelpers.export(exports, "deferredDie", ()=>deferredDie);
parcelHelpers.export(exports, "deferredDieSync", ()=>deferredDieSync);
parcelHelpers.export(exports, "deferredInterrupt", ()=>deferredInterrupt);
parcelHelpers.export(exports, "deferredInterruptWith", ()=>deferredInterruptWith);
parcelHelpers.export(exports, "deferredIsDone", ()=>deferredIsDone);
parcelHelpers.export(exports, "deferredPoll", ()=>deferredPoll);
parcelHelpers.export(exports, "deferredSucceed", ()=>deferredSucceed);
parcelHelpers.export(exports, "deferredSync", ()=>deferredSync);
parcelHelpers.export(exports, "deferredUnsafeDone", ()=>deferredUnsafeDone);
parcelHelpers.export(exports, "context", ()=>context);
parcelHelpers.export(exports, "contextWith", ()=>contextWith);
parcelHelpers.export(exports, "contextWithEffect", ()=>contextWithEffect);
parcelHelpers.export(exports, "provideContext", ()=>provideContext);
parcelHelpers.export(exports, "provideSomeContext", ()=>provideSomeContext);
parcelHelpers.export(exports, "mapInputContext", ()=>mapInputContext);
parcelHelpers.export(exports, "filterEffectOrElse", ()=>filterEffectOrElse);
parcelHelpers.export(exports, "filterEffectOrFail", ()=>filterEffectOrFail);
parcelHelpers.export(exports, "currentSpanFromFiber", ()=>currentSpanFromFiber);
parcelHelpers.export(exports, "noopSpan", ()=>noopSpan);
var _arrayJs = require("../Array.js");
var _chunkJs = require("../Chunk.js");
var _contextJs = require("../Context.js");
var _durationJs = require("../Duration.js");
var _eitherJs = require("../Either.js");
var _equalJs = require("../Equal.js");
var _fiberIdJs = require("../FiberId.js");
var _functionJs = require("../Function.js");
var _globalValueJs = require("../GlobalValue.js");
var _hashJs = require("../Hash.js");
var _hashMapJs = require("../HashMap.js");
var _inspectableJs = require("../Inspectable.js");
var _listJs = require("../List.js");
var _mutableRefJs = require("../MutableRef.js");
var _optionJs = require("../Option.js");
var _pipeableJs = require("../Pipeable.js");
var _predicateJs = require("../Predicate.js");
var _runtimeFlagsPatchJs = require("../RuntimeFlagsPatch.js");
var _utilsJs = require("../Utils.js");
var _blockedRequestsJs = require("./blockedRequests.js");
var _causeJs = require("./cause.js");
var _deferredJs = require("./deferred.js");
var _differJs = require("./differ.js");
var _effectableJs = require("./effectable.js");
var _errorsJs = require("./errors.js");
var _deferredJs1 = require("./opCodes/deferred.js");
var _effectJs = require("./opCodes/effect.js");
var _runtimeFlagsJs = require("./runtimeFlags.js");
var _singleShotGenJs = require("./singleShotGen.js");
const blocked = (blockedRequests, _continue)=>{
    const effect = new EffectPrimitive("Blocked");
    effect.effect_instruction_i0 = blockedRequests;
    effect.effect_instruction_i1 = _continue;
    return effect;
};
const runRequestBlock = (blockedRequests)=>{
    const effect = new EffectPrimitive("RunBlocked");
    effect.effect_instruction_i0 = blockedRequests;
    return effect;
};
const EffectTypeId = /*#__PURE__*/ Symbol.for("effect/Effect");
class RevertFlags {
    patch;
    op;
    _op = _effectJs.OP_REVERT_FLAGS;
    constructor(patch, op){
        this.patch = patch;
        this.op = op;
    }
}
class EffectPrimitive {
    _op;
    effect_instruction_i0 = undefined;
    effect_instruction_i1 = undefined;
    effect_instruction_i2 = undefined;
    trace = undefined;
    [EffectTypeId] = (0, _effectableJs.effectVariance);
    constructor(_op){
        this._op = _op;
    }
    [_equalJs.symbol](that) {
        return this === that;
    }
    [_hashJs.symbol]() {
        return _hashJs.cached(this, _hashJs.random(this));
    }
    pipe() {
        return (0, _pipeableJs.pipeArguments)(this, arguments);
    }
    toJSON() {
        return {
            _id: "Effect",
            _op: this._op,
            effect_instruction_i0: (0, _inspectableJs.toJSON)(this.effect_instruction_i0),
            effect_instruction_i1: (0, _inspectableJs.toJSON)(this.effect_instruction_i1),
            effect_instruction_i2: (0, _inspectableJs.toJSON)(this.effect_instruction_i2)
        };
    }
    toString() {
        return (0, _inspectableJs.format)(this.toJSON());
    }
    [(0, _inspectableJs.NodeInspectSymbol)]() {
        return this.toJSON();
    }
    [Symbol.iterator]() {
        return new (0, _singleShotGenJs.SingleShotGen)(new (0, _utilsJs.YieldWrap)(this));
    }
}
/** @internal */ class EffectPrimitiveFailure {
    _op;
    effect_instruction_i0 = undefined;
    effect_instruction_i1 = undefined;
    effect_instruction_i2 = undefined;
    trace = undefined;
    [EffectTypeId] = (0, _effectableJs.effectVariance);
    constructor(_op){
        this._op = _op;
        // @ts-expect-error
        this._tag = _op;
    }
    [_equalJs.symbol](that) {
        return exitIsExit(that) && that._op === "Failure" && // @ts-expect-error
        _equalJs.equals(this.effect_instruction_i0, that.effect_instruction_i0);
    }
    [_hashJs.symbol]() {
        return (0, _functionJs.pipe)(// @ts-expect-error
        _hashJs.string(this._tag), // @ts-expect-error
        _hashJs.combine(_hashJs.hash(this.effect_instruction_i0)), _hashJs.cached(this));
    }
    get cause() {
        return this.effect_instruction_i0;
    }
    pipe() {
        return (0, _pipeableJs.pipeArguments)(this, arguments);
    }
    toJSON() {
        return {
            _id: "Exit",
            _tag: this._op,
            cause: this.cause.toJSON()
        };
    }
    toString() {
        return (0, _inspectableJs.format)(this.toJSON());
    }
    [(0, _inspectableJs.NodeInspectSymbol)]() {
        return this.toJSON();
    }
    [Symbol.iterator]() {
        return new (0, _singleShotGenJs.SingleShotGen)(new (0, _utilsJs.YieldWrap)(this));
    }
}
/** @internal */ class EffectPrimitiveSuccess {
    _op;
    effect_instruction_i0 = undefined;
    effect_instruction_i1 = undefined;
    effect_instruction_i2 = undefined;
    trace = undefined;
    [EffectTypeId] = (0, _effectableJs.effectVariance);
    constructor(_op){
        this._op = _op;
        // @ts-expect-error
        this._tag = _op;
    }
    [_equalJs.symbol](that) {
        return exitIsExit(that) && that._op === "Success" && // @ts-expect-error
        _equalJs.equals(this.effect_instruction_i0, that.effect_instruction_i0);
    }
    [_hashJs.symbol]() {
        return (0, _functionJs.pipe)(// @ts-expect-error
        _hashJs.string(this._tag), // @ts-expect-error
        _hashJs.combine(_hashJs.hash(this.effect_instruction_i0)), _hashJs.cached(this));
    }
    get value() {
        return this.effect_instruction_i0;
    }
    pipe() {
        return (0, _pipeableJs.pipeArguments)(this, arguments);
    }
    toJSON() {
        return {
            _id: "Exit",
            _tag: this._op,
            value: (0, _inspectableJs.toJSON)(this.value)
        };
    }
    toString() {
        return (0, _inspectableJs.format)(this.toJSON());
    }
    [(0, _inspectableJs.NodeInspectSymbol)]() {
        return this.toJSON();
    }
    [Symbol.iterator]() {
        return new (0, _singleShotGenJs.SingleShotGen)(new (0, _utilsJs.YieldWrap)(this));
    }
}
const isEffect = (u)=>(0, _predicateJs.hasProperty)(u, EffectTypeId);
const withFiberRuntime = (withRuntime)=>{
    const effect = new EffectPrimitive(_effectJs.OP_WITH_RUNTIME);
    effect.effect_instruction_i0 = withRuntime;
    return effect;
};
const acquireUseRelease = /*#__PURE__*/ (0, _functionJs.dual)(3, (acquire, use, release)=>uninterruptibleMask((restore)=>flatMap(acquire, (a)=>flatMap(exit(suspend(()=>restore(use(a)))), (exit)=>{
                return suspend(()=>release(a, exit)).pipe(matchCauseEffect({
                    onFailure: (cause)=>{
                        switch(exit._tag){
                            case _effectJs.OP_FAILURE:
                                return failCause(_causeJs.sequential(exit.effect_instruction_i0, cause));
                            case _effectJs.OP_SUCCESS:
                                return failCause(cause);
                        }
                    },
                    onSuccess: ()=>exit
                }));
            }))));
const as = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, value)=>flatMap(self, ()=>succeed(value)));
const asVoid = (self)=>as(self, void 0);
const custom = function() {
    const wrapper = new EffectPrimitive(_effectJs.OP_COMMIT);
    switch(arguments.length){
        case 2:
            wrapper.effect_instruction_i0 = arguments[0];
            wrapper.commit = arguments[1];
            break;
        case 3:
            wrapper.effect_instruction_i0 = arguments[0];
            wrapper.effect_instruction_i1 = arguments[1];
            wrapper.commit = arguments[2];
            break;
        case 4:
            wrapper.effect_instruction_i0 = arguments[0];
            wrapper.effect_instruction_i1 = arguments[1];
            wrapper.effect_instruction_i2 = arguments[2];
            wrapper.commit = arguments[3];
            break;
        default:
            throw new Error((0, _errorsJs.getBugErrorMessage)("you're not supposed to end up here"));
    }
    return wrapper;
};
const unsafeAsync = (register, blockingOn = _fiberIdJs.none)=>{
    const effect = new EffectPrimitive(_effectJs.OP_ASYNC);
    let cancelerRef = undefined;
    effect.effect_instruction_i0 = (resume)=>{
        cancelerRef = register(resume);
    };
    effect.effect_instruction_i1 = blockingOn;
    return onInterrupt(effect, (_)=>isEffect(cancelerRef) ? cancelerRef : void_);
};
const asyncInterrupt = (register, blockingOn = _fiberIdJs.none)=>suspend(()=>unsafeAsync(register, blockingOn));
const async_ = (resume, blockingOn = _fiberIdJs.none)=>{
    return custom(resume, function() {
        let backingResume = undefined;
        let pendingEffect = undefined;
        function proxyResume(effect) {
            if (backingResume) backingResume(effect);
            else if (pendingEffect === undefined) pendingEffect = effect;
        }
        const effect = new EffectPrimitive(_effectJs.OP_ASYNC);
        effect.effect_instruction_i0 = (resume)=>{
            backingResume = resume;
            if (pendingEffect) resume(pendingEffect);
        };
        effect.effect_instruction_i1 = blockingOn;
        let cancelerRef = undefined;
        let controllerRef = undefined;
        if (this.effect_instruction_i0.length !== 1) {
            controllerRef = new AbortController();
            cancelerRef = (0, _utilsJs.internalCall)(()=>this.effect_instruction_i0(proxyResume, controllerRef.signal));
        } else cancelerRef = (0, _utilsJs.internalCall)(()=>this.effect_instruction_i0(proxyResume));
        return cancelerRef || controllerRef ? onInterrupt(effect, (_)=>{
            if (controllerRef) controllerRef.abort();
            return cancelerRef ?? void_;
        }) : effect;
    });
};
const catchAllCause = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>{
    const effect = new EffectPrimitive(_effectJs.OP_ON_FAILURE);
    effect.effect_instruction_i0 = self;
    effect.effect_instruction_i1 = f;
    return effect;
});
const catchAll = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>matchEffect(self, {
        onFailure: f,
        onSuccess: succeed
    }));
const catchIf = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, predicate, f)=>catchAllCause(self, (cause)=>{
        const either = _causeJs.failureOrCause(cause);
        switch(either._tag){
            case "Left":
                return predicate(either.left) ? f(either.left) : failCause(cause);
            case "Right":
                return failCause(either.right);
        }
    }));
const catchSome = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, pf)=>catchAllCause(self, (cause)=>{
        const either = _causeJs.failureOrCause(cause);
        switch(either._tag){
            case "Left":
                return (0, _functionJs.pipe)(pf(either.left), _optionJs.getOrElse(()=>failCause(cause)));
            case "Right":
                return failCause(either.right);
        }
    }));
const checkInterruptible = (f)=>withFiberRuntime((_, status)=>f(_runtimeFlagsJs.interruption(status.runtimeFlags)));
const originalSymbol = /*#__PURE__*/ Symbol.for("effect/OriginalAnnotation");
const originalInstance = (obj)=>{
    if ((0, _predicateJs.hasProperty)(obj, originalSymbol)) // @ts-expect-error
    return obj[originalSymbol];
    return obj;
};
const capture = (obj, span)=>{
    if (_optionJs.isSome(span)) return new Proxy(obj, {
        has (target, p) {
            return p === _causeJs.spanSymbol || p === originalSymbol || p in target;
        },
        get (target, p) {
            if (p === _causeJs.spanSymbol) return span.value;
            if (p === originalSymbol) return obj;
            // @ts-expect-error
            return target[p];
        }
    });
    return obj;
};
const die = (defect)=>(0, _predicateJs.isObject)(defect) && !(_causeJs.spanSymbol in defect) ? withFiberRuntime((fiber)=>failCause(_causeJs.die(capture(defect, currentSpanFromFiber(fiber))))) : failCause(_causeJs.die(defect));
const dieMessage = (message)=>failCauseSync(()=>_causeJs.die(new RuntimeException(message)));
const dieSync = (evaluate)=>flatMap(sync(evaluate), die);
const either = (self)=>matchEffect(self, {
        onFailure: (e)=>succeed(_eitherJs.left(e)),
        onSuccess: (a)=>succeed(_eitherJs.right(a))
    });
const exit = (self)=>matchCause(self, {
        onFailure: exitFailCause,
        onSuccess: exitSucceed
    });
const fail = (error)=>(0, _predicateJs.isObject)(error) && !(_causeJs.spanSymbol in error) ? withFiberRuntime((fiber)=>failCause(_causeJs.fail(capture(error, currentSpanFromFiber(fiber))))) : failCause(_causeJs.fail(error));
const failSync = (evaluate)=>flatMap(sync(evaluate), fail);
const failCause = (cause)=>{
    const effect = new EffectPrimitiveFailure(_effectJs.OP_FAILURE);
    effect.effect_instruction_i0 = cause;
    return effect;
};
const failCauseSync = (evaluate)=>flatMap(sync(evaluate), failCause);
const fiberId = /*#__PURE__*/ withFiberRuntime((state)=>succeed(state.id()));
const fiberIdWith = (f)=>withFiberRuntime((state)=>f(state.id()));
const flatMap = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>{
    const effect = new EffectPrimitive(_effectJs.OP_ON_SUCCESS);
    effect.effect_instruction_i0 = self;
    effect.effect_instruction_i1 = f;
    return effect;
});
const andThen = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>flatMap(self, (a)=>{
        const b = typeof f === "function" ? f(a) : f;
        if (isEffect(b)) return b;
        else if ((0, _predicateJs.isPromiseLike)(b)) return unsafeAsync((resume)=>{
            b.then((a)=>resume(succeed(a)), (e)=>resume(fail(new UnknownException(e, "An unknown error occurred in Effect.andThen"))));
        });
        return succeed(b);
    }));
const step = (self)=>{
    const effect = new EffectPrimitive("OnStep");
    effect.effect_instruction_i0 = self;
    return effect;
};
const flatten = (self)=>flatMap(self, (0, _functionJs.identity));
const flip = (self)=>matchEffect(self, {
        onFailure: succeed,
        onSuccess: fail
    });
const matchCause = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, options)=>matchCauseEffect(self, {
        onFailure: (cause)=>succeed(options.onFailure(cause)),
        onSuccess: (a)=>succeed(options.onSuccess(a))
    }));
const matchCauseEffect = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, options)=>{
    const effect = new EffectPrimitive(_effectJs.OP_ON_SUCCESS_AND_FAILURE);
    effect.effect_instruction_i0 = self;
    effect.effect_instruction_i1 = options.onFailure;
    effect.effect_instruction_i2 = options.onSuccess;
    return effect;
});
const matchEffect = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, options)=>matchCauseEffect(self, {
        onFailure: (cause)=>{
            const defects = _causeJs.defects(cause);
            if (defects.length > 0) return failCause(_causeJs.electFailures(cause));
            const failures = _causeJs.failures(cause);
            if (failures.length > 0) return options.onFailure(_chunkJs.unsafeHead(failures));
            return failCause(cause);
        },
        onSuccess: options.onSuccess
    }));
const forEachSequential = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>suspend(()=>{
        const arr = _arrayJs.fromIterable(self);
        const ret = _arrayJs.allocate(arr.length);
        let i = 0;
        return as(whileLoop({
            while: ()=>i < arr.length,
            body: ()=>f(arr[i], i),
            step: (b)=>{
                ret[i++] = b;
            }
        }), ret);
    }));
const forEachSequentialDiscard = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>suspend(()=>{
        const arr = _arrayJs.fromIterable(self);
        let i = 0;
        return whileLoop({
            while: ()=>i < arr.length,
            body: ()=>f(arr[i], i),
            step: ()=>{
                i++;
            }
        });
    }));
const if_ = /*#__PURE__*/ (0, _functionJs.dual)((args)=>typeof args[0] === "boolean" || isEffect(args[0]), (self, options)=>isEffect(self) ? flatMap(self, (b)=>b ? options.onTrue() : options.onFalse()) : self ? options.onTrue() : options.onFalse());
const interrupt = /*#__PURE__*/ flatMap(fiberId, (fiberId)=>interruptWith(fiberId));
const interruptWith = (fiberId)=>failCause(_causeJs.interrupt(fiberId));
const interruptible = (self)=>{
    const effect = new EffectPrimitive(_effectJs.OP_UPDATE_RUNTIME_FLAGS);
    effect.effect_instruction_i0 = _runtimeFlagsPatchJs.enable(_runtimeFlagsJs.Interruption);
    effect.effect_instruction_i1 = ()=>self;
    return effect;
};
const interruptibleMask = (f)=>custom(f, function() {
        const effect = new EffectPrimitive(_effectJs.OP_UPDATE_RUNTIME_FLAGS);
        effect.effect_instruction_i0 = _runtimeFlagsPatchJs.enable(_runtimeFlagsJs.Interruption);
        effect.effect_instruction_i1 = (oldFlags)=>_runtimeFlagsJs.interruption(oldFlags) ? (0, _utilsJs.internalCall)(()=>this.effect_instruction_i0(interruptible)) : (0, _utilsJs.internalCall)(()=>this.effect_instruction_i0(uninterruptible));
        return effect;
    });
const intoDeferred = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, deferred)=>uninterruptibleMask((restore)=>flatMap(exit(restore(self)), (exit)=>deferredDone(deferred, exit))));
const map = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>flatMap(self, (a)=>sync(()=>f(a))));
const mapBoth = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, options)=>matchEffect(self, {
        onFailure: (e)=>failSync(()=>options.onFailure(e)),
        onSuccess: (a)=>sync(()=>options.onSuccess(a))
    }));
const mapError = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>matchCauseEffect(self, {
        onFailure: (cause)=>{
            const either = _causeJs.failureOrCause(cause);
            switch(either._tag){
                case "Left":
                    return failSync(()=>f(either.left));
                case "Right":
                    return failCause(either.right);
            }
        },
        onSuccess: succeed
    }));
const onError = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, cleanup)=>onExit(self, (exit)=>exitIsSuccess(exit) ? void_ : cleanup(exit.effect_instruction_i0)));
const onExit = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, cleanup)=>uninterruptibleMask((restore)=>matchCauseEffect(restore(self), {
            onFailure: (cause1)=>{
                const result = exitFailCause(cause1);
                return matchCauseEffect(cleanup(result), {
                    onFailure: (cause2)=>exitFailCause(_causeJs.sequential(cause1, cause2)),
                    onSuccess: ()=>result
                });
            },
            onSuccess: (success)=>{
                const result = exitSucceed(success);
                return zipRight(cleanup(result), result);
            }
        })));
const onInterrupt = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, cleanup)=>onExit(self, exitMatch({
        onFailure: (cause)=>_causeJs.isInterruptedOnly(cause) ? asVoid(cleanup(_causeJs.interruptors(cause))) : void_,
        onSuccess: ()=>void_
    })));
const orElse = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>attemptOrElse(self, that, succeed));
const orDie = (self)=>orDieWith(self, (0, _functionJs.identity));
const orDieWith = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>matchEffect(self, {
        onFailure: (e)=>die(f(e)),
        onSuccess: succeed
    }));
const partitionMap = _arrayJs.partitionMap;
const runtimeFlags = /*#__PURE__*/ withFiberRuntime((_, status)=>succeed(status.runtimeFlags));
const succeed = (value)=>{
    const effect = new EffectPrimitiveSuccess(_effectJs.OP_SUCCESS);
    effect.effect_instruction_i0 = value;
    return effect;
};
const suspend = (evaluate)=>{
    const effect = new EffectPrimitive(_effectJs.OP_COMMIT);
    effect.commit = evaluate;
    return effect;
};
const sync = (thunk)=>{
    const effect = new EffectPrimitive(_effectJs.OP_SYNC);
    effect.effect_instruction_i0 = thunk;
    return effect;
};
const tap = /*#__PURE__*/ (0, _functionJs.dual)((args)=>args.length === 3 || args.length === 2 && !((0, _predicateJs.isObject)(args[1]) && "onlyEffect" in args[1]), (self, f)=>flatMap(self, (a)=>{
        const b = typeof f === "function" ? f(a) : f;
        if (isEffect(b)) return as(b, a);
        else if ((0, _predicateJs.isPromiseLike)(b)) return unsafeAsync((resume)=>{
            b.then((_)=>resume(succeed(a)), (e)=>resume(fail(new UnknownException(e, "An unknown error occurred in Effect.tap"))));
        });
        return succeed(a);
    }));
const transplant = (f)=>withFiberRuntime((state)=>{
        const scopeOverride = state.getFiberRef(currentForkScopeOverride);
        const scope = (0, _functionJs.pipe)(scopeOverride, _optionJs.getOrElse(()=>state.scope()));
        return f(fiberRefLocally(currentForkScopeOverride, _optionJs.some(scope)));
    });
const attemptOrElse = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, that, onSuccess)=>matchCauseEffect(self, {
        onFailure: (cause)=>{
            const defects = _causeJs.defects(cause);
            if (defects.length > 0) return failCause(_optionJs.getOrThrow(_causeJs.keepDefectsAndElectFailures(cause)));
            return that();
        },
        onSuccess
    }));
const uninterruptible = (self)=>{
    const effect = new EffectPrimitive(_effectJs.OP_UPDATE_RUNTIME_FLAGS);
    effect.effect_instruction_i0 = _runtimeFlagsPatchJs.disable(_runtimeFlagsJs.Interruption);
    effect.effect_instruction_i1 = ()=>self;
    return effect;
};
const uninterruptibleMask = (f)=>custom(f, function() {
        const effect = new EffectPrimitive(_effectJs.OP_UPDATE_RUNTIME_FLAGS);
        effect.effect_instruction_i0 = _runtimeFlagsPatchJs.disable(_runtimeFlagsJs.Interruption);
        effect.effect_instruction_i1 = (oldFlags)=>_runtimeFlagsJs.interruption(oldFlags) ? (0, _utilsJs.internalCall)(()=>this.effect_instruction_i0(interruptible)) : (0, _utilsJs.internalCall)(()=>this.effect_instruction_i0(uninterruptible));
        return effect;
    });
const void_ = /*#__PURE__*/ succeed(void 0);
const updateRuntimeFlags = (patch)=>{
    const effect = new EffectPrimitive(_effectJs.OP_UPDATE_RUNTIME_FLAGS);
    effect.effect_instruction_i0 = patch;
    effect.effect_instruction_i1 = void 0;
    return effect;
};
const whenEffect = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, condition)=>flatMap(condition, (b)=>{
        if (b) return (0, _functionJs.pipe)(self, map(_optionJs.some));
        return succeed(_optionJs.none());
    }));
const whileLoop = (options)=>{
    const effect = new EffectPrimitive(_effectJs.OP_WHILE);
    effect.effect_instruction_i0 = options.while;
    effect.effect_instruction_i1 = options.body;
    effect.effect_instruction_i2 = options.step;
    return effect;
};
const fromIterator = (iterator)=>suspend(()=>{
        const effect = new EffectPrimitive(_effectJs.OP_ITERATOR);
        effect.effect_instruction_i0 = iterator();
        return effect;
    });
const gen = function() {
    const f = arguments.length === 1 ? arguments[0] : arguments[1].bind(arguments[0]);
    return fromIterator(()=>f((0, _functionJs.pipe)));
};
const fnUntraced = (body, ...pipeables)=>Object.defineProperty(pipeables.length === 0 ? function(...args) {
        return fromIterator(()=>body.apply(this, args));
    } : function(...args) {
        let effect = fromIterator(()=>body.apply(this, args));
        for (const x of pipeables)effect = x(effect, ...args);
        return effect;
    }, "length", {
        value: body.length,
        configurable: true
    });
const withConcurrency = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, concurrency)=>fiberRefLocally(self, currentConcurrency, concurrency));
const withRequestBatching = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, requestBatching)=>fiberRefLocally(self, currentRequestBatching, requestBatching));
const withRuntimeFlags = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, update)=>{
    const effect = new EffectPrimitive(_effectJs.OP_UPDATE_RUNTIME_FLAGS);
    effect.effect_instruction_i0 = update;
    effect.effect_instruction_i1 = ()=>self;
    return effect;
});
const withTracerEnabled = /*#__PURE__*/ (0, _functionJs.dual)(2, (effect, enabled)=>fiberRefLocally(effect, currentTracerEnabled, enabled));
const withTracerTiming = /*#__PURE__*/ (0, _functionJs.dual)(2, (effect, enabled)=>fiberRefLocally(effect, currentTracerTimingEnabled, enabled));
const yieldNow = (options)=>{
    const effect = new EffectPrimitive(_effectJs.OP_YIELD);
    return typeof options?.priority !== "undefined" ? withSchedulingPriority(effect, options.priority) : effect;
};
const zip = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>flatMap(self, (a)=>map(that, (b)=>[
                a,
                b
            ])));
const zipFlatten = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>flatMap(self, (a)=>map(that, (b)=>[
                ...a,
                b
            ])));
const zipLeft = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>flatMap(self, (a)=>as(that, a)));
const zipRight = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>flatMap(self, ()=>that));
const zipWith = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, that, f)=>flatMap(self, (a)=>map(that, (b)=>f(a, b))));
const never = /*#__PURE__*/ asyncInterrupt(()=>{
    const interval = setInterval(()=>{
    //
    }, 2 ** 31 - 1);
    return sync(()=>clearInterval(interval));
});
const interruptFiber = (self)=>flatMap(fiberId, (fiberId)=>(0, _functionJs.pipe)(self, interruptAsFiber(fiberId)));
const interruptAsFiber = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, fiberId)=>flatMap(self.interruptAsFork(fiberId), ()=>self.await));
const logLevelAll = {
    _tag: "All",
    syslog: 0,
    label: "ALL",
    ordinal: Number.MIN_SAFE_INTEGER,
    pipe () {
        return (0, _pipeableJs.pipeArguments)(this, arguments);
    }
};
const logLevelFatal = {
    _tag: "Fatal",
    syslog: 2,
    label: "FATAL",
    ordinal: 50000,
    pipe () {
        return (0, _pipeableJs.pipeArguments)(this, arguments);
    }
};
const logLevelError = {
    _tag: "Error",
    syslog: 3,
    label: "ERROR",
    ordinal: 40000,
    pipe () {
        return (0, _pipeableJs.pipeArguments)(this, arguments);
    }
};
const logLevelWarning = {
    _tag: "Warning",
    syslog: 4,
    label: "WARN",
    ordinal: 30000,
    pipe () {
        return (0, _pipeableJs.pipeArguments)(this, arguments);
    }
};
const logLevelInfo = {
    _tag: "Info",
    syslog: 6,
    label: "INFO",
    ordinal: 20000,
    pipe () {
        return (0, _pipeableJs.pipeArguments)(this, arguments);
    }
};
const logLevelDebug = {
    _tag: "Debug",
    syslog: 7,
    label: "DEBUG",
    ordinal: 10000,
    pipe () {
        return (0, _pipeableJs.pipeArguments)(this, arguments);
    }
};
const logLevelTrace = {
    _tag: "Trace",
    syslog: 7,
    label: "TRACE",
    ordinal: 0,
    pipe () {
        return (0, _pipeableJs.pipeArguments)(this, arguments);
    }
};
const logLevelNone = {
    _tag: "None",
    syslog: 7,
    label: "OFF",
    ordinal: Number.MAX_SAFE_INTEGER,
    pipe () {
        return (0, _pipeableJs.pipeArguments)(this, arguments);
    }
};
const allLogLevels = [
    logLevelAll,
    logLevelTrace,
    logLevelDebug,
    logLevelInfo,
    logLevelWarning,
    logLevelError,
    logLevelFatal,
    logLevelNone
];
// -----------------------------------------------------------------------------
// FiberRef
// -----------------------------------------------------------------------------
/** @internal */ const FiberRefSymbolKey = "effect/FiberRef";
const FiberRefTypeId = /*#__PURE__*/ Symbol.for(FiberRefSymbolKey);
const fiberRefVariance = {
    /* c8 ignore next */ _A: (_)=>_
};
const fiberRefGet = (self)=>withFiberRuntime((fiber)=>exitSucceed(fiber.getFiberRef(self)));
const fiberRefGetAndSet = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, value)=>fiberRefModify(self, (v)=>[
            v,
            value
        ]));
const fiberRefGetAndUpdate = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>fiberRefModify(self, (v)=>[
            v,
            f(v)
        ]));
const fiberRefGetAndUpdateSome = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, pf)=>fiberRefModify(self, (v)=>[
            v,
            _optionJs.getOrElse(pf(v), ()=>v)
        ]));
const fiberRefGetWith = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>flatMap(fiberRefGet(self), f));
const fiberRefSet = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, value)=>fiberRefModify(self, ()=>[
            void 0,
            value
        ]));
const fiberRefDelete = (self)=>withFiberRuntime((state)=>{
        state.unsafeDeleteFiberRef(self);
        return void_;
    });
const fiberRefReset = (self)=>fiberRefSet(self, self.initial);
const fiberRefModify = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>withFiberRuntime((state)=>{
        const [b, a] = f(state.getFiberRef(self));
        state.setFiberRef(self, a);
        return succeed(b);
    }));
const fiberRefModifySome = (self, def, f)=>fiberRefModify(self, (v)=>_optionJs.getOrElse(f(v), ()=>[
                def,
                v
            ]));
const fiberRefUpdate = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>fiberRefModify(self, (v)=>[
            void 0,
            f(v)
        ]));
const fiberRefUpdateSome = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, pf)=>fiberRefModify(self, (v)=>[
            void 0,
            _optionJs.getOrElse(pf(v), ()=>v)
        ]));
const fiberRefUpdateAndGet = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>fiberRefModify(self, (v)=>{
        const result = f(v);
        return [
            result,
            result
        ];
    }));
const fiberRefUpdateSomeAndGet = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, pf)=>fiberRefModify(self, (v)=>{
        const result = _optionJs.getOrElse(pf(v), ()=>v);
        return [
            result,
            result
        ];
    }));
// circular
/** @internal */ const RequestResolverSymbolKey = "effect/RequestResolver";
const RequestResolverTypeId = /*#__PURE__*/ Symbol.for(RequestResolverSymbolKey);
const requestResolverVariance = {
    /* c8 ignore next */ _A: (_)=>_,
    /* c8 ignore next */ _R: (_)=>_
};
class RequestResolverImpl {
    runAll;
    target;
    [RequestResolverTypeId] = requestResolverVariance;
    constructor(runAll, target){
        this.runAll = runAll;
        this.target = target;
    }
    [_hashJs.symbol]() {
        return _hashJs.cached(this, this.target ? _hashJs.hash(this.target) : _hashJs.random(this));
    }
    [_equalJs.symbol](that) {
        return this.target ? isRequestResolver(that) && _equalJs.equals(this.target, that.target) : this === that;
    }
    identified(...ids) {
        return new RequestResolverImpl(this.runAll, _chunkJs.fromIterable(ids));
    }
    pipe() {
        return (0, _pipeableJs.pipeArguments)(this, arguments);
    }
}
const isRequestResolver = (u)=>(0, _predicateJs.hasProperty)(u, RequestResolverTypeId);
const resolverLocally = /*#__PURE__*/ (0, _functionJs.dual)(3, (use, self, value)=>new RequestResolverImpl((requests)=>fiberRefLocally(use.runAll(requests), self, value), _chunkJs.make("Locally", use, self, value)));
const requestBlockLocally = (self, ref, value)=>_blockedRequestsJs.reduce(self, LocallyReducer(ref, value));
const LocallyReducer = (ref, value)=>({
        emptyCase: ()=>_blockedRequestsJs.empty,
        parCase: (left, right)=>_blockedRequestsJs.par(left, right),
        seqCase: (left, right)=>_blockedRequestsJs.seq(left, right),
        singleCase: (dataSource, blockedRequest)=>_blockedRequestsJs.single(resolverLocally(dataSource, ref, value), blockedRequest)
    });
const fiberRefLocally = /*#__PURE__*/ (0, _functionJs.dual)(3, (use, self, value)=>acquireUseRelease(zipLeft(fiberRefGet(self), fiberRefSet(self, value)), ()=>use, (oldValue)=>fiberRefSet(self, oldValue)));
const fiberRefLocallyWith = /*#__PURE__*/ (0, _functionJs.dual)(3, (use, self, f)=>fiberRefGetWith(self, (a)=>fiberRefLocally(use, self, f(a))));
const fiberRefUnsafeMake = (initial, options)=>fiberRefUnsafeMakePatch(initial, {
        differ: _differJs.update(),
        fork: options?.fork ?? (0, _functionJs.identity),
        join: options?.join
    });
const fiberRefUnsafeMakeHashSet = (initial)=>{
    const differ = _differJs.hashSet();
    return fiberRefUnsafeMakePatch(initial, {
        differ,
        fork: differ.empty
    });
};
const fiberRefUnsafeMakeReadonlyArray = (initial)=>{
    const differ = _differJs.readonlyArray(_differJs.update());
    return fiberRefUnsafeMakePatch(initial, {
        differ,
        fork: differ.empty
    });
};
const fiberRefUnsafeMakeContext = (initial)=>{
    const differ = _differJs.environment();
    return fiberRefUnsafeMakePatch(initial, {
        differ,
        fork: differ.empty
    });
};
const fiberRefUnsafeMakePatch = (initial, options)=>{
    const _fiberRef = {
        ...(0, _effectableJs.CommitPrototype),
        [FiberRefTypeId]: fiberRefVariance,
        initial,
        commit () {
            return fiberRefGet(this);
        },
        diff: (oldValue, newValue)=>options.differ.diff(oldValue, newValue),
        combine: (first, second)=>options.differ.combine(first, second),
        patch: (patch)=>(oldValue)=>options.differ.patch(patch, oldValue),
        fork: options.fork,
        join: options.join ?? ((_, n)=>n)
    };
    return _fiberRef;
};
const fiberRefUnsafeMakeRuntimeFlags = (initial)=>fiberRefUnsafeMakePatch(initial, {
        differ: _runtimeFlagsJs.differ,
        fork: _runtimeFlagsJs.differ.empty
    });
const currentContext = /*#__PURE__*/ (0, _globalValueJs.globalValue)(/*#__PURE__*/ Symbol.for("effect/FiberRef/currentContext"), ()=>fiberRefUnsafeMakeContext(_contextJs.empty()));
const currentSchedulingPriority = /*#__PURE__*/ (0, _globalValueJs.globalValue)(/*#__PURE__*/ Symbol.for("effect/FiberRef/currentSchedulingPriority"), ()=>fiberRefUnsafeMake(0));
const currentMaxOpsBeforeYield = /*#__PURE__*/ (0, _globalValueJs.globalValue)(/*#__PURE__*/ Symbol.for("effect/FiberRef/currentMaxOpsBeforeYield"), ()=>fiberRefUnsafeMake(2048));
const currentLogAnnotations = /*#__PURE__*/ (0, _globalValueJs.globalValue)(/*#__PURE__*/ Symbol.for("effect/FiberRef/currentLogAnnotation"), ()=>fiberRefUnsafeMake(_hashMapJs.empty()));
const currentLogLevel = /*#__PURE__*/ (0, _globalValueJs.globalValue)(/*#__PURE__*/ Symbol.for("effect/FiberRef/currentLogLevel"), ()=>fiberRefUnsafeMake(logLevelInfo));
const currentLogSpan = /*#__PURE__*/ (0, _globalValueJs.globalValue)(/*#__PURE__*/ Symbol.for("effect/FiberRef/currentLogSpan"), ()=>fiberRefUnsafeMake(_listJs.empty()));
const withSchedulingPriority = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, scheduler)=>fiberRefLocally(self, currentSchedulingPriority, scheduler));
const withMaxOpsBeforeYield = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, scheduler)=>fiberRefLocally(self, currentMaxOpsBeforeYield, scheduler));
const currentConcurrency = /*#__PURE__*/ (0, _globalValueJs.globalValue)(/*#__PURE__*/ Symbol.for("effect/FiberRef/currentConcurrency"), ()=>fiberRefUnsafeMake("unbounded"));
const currentRequestBatching = /*#__PURE__*/ (0, _globalValueJs.globalValue)(/*#__PURE__*/ Symbol.for("effect/FiberRef/currentRequestBatching"), ()=>fiberRefUnsafeMake(true));
const currentUnhandledErrorLogLevel = /*#__PURE__*/ (0, _globalValueJs.globalValue)(/*#__PURE__*/ Symbol.for("effect/FiberRef/currentUnhandledErrorLogLevel"), ()=>fiberRefUnsafeMake(_optionJs.some(logLevelDebug)));
const withUnhandledErrorLogLevel = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, level)=>fiberRefLocally(self, currentUnhandledErrorLogLevel, level));
const currentMetricLabels = /*#__PURE__*/ (0, _globalValueJs.globalValue)(/*#__PURE__*/ Symbol.for("effect/FiberRef/currentMetricLabels"), ()=>fiberRefUnsafeMakeReadonlyArray(_arrayJs.empty()));
const metricLabels = /*#__PURE__*/ fiberRefGet(currentMetricLabels);
const currentForkScopeOverride = /*#__PURE__*/ (0, _globalValueJs.globalValue)(/*#__PURE__*/ Symbol.for("effect/FiberRef/currentForkScopeOverride"), ()=>fiberRefUnsafeMake(_optionJs.none(), {
        fork: ()=>_optionJs.none(),
        join: (parent, _)=>parent
    }));
const currentInterruptedCause = /*#__PURE__*/ (0, _globalValueJs.globalValue)(/*#__PURE__*/ Symbol.for("effect/FiberRef/currentInterruptedCause"), ()=>fiberRefUnsafeMake(_causeJs.empty, {
        fork: ()=>_causeJs.empty,
        join: (parent, _)=>parent
    }));
const currentTracerEnabled = /*#__PURE__*/ (0, _globalValueJs.globalValue)(/*#__PURE__*/ Symbol.for("effect/FiberRef/currentTracerEnabled"), ()=>fiberRefUnsafeMake(true));
const currentTracerTimingEnabled = /*#__PURE__*/ (0, _globalValueJs.globalValue)(/*#__PURE__*/ Symbol.for("effect/FiberRef/currentTracerTiming"), ()=>fiberRefUnsafeMake(true));
const currentTracerSpanAnnotations = /*#__PURE__*/ (0, _globalValueJs.globalValue)(/*#__PURE__*/ Symbol.for("effect/FiberRef/currentTracerSpanAnnotations"), ()=>fiberRefUnsafeMake(_hashMapJs.empty()));
const currentTracerSpanLinks = /*#__PURE__*/ (0, _globalValueJs.globalValue)(/*#__PURE__*/ Symbol.for("effect/FiberRef/currentTracerSpanLinks"), ()=>fiberRefUnsafeMake(_chunkJs.empty()));
const ScopeTypeId = /*#__PURE__*/ Symbol.for("effect/Scope");
const CloseableScopeTypeId = /*#__PURE__*/ Symbol.for("effect/CloseableScope");
const scopeAddFinalizer = (self, finalizer)=>self.addFinalizer(()=>asVoid(finalizer));
const scopeAddFinalizerExit = (self, finalizer)=>self.addFinalizer(finalizer);
const scopeClose = (self, exit)=>self.close(exit);
const scopeFork = (self, strategy)=>self.fork(strategy);
const causeSquash = (self)=>{
    return causeSquashWith((0, _functionJs.identity))(self);
};
const causeSquashWith = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>{
    const option = (0, _functionJs.pipe)(self, _causeJs.failureOption, _optionJs.map(f));
    switch(option._tag){
        case "None":
            return (0, _functionJs.pipe)(_causeJs.defects(self), _chunkJs.head, _optionJs.match({
                onNone: ()=>{
                    const interrupts = _arrayJs.fromIterable(_causeJs.interruptors(self)).flatMap((fiberId)=>_arrayJs.fromIterable(_fiberIdJs.ids(fiberId)).map((id)=>`#${id}`));
                    return new InterruptedException(interrupts ? `Interrupted by fibers: ${interrupts.join(", ")}` : void 0);
                },
                onSome: (0, _functionJs.identity)
            }));
        case "Some":
            return option.value;
    }
});
const YieldableError = /*#__PURE__*/ function() {
    class YieldableError extends globalThis.Error {
        commit() {
            return fail(this);
        }
        toJSON() {
            const obj = {
                ...this
            };
            if (this.message) obj.message = this.message;
            if (this.cause) obj.cause = this.cause;
            return obj;
        }
        [(0, _inspectableJs.NodeInspectSymbol)]() {
            if (this.toString !== globalThis.Error.prototype.toString) return this.stack ? `${this.toString()}\n${this.stack.split("\n").slice(1).join("\n")}` : this.toString();
            else if ("Bun" in globalThis) return _causeJs.pretty(_causeJs.fail(this), {
                renderErrorCause: true
            });
            return this;
        }
    }
    Object.assign(YieldableError.prototype, (0, _effectableJs.StructuralCommitPrototype));
    return YieldableError;
}();
const makeException = (proto, tag)=>{
    class Base extends YieldableError {
        _tag = tag;
    }
    Object.assign(Base.prototype, proto);
    Base.prototype.name = tag;
    return Base;
};
const RuntimeExceptionTypeId = /*#__PURE__*/ Symbol.for("effect/Cause/errors/RuntimeException");
const RuntimeException = /*#__PURE__*/ makeException({
    [RuntimeExceptionTypeId]: RuntimeExceptionTypeId
}, "RuntimeException");
const isRuntimeException = (u)=>(0, _predicateJs.hasProperty)(u, RuntimeExceptionTypeId);
const InterruptedExceptionTypeId = /*#__PURE__*/ Symbol.for("effect/Cause/errors/InterruptedException");
const InterruptedException = /*#__PURE__*/ makeException({
    [InterruptedExceptionTypeId]: InterruptedExceptionTypeId
}, "InterruptedException");
const isInterruptedException = (u)=>(0, _predicateJs.hasProperty)(u, InterruptedExceptionTypeId);
const IllegalArgumentExceptionTypeId = /*#__PURE__*/ Symbol.for("effect/Cause/errors/IllegalArgument");
const IllegalArgumentException = /*#__PURE__*/ makeException({
    [IllegalArgumentExceptionTypeId]: IllegalArgumentExceptionTypeId
}, "IllegalArgumentException");
const isIllegalArgumentException = (u)=>(0, _predicateJs.hasProperty)(u, IllegalArgumentExceptionTypeId);
const NoSuchElementExceptionTypeId = /*#__PURE__*/ Symbol.for("effect/Cause/errors/NoSuchElement");
const NoSuchElementException = /*#__PURE__*/ makeException({
    [NoSuchElementExceptionTypeId]: NoSuchElementExceptionTypeId
}, "NoSuchElementException");
const isNoSuchElementException = (u)=>(0, _predicateJs.hasProperty)(u, NoSuchElementExceptionTypeId);
const InvalidPubSubCapacityExceptionTypeId = /*#__PURE__*/ Symbol.for("effect/Cause/errors/InvalidPubSubCapacityException");
const InvalidPubSubCapacityException = /*#__PURE__*/ makeException({
    [InvalidPubSubCapacityExceptionTypeId]: InvalidPubSubCapacityExceptionTypeId
}, "InvalidPubSubCapacityException");
const ExceededCapacityExceptionTypeId = /*#__PURE__*/ Symbol.for("effect/Cause/errors/ExceededCapacityException");
const ExceededCapacityException = /*#__PURE__*/ makeException({
    [ExceededCapacityExceptionTypeId]: ExceededCapacityExceptionTypeId
}, "ExceededCapacityException");
const isExceededCapacityException = (u)=>(0, _predicateJs.hasProperty)(u, ExceededCapacityExceptionTypeId);
const isInvalidCapacityError = (u)=>(0, _predicateJs.hasProperty)(u, InvalidPubSubCapacityExceptionTypeId);
const TimeoutExceptionTypeId = /*#__PURE__*/ Symbol.for("effect/Cause/errors/Timeout");
const TimeoutException = /*#__PURE__*/ makeException({
    [TimeoutExceptionTypeId]: TimeoutExceptionTypeId
}, "TimeoutException");
const timeoutExceptionFromDuration = (duration)=>new TimeoutException(`Operation timed out after '${_durationJs.format(duration)}'`);
const isTimeoutException = (u)=>(0, _predicateJs.hasProperty)(u, TimeoutExceptionTypeId);
const UnknownExceptionTypeId = /*#__PURE__*/ Symbol.for("effect/Cause/errors/UnknownException");
const UnknownException = /*#__PURE__*/ function() {
    class UnknownException extends YieldableError {
        _tag = "UnknownException";
        error;
        constructor(cause, message){
            super(message ?? "An unknown error occurred", {
                cause
            });
            this.error = cause;
        }
    }
    Object.assign(UnknownException.prototype, {
        [UnknownExceptionTypeId]: UnknownExceptionTypeId,
        name: "UnknownException"
    });
    return UnknownException;
}();
const isUnknownException = (u)=>(0, _predicateJs.hasProperty)(u, UnknownExceptionTypeId);
const exitIsExit = (u)=>isEffect(u) && "_tag" in u && (u._tag === "Success" || u._tag === "Failure");
const exitIsFailure = (self)=>self._tag === "Failure";
const exitIsSuccess = (self)=>self._tag === "Success";
const exitIsInterrupted = (self)=>{
    switch(self._tag){
        case _effectJs.OP_FAILURE:
            return _causeJs.isInterrupted(self.effect_instruction_i0);
        case _effectJs.OP_SUCCESS:
            return false;
    }
};
const exitAs = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, value)=>{
    switch(self._tag){
        case _effectJs.OP_FAILURE:
            return exitFailCause(self.effect_instruction_i0);
        case _effectJs.OP_SUCCESS:
            return exitSucceed(value);
    }
});
const exitAsVoid = (self)=>exitAs(self, void 0);
const exitCauseOption = (self)=>{
    switch(self._tag){
        case _effectJs.OP_FAILURE:
            return _optionJs.some(self.effect_instruction_i0);
        case _effectJs.OP_SUCCESS:
            return _optionJs.none();
    }
};
const exitCollectAll = (exits, options)=>exitCollectAllInternal(exits, options?.parallel ? _causeJs.parallel : _causeJs.sequential);
const exitDie = (defect)=>exitFailCause(_causeJs.die(defect));
const exitExists = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, refinement)=>{
    switch(self._tag){
        case _effectJs.OP_FAILURE:
            return false;
        case _effectJs.OP_SUCCESS:
            return refinement(self.effect_instruction_i0);
    }
});
const exitFail = (error)=>exitFailCause(_causeJs.fail(error));
const exitFailCause = (cause)=>{
    const effect = new EffectPrimitiveFailure(_effectJs.OP_FAILURE);
    effect.effect_instruction_i0 = cause;
    return effect;
};
const exitFlatMap = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>{
    switch(self._tag){
        case _effectJs.OP_FAILURE:
            return exitFailCause(self.effect_instruction_i0);
        case _effectJs.OP_SUCCESS:
            return f(self.effect_instruction_i0);
    }
});
const exitFlatMapEffect = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>{
    switch(self._tag){
        case _effectJs.OP_FAILURE:
            return succeed(exitFailCause(self.effect_instruction_i0));
        case _effectJs.OP_SUCCESS:
            return f(self.effect_instruction_i0);
    }
});
const exitFlatten = (self)=>(0, _functionJs.pipe)(self, exitFlatMap((0, _functionJs.identity)));
const exitForEachEffect = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>{
    switch(self._tag){
        case _effectJs.OP_FAILURE:
            return succeed(exitFailCause(self.effect_instruction_i0));
        case _effectJs.OP_SUCCESS:
            return exit(f(self.effect_instruction_i0));
    }
});
const exitFromEither = (either)=>{
    switch(either._tag){
        case "Left":
            return exitFail(either.left);
        case "Right":
            return exitSucceed(either.right);
    }
};
const exitFromOption = (option)=>{
    switch(option._tag){
        case "None":
            return exitFail(void 0);
        case "Some":
            return exitSucceed(option.value);
    }
};
const exitGetOrElse = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, orElse)=>{
    switch(self._tag){
        case _effectJs.OP_FAILURE:
            return orElse(self.effect_instruction_i0);
        case _effectJs.OP_SUCCESS:
            return self.effect_instruction_i0;
    }
});
const exitInterrupt = (fiberId)=>exitFailCause(_causeJs.interrupt(fiberId));
const exitMap = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>{
    switch(self._tag){
        case _effectJs.OP_FAILURE:
            return exitFailCause(self.effect_instruction_i0);
        case _effectJs.OP_SUCCESS:
            return exitSucceed(f(self.effect_instruction_i0));
    }
});
const exitMapBoth = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, { onFailure, onSuccess })=>{
    switch(self._tag){
        case _effectJs.OP_FAILURE:
            return exitFailCause((0, _functionJs.pipe)(self.effect_instruction_i0, _causeJs.map(onFailure)));
        case _effectJs.OP_SUCCESS:
            return exitSucceed(onSuccess(self.effect_instruction_i0));
    }
});
const exitMapError = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>{
    switch(self._tag){
        case _effectJs.OP_FAILURE:
            return exitFailCause((0, _functionJs.pipe)(self.effect_instruction_i0, _causeJs.map(f)));
        case _effectJs.OP_SUCCESS:
            return exitSucceed(self.effect_instruction_i0);
    }
});
const exitMapErrorCause = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>{
    switch(self._tag){
        case _effectJs.OP_FAILURE:
            return exitFailCause(f(self.effect_instruction_i0));
        case _effectJs.OP_SUCCESS:
            return exitSucceed(self.effect_instruction_i0);
    }
});
const exitMatch = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, { onFailure, onSuccess })=>{
    switch(self._tag){
        case _effectJs.OP_FAILURE:
            return onFailure(self.effect_instruction_i0);
        case _effectJs.OP_SUCCESS:
            return onSuccess(self.effect_instruction_i0);
    }
});
const exitMatchEffect = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, { onFailure, onSuccess })=>{
    switch(self._tag){
        case _effectJs.OP_FAILURE:
            return onFailure(self.effect_instruction_i0);
        case _effectJs.OP_SUCCESS:
            return onSuccess(self.effect_instruction_i0);
    }
});
const exitSucceed = (value)=>{
    const effect = new EffectPrimitiveSuccess(_effectJs.OP_SUCCESS);
    effect.effect_instruction_i0 = value;
    return effect;
};
const exitVoid = /*#__PURE__*/ exitSucceed(void 0);
const exitZip = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>exitZipWith(self, that, {
        onSuccess: (a, a2)=>[
                a,
                a2
            ],
        onFailure: _causeJs.sequential
    }));
const exitZipLeft = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>exitZipWith(self, that, {
        onSuccess: (a, _)=>a,
        onFailure: _causeJs.sequential
    }));
const exitZipRight = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>exitZipWith(self, that, {
        onSuccess: (_, a2)=>a2,
        onFailure: _causeJs.sequential
    }));
const exitZipPar = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>exitZipWith(self, that, {
        onSuccess: (a, a2)=>[
                a,
                a2
            ],
        onFailure: _causeJs.parallel
    }));
const exitZipParLeft = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>exitZipWith(self, that, {
        onSuccess: (a, _)=>a,
        onFailure: _causeJs.parallel
    }));
const exitZipParRight = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>exitZipWith(self, that, {
        onSuccess: (_, a2)=>a2,
        onFailure: _causeJs.parallel
    }));
const exitZipWith = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, that, { onFailure, onSuccess })=>{
    switch(self._tag){
        case _effectJs.OP_FAILURE:
            switch(that._tag){
                case _effectJs.OP_SUCCESS:
                    return exitFailCause(self.effect_instruction_i0);
                case _effectJs.OP_FAILURE:
                    return exitFailCause(onFailure(self.effect_instruction_i0, that.effect_instruction_i0));
            }
        case _effectJs.OP_SUCCESS:
            switch(that._tag){
                case _effectJs.OP_SUCCESS:
                    return exitSucceed(onSuccess(self.effect_instruction_i0, that.effect_instruction_i0));
                case _effectJs.OP_FAILURE:
                    return exitFailCause(that.effect_instruction_i0);
            }
    }
});
const exitCollectAllInternal = (exits, combineCauses)=>{
    const list = _chunkJs.fromIterable(exits);
    if (!_chunkJs.isNonEmpty(list)) return _optionJs.none();
    return (0, _functionJs.pipe)(_chunkJs.tailNonEmpty(list), _arrayJs.reduce((0, _functionJs.pipe)(_chunkJs.headNonEmpty(list), exitMap(_chunkJs.of)), (accumulator, current)=>(0, _functionJs.pipe)(accumulator, exitZipWith(current, {
            onSuccess: (list, value)=>(0, _functionJs.pipe)(list, _chunkJs.prepend(value)),
            onFailure: combineCauses
        }))), exitMap(_chunkJs.reverse), exitMap((chunk)=>_chunkJs.toReadonlyArray(chunk)), _optionJs.some);
};
const deferredUnsafeMake = (fiberId)=>{
    const _deferred = {
        ...(0, _effectableJs.CommitPrototype),
        [_deferredJs.DeferredTypeId]: _deferredJs.deferredVariance,
        state: _mutableRefJs.make(_deferredJs.pending([])),
        commit () {
            return deferredAwait(this);
        },
        blockingOn: fiberId
    };
    return _deferred;
};
const deferredMake = ()=>flatMap(fiberId, (id)=>deferredMakeAs(id));
const deferredMakeAs = (fiberId)=>sync(()=>deferredUnsafeMake(fiberId));
const deferredAwait = (self)=>asyncInterrupt((resume)=>{
        const state = _mutableRefJs.get(self.state);
        switch(state._tag){
            case _deferredJs1.OP_STATE_DONE:
                return resume(state.effect);
            case _deferredJs1.OP_STATE_PENDING:
                // we can push here as the internal state is mutable
                state.joiners.push(resume);
                return deferredInterruptJoiner(self, resume);
        }
    }, self.blockingOn);
const deferredComplete = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, effect)=>intoDeferred(effect, self));
const deferredCompleteWith = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, effect)=>sync(()=>{
        const state = _mutableRefJs.get(self.state);
        switch(state._tag){
            case _deferredJs1.OP_STATE_DONE:
                return false;
            case _deferredJs1.OP_STATE_PENDING:
                _mutableRefJs.set(self.state, _deferredJs.done(effect));
                for(let i = 0, len = state.joiners.length; i < len; i++)state.joiners[i](effect);
                return true;
        }
    }));
const deferredDone = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, exit)=>deferredCompleteWith(self, exit));
const deferredFail = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, error)=>deferredCompleteWith(self, fail(error)));
const deferredFailSync = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, evaluate)=>deferredCompleteWith(self, failSync(evaluate)));
const deferredFailCause = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, cause)=>deferredCompleteWith(self, failCause(cause)));
const deferredFailCauseSync = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, evaluate)=>deferredCompleteWith(self, failCauseSync(evaluate)));
const deferredDie = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, defect)=>deferredCompleteWith(self, die(defect)));
const deferredDieSync = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, evaluate)=>deferredCompleteWith(self, dieSync(evaluate)));
const deferredInterrupt = (self)=>flatMap(fiberId, (fiberId)=>deferredCompleteWith(self, interruptWith(fiberId)));
const deferredInterruptWith = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, fiberId)=>deferredCompleteWith(self, interruptWith(fiberId)));
const deferredIsDone = (self)=>sync(()=>_mutableRefJs.get(self.state)._tag === _deferredJs1.OP_STATE_DONE);
const deferredPoll = (self)=>sync(()=>{
        const state = _mutableRefJs.get(self.state);
        switch(state._tag){
            case _deferredJs1.OP_STATE_DONE:
                return _optionJs.some(state.effect);
            case _deferredJs1.OP_STATE_PENDING:
                return _optionJs.none();
        }
    });
const deferredSucceed = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, value)=>deferredCompleteWith(self, succeed(value)));
const deferredSync = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, evaluate)=>deferredCompleteWith(self, sync(evaluate)));
const deferredUnsafeDone = (self, effect)=>{
    const state = _mutableRefJs.get(self.state);
    if (state._tag === _deferredJs1.OP_STATE_PENDING) {
        _mutableRefJs.set(self.state, _deferredJs.done(effect));
        for(let i = 0, len = state.joiners.length; i < len; i++)state.joiners[i](effect);
    }
};
const deferredInterruptJoiner = (self, joiner)=>sync(()=>{
        const state = _mutableRefJs.get(self.state);
        if (state._tag === _deferredJs1.OP_STATE_PENDING) {
            const index = state.joiners.indexOf(joiner);
            if (index >= 0) // we can splice here as the internal state is mutable
            state.joiners.splice(index, 1);
        }
    });
// -----------------------------------------------------------------------------
// Context
// -----------------------------------------------------------------------------
const constContext = /*#__PURE__*/ withFiberRuntime((fiber)=>exitSucceed(fiber.currentContext));
const context = ()=>constContext;
const contextWith = (f)=>map(context(), f);
const contextWithEffect = (f)=>flatMap(context(), f);
const provideContext = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, context)=>fiberRefLocally(currentContext, context)(self));
const provideSomeContext = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, context)=>fiberRefLocallyWith(currentContext, (parent)=>_contextJs.merge(parent, context))(self));
const mapInputContext = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>contextWithEffect((context)=>provideContext(self, f(context))));
const filterEffectOrElse = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, options)=>flatMap(self, (a)=>flatMap(options.predicate(a), (pass)=>pass ? succeed(a) : options.orElse(a))));
const filterEffectOrFail = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, options)=>filterEffectOrElse(self, {
        predicate: options.predicate,
        orElse: (a)=>fail(options.orFailWith(a))
    }));
const currentSpanFromFiber = (fiber)=>{
    const span = fiber.currentSpan;
    return span !== undefined && span._tag === "Span" ? _optionJs.some(span) : _optionJs.none();
};
const NoopSpanProto = {
    _tag: "Span",
    spanId: "noop",
    traceId: "noop",
    sampled: false,
    status: {
        _tag: "Ended",
        startTime: /*#__PURE__*/ BigInt(0),
        endTime: /*#__PURE__*/ BigInt(0),
        exit: exitVoid
    },
    attributes: /*#__PURE__*/ new Map(),
    links: [],
    kind: "internal",
    attribute () {},
    event () {},
    end () {},
    addLinks () {}
};
const noopSpan = (options)=>Object.assign(Object.create(NoopSpanProto), options);

},{"../Array.js":"8L2Gk","../Chunk.js":"dL1OO","../Context.js":"c2abN","../Duration.js":"czLLe","../Either.js":"4amnT","../Equal.js":"gA0qD","../FiberId.js":"4K4GG","../Function.js":"21gOL","../GlobalValue.js":"5w3Hn","../Hash.js":"gFMwE","../HashMap.js":"aG8zS","../Inspectable.js":"1Ur70","../List.js":"a341T","../MutableRef.js":"aCyaL","../Option.js":"6sHA7","../Pipeable.js":"b5RU2","../Predicate.js":"gW5pd","../RuntimeFlagsPatch.js":"bY5hN","../Utils.js":"dYvz1","./blockedRequests.js":"2UYO5","./cause.js":"l3ev0","./deferred.js":"1Hftc","./differ.js":"jOq6n","./effectable.js":"8EvvU","./errors.js":"2Q5er","./opCodes/deferred.js":"1tDM6","./opCodes/effect.js":"9RoDl","./runtimeFlags.js":"9rFhC","./singleShotGen.js":"3p5I1","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"c2abN":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "GenericTag", ()=>GenericTag);
parcelHelpers.export(exports, "unsafeMake", ()=>unsafeMake);
parcelHelpers.export(exports, "isContext", ()=>isContext);
parcelHelpers.export(exports, "isTag", ()=>isTag);
parcelHelpers.export(exports, "isReference", ()=>isReference);
parcelHelpers.export(exports, "empty", ()=>empty);
parcelHelpers.export(exports, "make", ()=>make);
parcelHelpers.export(exports, "add", ()=>add);
parcelHelpers.export(exports, "get", ()=>get);
parcelHelpers.export(exports, "getOrElse", ()=>getOrElse);
parcelHelpers.export(exports, "unsafeGet", ()=>unsafeGet);
parcelHelpers.export(exports, "getOption", ()=>getOption);
parcelHelpers.export(exports, "merge", ()=>merge);
parcelHelpers.export(exports, "mergeAll", ()=>mergeAll);
parcelHelpers.export(exports, "pick", ()=>pick);
parcelHelpers.export(exports, "omit", ()=>omit);
parcelHelpers.export(exports, "Tag", ()=>Tag);
parcelHelpers.export(exports, "Reference", ()=>Reference);
var _contextJs = require("./internal/context.js");
const TagTypeId = _contextJs.TagTypeId;
const ReferenceTypeId = _contextJs.ReferenceTypeId;
const GenericTag = _contextJs.makeGenericTag;
const TypeId = _contextJs.TypeId;
const unsafeMake = _contextJs.makeContext;
const isContext = _contextJs.isContext;
const isTag = _contextJs.isTag;
const isReference = _contextJs.isReference;
const empty = _contextJs.empty;
const make = _contextJs.make;
const add = _contextJs.add;
const get = _contextJs.get;
const getOrElse = _contextJs.getOrElse;
const unsafeGet = _contextJs.unsafeGet;
const getOption = _contextJs.getOption;
const merge = _contextJs.merge;
const mergeAll = _contextJs.mergeAll;
const pick = _contextJs.pick;
const omit = _contextJs.omit;
const Tag = _contextJs.Tag;
const Reference = _contextJs.Reference;

},{"./internal/context.js":"g5r35","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"g5r35":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TagTypeId", ()=>TagTypeId);
parcelHelpers.export(exports, "ReferenceTypeId", ()=>ReferenceTypeId);
parcelHelpers.export(exports, "STMTypeId", ()=>STMTypeId);
parcelHelpers.export(exports, "TagProto", ()=>TagProto);
parcelHelpers.export(exports, "ReferenceProto", ()=>ReferenceProto);
parcelHelpers.export(exports, "makeGenericTag", ()=>makeGenericTag);
parcelHelpers.export(exports, "Tag", ()=>Tag);
parcelHelpers.export(exports, "Reference", ()=>Reference);
parcelHelpers.export(exports, "TypeId", ()=>TypeId);
parcelHelpers.export(exports, "ContextProto", ()=>ContextProto);
parcelHelpers.export(exports, "makeContext", ()=>makeContext);
parcelHelpers.export(exports, "isContext", ()=>isContext);
parcelHelpers.export(exports, "isTag", ()=>isTag);
parcelHelpers.export(exports, "isReference", ()=>isReference);
parcelHelpers.export(exports, "empty", ()=>empty);
parcelHelpers.export(exports, "make", ()=>make);
parcelHelpers.export(exports, "add", ()=>add);
parcelHelpers.export(exports, "unsafeGetReference", ()=>unsafeGetReference);
parcelHelpers.export(exports, "unsafeGet", ()=>unsafeGet);
parcelHelpers.export(exports, "get", ()=>get);
parcelHelpers.export(exports, "getOrElse", ()=>getOrElse);
parcelHelpers.export(exports, "getOption", ()=>getOption);
parcelHelpers.export(exports, "merge", ()=>merge);
parcelHelpers.export(exports, "mergeAll", ()=>mergeAll);
parcelHelpers.export(exports, "pick", ()=>pick);
parcelHelpers.export(exports, "omit", ()=>omit);
var _equalJs = require("../Equal.js");
var _functionJs = require("../Function.js");
var _globalValueJs = require("../GlobalValue.js");
var _hashJs = require("../Hash.js");
var _inspectableJs = require("../Inspectable.js");
var _pipeableJs = require("../Pipeable.js");
var _predicateJs = require("../Predicate.js");
var _effectableJs = require("./effectable.js");
var _optionJs = require("./option.js");
const TagTypeId = /*#__PURE__*/ Symbol.for("effect/Context/Tag");
const ReferenceTypeId = /*#__PURE__*/ Symbol.for("effect/Context/Reference");
/** @internal */ const STMSymbolKey = "effect/STM";
const STMTypeId = /*#__PURE__*/ Symbol.for(STMSymbolKey);
const TagProto = {
    ...(0, _effectableJs.EffectPrototype),
    _op: "Tag",
    [STMTypeId]: (0, _effectableJs.effectVariance),
    [TagTypeId]: {
        _Service: (_)=>_,
        _Identifier: (_)=>_
    },
    toString () {
        return (0, _inspectableJs.format)(this.toJSON());
    },
    toJSON () {
        return {
            _id: "Tag",
            key: this.key,
            stack: this.stack
        };
    },
    [(0, _inspectableJs.NodeInspectSymbol)] () {
        return this.toJSON();
    },
    of (self) {
        return self;
    },
    context (self) {
        return make(this, self);
    }
};
const ReferenceProto = {
    ...TagProto,
    [ReferenceTypeId]: ReferenceTypeId
};
const makeGenericTag = (key)=>{
    const limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 2;
    const creationError = new Error();
    Error.stackTraceLimit = limit;
    const tag = Object.create(TagProto);
    Object.defineProperty(tag, "stack", {
        get () {
            return creationError.stack;
        }
    });
    tag.key = key;
    return tag;
};
const Tag = (id)=>()=>{
        const limit = Error.stackTraceLimit;
        Error.stackTraceLimit = 2;
        const creationError = new Error();
        Error.stackTraceLimit = limit;
        function TagClass() {}
        Object.setPrototypeOf(TagClass, TagProto);
        TagClass.key = id;
        Object.defineProperty(TagClass, "stack", {
            get () {
                return creationError.stack;
            }
        });
        return TagClass;
    };
const Reference = ()=>(id, options)=>{
        const limit = Error.stackTraceLimit;
        Error.stackTraceLimit = 2;
        const creationError = new Error();
        Error.stackTraceLimit = limit;
        function ReferenceClass() {}
        Object.setPrototypeOf(ReferenceClass, ReferenceProto);
        ReferenceClass.key = id;
        ReferenceClass.defaultValue = options.defaultValue;
        Object.defineProperty(ReferenceClass, "stack", {
            get () {
                return creationError.stack;
            }
        });
        return ReferenceClass;
    };
const TypeId = /*#__PURE__*/ Symbol.for("effect/Context");
const ContextProto = {
    [TypeId]: {
        _Services: (_)=>_
    },
    [_equalJs.symbol] (that) {
        if (isContext(that)) {
            if (this.unsafeMap.size === that.unsafeMap.size) {
                for (const k of this.unsafeMap.keys()){
                    if (!that.unsafeMap.has(k) || !_equalJs.equals(this.unsafeMap.get(k), that.unsafeMap.get(k))) return false;
                }
                return true;
            }
        }
        return false;
    },
    [_hashJs.symbol] () {
        return _hashJs.cached(this, _hashJs.number(this.unsafeMap.size));
    },
    pipe () {
        return (0, _pipeableJs.pipeArguments)(this, arguments);
    },
    toString () {
        return (0, _inspectableJs.format)(this.toJSON());
    },
    toJSON () {
        return {
            _id: "Context",
            services: Array.from(this.unsafeMap).map((0, _inspectableJs.toJSON))
        };
    },
    [(0, _inspectableJs.NodeInspectSymbol)] () {
        return this.toJSON();
    }
};
const makeContext = (unsafeMap)=>{
    const context = Object.create(ContextProto);
    context.unsafeMap = unsafeMap;
    return context;
};
const serviceNotFoundError = (tag)=>{
    const error = new Error(`Service not found${tag.key ? `: ${String(tag.key)}` : ""}`);
    if (tag.stack) {
        const lines = tag.stack.split("\n");
        if (lines.length > 2) {
            const afterAt = lines[2].match(/at (.*)/);
            if (afterAt) error.message = error.message + ` (defined at ${afterAt[1]})`;
        }
    }
    if (error.stack) {
        const lines = error.stack.split("\n");
        lines.splice(1, 3);
        error.stack = lines.join("\n");
    }
    return error;
};
const isContext = (u)=>(0, _predicateJs.hasProperty)(u, TypeId);
const isTag = (u)=>(0, _predicateJs.hasProperty)(u, TagTypeId);
const isReference = (u)=>(0, _predicateJs.hasProperty)(u, ReferenceTypeId);
const _empty = /*#__PURE__*/ makeContext(/*#__PURE__*/ new Map());
const empty = ()=>_empty;
const make = (tag, service)=>makeContext(new Map([
        [
            tag.key,
            service
        ]
    ]));
const add = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, tag, service)=>{
    const map = new Map(self.unsafeMap);
    map.set(tag.key, service);
    return makeContext(map);
});
const defaultValueCache = /*#__PURE__*/ (0, _globalValueJs.globalValue)("effect/Context/defaultValueCache", ()=>new Map());
const getDefaultValue = (tag)=>{
    if (defaultValueCache.has(tag.key)) return defaultValueCache.get(tag.key);
    const value = tag.defaultValue();
    defaultValueCache.set(tag.key, value);
    return value;
};
const unsafeGetReference = (self, tag)=>{
    return self.unsafeMap.has(tag.key) ? self.unsafeMap.get(tag.key) : getDefaultValue(tag);
};
const unsafeGet = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, tag)=>{
    if (!self.unsafeMap.has(tag.key)) {
        if (ReferenceTypeId in tag) return getDefaultValue(tag);
        throw serviceNotFoundError(tag);
    }
    return self.unsafeMap.get(tag.key);
});
const get = unsafeGet;
const getOrElse = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, tag, orElse)=>{
    if (!self.unsafeMap.has(tag.key)) return isReference(tag) ? getDefaultValue(tag) : orElse();
    return self.unsafeMap.get(tag.key);
});
const getOption = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, tag)=>{
    if (!self.unsafeMap.has(tag.key)) return isReference(tag) ? _optionJs.some(getDefaultValue(tag)) : _optionJs.none;
    return _optionJs.some(self.unsafeMap.get(tag.key));
});
const merge = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>{
    const map = new Map(self.unsafeMap);
    for (const [tag, s] of that.unsafeMap)map.set(tag, s);
    return makeContext(map);
});
const mergeAll = (...ctxs)=>{
    const map = new Map();
    for (const ctx of ctxs)for (const [tag, s] of ctx.unsafeMap)map.set(tag, s);
    return makeContext(map);
};
const pick = (...tags)=>(self)=>{
        const tagSet = new Set(tags.map((_)=>_.key));
        const newEnv = new Map();
        for (const [tag, s] of self.unsafeMap.entries())if (tagSet.has(tag)) newEnv.set(tag, s);
        return makeContext(newEnv);
    };
const omit = (...tags)=>(self)=>{
        const newEnv = new Map(self.unsafeMap);
        for (const tag of tags)newEnv.delete(tag.key);
        return makeContext(newEnv);
    };

},{"../Equal.js":"gA0qD","../Function.js":"21gOL","../GlobalValue.js":"5w3Hn","../Hash.js":"gFMwE","../Inspectable.js":"1Ur70","../Pipeable.js":"b5RU2","../Predicate.js":"gW5pd","./effectable.js":"8EvvU","./option.js":"c4fL5","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"czLLe":[function(require,module,exports,__globalThis) {
/**
 * @since 2.0.0
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "decode", ()=>decode);
parcelHelpers.export(exports, "decodeUnknown", ()=>decodeUnknown);
parcelHelpers.export(exports, "isDuration", ()=>isDuration);
parcelHelpers.export(exports, "isFinite", ()=>isFinite);
parcelHelpers.export(exports, "isZero", ()=>isZero);
parcelHelpers.export(exports, "zero", ()=>zero);
parcelHelpers.export(exports, "infinity", ()=>infinity);
parcelHelpers.export(exports, "nanos", ()=>nanos);
parcelHelpers.export(exports, "micros", ()=>micros);
parcelHelpers.export(exports, "millis", ()=>millis);
parcelHelpers.export(exports, "seconds", ()=>seconds);
parcelHelpers.export(exports, "minutes", ()=>minutes);
parcelHelpers.export(exports, "hours", ()=>hours);
parcelHelpers.export(exports, "days", ()=>days);
parcelHelpers.export(exports, "weeks", ()=>weeks);
parcelHelpers.export(exports, "toMillis", ()=>toMillis);
parcelHelpers.export(exports, "toSeconds", ()=>toSeconds);
parcelHelpers.export(exports, "toMinutes", ()=>toMinutes);
parcelHelpers.export(exports, "toHours", ()=>toHours);
parcelHelpers.export(exports, "toDays", ()=>toDays);
parcelHelpers.export(exports, "toWeeks", ()=>toWeeks);
parcelHelpers.export(exports, "toNanos", ()=>toNanos);
parcelHelpers.export(exports, "unsafeToNanos", ()=>unsafeToNanos);
parcelHelpers.export(exports, "toHrTime", ()=>toHrTime);
parcelHelpers.export(exports, "match", ()=>match);
parcelHelpers.export(exports, "matchWith", ()=>matchWith);
parcelHelpers.export(exports, "Order", ()=>Order);
parcelHelpers.export(exports, "between", ()=>between);
parcelHelpers.export(exports, "Equivalence", ()=>Equivalence);
parcelHelpers.export(exports, "min", ()=>min);
parcelHelpers.export(exports, "max", ()=>max);
parcelHelpers.export(exports, "clamp", ()=>clamp);
parcelHelpers.export(exports, "divide", ()=>divide);
parcelHelpers.export(exports, "unsafeDivide", ()=>unsafeDivide);
parcelHelpers.export(exports, "times", ()=>times);
parcelHelpers.export(exports, "subtract", ()=>subtract);
parcelHelpers.export(exports, "sum", ()=>sum);
parcelHelpers.export(exports, "lessThan", ()=>lessThan);
parcelHelpers.export(exports, "lessThanOrEqualTo", ()=>lessThanOrEqualTo);
parcelHelpers.export(exports, "greaterThan", ()=>greaterThan);
parcelHelpers.export(exports, "greaterThanOrEqualTo", ()=>greaterThanOrEqualTo);
parcelHelpers.export(exports, "equals", ()=>equals);
parcelHelpers.export(exports, "parts", ()=>parts);
parcelHelpers.export(exports, "format", ()=>format);
parcelHelpers.export(exports, "unsafeFormatIso", ()=>unsafeFormatIso);
parcelHelpers.export(exports, "formatIso", ()=>formatIso);
parcelHelpers.export(exports, "fromIso", ()=>fromIso);
var _equalJs = require("./Equal.js");
var _functionJs = require("./Function.js");
var _hashJs = require("./Hash.js");
var _inspectableJs = require("./Inspectable.js");
var _optionJs = require("./Option.js");
var _orderJs = require("./Order.js");
var _pipeableJs = require("./Pipeable.js");
var _predicateJs = require("./Predicate.js");
const TypeId = /*#__PURE__*/ Symbol.for("effect/Duration");
const bigint0 = /*#__PURE__*/ BigInt(0);
const bigint24 = /*#__PURE__*/ BigInt(24);
const bigint60 = /*#__PURE__*/ BigInt(60);
const bigint1e3 = /*#__PURE__*/ BigInt(1000);
const bigint1e6 = /*#__PURE__*/ BigInt(1000000);
const bigint1e9 = /*#__PURE__*/ BigInt(1000000000);
const DURATION_REGEX = /^(-?\d+(?:\.\d+)?)\s+(nanos?|micros?|millis?|seconds?|minutes?|hours?|days?|weeks?)$/;
const decode = (input)=>{
    if (isDuration(input)) return input;
    else if ((0, _predicateJs.isNumber)(input)) return millis(input);
    else if ((0, _predicateJs.isBigInt)(input)) return nanos(input);
    else if (Array.isArray(input) && input.length === 2 && input.every((0, _predicateJs.isNumber))) {
        if (input[0] === -Infinity || input[1] === -Infinity || Number.isNaN(input[0]) || Number.isNaN(input[1])) return zero;
        if (input[0] === Infinity || input[1] === Infinity) return infinity;
        return nanos(BigInt(Math.round(input[0] * 1000000000)) + BigInt(Math.round(input[1])));
    } else if ((0, _predicateJs.isString)(input)) {
        const match = DURATION_REGEX.exec(input);
        if (match) {
            const [_, valueStr, unit] = match;
            const value = Number(valueStr);
            switch(unit){
                case "nano":
                case "nanos":
                    return nanos(BigInt(valueStr));
                case "micro":
                case "micros":
                    return micros(BigInt(valueStr));
                case "milli":
                case "millis":
                    return millis(value);
                case "second":
                case "seconds":
                    return seconds(value);
                case "minute":
                case "minutes":
                    return minutes(value);
                case "hour":
                case "hours":
                    return hours(value);
                case "day":
                case "days":
                    return days(value);
                case "week":
                case "weeks":
                    return weeks(value);
            }
        }
    }
    throw new Error("Invalid DurationInput");
};
const decodeUnknown = /*#__PURE__*/ _optionJs.liftThrowable(decode);
const zeroValue = {
    _tag: "Millis",
    millis: 0
};
const infinityValue = {
    _tag: "Infinity"
};
const DurationProto = {
    [TypeId]: TypeId,
    [_hashJs.symbol] () {
        return _hashJs.cached(this, _hashJs.structure(this.value));
    },
    [_equalJs.symbol] (that) {
        return isDuration(that) && equals(this, that);
    },
    toString () {
        return `Duration(${format(this)})`;
    },
    toJSON () {
        switch(this.value._tag){
            case "Millis":
                return {
                    _id: "Duration",
                    _tag: "Millis",
                    millis: this.value.millis
                };
            case "Nanos":
                return {
                    _id: "Duration",
                    _tag: "Nanos",
                    hrtime: toHrTime(this)
                };
            case "Infinity":
                return {
                    _id: "Duration",
                    _tag: "Infinity"
                };
        }
    },
    [(0, _inspectableJs.NodeInspectSymbol)] () {
        return this.toJSON();
    },
    pipe () {
        return (0, _pipeableJs.pipeArguments)(this, arguments);
    }
};
const make = (input)=>{
    const duration = Object.create(DurationProto);
    if ((0, _predicateJs.isNumber)(input)) {
        if (isNaN(input) || input <= 0) duration.value = zeroValue;
        else if (!Number.isFinite(input)) duration.value = infinityValue;
        else if (!Number.isInteger(input)) duration.value = {
            _tag: "Nanos",
            nanos: BigInt(Math.round(input * 1000000))
        };
        else duration.value = {
            _tag: "Millis",
            millis: input
        };
    } else if (input <= bigint0) duration.value = zeroValue;
    else duration.value = {
        _tag: "Nanos",
        nanos: input
    };
    return duration;
};
const isDuration = (u)=>(0, _predicateJs.hasProperty)(u, TypeId);
const isFinite = (self)=>self.value._tag !== "Infinity";
const isZero = (self)=>{
    switch(self.value._tag){
        case "Millis":
            return self.value.millis === 0;
        case "Nanos":
            return self.value.nanos === bigint0;
        case "Infinity":
            return false;
    }
};
const zero = /*#__PURE__*/ make(0);
const infinity = /*#__PURE__*/ make(Infinity);
const nanos = (nanos)=>make(nanos);
const micros = (micros)=>make(micros * bigint1e3);
const millis = (millis)=>make(millis);
const seconds = (seconds)=>make(seconds * 1000);
const minutes = (minutes)=>make(minutes * 60000);
const hours = (hours)=>make(hours * 3600000);
const days = (days)=>make(days * 86400000);
const weeks = (weeks)=>make(weeks * 604800000);
const toMillis = (self)=>match(self, {
        onMillis: (millis)=>millis,
        onNanos: (nanos)=>Number(nanos) / 1000000
    });
const toSeconds = (self)=>match(self, {
        onMillis: (millis)=>millis / 1000,
        onNanos: (nanos)=>Number(nanos) / 1000000000
    });
const toMinutes = (self)=>match(self, {
        onMillis: (millis)=>millis / 60000,
        onNanos: (nanos)=>Number(nanos) / 60000000000
    });
const toHours = (self)=>match(self, {
        onMillis: (millis)=>millis / 3600000,
        onNanos: (nanos)=>Number(nanos) / 3600000000000
    });
const toDays = (self)=>match(self, {
        onMillis: (millis)=>millis / 86400000,
        onNanos: (nanos)=>Number(nanos) / 86400000000000
    });
const toWeeks = (self)=>match(self, {
        onMillis: (millis)=>millis / 604800000,
        onNanos: (nanos)=>Number(nanos) / 604800000000000
    });
const toNanos = (self)=>{
    const _self = decode(self);
    switch(_self.value._tag){
        case "Infinity":
            return _optionJs.none();
        case "Nanos":
            return _optionJs.some(_self.value.nanos);
        case "Millis":
            return _optionJs.some(BigInt(Math.round(_self.value.millis * 1000000)));
    }
};
const unsafeToNanos = (self)=>{
    const _self = decode(self);
    switch(_self.value._tag){
        case "Infinity":
            throw new Error("Cannot convert infinite duration to nanos");
        case "Nanos":
            return _self.value.nanos;
        case "Millis":
            return BigInt(Math.round(_self.value.millis * 1000000));
    }
};
const toHrTime = (self)=>{
    const _self = decode(self);
    switch(_self.value._tag){
        case "Infinity":
            return [
                Infinity,
                0
            ];
        case "Nanos":
            return [
                Number(_self.value.nanos / bigint1e9),
                Number(_self.value.nanos % bigint1e9)
            ];
        case "Millis":
            return [
                Math.floor(_self.value.millis / 1000),
                Math.round(_self.value.millis % 1000 * 1000000)
            ];
    }
};
const match = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, options)=>{
    const _self = decode(self);
    switch(_self.value._tag){
        case "Nanos":
            return options.onNanos(_self.value.nanos);
        case "Infinity":
            return options.onMillis(Infinity);
        case "Millis":
            return options.onMillis(_self.value.millis);
    }
});
const matchWith = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, that, options)=>{
    const _self = decode(self);
    const _that = decode(that);
    if (_self.value._tag === "Infinity" || _that.value._tag === "Infinity") return options.onMillis(toMillis(_self), toMillis(_that));
    else if (_self.value._tag === "Nanos" || _that.value._tag === "Nanos") {
        const selfNanos = _self.value._tag === "Nanos" ? _self.value.nanos : BigInt(Math.round(_self.value.millis * 1000000));
        const thatNanos = _that.value._tag === "Nanos" ? _that.value.nanos : BigInt(Math.round(_that.value.millis * 1000000));
        return options.onNanos(selfNanos, thatNanos);
    }
    return options.onMillis(_self.value.millis, _that.value.millis);
});
const Order = /*#__PURE__*/ _orderJs.make((self, that)=>matchWith(self, that, {
        onMillis: (self, that)=>self < that ? -1 : self > that ? 1 : 0,
        onNanos: (self, that)=>self < that ? -1 : self > that ? 1 : 0
    }));
const between = /*#__PURE__*/ _orderJs.between(/*#__PURE__*/ _orderJs.mapInput(Order, decode));
const Equivalence = (self, that)=>matchWith(self, that, {
        onMillis: (self, that)=>self === that,
        onNanos: (self, that)=>self === that
    });
const _min = /*#__PURE__*/ _orderJs.min(Order);
const min = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>_min(decode(self), decode(that)));
const _max = /*#__PURE__*/ _orderJs.max(Order);
const max = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>_max(decode(self), decode(that)));
const _clamp = /*#__PURE__*/ _orderJs.clamp(Order);
const clamp = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, options)=>_clamp(decode(self), {
        minimum: decode(options.minimum),
        maximum: decode(options.maximum)
    }));
const divide = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, by)=>match(self, {
        onMillis: (millis)=>{
            if (by === 0 || isNaN(by) || !Number.isFinite(by)) return _optionJs.none();
            return _optionJs.some(make(millis / by));
        },
        onNanos: (nanos)=>{
            if (isNaN(by) || by <= 0 || !Number.isFinite(by)) return _optionJs.none();
            try {
                return _optionJs.some(make(nanos / BigInt(by)));
            } catch (e) {
                return _optionJs.none();
            }
        }
    }));
const unsafeDivide = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, by)=>match(self, {
        onMillis: (millis)=>make(millis / by),
        onNanos: (nanos)=>{
            if (isNaN(by) || by < 0 || Object.is(by, -0)) return zero;
            else if (Object.is(by, 0) || !Number.isFinite(by)) return infinity;
            return make(nanos / BigInt(by));
        }
    }));
const times = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, times)=>match(self, {
        onMillis: (millis)=>make(millis * times),
        onNanos: (nanos)=>make(nanos * BigInt(times))
    }));
const subtract = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>matchWith(self, that, {
        onMillis: (self, that)=>make(self - that),
        onNanos: (self, that)=>make(self - that)
    }));
const sum = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>matchWith(self, that, {
        onMillis: (self, that)=>make(self + that),
        onNanos: (self, that)=>make(self + that)
    }));
const lessThan = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>matchWith(self, that, {
        onMillis: (self, that)=>self < that,
        onNanos: (self, that)=>self < that
    }));
const lessThanOrEqualTo = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>matchWith(self, that, {
        onMillis: (self, that)=>self <= that,
        onNanos: (self, that)=>self <= that
    }));
const greaterThan = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>matchWith(self, that, {
        onMillis: (self, that)=>self > that,
        onNanos: (self, that)=>self > that
    }));
const greaterThanOrEqualTo = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>matchWith(self, that, {
        onMillis: (self, that)=>self >= that,
        onNanos: (self, that)=>self >= that
    }));
const equals = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>Equivalence(decode(self), decode(that)));
const parts = (self)=>{
    const duration = decode(self);
    if (duration.value._tag === "Infinity") return {
        days: Infinity,
        hours: Infinity,
        minutes: Infinity,
        seconds: Infinity,
        millis: Infinity,
        nanos: Infinity
    };
    const nanos = unsafeToNanos(duration);
    const ms = nanos / bigint1e6;
    const sec = ms / bigint1e3;
    const min = sec / bigint60;
    const hr = min / bigint60;
    const days = hr / bigint24;
    return {
        days: Number(days),
        hours: Number(hr % bigint24),
        minutes: Number(min % bigint60),
        seconds: Number(sec % bigint60),
        millis: Number(ms % bigint1e3),
        nanos: Number(nanos % bigint1e6)
    };
};
const format = (self)=>{
    const duration = decode(self);
    if (duration.value._tag === "Infinity") return "Infinity";
    if (isZero(duration)) return "0";
    const fragments = parts(duration);
    const pieces = [];
    if (fragments.days !== 0) pieces.push(`${fragments.days}d`);
    if (fragments.hours !== 0) pieces.push(`${fragments.hours}h`);
    if (fragments.minutes !== 0) pieces.push(`${fragments.minutes}m`);
    if (fragments.seconds !== 0) pieces.push(`${fragments.seconds}s`);
    if (fragments.millis !== 0) pieces.push(`${fragments.millis}ms`);
    if (fragments.nanos !== 0) pieces.push(`${fragments.nanos}ns`);
    return pieces.join(" ");
};
const unsafeFormatIso = (self)=>{
    const duration = decode(self);
    if (!isFinite(duration)) throw new RangeError("Cannot format infinite duration");
    const fragments = [];
    const { days, hours, millis, minutes, nanos, seconds } = parts(duration);
    let rest = days;
    if (rest >= 365) {
        const years = Math.floor(rest / 365);
        rest %= 365;
        fragments.push(`${years}Y`);
    }
    if (rest >= 30) {
        const months = Math.floor(rest / 30);
        rest %= 30;
        fragments.push(`${months}M`);
    }
    if (rest >= 7) {
        const weeks = Math.floor(rest / 7);
        rest %= 7;
        fragments.push(`${weeks}W`);
    }
    if (rest > 0) fragments.push(`${rest}D`);
    if (hours !== 0 || minutes !== 0 || seconds !== 0 || millis !== 0 || nanos !== 0) {
        fragments.push("T");
        if (hours !== 0) fragments.push(`${hours}H`);
        if (minutes !== 0) fragments.push(`${minutes}M`);
        if (seconds !== 0 || millis !== 0 || nanos !== 0) {
            const total = BigInt(seconds) * bigint1e9 + BigInt(millis) * bigint1e6 + BigInt(nanos);
            const str = (Number(total) / 1e9).toFixed(9).replace(/\.?0+$/, "");
            fragments.push(`${str}S`);
        }
    }
    return `P${fragments.join("") || "T0S"}`;
};
const formatIso = (self)=>{
    const duration = decode(self);
    return isFinite(duration) ? _optionJs.some(unsafeFormatIso(duration)) : _optionJs.none();
};
const fromIso = (iso)=>{
    const result = DURATION_ISO_REGEX.exec(iso);
    if (result == null) return _optionJs.none();
    const [years, months, weeks, days, hours, mins, secs] = result.slice(1, 8).map((_)=>_ ? Number(_) : 0);
    const value = years * 31536000 + months * 2592000 + weeks * 604800 + days * 86400 + hours * 3600 + mins * 60 + secs;
    return _optionJs.some(seconds(value));
};
const DURATION_ISO_REGEX = /^P(?!$)(?:(\d+)Y)?(?:(\d+)M)?(?:(\d+)W)?(?:(\d+)D)?(?:T(?!$)(?:(\d+)H)?(?:(\d+)M)?(?:(\d+(?:\.\d+)?)S)?)?$/;

},{"./Equal.js":"gA0qD","./Function.js":"21gOL","./Hash.js":"gFMwE","./Inspectable.js":"1Ur70","./Option.js":"6sHA7","./Order.js":"lQMwD","./Pipeable.js":"b5RU2","./Predicate.js":"gW5pd","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"4K4GG":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FiberIdTypeId", ()=>FiberIdTypeId);
parcelHelpers.export(exports, "none", ()=>none);
parcelHelpers.export(exports, "runtime", ()=>runtime);
parcelHelpers.export(exports, "composite", ()=>composite);
parcelHelpers.export(exports, "isFiberId", ()=>isFiberId);
parcelHelpers.export(exports, "isNone", ()=>isNone);
parcelHelpers.export(exports, "isRuntime", ()=>isRuntime);
parcelHelpers.export(exports, "isComposite", ()=>isComposite);
parcelHelpers.export(exports, "combine", ()=>combine);
parcelHelpers.export(exports, "combineAll", ()=>combineAll);
parcelHelpers.export(exports, "getOrElse", ()=>getOrElse);
parcelHelpers.export(exports, "ids", ()=>ids);
parcelHelpers.export(exports, "make", ()=>make);
parcelHelpers.export(exports, "threadName", ()=>threadName);
parcelHelpers.export(exports, "toOption", ()=>toOption);
parcelHelpers.export(exports, "toSet", ()=>toSet);
parcelHelpers.export(exports, "unsafeMake", ()=>unsafeMake);
var _fiberIdJs = require("./internal/fiberId.js");
const FiberIdTypeId = _fiberIdJs.FiberIdTypeId;
const none = _fiberIdJs.none;
const runtime = _fiberIdJs.runtime;
const composite = _fiberIdJs.composite;
const isFiberId = _fiberIdJs.isFiberId;
const isNone = _fiberIdJs.isNone;
const isRuntime = _fiberIdJs.isRuntime;
const isComposite = _fiberIdJs.isComposite;
const combine = _fiberIdJs.combine;
const combineAll = _fiberIdJs.combineAll;
const getOrElse = _fiberIdJs.getOrElse;
const ids = _fiberIdJs.ids;
const make = _fiberIdJs.make;
const threadName = _fiberIdJs.threadName;
const toOption = _fiberIdJs.toOption;
const toSet = _fiberIdJs.toSet;
const unsafeMake = _fiberIdJs.unsafeMake;

},{"./internal/fiberId.js":"azUa1","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"azUa1":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FiberIdTypeId", ()=>FiberIdTypeId);
parcelHelpers.export(exports, "none", ()=>none);
parcelHelpers.export(exports, "runtime", ()=>runtime);
parcelHelpers.export(exports, "composite", ()=>composite);
parcelHelpers.export(exports, "isFiberId", ()=>isFiberId);
parcelHelpers.export(exports, "isNone", ()=>isNone);
parcelHelpers.export(exports, "isRuntime", ()=>isRuntime);
parcelHelpers.export(exports, "isComposite", ()=>isComposite);
parcelHelpers.export(exports, "combine", ()=>combine);
parcelHelpers.export(exports, "combineAll", ()=>combineAll);
parcelHelpers.export(exports, "getOrElse", ()=>getOrElse);
parcelHelpers.export(exports, "ids", ()=>ids);
parcelHelpers.export(exports, "make", ()=>make);
parcelHelpers.export(exports, "threadName", ()=>threadName);
parcelHelpers.export(exports, "toOption", ()=>toOption);
parcelHelpers.export(exports, "toSet", ()=>toSet);
parcelHelpers.export(exports, "unsafeMake", ()=>unsafeMake);
var _equalJs = require("../Equal.js");
var _functionJs = require("../Function.js");
var _globalValueJs = require("../GlobalValue.js");
var _hashJs = require("../Hash.js");
var _hashSetJs = require("../HashSet.js");
var _inspectableJs = require("../Inspectable.js");
var _mutableRefJs = require("../MutableRef.js");
var _optionJs = require("../Option.js");
var _predicateJs = require("../Predicate.js");
/** @internal */ const FiberIdSymbolKey = "effect/FiberId";
const FiberIdTypeId = /*#__PURE__*/ Symbol.for(FiberIdSymbolKey);
/** @internal */ const OP_NONE = "None";
/** @internal */ const OP_RUNTIME = "Runtime";
/** @internal */ const OP_COMPOSITE = "Composite";
const emptyHash = /*#__PURE__*/ _hashJs.string(`${FiberIdSymbolKey}-${OP_NONE}`);
/** @internal */ class None {
    [FiberIdTypeId] = FiberIdTypeId;
    _tag = OP_NONE;
    id = -1;
    startTimeMillis = -1;
    [_hashJs.symbol]() {
        return emptyHash;
    }
    [_equalJs.symbol](that) {
        return isFiberId(that) && that._tag === OP_NONE;
    }
    toString() {
        return (0, _inspectableJs.format)(this.toJSON());
    }
    toJSON() {
        return {
            _id: "FiberId",
            _tag: this._tag
        };
    }
    [(0, _inspectableJs.NodeInspectSymbol)]() {
        return this.toJSON();
    }
}
/** @internal */ class Runtime {
    id;
    startTimeMillis;
    [FiberIdTypeId] = FiberIdTypeId;
    _tag = OP_RUNTIME;
    constructor(id, startTimeMillis){
        this.id = id;
        this.startTimeMillis = startTimeMillis;
    }
    [_hashJs.symbol]() {
        return _hashJs.cached(this, _hashJs.string(`${FiberIdSymbolKey}-${this._tag}-${this.id}-${this.startTimeMillis}`));
    }
    [_equalJs.symbol](that) {
        return isFiberId(that) && that._tag === OP_RUNTIME && this.id === that.id && this.startTimeMillis === that.startTimeMillis;
    }
    toString() {
        return (0, _inspectableJs.format)(this.toJSON());
    }
    toJSON() {
        return {
            _id: "FiberId",
            _tag: this._tag,
            id: this.id,
            startTimeMillis: this.startTimeMillis
        };
    }
    [(0, _inspectableJs.NodeInspectSymbol)]() {
        return this.toJSON();
    }
}
/** @internal */ class Composite {
    left;
    right;
    [FiberIdTypeId] = FiberIdTypeId;
    _tag = OP_COMPOSITE;
    constructor(left, right){
        this.left = left;
        this.right = right;
    }
    _hash;
    [_hashJs.symbol]() {
        return (0, _functionJs.pipe)(_hashJs.string(`${FiberIdSymbolKey}-${this._tag}`), _hashJs.combine(_hashJs.hash(this.left)), _hashJs.combine(_hashJs.hash(this.right)), _hashJs.cached(this));
    }
    [_equalJs.symbol](that) {
        return isFiberId(that) && that._tag === OP_COMPOSITE && _equalJs.equals(this.left, that.left) && _equalJs.equals(this.right, that.right);
    }
    toString() {
        return (0, _inspectableJs.format)(this.toJSON());
    }
    toJSON() {
        return {
            _id: "FiberId",
            _tag: this._tag,
            left: (0, _inspectableJs.toJSON)(this.left),
            right: (0, _inspectableJs.toJSON)(this.right)
        };
    }
    [(0, _inspectableJs.NodeInspectSymbol)]() {
        return this.toJSON();
    }
}
const none = /*#__PURE__*/ new None();
const runtime = (id, startTimeMillis)=>{
    return new Runtime(id, startTimeMillis);
};
const composite = (left, right)=>{
    return new Composite(left, right);
};
const isFiberId = (self)=>(0, _predicateJs.hasProperty)(self, FiberIdTypeId);
const isNone = (self)=>{
    return self._tag === OP_NONE || (0, _functionJs.pipe)(toSet(self), _hashSetJs.every((id)=>isNone(id)));
};
const isRuntime = (self)=>{
    return self._tag === OP_RUNTIME;
};
const isComposite = (self)=>{
    return self._tag === OP_COMPOSITE;
};
const combine = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>{
    if (self._tag === OP_NONE) return that;
    if (that._tag === OP_NONE) return self;
    return new Composite(self, that);
});
const combineAll = (fiberIds)=>{
    return (0, _functionJs.pipe)(fiberIds, _hashSetJs.reduce(none, (a, b)=>combine(b)(a)));
};
const getOrElse = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>isNone(self) ? that : self);
const ids = (self)=>{
    switch(self._tag){
        case OP_NONE:
            return _hashSetJs.empty();
        case OP_RUNTIME:
            return _hashSetJs.make(self.id);
        case OP_COMPOSITE:
            return (0, _functionJs.pipe)(ids(self.left), _hashSetJs.union(ids(self.right)));
    }
};
const _fiberCounter = /*#__PURE__*/ (0, _globalValueJs.globalValue)(/*#__PURE__*/ Symbol.for("effect/Fiber/Id/_fiberCounter"), ()=>_mutableRefJs.make(0));
const make = (id, startTimeSeconds)=>{
    return new Runtime(id, startTimeSeconds);
};
const threadName = (self)=>{
    const identifiers = Array.from(ids(self)).map((n)=>`#${n}`).join(",");
    return identifiers;
};
const toOption = (self)=>{
    const fiberIds = toSet(self);
    if (_hashSetJs.size(fiberIds) === 0) return _optionJs.none();
    let first = true;
    let acc;
    for (const fiberId of fiberIds)if (first) {
        acc = fiberId;
        first = false;
    } else // @ts-expect-error
    acc = (0, _functionJs.pipe)(acc, combine(fiberId));
    // @ts-expect-error
    return _optionJs.some(acc);
};
const toSet = (self)=>{
    switch(self._tag){
        case OP_NONE:
            return _hashSetJs.empty();
        case OP_RUNTIME:
            return _hashSetJs.make(self);
        case OP_COMPOSITE:
            return (0, _functionJs.pipe)(toSet(self.left), _hashSetJs.union(toSet(self.right)));
    }
};
const unsafeMake = ()=>{
    const id = _mutableRefJs.get(_fiberCounter);
    (0, _functionJs.pipe)(_fiberCounter, _mutableRefJs.set(id + 1));
    return new Runtime(id, Date.now());
};

},{"../Equal.js":"gA0qD","../Function.js":"21gOL","../GlobalValue.js":"5w3Hn","../Hash.js":"gFMwE","../HashSet.js":"aKFFV","../Inspectable.js":"1Ur70","../MutableRef.js":"aCyaL","../Option.js":"6sHA7","../Predicate.js":"gW5pd","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"aCyaL":[function(require,module,exports,__globalThis) {
/**
 * @since 2.0.0
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "make", ()=>make);
parcelHelpers.export(exports, "compareAndSet", ()=>compareAndSet);
parcelHelpers.export(exports, "decrement", ()=>decrement);
parcelHelpers.export(exports, "decrementAndGet", ()=>decrementAndGet);
parcelHelpers.export(exports, "get", ()=>get);
parcelHelpers.export(exports, "getAndDecrement", ()=>getAndDecrement);
parcelHelpers.export(exports, "getAndIncrement", ()=>getAndIncrement);
parcelHelpers.export(exports, "getAndSet", ()=>getAndSet);
parcelHelpers.export(exports, "getAndUpdate", ()=>getAndUpdate);
parcelHelpers.export(exports, "increment", ()=>increment);
parcelHelpers.export(exports, "incrementAndGet", ()=>incrementAndGet);
parcelHelpers.export(exports, "set", ()=>set);
parcelHelpers.export(exports, "setAndGet", ()=>setAndGet);
parcelHelpers.export(exports, "update", ()=>update);
parcelHelpers.export(exports, "updateAndGet", ()=>updateAndGet);
parcelHelpers.export(exports, "toggle", ()=>toggle);
var _equalJs = require("./Equal.js");
var _functionJs = require("./Function.js");
var _inspectableJs = require("./Inspectable.js");
var _pipeableJs = require("./Pipeable.js");
const TypeId = /*#__PURE__*/ Symbol.for("effect/MutableRef");
const MutableRefProto = {
    [TypeId]: TypeId,
    toString () {
        return (0, _inspectableJs.format)(this.toJSON());
    },
    toJSON () {
        return {
            _id: "MutableRef",
            current: (0, _inspectableJs.toJSON)(this.current)
        };
    },
    [(0, _inspectableJs.NodeInspectSymbol)] () {
        return this.toJSON();
    },
    pipe () {
        return (0, _pipeableJs.pipeArguments)(this, arguments);
    }
};
const make = (value)=>{
    const ref = Object.create(MutableRefProto);
    ref.current = value;
    return ref;
};
const compareAndSet = /*#__PURE__*/ _functionJs.dual(3, (self, oldValue, newValue)=>{
    if (_equalJs.equals(oldValue, self.current)) {
        self.current = newValue;
        return true;
    }
    return false;
});
const decrement = (self)=>update(self, (n)=>n - 1);
const decrementAndGet = (self)=>updateAndGet(self, (n)=>n - 1);
const get = (self)=>self.current;
const getAndDecrement = (self)=>getAndUpdate(self, (n)=>n - 1);
const getAndIncrement = (self)=>getAndUpdate(self, (n)=>n + 1);
const getAndSet = /*#__PURE__*/ _functionJs.dual(2, (self, value)=>{
    const ret = self.current;
    self.current = value;
    return ret;
});
const getAndUpdate = /*#__PURE__*/ _functionJs.dual(2, (self, f)=>getAndSet(self, f(get(self))));
const increment = (self)=>update(self, (n)=>n + 1);
const incrementAndGet = (self)=>updateAndGet(self, (n)=>n + 1);
const set = /*#__PURE__*/ _functionJs.dual(2, (self, value)=>{
    self.current = value;
    return self;
});
const setAndGet = /*#__PURE__*/ _functionJs.dual(2, (self, value)=>{
    self.current = value;
    return self.current;
});
const update = /*#__PURE__*/ _functionJs.dual(2, (self, f)=>set(self, f(get(self))));
const updateAndGet = /*#__PURE__*/ _functionJs.dual(2, (self, f)=>setAndGet(self, f(get(self))));
const toggle = (self)=>update(self, (_)=>!_);

},{"./Equal.js":"gA0qD","./Function.js":"21gOL","./Inspectable.js":"1Ur70","./Pipeable.js":"b5RU2","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"aG8zS":[function(require,module,exports,__globalThis) {
/**
 * @since 2.0.0
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isHashMap", ()=>isHashMap);
parcelHelpers.export(exports, "empty", ()=>empty);
parcelHelpers.export(exports, "make", ()=>make);
parcelHelpers.export(exports, "fromIterable", ()=>fromIterable);
parcelHelpers.export(exports, "isEmpty", ()=>isEmpty);
parcelHelpers.export(exports, "get", ()=>get);
parcelHelpers.export(exports, "getHash", ()=>getHash);
parcelHelpers.export(exports, "unsafeGet", ()=>unsafeGet);
parcelHelpers.export(exports, "has", ()=>has);
parcelHelpers.export(exports, "hasHash", ()=>hasHash);
parcelHelpers.export(exports, "set", ()=>set);
parcelHelpers.export(exports, "keys", ()=>keys);
parcelHelpers.export(exports, "keySet", ()=>keySet);
parcelHelpers.export(exports, "values", ()=>values);
parcelHelpers.export(exports, "toValues", ()=>toValues);
parcelHelpers.export(exports, "entries", ()=>entries);
parcelHelpers.export(exports, "toEntries", ()=>toEntries);
parcelHelpers.export(exports, "size", ()=>size);
parcelHelpers.export(exports, "beginMutation", ()=>beginMutation);
parcelHelpers.export(exports, "endMutation", ()=>endMutation);
parcelHelpers.export(exports, "mutate", ()=>mutate);
parcelHelpers.export(exports, "modifyAt", ()=>modifyAt);
parcelHelpers.export(exports, "modifyHash", ()=>modifyHash);
parcelHelpers.export(exports, "modify", ()=>modify);
parcelHelpers.export(exports, "union", ()=>union);
parcelHelpers.export(exports, "remove", ()=>remove);
parcelHelpers.export(exports, "removeMany", ()=>removeMany);
parcelHelpers.export(exports, "map", ()=>map);
parcelHelpers.export(exports, "flatMap", ()=>flatMap);
parcelHelpers.export(exports, "forEach", ()=>forEach);
parcelHelpers.export(exports, "reduce", ()=>reduce);
parcelHelpers.export(exports, "filter", ()=>filter);
parcelHelpers.export(exports, "compact", ()=>compact);
parcelHelpers.export(exports, "filterMap", ()=>filterMap);
parcelHelpers.export(exports, "findFirst", ()=>findFirst);
parcelHelpers.export(exports, "some", ()=>some);
parcelHelpers.export(exports, "every", ()=>every);
var _hashMapJs = require("./internal/hashMap.js");
var _keySetJs = require("./internal/hashMap/keySet.js");
const TypeId = _hashMapJs.HashMapTypeId;
const isHashMap = _hashMapJs.isHashMap;
const empty = _hashMapJs.empty;
const make = _hashMapJs.make;
const fromIterable = _hashMapJs.fromIterable;
const isEmpty = _hashMapJs.isEmpty;
const get = _hashMapJs.get;
const getHash = _hashMapJs.getHash;
const unsafeGet = _hashMapJs.unsafeGet;
const has = _hashMapJs.has;
const hasHash = _hashMapJs.hasHash;
const set = _hashMapJs.set;
const keys = _hashMapJs.keys;
const keySet = _keySetJs.keySet;
const values = _hashMapJs.values;
const toValues = (self)=>Array.from(values(self));
const entries = _hashMapJs.entries;
const toEntries = (self)=>Array.from(entries(self));
const size = _hashMapJs.size;
const beginMutation = _hashMapJs.beginMutation;
const endMutation = _hashMapJs.endMutation;
const mutate = _hashMapJs.mutate;
const modifyAt = _hashMapJs.modifyAt;
const modifyHash = _hashMapJs.modifyHash;
const modify = _hashMapJs.modify;
const union = _hashMapJs.union;
const remove = _hashMapJs.remove;
const removeMany = _hashMapJs.removeMany;
const map = _hashMapJs.map;
const flatMap = _hashMapJs.flatMap;
const forEach = _hashMapJs.forEach;
const reduce = _hashMapJs.reduce;
const filter = _hashMapJs.filter;
const compact = _hashMapJs.compact;
const filterMap = _hashMapJs.filterMap;
const findFirst = _hashMapJs.findFirst;
const some = _hashMapJs.some;
const every = _hashMapJs.every;

},{"./internal/hashMap.js":"ckTQ5","./internal/hashMap/keySet.js":"gAWfo","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"gAWfo":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** @internal */ parcelHelpers.export(exports, "keySet", ()=>keySet);
var _hashSetJs = require("../hashSet.js");
function keySet(self) {
    return (0, _hashSetJs.makeImpl)(self);
}

},{"../hashSet.js":"9DZmM","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"a341T":[function(require,module,exports,__globalThis) {
/**
 * A data type for immutable linked lists representing ordered collections of elements of type `A`.
 *
 * This data type is optimal for last-in-first-out (LIFO), stack-like access patterns. If you need another access pattern, for example, random access or FIFO, consider using a collection more suited to this than `List`.
 *
 * **Performance**
 *
 * - Time: `List` has `O(1)` prepend and head/tail access. Most other operations are `O(n)` on the number of elements in the list. This includes the index-based lookup of elements, `length`, `append` and `reverse`.
 * - Space: `List` implements structural sharing of the tail list. This means that many operations are either zero- or constant-memory cost.
 *
 * @since 2.0.0
 */ /**
 * This file is ported from
 *
 * Scala (https://www.scala-lang.org)
 *
 * Copyright EPFL and Lightbend, Inc.
 *
 * Licensed under Apache License 2.0
 * (http://www.apache.org/licenses/LICENSE-2.0).
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TypeId", ()=>TypeId);
parcelHelpers.export(exports, "toArray", ()=>toArray);
parcelHelpers.export(exports, "getEquivalence", ()=>getEquivalence);
parcelHelpers.export(exports, "isList", ()=>isList);
parcelHelpers.export(exports, "isNil", ()=>isNil);
parcelHelpers.export(exports, "isCons", ()=>isCons);
parcelHelpers.export(exports, "size", ()=>size);
parcelHelpers.export(exports, "nil", ()=>nil);
parcelHelpers.export(exports, "cons", ()=>cons);
parcelHelpers.export(exports, "empty", ()=>empty);
parcelHelpers.export(exports, "of", ()=>of);
parcelHelpers.export(exports, "fromIterable", ()=>fromIterable);
parcelHelpers.export(exports, "make", ()=>make);
parcelHelpers.export(exports, "append", ()=>append);
parcelHelpers.export(exports, "appendAll", ()=>appendAll);
parcelHelpers.export(exports, "prepend", ()=>prepend);
parcelHelpers.export(exports, "prependAll", ()=>prependAll);
parcelHelpers.export(exports, "prependAllReversed", ()=>prependAllReversed);
parcelHelpers.export(exports, "drop", ()=>drop);
parcelHelpers.export(exports, "every", ()=>every);
parcelHelpers.export(exports, "some", ()=>some);
parcelHelpers.export(exports, "filter", ()=>filter);
parcelHelpers.export(exports, "filterMap", ()=>filterMap);
parcelHelpers.export(exports, "compact", ()=>compact);
parcelHelpers.export(exports, "findFirst", ()=>findFirst);
parcelHelpers.export(exports, "flatMap", ()=>flatMap);
parcelHelpers.export(exports, "forEach", ()=>forEach);
parcelHelpers.export(exports, "head", ()=>head);
parcelHelpers.export(exports, "last", ()=>last);
parcelHelpers.export(exports, "map", ()=>map);
parcelHelpers.export(exports, "partition", ()=>partition);
parcelHelpers.export(exports, "partitionMap", ()=>partitionMap);
parcelHelpers.export(exports, "reduce", ()=>reduce);
parcelHelpers.export(exports, "reduceRight", ()=>reduceRight);
parcelHelpers.export(exports, "reverse", ()=>reverse);
parcelHelpers.export(exports, "splitAt", ()=>splitAt);
parcelHelpers.export(exports, "tail", ()=>tail);
parcelHelpers.export(exports, "take", ()=>take);
parcelHelpers.export(exports, "toChunk", ()=>toChunk);
parcelHelpers.export(exports, "unsafeHead", ()=>unsafeHead);
parcelHelpers.export(exports, "unsafeLast", ()=>unsafeLast);
parcelHelpers.export(exports, "unsafeTail", ()=>unsafeTail);
var _arrayJs = require("./Array.js");
var _chunkJs = require("./Chunk.js");
var _eitherJs = require("./Either.js");
var _equalJs = require("./Equal.js");
var _equivalenceJs = require("./Equivalence.js");
var _functionJs = require("./Function.js");
var _hashJs = require("./Hash.js");
var _inspectableJs = require("./Inspectable.js");
var _optionJs = require("./Option.js");
var _pipeableJs = require("./Pipeable.js");
var _predicateJs = require("./Predicate.js");
const TypeId = /*#__PURE__*/ Symbol.for("effect/List");
const toArray = (self)=>_arrayJs.fromIterable(self);
const getEquivalence = (isEquivalent)=>_equivalenceJs.mapInput(_arrayJs.getEquivalence(isEquivalent), toArray);
const _equivalence = /*#__PURE__*/ getEquivalence(_equalJs.equals);
const ConsProto = {
    [TypeId]: TypeId,
    _tag: "Cons",
    toString () {
        return (0, _inspectableJs.format)(this.toJSON());
    },
    toJSON () {
        return {
            _id: "List",
            _tag: "Cons",
            values: toArray(this).map((0, _inspectableJs.toJSON))
        };
    },
    [(0, _inspectableJs.NodeInspectSymbol)] () {
        return this.toJSON();
    },
    [_equalJs.symbol] (that) {
        return isList(that) && this._tag === that._tag && _equivalence(this, that);
    },
    [_hashJs.symbol] () {
        return _hashJs.cached(this, _hashJs.array(toArray(this)));
    },
    [Symbol.iterator] () {
        let done = false;
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        let self = this;
        return {
            next () {
                if (done) return this.return();
                if (self._tag === "Nil") {
                    done = true;
                    return this.return();
                }
                const value = self.head;
                self = self.tail;
                return {
                    done,
                    value
                };
            },
            return (value) {
                if (!done) done = true;
                return {
                    done: true,
                    value
                };
            }
        };
    },
    pipe () {
        return (0, _pipeableJs.pipeArguments)(this, arguments);
    }
};
const makeCons = (head, tail)=>{
    const cons = Object.create(ConsProto);
    cons.head = head;
    cons.tail = tail;
    return cons;
};
const NilHash = /*#__PURE__*/ _hashJs.string("Nil");
const NilProto = {
    [TypeId]: TypeId,
    _tag: "Nil",
    toString () {
        return (0, _inspectableJs.format)(this.toJSON());
    },
    toJSON () {
        return {
            _id: "List",
            _tag: "Nil"
        };
    },
    [(0, _inspectableJs.NodeInspectSymbol)] () {
        return this.toJSON();
    },
    [_hashJs.symbol] () {
        return NilHash;
    },
    [_equalJs.symbol] (that) {
        return isList(that) && this._tag === that._tag;
    },
    [Symbol.iterator] () {
        return {
            next () {
                return {
                    done: true,
                    value: undefined
                };
            }
        };
    },
    pipe () {
        return (0, _pipeableJs.pipeArguments)(this, arguments);
    }
};
const _Nil = /*#__PURE__*/ Object.create(NilProto);
const isList = (u)=>(0, _predicateJs.hasProperty)(u, TypeId);
const isNil = (self)=>self._tag === "Nil";
const isCons = (self)=>self._tag === "Cons";
const size = (self)=>{
    let these = self;
    let len = 0;
    while(!isNil(these)){
        len += 1;
        these = these.tail;
    }
    return len;
};
const nil = ()=>_Nil;
const cons = (head, tail)=>makeCons(head, tail);
const empty = nil;
const of = (value)=>makeCons(value, _Nil);
const fromIterable = (prefix)=>{
    const iterator = prefix[Symbol.iterator]();
    let next;
    if ((next = iterator.next()) && !next.done) {
        const result = makeCons(next.value, _Nil);
        let curr = result;
        while((next = iterator.next()) && !next.done){
            const temp = makeCons(next.value, _Nil);
            curr.tail = temp;
            curr = temp;
        }
        return result;
    } else return _Nil;
};
const make = (...elements)=>fromIterable(elements);
const append = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, element)=>appendAll(self, of(element)));
const appendAll = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>prependAll(that, self));
const prepend = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, element)=>cons(element, self));
const prependAll = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, prefix)=>{
    if (isNil(self)) return prefix;
    else if (isNil(prefix)) return self;
    else {
        const result = makeCons(prefix.head, self);
        let curr = result;
        let that = prefix.tail;
        while(!isNil(that)){
            const temp = makeCons(that.head, self);
            curr.tail = temp;
            curr = temp;
            that = that.tail;
        }
        return result;
    }
});
const prependAllReversed = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, prefix)=>{
    let out = self;
    let pres = prefix;
    while(isCons(pres)){
        out = makeCons(pres.head, out);
        pres = pres.tail;
    }
    return out;
});
const drop = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, n)=>{
    if (n <= 0) return self;
    if (n >= size(self)) return _Nil;
    let these = self;
    let i = 0;
    while(!isNil(these) && i < n){
        these = these.tail;
        i += 1;
    }
    return these;
});
const every = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, refinement)=>{
    for (const a of self){
        if (!refinement(a)) return false;
    }
    return true;
});
const some = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, predicate)=>{
    let these = self;
    while(!isNil(these)){
        if (predicate(these.head)) return true;
        these = these.tail;
    }
    return false;
});
const filter = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, predicate)=>noneIn(self, predicate, false));
// everything seen so far is not included
const noneIn = (self, predicate, isFlipped)=>{
    while(true){
        if (isNil(self)) return _Nil;
        else {
            if (predicate(self.head) !== isFlipped) return allIn(self, self.tail, predicate, isFlipped);
            else self = self.tail;
        }
    }
};
// everything from 'start' is included, if everything from this point is in we can return the origin
// start otherwise if we discover an element that is out we must create a new partial list.
const allIn = (start, remaining, predicate, isFlipped)=>{
    while(true){
        if (isNil(remaining)) return start;
        else {
            if (predicate(remaining.head) !== isFlipped) remaining = remaining.tail;
            else return partialFill(start, remaining, predicate, isFlipped);
        }
    }
};
// we have seen elements that should be included then one that should be excluded, start building
const partialFill = (origStart, firstMiss, predicate, isFlipped)=>{
    const newHead = makeCons(unsafeHead(origStart), _Nil);
    let toProcess = unsafeTail(origStart);
    let currentLast = newHead;
    // we know that all elements are :: until at least firstMiss.tail
    while(!(toProcess === firstMiss)){
        const newElem = makeCons(unsafeHead(toProcess), _Nil);
        currentLast.tail = newElem;
        currentLast = (0, _functionJs.unsafeCoerce)(newElem);
        toProcess = (0, _functionJs.unsafeCoerce)(toProcess.tail);
    }
    // at this point newHead points to a list which is a duplicate of all the 'in' elements up to the first miss.
    // currentLast is the last element in that list.
    // now we are going to try and share as much of the tail as we can, only moving elements across when we have to.
    let next = firstMiss.tail;
    let nextToCopy = (0, _functionJs.unsafeCoerce)(next); // the next element we would need to copy to our list if we cant share.
    while(!isNil(next)){
        // generally recommended is next.isNonEmpty but this incurs an extra method call.
        const head = unsafeHead(next);
        if (predicate(head) !== isFlipped) next = next.tail;
        else {
            // its not a match - do we have outstanding elements?
            while(!(nextToCopy === next)){
                const newElem = makeCons(unsafeHead(nextToCopy), _Nil);
                currentLast.tail = newElem;
                currentLast = newElem;
                nextToCopy = (0, _functionJs.unsafeCoerce)(nextToCopy.tail);
            }
            nextToCopy = (0, _functionJs.unsafeCoerce)(next.tail);
            next = next.tail;
        }
    }
    // we have remaining elements - they are unchanged attach them to the end
    if (!isNil(nextToCopy)) currentLast.tail = nextToCopy;
    return newHead;
};
const filterMap = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>{
    const bs = [];
    for (const a of self){
        const oa = f(a);
        if (_optionJs.isSome(oa)) bs.push(oa.value);
    }
    return fromIterable(bs);
});
const compact = (self)=>filterMap(self, (0, _functionJs.identity));
const findFirst = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, predicate)=>{
    let these = self;
    while(!isNil(these)){
        if (predicate(these.head)) return _optionJs.some(these.head);
        these = these.tail;
    }
    return _optionJs.none();
});
const flatMap = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>{
    let rest = self;
    let head = undefined;
    let tail = undefined;
    while(!isNil(rest)){
        let bs = f(rest.head);
        while(!isNil(bs)){
            const next = makeCons(bs.head, _Nil);
            if (tail === undefined) head = next;
            else tail.tail = next;
            tail = next;
            bs = bs.tail;
        }
        rest = rest.tail;
    }
    if (head === undefined) return _Nil;
    return head;
});
const forEach = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>{
    let these = self;
    while(!isNil(these)){
        f(these.head);
        these = these.tail;
    }
});
const head = (self)=>isNil(self) ? _optionJs.none() : _optionJs.some(self.head);
const last = (self)=>isNil(self) ? _optionJs.none() : _optionJs.some(unsafeLast(self));
const map = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>{
    if (isNil(self)) return self;
    else {
        let i = 0;
        const head = makeCons(f(self.head, i++), _Nil);
        let nextHead = head;
        let rest = self.tail;
        while(!isNil(rest)){
            const next = makeCons(f(rest.head, i++), _Nil);
            nextHead.tail = next;
            nextHead = next;
            rest = rest.tail;
        }
        return head;
    }
});
const partition = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, predicate)=>{
    const left = [];
    const right = [];
    for (const a of self)if (predicate(a)) right.push(a);
    else left.push(a);
    return [
        fromIterable(left),
        fromIterable(right)
    ];
});
const partitionMap = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>{
    const left = [];
    const right = [];
    for (const a of self){
        const e = f(a);
        if (_eitherJs.isLeft(e)) left.push(e.left);
        else right.push(e.right);
    }
    return [
        fromIterable(left),
        fromIterable(right)
    ];
});
const reduce = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, zero, f)=>{
    let acc = zero;
    let these = self;
    while(!isNil(these)){
        acc = f(acc, these.head);
        these = these.tail;
    }
    return acc;
});
const reduceRight = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, zero, f)=>{
    let acc = zero;
    let these = reverse(self);
    while(!isNil(these)){
        acc = f(acc, these.head);
        these = these.tail;
    }
    return acc;
});
const reverse = (self)=>{
    let result = empty();
    let these = self;
    while(!isNil(these)){
        result = prepend(result, these.head);
        these = these.tail;
    }
    return result;
};
const splitAt = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, n)=>[
        take(self, n),
        drop(self, n)
    ]);
const tail = (self)=>isNil(self) ? _optionJs.none() : _optionJs.some(self.tail);
const take = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, n)=>{
    if (n <= 0) return _Nil;
    if (n >= size(self)) return self;
    let these = make(unsafeHead(self));
    let current = unsafeTail(self);
    for(let i = 1; i < n; i++){
        these = makeCons(unsafeHead(current), these);
        current = unsafeTail(current);
    }
    return reverse(these);
});
const toChunk = (self)=>_chunkJs.fromIterable(self);
const getExpectedListToBeNonEmptyErrorMessage = "Expected List to be non-empty";
const unsafeHead = (self)=>{
    if (isNil(self)) throw new Error(getExpectedListToBeNonEmptyErrorMessage);
    return self.head;
};
const unsafeLast = (self)=>{
    if (isNil(self)) throw new Error(getExpectedListToBeNonEmptyErrorMessage);
    let these = self;
    let scout = self.tail;
    while(!isNil(scout)){
        these = scout;
        scout = scout.tail;
    }
    return these.head;
};
const unsafeTail = (self)=>{
    if (isNil(self)) throw new Error(getExpectedListToBeNonEmptyErrorMessage);
    return self.tail;
};

},{"./Array.js":"8L2Gk","./Chunk.js":"dL1OO","./Either.js":"4amnT","./Equal.js":"gA0qD","./Equivalence.js":"1WBUa","./Function.js":"21gOL","./Hash.js":"gFMwE","./Inspectable.js":"1Ur70","./Option.js":"6sHA7","./Pipeable.js":"b5RU2","./Predicate.js":"gW5pd","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"bY5hN":[function(require,module,exports,__globalThis) {
/**
 * @since 2.0.0
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "empty", ()=>empty);
parcelHelpers.export(exports, "make", ()=>make);
parcelHelpers.export(exports, "enable", ()=>enable);
parcelHelpers.export(exports, "disable", ()=>disable);
parcelHelpers.export(exports, "isEmpty", ()=>isEmpty);
parcelHelpers.export(exports, "isActive", ()=>isActive);
parcelHelpers.export(exports, "isEnabled", ()=>isEnabled);
parcelHelpers.export(exports, "isDisabled", ()=>isDisabled);
parcelHelpers.export(exports, "includes", ()=>includes);
parcelHelpers.export(exports, "andThen", ()=>andThen);
parcelHelpers.export(exports, "both", ()=>both);
parcelHelpers.export(exports, "either", ()=>either);
parcelHelpers.export(exports, "exclude", ()=>exclude);
parcelHelpers.export(exports, "inverse", ()=>inverse);
parcelHelpers.export(exports, "enabledSet", ()=>enabledSet);
parcelHelpers.export(exports, "disabledSet", ()=>disabledSet);
parcelHelpers.export(exports, "render", ()=>render);
var _runtimeFlagsJs = require("./internal/runtimeFlags.js");
var _runtimeFlagsPatchJs = require("./internal/runtimeFlagsPatch.js");
const empty = _runtimeFlagsPatchJs.empty;
const make = _runtimeFlagsPatchJs.make;
const enable = _runtimeFlagsPatchJs.enable;
const disable = _runtimeFlagsPatchJs.disable;
const isEmpty = _runtimeFlagsPatchJs.isEmpty;
const isActive = _runtimeFlagsPatchJs.isActive;
const isEnabled = _runtimeFlagsPatchJs.isEnabled;
const isDisabled = _runtimeFlagsPatchJs.isDisabled;
const includes = _runtimeFlagsPatchJs.isActive;
const andThen = _runtimeFlagsPatchJs.andThen;
const both = _runtimeFlagsPatchJs.both;
const either = _runtimeFlagsPatchJs.either;
const exclude = _runtimeFlagsPatchJs.exclude;
const inverse = _runtimeFlagsPatchJs.inverse;
const enabledSet = _runtimeFlagsJs.enabledSet;
const disabledSet = _runtimeFlagsJs.disabledSet;
const render = _runtimeFlagsJs.renderPatch;

},{"./internal/runtimeFlags.js":"9rFhC","./internal/runtimeFlagsPatch.js":"4PDkQ","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"9rFhC":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "None", ()=>None);
parcelHelpers.export(exports, "Interruption", ()=>Interruption);
parcelHelpers.export(exports, "OpSupervision", ()=>OpSupervision);
parcelHelpers.export(exports, "RuntimeMetrics", ()=>RuntimeMetrics);
parcelHelpers.export(exports, "WindDown", ()=>WindDown);
parcelHelpers.export(exports, "CooperativeYielding", ()=>CooperativeYielding);
parcelHelpers.export(exports, "allFlags", ()=>allFlags);
parcelHelpers.export(exports, "cooperativeYielding", ()=>cooperativeYielding);
parcelHelpers.export(exports, "disable", ()=>disable);
parcelHelpers.export(exports, "disableAll", ()=>disableAll);
parcelHelpers.export(exports, "enable", ()=>enable);
parcelHelpers.export(exports, "enableAll", ()=>enableAll);
parcelHelpers.export(exports, "interruptible", ()=>interruptible);
parcelHelpers.export(exports, "interruption", ()=>interruption);
parcelHelpers.export(exports, "isDisabled", ()=>isDisabled);
parcelHelpers.export(exports, "isEnabled", ()=>isEnabled);
parcelHelpers.export(exports, "make", ()=>make);
parcelHelpers.export(exports, "none", ()=>none);
parcelHelpers.export(exports, "opSupervision", ()=>opSupervision);
parcelHelpers.export(exports, "render", ()=>render);
parcelHelpers.export(exports, "runtimeMetrics", ()=>runtimeMetrics);
parcelHelpers.export(exports, "toSet", ()=>toSet);
parcelHelpers.export(exports, "windDown", ()=>windDown);
parcelHelpers.export(exports, "enabledSet", ()=>enabledSet);
parcelHelpers.export(exports, "disabledSet", ()=>disabledSet);
parcelHelpers.export(exports, "diff", ()=>diff);
parcelHelpers.export(exports, "patch", ()=>patch);
parcelHelpers.export(exports, "renderPatch", ()=>renderPatch);
parcelHelpers.export(exports, "differ", ()=>differ);
var _functionJs = require("../Function.js");
var _differJs = require("./differ.js");
var _runtimeFlagsPatchJs = require("./runtimeFlagsPatch.js");
const None = 0;
const Interruption = 1;
const OpSupervision = 2;
const RuntimeMetrics = 4;
const WindDown = 16;
const CooperativeYielding = 32;
const allFlags = [
    None,
    Interruption,
    OpSupervision,
    RuntimeMetrics,
    WindDown,
    CooperativeYielding
];
const print = (flag)=>{
    switch(flag){
        case CooperativeYielding:
            return "CooperativeYielding";
        case WindDown:
            return "WindDown";
        case RuntimeMetrics:
            return "RuntimeMetrics";
        case OpSupervision:
            return "OpSupervision";
        case Interruption:
            return "Interruption";
        case None:
            return "None";
    }
};
const cooperativeYielding = (self)=>isEnabled(self, CooperativeYielding);
const disable = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, flag)=>self & ~flag);
const disableAll = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, flags)=>self & ~flags);
const enable = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, flag)=>self | flag);
const enableAll = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, flags)=>self | flags);
const interruptible = (self)=>interruption(self) && !windDown(self);
const interruption = (self)=>isEnabled(self, Interruption);
const isDisabled = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, flag)=>!isEnabled(self, flag));
const isEnabled = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, flag)=>(self & flag) !== 0);
const make = (...flags)=>flags.reduce((a, b)=>a | b, 0);
const none = /*#__PURE__*/ make(None);
const opSupervision = (self)=>isEnabled(self, OpSupervision);
const render = (self)=>{
    const active = [];
    allFlags.forEach((flag)=>{
        if (isEnabled(self, flag)) active.push(`${print(flag)}`);
    });
    return `RuntimeFlags(${active.join(", ")})`;
};
const runtimeMetrics = (self)=>isEnabled(self, RuntimeMetrics);
const toSet = (self)=>new Set(allFlags.filter((flag)=>isEnabled(self, flag)));
const windDown = (self)=>isEnabled(self, WindDown);
const enabledSet = (self)=>toSet(_runtimeFlagsPatchJs.active(self) & _runtimeFlagsPatchJs.enabled(self));
const disabledSet = (self)=>toSet(_runtimeFlagsPatchJs.active(self) & ~_runtimeFlagsPatchJs.enabled(self));
const diff = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>_runtimeFlagsPatchJs.make(self ^ that, that));
const patch = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, patch)=>self & (_runtimeFlagsPatchJs.invert(_runtimeFlagsPatchJs.active(patch)) | _runtimeFlagsPatchJs.enabled(patch)) | _runtimeFlagsPatchJs.active(patch) & _runtimeFlagsPatchJs.enabled(patch));
const renderPatch = (self)=>{
    const enabled = Array.from(enabledSet(self)).map((flag)=>print(flag)).join(", ");
    const disabled = Array.from(disabledSet(self)).map((flag)=>print(flag)).join(", ");
    return `RuntimeFlagsPatch(enabled = (${enabled}), disabled = (${disabled}))`;
};
const differ = /*#__PURE__*/ _differJs.make({
    empty: _runtimeFlagsPatchJs.empty,
    diff: (oldValue, newValue)=>diff(oldValue, newValue),
    combine: (first, second)=>_runtimeFlagsPatchJs.andThen(second)(first),
    patch: (_patch, oldValue)=>patch(oldValue, _patch)
});

},{"../Function.js":"21gOL","./differ.js":"jOq6n","./runtimeFlagsPatch.js":"4PDkQ","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"jOq6n":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DifferTypeId", ()=>DifferTypeId);
parcelHelpers.export(exports, "DifferProto", ()=>DifferProto);
parcelHelpers.export(exports, "make", ()=>make);
parcelHelpers.export(exports, "environment", ()=>environment);
parcelHelpers.export(exports, "chunk", ()=>chunk);
parcelHelpers.export(exports, "hashMap", ()=>hashMap);
parcelHelpers.export(exports, "hashSet", ()=>hashSet);
parcelHelpers.export(exports, "orElseEither", ()=>orElseEither);
parcelHelpers.export(exports, "readonlyArray", ()=>readonlyArray);
parcelHelpers.export(exports, "transform", ()=>transform);
parcelHelpers.export(exports, "update", ()=>update);
parcelHelpers.export(exports, "updateWith", ()=>updateWith);
parcelHelpers.export(exports, "zip", ()=>zip);
var _equalJs = require("../Equal.js");
var _functionJs = require("../Function.js");
var _pipeableJs = require("../Pipeable.js");
var _chunkPatchJs = require("./differ/chunkPatch.js");
var _contextPatchJs = require("./differ/contextPatch.js");
var _hashMapPatchJs = require("./differ/hashMapPatch.js");
var _hashSetPatchJs = require("./differ/hashSetPatch.js");
var _orPatchJs = require("./differ/orPatch.js");
var _readonlyArrayPatchJs = require("./differ/readonlyArrayPatch.js");
const DifferTypeId = /*#__PURE__*/ Symbol.for("effect/Differ");
const DifferProto = {
    [DifferTypeId]: {
        _P: (0, _functionJs.identity),
        _V: (0, _functionJs.identity)
    },
    pipe () {
        return (0, _pipeableJs.pipeArguments)(this, arguments);
    }
};
const make = (params)=>{
    const differ = Object.create(DifferProto);
    differ.empty = params.empty;
    differ.diff = params.diff;
    differ.combine = params.combine;
    differ.patch = params.patch;
    return differ;
};
const environment = ()=>make({
        empty: _contextPatchJs.empty(),
        combine: (first, second)=>_contextPatchJs.combine(second)(first),
        diff: (oldValue, newValue)=>_contextPatchJs.diff(oldValue, newValue),
        patch: (patch, oldValue)=>_contextPatchJs.patch(oldValue)(patch)
    });
const chunk = (differ)=>make({
        empty: _chunkPatchJs.empty(),
        combine: (first, second)=>_chunkPatchJs.combine(second)(first),
        diff: (oldValue, newValue)=>_chunkPatchJs.diff({
                oldValue,
                newValue,
                differ
            }),
        patch: (patch, oldValue)=>_chunkPatchJs.patch(oldValue, differ)(patch)
    });
const hashMap = (differ)=>make({
        empty: _hashMapPatchJs.empty(),
        combine: (first, second)=>_hashMapPatchJs.combine(second)(first),
        diff: (oldValue, newValue)=>_hashMapPatchJs.diff({
                oldValue,
                newValue,
                differ
            }),
        patch: (patch, oldValue)=>_hashMapPatchJs.patch(oldValue, differ)(patch)
    });
const hashSet = ()=>make({
        empty: _hashSetPatchJs.empty(),
        combine: (first, second)=>_hashSetPatchJs.combine(second)(first),
        diff: (oldValue, newValue)=>_hashSetPatchJs.diff(oldValue, newValue),
        patch: (patch, oldValue)=>_hashSetPatchJs.patch(oldValue)(patch)
    });
const orElseEither = /*#__PURE__*/ _functionJs.dual(2, (self, that)=>make({
        empty: _orPatchJs.empty(),
        combine: (first, second)=>_orPatchJs.combine(first, second),
        diff: (oldValue, newValue)=>_orPatchJs.diff({
                oldValue,
                newValue,
                left: self,
                right: that
            }),
        patch: (patch, oldValue)=>_orPatchJs.patch(patch, {
                oldValue,
                left: self,
                right: that
            })
    }));
const readonlyArray = (differ)=>make({
        empty: _readonlyArrayPatchJs.empty(),
        combine: (first, second)=>_readonlyArrayPatchJs.combine(first, second),
        diff: (oldValue, newValue)=>_readonlyArrayPatchJs.diff({
                oldValue,
                newValue,
                differ
            }),
        patch: (patch, oldValue)=>_readonlyArrayPatchJs.patch(patch, oldValue, differ)
    });
const transform = /*#__PURE__*/ _functionJs.dual(2, (self, { toNew, toOld })=>make({
        empty: self.empty,
        combine: (first, second)=>self.combine(first, second),
        diff: (oldValue, newValue)=>self.diff(toOld(oldValue), toOld(newValue)),
        patch: (patch, oldValue)=>toNew(self.patch(patch, toOld(oldValue)))
    }));
const update = ()=>updateWith((_, a)=>a);
const updateWith = (f)=>make({
        empty: (0, _functionJs.identity),
        combine: (first, second)=>{
            if (first === (0, _functionJs.identity)) return second;
            if (second === (0, _functionJs.identity)) return first;
            return (a)=>second(first(a));
        },
        diff: (oldValue, newValue)=>{
            if (_equalJs.equals(oldValue, newValue)) return 0, _functionJs.identity;
            return (0, _functionJs.constant)(newValue);
        },
        patch: (patch, oldValue)=>f(oldValue, patch(oldValue))
    });
const zip = /*#__PURE__*/ _functionJs.dual(2, (self, that)=>make({
        empty: [
            self.empty,
            that.empty
        ],
        combine: (first, second)=>[
                self.combine(first[0], second[0]),
                that.combine(first[1], second[1])
            ],
        diff: (oldValue, newValue)=>[
                self.diff(oldValue[0], newValue[0]),
                that.diff(oldValue[1], newValue[1])
            ],
        patch: (patch, oldValue)=>[
                self.patch(patch[0], oldValue[0]),
                that.patch(patch[1], oldValue[1])
            ]
    }));

},{"../Equal.js":"gA0qD","../Function.js":"21gOL","../Pipeable.js":"b5RU2","./differ/chunkPatch.js":"gqpP3","./differ/contextPatch.js":"dOZM5","./differ/hashMapPatch.js":"guP0Y","./differ/hashSetPatch.js":"1i5Zt","./differ/orPatch.js":"RGDmm","./differ/readonlyArrayPatch.js":"uaIJN","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"gqpP3":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ChunkPatchTypeId", ()=>ChunkPatchTypeId);
parcelHelpers.export(exports, "empty", ()=>empty);
parcelHelpers.export(exports, "diff", ()=>diff);
parcelHelpers.export(exports, "combine", ()=>combine);
parcelHelpers.export(exports, "patch", ()=>patch);
var _chunkJs = require("../../Chunk.js");
var _equalJs = require("../../Equal.js");
var _functionJs = require("../../Function.js");
var _dataJs = require("../data.js");
const ChunkPatchTypeId = /*#__PURE__*/ Symbol.for("effect/DifferChunkPatch");
function variance(a) {
    return a;
}
const PatchProto = {
    ..._dataJs.Structural.prototype,
    [ChunkPatchTypeId]: {
        _Value: variance,
        _Patch: variance
    }
};
const EmptyProto = /*#__PURE__*/ Object.assign(/*#__PURE__*/ Object.create(PatchProto), {
    _tag: "Empty"
});
const _empty = /*#__PURE__*/ Object.create(EmptyProto);
const empty = ()=>_empty;
const AndThenProto = /*#__PURE__*/ Object.assign(/*#__PURE__*/ Object.create(PatchProto), {
    _tag: "AndThen"
});
const makeAndThen = (first, second)=>{
    const o = Object.create(AndThenProto);
    o.first = first;
    o.second = second;
    return o;
};
const AppendProto = /*#__PURE__*/ Object.assign(/*#__PURE__*/ Object.create(PatchProto), {
    _tag: "Append"
});
const makeAppend = (values)=>{
    const o = Object.create(AppendProto);
    o.values = values;
    return o;
};
const SliceProto = /*#__PURE__*/ Object.assign(/*#__PURE__*/ Object.create(PatchProto), {
    _tag: "Slice"
});
const makeSlice = (from, until)=>{
    const o = Object.create(SliceProto);
    o.from = from;
    o.until = until;
    return o;
};
const UpdateProto = /*#__PURE__*/ Object.assign(/*#__PURE__*/ Object.create(PatchProto), {
    _tag: "Update"
});
const makeUpdate = (index, patch)=>{
    const o = Object.create(UpdateProto);
    o.index = index;
    o.patch = patch;
    return o;
};
const diff = (options)=>{
    let i = 0;
    let patch = empty();
    while(i < options.oldValue.length && i < options.newValue.length){
        const oldElement = _chunkJs.unsafeGet(i)(options.oldValue);
        const newElement = _chunkJs.unsafeGet(i)(options.newValue);
        const valuePatch = options.differ.diff(oldElement, newElement);
        if (!_equalJs.equals(valuePatch, options.differ.empty)) patch = (0, _functionJs.pipe)(patch, combine(makeUpdate(i, valuePatch)));
        i = i + 1;
    }
    if (i < options.oldValue.length) patch = (0, _functionJs.pipe)(patch, combine(makeSlice(0, i)));
    if (i < options.newValue.length) patch = (0, _functionJs.pipe)(patch, combine(makeAppend(_chunkJs.drop(i)(options.newValue))));
    return patch;
};
const combine = /*#__PURE__*/ _functionJs.dual(2, (self, that)=>makeAndThen(self, that));
const patch = /*#__PURE__*/ _functionJs.dual(3, (self, oldValue, differ)=>{
    if (self._tag === "Empty") return oldValue;
    let chunk = oldValue;
    let patches = _chunkJs.of(self);
    while(_chunkJs.isNonEmpty(patches)){
        const head = _chunkJs.headNonEmpty(patches);
        const tail = _chunkJs.tailNonEmpty(patches);
        switch(head._tag){
            case "Empty":
                patches = tail;
                break;
            case "AndThen":
                patches = _chunkJs.prepend(head.first)(_chunkJs.prepend(head.second)(tail));
                break;
            case "Append":
                chunk = _chunkJs.appendAll(head.values)(chunk);
                patches = tail;
                break;
            case "Slice":
                {
                    const array = _chunkJs.toReadonlyArray(chunk);
                    chunk = _chunkJs.unsafeFromArray(array.slice(head.from, head.until));
                    patches = tail;
                    break;
                }
            case "Update":
                {
                    const array = _chunkJs.toReadonlyArray(chunk);
                    array[head.index] = differ.patch(head.patch, array[head.index]);
                    chunk = _chunkJs.unsafeFromArray(array);
                    patches = tail;
                    break;
                }
        }
    }
    return chunk;
});

},{"../../Chunk.js":"dL1OO","../../Equal.js":"gA0qD","../../Function.js":"21gOL","../data.js":"fk0Pw","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"fk0Pw":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ArrayProto", ()=>ArrayProto);
parcelHelpers.export(exports, "Structural", ()=>Structural);
parcelHelpers.export(exports, "struct", ()=>struct);
var _equalJs = require("../Equal.js");
var _hashJs = require("../Hash.js");
var _effectableJs = require("./effectable.js");
const ArrayProto = /*#__PURE__*/ Object.assign(/*#__PURE__*/ Object.create(Array.prototype), {
    [_hashJs.symbol] () {
        return _hashJs.cached(this, _hashJs.array(this));
    },
    [_equalJs.symbol] (that) {
        if (Array.isArray(that) && this.length === that.length) return this.every((v, i)=>_equalJs.equals(v, that[i]));
        else return false;
    }
});
const Structural = /*#__PURE__*/ function() {
    function Structural(args) {
        if (args) Object.assign(this, args);
    }
    Structural.prototype = (0, _effectableJs.StructuralPrototype);
    return Structural;
}();
const struct = (as)=>Object.assign(Object.create((0, _effectableJs.StructuralPrototype)), as);

},{"../Equal.js":"gA0qD","../Hash.js":"gFMwE","./effectable.js":"8EvvU","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"dOZM5":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ContextPatchTypeId", ()=>ContextPatchTypeId);
parcelHelpers.export(exports, "empty", ()=>empty);
parcelHelpers.export(exports, "diff", ()=>diff);
parcelHelpers.export(exports, "combine", ()=>combine);
parcelHelpers.export(exports, "patch", ()=>patch);
var _chunkJs = require("../../Chunk.js");
var _equalJs = require("../../Equal.js");
var _functionJs = require("../../Function.js");
var _contextJs = require("../context.js");
var _dataJs = require("../data.js");
const ContextPatchTypeId = /*#__PURE__*/ Symbol.for("effect/DifferContextPatch");
function variance(a) {
    return a;
}
/** @internal */ const PatchProto = {
    ...(0, _dataJs.Structural).prototype,
    [ContextPatchTypeId]: {
        _Value: variance,
        _Patch: variance
    }
};
const EmptyProto = /*#__PURE__*/ Object.assign(/*#__PURE__*/ Object.create(PatchProto), {
    _tag: "Empty"
});
const _empty = /*#__PURE__*/ Object.create(EmptyProto);
const empty = ()=>_empty;
const AndThenProto = /*#__PURE__*/ Object.assign(/*#__PURE__*/ Object.create(PatchProto), {
    _tag: "AndThen"
});
const makeAndThen = (first, second)=>{
    const o = Object.create(AndThenProto);
    o.first = first;
    o.second = second;
    return o;
};
const AddServiceProto = /*#__PURE__*/ Object.assign(/*#__PURE__*/ Object.create(PatchProto), {
    _tag: "AddService"
});
const makeAddService = (key, service)=>{
    const o = Object.create(AddServiceProto);
    o.key = key;
    o.service = service;
    return o;
};
const RemoveServiceProto = /*#__PURE__*/ Object.assign(/*#__PURE__*/ Object.create(PatchProto), {
    _tag: "RemoveService"
});
const makeRemoveService = (key)=>{
    const o = Object.create(RemoveServiceProto);
    o.key = key;
    return o;
};
const UpdateServiceProto = /*#__PURE__*/ Object.assign(/*#__PURE__*/ Object.create(PatchProto), {
    _tag: "UpdateService"
});
const makeUpdateService = (key, update)=>{
    const o = Object.create(UpdateServiceProto);
    o.key = key;
    o.update = update;
    return o;
};
const diff = (oldValue, newValue)=>{
    const missingServices = new Map(oldValue.unsafeMap);
    let patch = empty();
    for (const [tag, newService] of newValue.unsafeMap.entries())if (missingServices.has(tag)) {
        const old = missingServices.get(tag);
        missingServices.delete(tag);
        if (!_equalJs.equals(old, newService)) patch = combine(makeUpdateService(tag, ()=>newService))(patch);
    } else {
        missingServices.delete(tag);
        patch = combine(makeAddService(tag, newService))(patch);
    }
    for (const [tag] of missingServices.entries())patch = combine(makeRemoveService(tag))(patch);
    return patch;
};
const combine = /*#__PURE__*/ _functionJs.dual(2, (self, that)=>makeAndThen(self, that));
const patch = /*#__PURE__*/ _functionJs.dual(2, (self, context)=>{
    if (self._tag === "Empty") return context;
    let wasServiceUpdated = false;
    let patches = _chunkJs.of(self);
    const updatedContext = new Map(context.unsafeMap);
    while(_chunkJs.isNonEmpty(patches)){
        const head = _chunkJs.headNonEmpty(patches);
        const tail = _chunkJs.tailNonEmpty(patches);
        switch(head._tag){
            case "Empty":
                patches = tail;
                break;
            case "AddService":
                updatedContext.set(head.key, head.service);
                patches = tail;
                break;
            case "AndThen":
                patches = _chunkJs.prepend(_chunkJs.prepend(tail, head.second), head.first);
                break;
            case "RemoveService":
                updatedContext.delete(head.key);
                patches = tail;
                break;
            case "UpdateService":
                updatedContext.set(head.key, head.update(updatedContext.get(head.key)));
                wasServiceUpdated = true;
                patches = tail;
                break;
        }
    }
    if (!wasServiceUpdated) return (0, _contextJs.makeContext)(updatedContext);
    const map = new Map();
    for (const [tag] of context.unsafeMap)if (updatedContext.has(tag)) {
        map.set(tag, updatedContext.get(tag));
        updatedContext.delete(tag);
    }
    for (const [tag, s] of updatedContext)map.set(tag, s);
    return (0, _contextJs.makeContext)(map);
});

},{"../../Chunk.js":"dL1OO","../../Equal.js":"gA0qD","../../Function.js":"21gOL","../context.js":"g5r35","../data.js":"fk0Pw","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"guP0Y":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "HashMapPatchTypeId", ()=>HashMapPatchTypeId);
parcelHelpers.export(exports, "empty", ()=>empty);
parcelHelpers.export(exports, "diff", ()=>diff);
parcelHelpers.export(exports, "combine", ()=>combine);
parcelHelpers.export(exports, "patch", ()=>patch);
var _chunkJs = require("../../Chunk.js");
var _equalJs = require("../../Equal.js");
var _functionJs = require("../../Function.js");
var _hashMapJs = require("../../HashMap.js");
var _dataJs = require("../data.js");
const HashMapPatchTypeId = /*#__PURE__*/ Symbol.for("effect/DifferHashMapPatch");
function variance(a) {
    return a;
}
/** @internal */ const PatchProto = {
    ...(0, _dataJs.Structural).prototype,
    [HashMapPatchTypeId]: {
        _Value: variance,
        _Key: variance,
        _Patch: variance
    }
};
const EmptyProto = /*#__PURE__*/ Object.assign(/*#__PURE__*/ Object.create(PatchProto), {
    _tag: "Empty"
});
const _empty = /*#__PURE__*/ Object.create(EmptyProto);
const empty = ()=>_empty;
const AndThenProto = /*#__PURE__*/ Object.assign(/*#__PURE__*/ Object.create(PatchProto), {
    _tag: "AndThen"
});
const makeAndThen = (first, second)=>{
    const o = Object.create(AndThenProto);
    o.first = first;
    o.second = second;
    return o;
};
const AddProto = /*#__PURE__*/ Object.assign(/*#__PURE__*/ Object.create(PatchProto), {
    _tag: "Add"
});
const makeAdd = (key, value)=>{
    const o = Object.create(AddProto);
    o.key = key;
    o.value = value;
    return o;
};
const RemoveProto = /*#__PURE__*/ Object.assign(/*#__PURE__*/ Object.create(PatchProto), {
    _tag: "Remove"
});
const makeRemove = (key)=>{
    const o = Object.create(RemoveProto);
    o.key = key;
    return o;
};
const UpdateProto = /*#__PURE__*/ Object.assign(/*#__PURE__*/ Object.create(PatchProto), {
    _tag: "Update"
});
const makeUpdate = (key, patch)=>{
    const o = Object.create(UpdateProto);
    o.key = key;
    o.patch = patch;
    return o;
};
const diff = (options)=>{
    const [removed, patch] = _hashMapJs.reduce([
        options.oldValue,
        empty()
    ], ([map, patch], newValue, key)=>{
        const option = _hashMapJs.get(key)(map);
        switch(option._tag){
            case "Some":
                {
                    const valuePatch = options.differ.diff(option.value, newValue);
                    if (_equalJs.equals(valuePatch, options.differ.empty)) return [
                        _hashMapJs.remove(key)(map),
                        patch
                    ];
                    return [
                        _hashMapJs.remove(key)(map),
                        combine(makeUpdate(key, valuePatch))(patch)
                    ];
                }
            case "None":
                return [
                    map,
                    combine(makeAdd(key, newValue))(patch)
                ];
        }
    })(options.newValue);
    return _hashMapJs.reduce(patch, (patch, _, key)=>combine(makeRemove(key))(patch))(removed);
};
const combine = /*#__PURE__*/ _functionJs.dual(2, (self, that)=>makeAndThen(self, that));
const patch = /*#__PURE__*/ _functionJs.dual(3, (self, oldValue, differ)=>{
    if (self._tag === "Empty") return oldValue;
    let map = oldValue;
    let patches = _chunkJs.of(self);
    while(_chunkJs.isNonEmpty(patches)){
        const head = _chunkJs.headNonEmpty(patches);
        const tail = _chunkJs.tailNonEmpty(patches);
        switch(head._tag){
            case "Empty":
                patches = tail;
                break;
            case "AndThen":
                patches = _chunkJs.prepend(head.first)(_chunkJs.prepend(head.second)(tail));
                break;
            case "Add":
                map = _hashMapJs.set(head.key, head.value)(map);
                patches = tail;
                break;
            case "Remove":
                map = _hashMapJs.remove(head.key)(map);
                patches = tail;
                break;
            case "Update":
                {
                    const option = _hashMapJs.get(head.key)(map);
                    if (option._tag === "Some") map = _hashMapJs.set(head.key, differ.patch(head.patch, option.value))(map);
                    patches = tail;
                    break;
                }
        }
    }
    return map;
});

},{"../../Chunk.js":"dL1OO","../../Equal.js":"gA0qD","../../Function.js":"21gOL","../../HashMap.js":"aG8zS","../data.js":"fk0Pw","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"1i5Zt":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "HashSetPatchTypeId", ()=>HashSetPatchTypeId);
parcelHelpers.export(exports, "empty", ()=>empty);
parcelHelpers.export(exports, "makeAndThen", ()=>makeAndThen);
parcelHelpers.export(exports, "makeAdd", ()=>makeAdd);
parcelHelpers.export(exports, "makeRemove", ()=>makeRemove);
parcelHelpers.export(exports, "diff", ()=>diff);
parcelHelpers.export(exports, "combine", ()=>combine);
parcelHelpers.export(exports, "patch", ()=>patch);
var _chunkJs = require("../../Chunk.js");
var _functionJs = require("../../Function.js");
var _hashSetJs = require("../../HashSet.js");
var _dataJs = require("../data.js");
const HashSetPatchTypeId = /*#__PURE__*/ Symbol.for("effect/DifferHashSetPatch");
function variance(a) {
    return a;
}
/** @internal */ const PatchProto = {
    ...(0, _dataJs.Structural).prototype,
    [HashSetPatchTypeId]: {
        _Value: variance,
        _Key: variance,
        _Patch: variance
    }
};
const EmptyProto = /*#__PURE__*/ Object.assign(/*#__PURE__*/ Object.create(PatchProto), {
    _tag: "Empty"
});
const _empty = /*#__PURE__*/ Object.create(EmptyProto);
const empty = ()=>_empty;
const AndThenProto = /*#__PURE__*/ Object.assign(/*#__PURE__*/ Object.create(PatchProto), {
    _tag: "AndThen"
});
const makeAndThen = (first, second)=>{
    const o = Object.create(AndThenProto);
    o.first = first;
    o.second = second;
    return o;
};
const AddProto = /*#__PURE__*/ Object.assign(/*#__PURE__*/ Object.create(PatchProto), {
    _tag: "Add"
});
const makeAdd = (value)=>{
    const o = Object.create(AddProto);
    o.value = value;
    return o;
};
const RemoveProto = /*#__PURE__*/ Object.assign(/*#__PURE__*/ Object.create(PatchProto), {
    _tag: "Remove"
});
const makeRemove = (value)=>{
    const o = Object.create(RemoveProto);
    o.value = value;
    return o;
};
const diff = (oldValue, newValue)=>{
    const [removed, patch] = _hashSetJs.reduce([
        oldValue,
        empty()
    ], ([set, patch], value)=>{
        if (_hashSetJs.has(value)(set)) return [
            _hashSetJs.remove(value)(set),
            patch
        ];
        return [
            set,
            combine(makeAdd(value))(patch)
        ];
    })(newValue);
    return _hashSetJs.reduce(patch, (patch, value)=>combine(makeRemove(value))(patch))(removed);
};
const combine = /*#__PURE__*/ _functionJs.dual(2, (self, that)=>makeAndThen(self, that));
const patch = /*#__PURE__*/ _functionJs.dual(2, (self, oldValue)=>{
    if (self._tag === "Empty") return oldValue;
    let set = oldValue;
    let patches = _chunkJs.of(self);
    while(_chunkJs.isNonEmpty(patches)){
        const head = _chunkJs.headNonEmpty(patches);
        const tail = _chunkJs.tailNonEmpty(patches);
        switch(head._tag){
            case "Empty":
                patches = tail;
                break;
            case "AndThen":
                patches = _chunkJs.prepend(head.first)(_chunkJs.prepend(head.second)(tail));
                break;
            case "Add":
                set = _hashSetJs.add(head.value)(set);
                patches = tail;
                break;
            case "Remove":
                set = _hashSetJs.remove(head.value)(set);
                patches = tail;
        }
    }
    return set;
});

},{"../../Chunk.js":"dL1OO","../../Function.js":"21gOL","../../HashSet.js":"aKFFV","../data.js":"fk0Pw","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"RGDmm":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "OrPatchTypeId", ()=>OrPatchTypeId);
parcelHelpers.export(exports, "empty", ()=>empty);
parcelHelpers.export(exports, "makeAndThen", ()=>makeAndThen);
parcelHelpers.export(exports, "makeSetLeft", ()=>makeSetLeft);
parcelHelpers.export(exports, "makeSetRight", ()=>makeSetRight);
parcelHelpers.export(exports, "makeUpdateLeft", ()=>makeUpdateLeft);
parcelHelpers.export(exports, "makeUpdateRight", ()=>makeUpdateRight);
parcelHelpers.export(exports, "diff", ()=>diff);
parcelHelpers.export(exports, "combine", ()=>combine);
parcelHelpers.export(exports, "patch", ()=>patch);
var _chunkJs = require("../../Chunk.js");
var _eitherJs = require("../../Either.js");
var _equalJs = require("../../Equal.js");
var _functionJs = require("../../Function.js");
var _dataJs = require("../data.js");
const OrPatchTypeId = /*#__PURE__*/ Symbol.for("effect/DifferOrPatch");
function variance(a) {
    return a;
}
/** @internal */ const PatchProto = {
    ...(0, _dataJs.Structural).prototype,
    [OrPatchTypeId]: {
        _Value: variance,
        _Key: variance,
        _Patch: variance
    }
};
const EmptyProto = /*#__PURE__*/ Object.assign(/*#__PURE__*/ Object.create(PatchProto), {
    _tag: "Empty"
});
const _empty = /*#__PURE__*/ Object.create(EmptyProto);
const empty = ()=>_empty;
const AndThenProto = /*#__PURE__*/ Object.assign(/*#__PURE__*/ Object.create(PatchProto), {
    _tag: "AndThen"
});
const makeAndThen = (first, second)=>{
    const o = Object.create(AndThenProto);
    o.first = first;
    o.second = second;
    return o;
};
const SetLeftProto = /*#__PURE__*/ Object.assign(/*#__PURE__*/ Object.create(PatchProto), {
    _tag: "SetLeft"
});
const makeSetLeft = (value)=>{
    const o = Object.create(SetLeftProto);
    o.value = value;
    return o;
};
const SetRightProto = /*#__PURE__*/ Object.assign(/*#__PURE__*/ Object.create(PatchProto), {
    _tag: "SetRight"
});
const makeSetRight = (value)=>{
    const o = Object.create(SetRightProto);
    o.value = value;
    return o;
};
const UpdateLeftProto = /*#__PURE__*/ Object.assign(/*#__PURE__*/ Object.create(PatchProto), {
    _tag: "UpdateLeft"
});
const makeUpdateLeft = (patch)=>{
    const o = Object.create(UpdateLeftProto);
    o.patch = patch;
    return o;
};
const UpdateRightProto = /*#__PURE__*/ Object.assign(/*#__PURE__*/ Object.create(PatchProto), {
    _tag: "UpdateRight"
});
const makeUpdateRight = (patch)=>{
    const o = Object.create(UpdateRightProto);
    o.patch = patch;
    return o;
};
const diff = (options)=>{
    switch(options.oldValue._tag){
        case "Left":
            switch(options.newValue._tag){
                case "Left":
                    {
                        const valuePatch = options.left.diff(options.oldValue.left, options.newValue.left);
                        if (_equalJs.equals(valuePatch, options.left.empty)) return empty();
                        return makeUpdateLeft(valuePatch);
                    }
                case "Right":
                    return makeSetRight(options.newValue.right);
            }
        case "Right":
            switch(options.newValue._tag){
                case "Left":
                    return makeSetLeft(options.newValue.left);
                case "Right":
                    {
                        const valuePatch = options.right.diff(options.oldValue.right, options.newValue.right);
                        if (_equalJs.equals(valuePatch, options.right.empty)) return empty();
                        return makeUpdateRight(valuePatch);
                    }
            }
    }
};
const combine = /*#__PURE__*/ _functionJs.dual(2, (self, that)=>makeAndThen(self, that));
const patch = /*#__PURE__*/ _functionJs.dual(2, (self, { left, oldValue, right })=>{
    if (self._tag === "Empty") return oldValue;
    let patches = _chunkJs.of(self);
    let result = oldValue;
    while(_chunkJs.isNonEmpty(patches)){
        const head = _chunkJs.headNonEmpty(patches);
        const tail = _chunkJs.tailNonEmpty(patches);
        switch(head._tag){
            case "Empty":
                patches = tail;
                break;
            case "AndThen":
                patches = _chunkJs.prepend(head.first)(_chunkJs.prepend(head.second)(tail));
                break;
            case "UpdateLeft":
                if (result._tag === "Left") result = _eitherJs.left(left.patch(head.patch, result.left));
                patches = tail;
                break;
            case "UpdateRight":
                if (result._tag === "Right") result = _eitherJs.right(right.patch(head.patch, result.right));
                patches = tail;
                break;
            case "SetLeft":
                result = _eitherJs.left(head.value);
                patches = tail;
                break;
            case "SetRight":
                result = _eitherJs.right(head.value);
                patches = tail;
                break;
        }
    }
    return result;
});

},{"../../Chunk.js":"dL1OO","../../Either.js":"4amnT","../../Equal.js":"gA0qD","../../Function.js":"21gOL","../data.js":"fk0Pw","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"uaIJN":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ReadonlyArrayPatchTypeId", ()=>ReadonlyArrayPatchTypeId);
parcelHelpers.export(exports, "empty", ()=>empty);
parcelHelpers.export(exports, "diff", ()=>diff);
parcelHelpers.export(exports, "combine", ()=>combine);
parcelHelpers.export(exports, "patch", ()=>patch);
var _arrayJs = require("../../Array.js");
var _equalJs = require("../../Equal.js");
var _functionJs = require("../../Function.js");
var _dataJs = require("../data.js");
const ReadonlyArrayPatchTypeId = /*#__PURE__*/ Symbol.for("effect/DifferReadonlyArrayPatch");
function variance(a) {
    return a;
}
const PatchProto = {
    ..._dataJs.Structural.prototype,
    [ReadonlyArrayPatchTypeId]: {
        _Value: variance,
        _Patch: variance
    }
};
const EmptyProto = /*#__PURE__*/ Object.assign(/*#__PURE__*/ Object.create(PatchProto), {
    _tag: "Empty"
});
const _empty = /*#__PURE__*/ Object.create(EmptyProto);
const empty = ()=>_empty;
const AndThenProto = /*#__PURE__*/ Object.assign(/*#__PURE__*/ Object.create(PatchProto), {
    _tag: "AndThen"
});
const makeAndThen = (first, second)=>{
    const o = Object.create(AndThenProto);
    o.first = first;
    o.second = second;
    return o;
};
const AppendProto = /*#__PURE__*/ Object.assign(/*#__PURE__*/ Object.create(PatchProto), {
    _tag: "Append"
});
const makeAppend = (values)=>{
    const o = Object.create(AppendProto);
    o.values = values;
    return o;
};
const SliceProto = /*#__PURE__*/ Object.assign(/*#__PURE__*/ Object.create(PatchProto), {
    _tag: "Slice"
});
const makeSlice = (from, until)=>{
    const o = Object.create(SliceProto);
    o.from = from;
    o.until = until;
    return o;
};
const UpdateProto = /*#__PURE__*/ Object.assign(/*#__PURE__*/ Object.create(PatchProto), {
    _tag: "Update"
});
const makeUpdate = (index, patch)=>{
    const o = Object.create(UpdateProto);
    o.index = index;
    o.patch = patch;
    return o;
};
const diff = (options)=>{
    let i = 0;
    let patch = empty();
    while(i < options.oldValue.length && i < options.newValue.length){
        const oldElement = options.oldValue[i];
        const newElement = options.newValue[i];
        const valuePatch = options.differ.diff(oldElement, newElement);
        if (!_equalJs.equals(valuePatch, options.differ.empty)) patch = combine(patch, makeUpdate(i, valuePatch));
        i = i + 1;
    }
    if (i < options.oldValue.length) patch = combine(patch, makeSlice(0, i));
    if (i < options.newValue.length) patch = combine(patch, makeAppend(_arrayJs.drop(i)(options.newValue)));
    return patch;
};
const combine = /*#__PURE__*/ _functionJs.dual(2, (self, that)=>makeAndThen(self, that));
const patch = /*#__PURE__*/ _functionJs.dual(3, (self, oldValue, differ)=>{
    if (self._tag === "Empty") return oldValue;
    let readonlyArray = oldValue.slice();
    let patches = _arrayJs.of(self);
    while(_arrayJs.isNonEmptyArray(patches)){
        const head = _arrayJs.headNonEmpty(patches);
        const tail = _arrayJs.tailNonEmpty(patches);
        switch(head._tag){
            case "Empty":
                patches = tail;
                break;
            case "AndThen":
                tail.unshift(head.first, head.second);
                patches = tail;
                break;
            case "Append":
                for (const value of head.values)readonlyArray.push(value);
                patches = tail;
                break;
            case "Slice":
                readonlyArray = readonlyArray.slice(head.from, head.until);
                patches = tail;
                break;
            case "Update":
                readonlyArray[head.index] = differ.patch(head.patch, readonlyArray[head.index]);
                patches = tail;
                break;
        }
    }
    return readonlyArray;
});

},{"../../Array.js":"8L2Gk","../../Equal.js":"gA0qD","../../Function.js":"21gOL","../data.js":"fk0Pw","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"4PDkQ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "active", ()=>active);
parcelHelpers.export(exports, "enabled", ()=>enabled);
parcelHelpers.export(exports, "make", ()=>make);
parcelHelpers.export(exports, "empty", ()=>empty);
parcelHelpers.export(exports, "enable", ()=>enable);
parcelHelpers.export(exports, "disable", ()=>disable);
parcelHelpers.export(exports, "isEmpty", ()=>isEmpty);
parcelHelpers.export(exports, "isActive", ()=>isActive);
parcelHelpers.export(exports, "isEnabled", ()=>isEnabled);
parcelHelpers.export(exports, "isDisabled", ()=>isDisabled);
parcelHelpers.export(exports, "exclude", ()=>exclude);
parcelHelpers.export(exports, "both", ()=>both);
parcelHelpers.export(exports, "either", ()=>either);
parcelHelpers.export(exports, "andThen", ()=>andThen);
parcelHelpers.export(exports, "inverse", ()=>inverse);
parcelHelpers.export(exports, "invert", ()=>invert);
var _functionJs = require("../Function.js");
/** @internal */ const BIT_MASK = 0xff;
/** @internal */ const BIT_SHIFT = 0x08;
const active = (patch)=>patch & BIT_MASK;
const enabled = (patch)=>patch >> BIT_SHIFT & BIT_MASK;
const make = (active, enabled)=>(active & BIT_MASK) + ((enabled & active & BIT_MASK) << BIT_SHIFT);
const empty = /*#__PURE__*/ make(0, 0);
const enable = (flag)=>make(flag, flag);
const disable = (flag)=>make(flag, 0);
const isEmpty = (patch)=>patch === 0;
const isActive = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, flag)=>(active(self) & flag) !== 0);
const isEnabled = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, flag)=>(enabled(self) & flag) !== 0);
const isDisabled = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, flag)=>(active(self) & flag) !== 0 && (enabled(self) & flag) === 0);
const exclude = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, flag)=>make(active(self) & ~flag, enabled(self)));
const both = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>make(active(self) | active(that), enabled(self) & enabled(that)));
const either = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>make(active(self) | active(that), enabled(self) | enabled(that)));
const andThen = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>self | that);
const inverse = (patch)=>make(enabled(patch), invert(active(patch)));
const invert = (n)=>~n >>> 0 & BIT_MASK;

},{"../Function.js":"21gOL","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"2UYO5":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "empty", ()=>empty);
parcelHelpers.export(exports, "par", ()=>par);
parcelHelpers.export(exports, "seq", ()=>seq);
parcelHelpers.export(exports, "single", ()=>single);
parcelHelpers.export(exports, "MapRequestResolversReducer", ()=>MapRequestResolversReducer);
parcelHelpers.export(exports, "mapRequestResolvers", ()=>mapRequestResolvers);
parcelHelpers.export(exports, "reduce", ()=>reduce);
parcelHelpers.export(exports, "flatten", ()=>flatten);
parcelHelpers.export(exports, "EntryTypeId", ()=>EntryTypeId);
parcelHelpers.export(exports, "isEntry", ()=>isEntry);
parcelHelpers.export(exports, "makeEntry", ()=>makeEntry);
parcelHelpers.export(exports, "RequestBlockParallelTypeId", ()=>RequestBlockParallelTypeId);
parcelHelpers.export(exports, "parallelCollectionEmpty", ()=>parallelCollectionEmpty);
parcelHelpers.export(exports, "parallelCollectionMake", ()=>parallelCollectionMake);
parcelHelpers.export(exports, "parallelCollectionAdd", ()=>parallelCollectionAdd);
parcelHelpers.export(exports, "parallelCollectionCombine", ()=>parallelCollectionCombine);
parcelHelpers.export(exports, "parallelCollectionIsEmpty", ()=>parallelCollectionIsEmpty);
parcelHelpers.export(exports, "parallelCollectionKeys", ()=>parallelCollectionKeys);
parcelHelpers.export(exports, "parallelCollectionToSequentialCollection", ()=>parallelCollectionToSequentialCollection);
parcelHelpers.export(exports, "SequentialCollectionTypeId", ()=>SequentialCollectionTypeId);
parcelHelpers.export(exports, "sequentialCollectionMake", ()=>sequentialCollectionMake);
parcelHelpers.export(exports, "sequentialCollectionCombine", ()=>sequentialCollectionCombine);
parcelHelpers.export(exports, "sequentialCollectionIsEmpty", ()=>sequentialCollectionIsEmpty);
parcelHelpers.export(exports, "sequentialCollectionKeys", ()=>sequentialCollectionKeys);
parcelHelpers.export(exports, "sequentialCollectionToChunk", ()=>sequentialCollectionToChunk);
var _chunkJs = require("../Chunk.js");
var _eitherJs = require("../Either.js");
var _equalJs = require("../Equal.js");
var _hashMapJs = require("../HashMap.js");
var _listJs = require("../List.js");
var _optionJs = require("../Option.js");
var _predicateJs = require("../Predicate.js");
const empty = {
    _tag: "Empty"
};
const par = (self, that)=>({
        _tag: "Par",
        left: self,
        right: that
    });
const seq = (self, that)=>({
        _tag: "Seq",
        left: self,
        right: that
    });
const single = (dataSource, blockedRequest)=>({
        _tag: "Single",
        dataSource: dataSource,
        blockedRequest
    });
const MapRequestResolversReducer = (f)=>({
        emptyCase: ()=>empty,
        parCase: (left, right)=>par(left, right),
        seqCase: (left, right)=>seq(left, right),
        singleCase: (dataSource, blockedRequest)=>single(f(dataSource), blockedRequest)
    });
const mapRequestResolvers = (self, f)=>reduce(self, MapRequestResolversReducer(f));
const reduce = (self, reducer)=>{
    let input = _listJs.of(self);
    let output = _listJs.empty();
    while(_listJs.isCons(input)){
        const current = input.head;
        switch(current._tag){
            case "Empty":
                output = _listJs.cons(_eitherJs.right(reducer.emptyCase()), output);
                input = input.tail;
                break;
            case "Par":
                output = _listJs.cons(_eitherJs.left({
                    _tag: "ParCase"
                }), output);
                input = _listJs.cons(current.left, _listJs.cons(current.right, input.tail));
                break;
            case "Seq":
                output = _listJs.cons(_eitherJs.left({
                    _tag: "SeqCase"
                }), output);
                input = _listJs.cons(current.left, _listJs.cons(current.right, input.tail));
                break;
            case "Single":
                {
                    const result = reducer.singleCase(current.dataSource, current.blockedRequest);
                    output = _listJs.cons(_eitherJs.right(result), output);
                    input = input.tail;
                    break;
                }
        }
    }
    const result = _listJs.reduce(output, _listJs.empty(), (acc, current)=>{
        switch(current._tag){
            case "Left":
                {
                    const left = _listJs.unsafeHead(acc);
                    const right = _listJs.unsafeHead(_listJs.unsafeTail(acc));
                    const tail = _listJs.unsafeTail(_listJs.unsafeTail(acc));
                    switch(current.left._tag){
                        case "ParCase":
                            return _listJs.cons(reducer.parCase(left, right), tail);
                        case "SeqCase":
                            return _listJs.cons(reducer.seqCase(left, right), tail);
                    }
                }
            case "Right":
                return _listJs.cons(current.right, acc);
        }
    });
    if (_listJs.isNil(result)) throw new Error("BUG: BlockedRequests.reduce - please report an issue at https://github.com/Effect-TS/effect/issues");
    return result.head;
};
const flatten = (self)=>{
    let current = _listJs.of(self);
    let updated = _listJs.empty();
    // eslint-disable-next-line no-constant-condition
    while(true){
        const [parallel, sequential] = _listJs.reduce(current, [
            parallelCollectionEmpty(),
            _listJs.empty()
        ], ([parallel, sequential], blockedRequest)=>{
            const [par, seq] = step(blockedRequest);
            return [
                parallelCollectionCombine(parallel, par),
                _listJs.appendAll(sequential, seq)
            ];
        });
        updated = merge(updated, parallel);
        if (_listJs.isNil(sequential)) return _listJs.reverse(updated);
        current = sequential;
    }
    throw new Error("BUG: BlockedRequests.flatten - please report an issue at https://github.com/Effect-TS/effect/issues");
};
/**
 * Takes one step in evaluating a collection of blocked requests, returning a
 * collection of blocked requests that can be performed in parallel and a list
 * of blocked requests that must be performed sequentially after those
 * requests.
 */ const step = (requests)=>{
    let current = requests;
    let parallel = parallelCollectionEmpty();
    let stack = _listJs.empty();
    let sequential = _listJs.empty();
    // eslint-disable-next-line no-constant-condition
    while(true)switch(current._tag){
        case "Empty":
            if (_listJs.isNil(stack)) return [
                parallel,
                sequential
            ];
            current = stack.head;
            stack = stack.tail;
            break;
        case "Par":
            stack = _listJs.cons(current.right, stack);
            current = current.left;
            break;
        case "Seq":
            {
                const left = current.left;
                const right = current.right;
                switch(left._tag){
                    case "Empty":
                        current = right;
                        break;
                    case "Par":
                        {
                            const l = left.left;
                            const r = left.right;
                            current = par(seq(l, right), seq(r, right));
                            break;
                        }
                    case "Seq":
                        {
                            const l = left.left;
                            const r = left.right;
                            current = seq(l, seq(r, right));
                            break;
                        }
                    case "Single":
                        current = left;
                        sequential = _listJs.cons(right, sequential);
                        break;
                }
                break;
            }
        case "Single":
            parallel = parallelCollectionAdd(parallel, current);
            if (_listJs.isNil(stack)) return [
                parallel,
                sequential
            ];
            current = stack.head;
            stack = stack.tail;
            break;
    }
    throw new Error("BUG: BlockedRequests.step - please report an issue at https://github.com/Effect-TS/effect/issues");
};
/**
 * Merges a collection of requests that must be executed sequentially with a
 * collection of requests that can be executed in parallel. If the collections
 * are both from the same single data source then the requests can be
 * pipelined while preserving ordering guarantees.
 */ const merge = (sequential, parallel)=>{
    if (_listJs.isNil(sequential)) return _listJs.of(parallelCollectionToSequentialCollection(parallel));
    if (parallelCollectionIsEmpty(parallel)) return sequential;
    const seqHeadKeys = sequentialCollectionKeys(sequential.head);
    const parKeys = parallelCollectionKeys(parallel);
    if (seqHeadKeys.length === 1 && parKeys.length === 1 && _equalJs.equals(seqHeadKeys[0], parKeys[0])) return _listJs.cons(sequentialCollectionCombine(sequential.head, parallelCollectionToSequentialCollection(parallel)), sequential.tail);
    return _listJs.cons(parallelCollectionToSequentialCollection(parallel), sequential);
};
const EntryTypeId = /*#__PURE__*/ Symbol.for("effect/RequestBlock/Entry");
/** @internal */ class EntryImpl {
    request;
    result;
    listeners;
    ownerId;
    state;
    [EntryTypeId] = blockedRequestVariance;
    constructor(request, result, listeners, ownerId, state){
        this.request = request;
        this.result = result;
        this.listeners = listeners;
        this.ownerId = ownerId;
        this.state = state;
    }
}
const blockedRequestVariance = {
    /* c8 ignore next */ _R: (_)=>_
};
const isEntry = (u)=>(0, _predicateJs.hasProperty)(u, EntryTypeId);
const makeEntry = (options)=>new EntryImpl(options.request, options.result, options.listeners, options.ownerId, options.state);
const RequestBlockParallelTypeId = /*#__PURE__*/ Symbol.for("effect/RequestBlock/RequestBlockParallel");
const parallelVariance = {
    /* c8 ignore next */ _R: (_)=>_
};
class ParallelImpl {
    map;
    [RequestBlockParallelTypeId] = parallelVariance;
    constructor(map){
        this.map = map;
    }
}
const parallelCollectionEmpty = ()=>new ParallelImpl(_hashMapJs.empty());
const parallelCollectionMake = (dataSource, blockedRequest)=>new ParallelImpl(_hashMapJs.make([
        dataSource,
        _chunkJs.of(blockedRequest)
    ]));
const parallelCollectionAdd = (self, blockedRequest)=>new ParallelImpl(_hashMapJs.modifyAt(self.map, blockedRequest.dataSource, (_)=>_optionJs.orElseSome(_optionJs.map(_, _chunkJs.append(blockedRequest.blockedRequest)), ()=>_chunkJs.of(blockedRequest.blockedRequest))));
const parallelCollectionCombine = (self, that)=>new ParallelImpl(_hashMapJs.reduce(self.map, that.map, (map, value, key)=>_hashMapJs.set(map, key, _optionJs.match(_hashMapJs.get(map, key), {
            onNone: ()=>value,
            onSome: (other)=>_chunkJs.appendAll(value, other)
        }))));
const parallelCollectionIsEmpty = (self)=>_hashMapJs.isEmpty(self.map);
const parallelCollectionKeys = (self)=>Array.from(_hashMapJs.keys(self.map));
const parallelCollectionToSequentialCollection = (self)=>sequentialCollectionMake(_hashMapJs.map(self.map, (x)=>_chunkJs.of(x)));
const SequentialCollectionTypeId = /*#__PURE__*/ Symbol.for("effect/RequestBlock/RequestBlockSequential");
const sequentialVariance = {
    /* c8 ignore next */ _R: (_)=>_
};
class SequentialImpl {
    map;
    [SequentialCollectionTypeId] = sequentialVariance;
    constructor(map){
        this.map = map;
    }
}
const sequentialCollectionMake = (map)=>new SequentialImpl(map);
const sequentialCollectionCombine = (self, that)=>new SequentialImpl(_hashMapJs.reduce(that.map, self.map, (map, value, key)=>_hashMapJs.set(map, key, _optionJs.match(_hashMapJs.get(map, key), {
            onNone: ()=>_chunkJs.empty(),
            onSome: (a)=>_chunkJs.appendAll(a, value)
        }))));
const sequentialCollectionIsEmpty = (self)=>_hashMapJs.isEmpty(self.map);
const sequentialCollectionKeys = (self)=>Array.from(_hashMapJs.keys(self.map));
const sequentialCollectionToChunk = (self)=>Array.from(self.map);

},{"../Chunk.js":"dL1OO","../Either.js":"4amnT","../Equal.js":"gA0qD","../HashMap.js":"aG8zS","../List.js":"a341T","../Option.js":"6sHA7","../Predicate.js":"gW5pd","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"1Hftc":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DeferredTypeId", ()=>DeferredTypeId);
parcelHelpers.export(exports, "deferredVariance", ()=>deferredVariance);
parcelHelpers.export(exports, "pending", ()=>pending);
parcelHelpers.export(exports, "done", ()=>done);
var _deferredJs = require("./opCodes/deferred.js");
/** @internal */ const DeferredSymbolKey = "effect/Deferred";
const DeferredTypeId = /*#__PURE__*/ Symbol.for(DeferredSymbolKey);
const deferredVariance = {
    /* c8 ignore next */ _E: (_)=>_,
    /* c8 ignore next */ _A: (_)=>_
};
const pending = (joiners)=>{
    return {
        _tag: _deferredJs.OP_STATE_PENDING,
        joiners
    };
};
const done = (effect)=>{
    return {
        _tag: _deferredJs.OP_STATE_DONE,
        effect
    };
};

},{"./opCodes/deferred.js":"1tDM6","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"1tDM6":[function(require,module,exports,__globalThis) {
/** @internal */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "OP_STATE_PENDING", ()=>OP_STATE_PENDING);
parcelHelpers.export(exports, "OP_STATE_DONE", ()=>OP_STATE_DONE);
const OP_STATE_PENDING = "Pending";
const OP_STATE_DONE = "Done";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"3p5I1":[function(require,module,exports,__globalThis) {
/** @internal */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SingleShotGen", ()=>SingleShotGen);
class SingleShotGen {
    self;
    called = false;
    constructor(self){
        this.self = self;
    }
    next(a) {
        return this.called ? {
            value: a,
            done: true
        } : (this.called = true, {
            value: this.self,
            done: false
        });
    }
    return(a) {
        return {
            value: a,
            done: true
        };
    }
    throw(e) {
        throw e;
    }
    [Symbol.iterator]() {
        return new SingleShotGen(this.self);
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"2Ndj4":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ClockTypeId", ()=>ClockTypeId);
parcelHelpers.export(exports, "make", ()=>make);
parcelHelpers.export(exports, "sleep", ()=>sleep);
parcelHelpers.export(exports, "currentTimeMillis", ()=>currentTimeMillis);
parcelHelpers.export(exports, "currentTimeNanos", ()=>currentTimeNanos);
parcelHelpers.export(exports, "clockWith", ()=>clockWith);
parcelHelpers.export(exports, "Clock", ()=>Clock);
var _clockJs = require("./internal/clock.js");
var _defaultServicesJs = require("./internal/defaultServices.js");
const ClockTypeId = _clockJs.ClockTypeId;
const make = _clockJs.make;
const sleep = _defaultServicesJs.sleep;
const currentTimeMillis = _defaultServicesJs.currentTimeMillis;
const currentTimeNanos = _defaultServicesJs.currentTimeNanos;
const clockWith = _defaultServicesJs.clockWith;
const Clock = _clockJs.clockTag;

},{"./internal/clock.js":"27hJp","./internal/defaultServices.js":"aF4q8","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"27hJp":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ClockTypeId", ()=>ClockTypeId);
parcelHelpers.export(exports, "clockTag", ()=>clockTag);
parcelHelpers.export(exports, "MAX_TIMER_MILLIS", ()=>MAX_TIMER_MILLIS);
parcelHelpers.export(exports, "globalClockScheduler", ()=>globalClockScheduler);
parcelHelpers.export(exports, "make", ()=>make);
var _contextJs = require("../Context.js");
var _durationJs = require("../Duration.js");
var _functionJs = require("../Function.js");
var _coreJs = require("./core.js");
/** @internal */ const ClockSymbolKey = "effect/Clock";
const ClockTypeId = /*#__PURE__*/ Symbol.for(ClockSymbolKey);
const clockTag = /*#__PURE__*/ _contextJs.GenericTag("effect/Clock");
const MAX_TIMER_MILLIS = 2 ** 31 - 1;
const globalClockScheduler = {
    unsafeSchedule (task, duration) {
        const millis = _durationJs.toMillis(duration);
        // If the duration is greater than the value allowable by the JS timer
        // functions, treat the value as an infinite duration
        if (millis > MAX_TIMER_MILLIS) return 0, _functionJs.constFalse;
        let completed = false;
        const handle = setTimeout(()=>{
            completed = true;
            task();
        }, millis);
        return ()=>{
            clearTimeout(handle);
            return !completed;
        };
    }
};
const performanceNowNanos = /*#__PURE__*/ function() {
    const bigint1e6 = /*#__PURE__*/ BigInt(1000000);
    if (typeof performance === "undefined") return ()=>BigInt(Date.now()) * bigint1e6;
    let origin;
    return ()=>{
        if (origin === undefined) origin = BigInt(Date.now()) * bigint1e6 - BigInt(Math.round(performance.now() * 1000000));
        return origin + BigInt(Math.round(performance.now() * 1000000));
    };
}();
const processOrPerformanceNow = /*#__PURE__*/ function() {
    const processHrtime = undefined;
    if (!processHrtime) return performanceNowNanos;
    const origin = /*#__PURE__*/ performanceNowNanos() - /*#__PURE__*/ processHrtime.bigint();
    return ()=>origin + processHrtime.bigint();
}();
/** @internal */ class ClockImpl {
    [ClockTypeId] = ClockTypeId;
    unsafeCurrentTimeMillis() {
        return Date.now();
    }
    unsafeCurrentTimeNanos() {
        return processOrPerformanceNow();
    }
    currentTimeMillis = /*#__PURE__*/ _coreJs.sync(()=>this.unsafeCurrentTimeMillis());
    currentTimeNanos = /*#__PURE__*/ _coreJs.sync(()=>this.unsafeCurrentTimeNanos());
    scheduler() {
        return _coreJs.succeed(globalClockScheduler);
    }
    sleep(duration) {
        return _coreJs.async((resume)=>{
            const canceler = globalClockScheduler.unsafeSchedule(()=>resume(_coreJs.void), duration);
            return _coreJs.asVoid(_coreJs.sync(canceler));
        });
    }
}
const make = ()=>new ClockImpl();

},{"../Context.js":"c2abN","../Duration.js":"czLLe","../Function.js":"21gOL","./core.js":"cr3YV","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"aF4q8":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "liveServices", ()=>liveServices);
parcelHelpers.export(exports, "currentServices", ()=>currentServices);
parcelHelpers.export(exports, "sleep", ()=>sleep);
parcelHelpers.export(exports, "defaultServicesWith", ()=>defaultServicesWith);
parcelHelpers.export(exports, "clockWith", ()=>clockWith);
parcelHelpers.export(exports, "currentTimeMillis", ()=>currentTimeMillis);
parcelHelpers.export(exports, "currentTimeNanos", ()=>currentTimeNanos);
parcelHelpers.export(exports, "withClock", ()=>withClock);
parcelHelpers.export(exports, "withConfigProvider", ()=>withConfigProvider);
parcelHelpers.export(exports, "configProviderWith", ()=>configProviderWith);
parcelHelpers.export(exports, "config", ()=>config);
parcelHelpers.export(exports, "configOrDie", ()=>configOrDie);
parcelHelpers.export(exports, "randomWith", ()=>randomWith);
parcelHelpers.export(exports, "withRandom", ()=>withRandom);
parcelHelpers.export(exports, "next", ()=>next);
parcelHelpers.export(exports, "nextInt", ()=>nextInt);
parcelHelpers.export(exports, "nextBoolean", ()=>nextBoolean);
parcelHelpers.export(exports, "nextRange", ()=>nextRange);
parcelHelpers.export(exports, "nextIntBetween", ()=>nextIntBetween);
parcelHelpers.export(exports, "shuffle", ()=>shuffle);
parcelHelpers.export(exports, "choice", ()=>choice);
parcelHelpers.export(exports, "tracerWith", ()=>tracerWith);
parcelHelpers.export(exports, "withTracer", ()=>withTracer);
var _arrayJs = require("../Array.js");
var _contextJs = require("../Context.js");
var _durationJs = require("../Duration.js");
var _functionJs = require("../Function.js");
var _globalValueJs = require("../GlobalValue.js");
var _clockJs = require("./clock.js");
var _configProviderJs = require("./configProvider.js");
var _coreJs = require("./core.js");
var _consoleJs = require("./defaultServices/console.js");
var _randomJs = require("./random.js");
var _tracerJs = require("./tracer.js");
const liveServices = /*#__PURE__*/ (0, _functionJs.pipe)(/*#__PURE__*/ _contextJs.empty(), /*#__PURE__*/ _contextJs.add(_clockJs.clockTag, /*#__PURE__*/ _clockJs.make()), /*#__PURE__*/ _contextJs.add(_consoleJs.consoleTag, _consoleJs.defaultConsole), /*#__PURE__*/ _contextJs.add(_randomJs.randomTag, /*#__PURE__*/ _randomJs.make(/*#__PURE__*/ Math.random())), /*#__PURE__*/ _contextJs.add(_configProviderJs.configProviderTag, /*#__PURE__*/ _configProviderJs.fromEnv()), /*#__PURE__*/ _contextJs.add(_tracerJs.tracerTag, _tracerJs.nativeTracer));
const currentServices = /*#__PURE__*/ (0, _globalValueJs.globalValue)(/*#__PURE__*/ Symbol.for("effect/DefaultServices/currentServices"), ()=>_coreJs.fiberRefUnsafeMakeContext(liveServices));
const sleep = (duration)=>{
    const decodedDuration = _durationJs.decode(duration);
    return clockWith((clock)=>clock.sleep(decodedDuration));
};
const defaultServicesWith = (f)=>_coreJs.withFiberRuntime((fiber)=>f(fiber.currentDefaultServices));
const clockWith = (f)=>defaultServicesWith((services)=>f(services.unsafeMap.get(_clockJs.clockTag.key)));
const currentTimeMillis = /*#__PURE__*/ clockWith((clock)=>clock.currentTimeMillis);
const currentTimeNanos = /*#__PURE__*/ clockWith((clock)=>clock.currentTimeNanos);
const withClock = /*#__PURE__*/ (0, _functionJs.dual)(2, (effect, c)=>_coreJs.fiberRefLocallyWith(currentServices, _contextJs.add(_clockJs.clockTag, c))(effect));
const withConfigProvider = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, provider)=>_coreJs.fiberRefLocallyWith(currentServices, _contextJs.add(_configProviderJs.configProviderTag, provider))(self));
const configProviderWith = (f)=>defaultServicesWith((services)=>f(services.unsafeMap.get(_configProviderJs.configProviderTag.key)));
const config = (config)=>configProviderWith((_)=>_.load(config));
const configOrDie = (config)=>_coreJs.orDie(configProviderWith((_)=>_.load(config)));
const randomWith = (f)=>defaultServicesWith((services)=>f(services.unsafeMap.get(_randomJs.randomTag.key)));
const withRandom = /*#__PURE__*/ (0, _functionJs.dual)(2, (effect, value)=>_coreJs.fiberRefLocallyWith(currentServices, _contextJs.add(_randomJs.randomTag, value))(effect));
const next = /*#__PURE__*/ randomWith((random)=>random.next);
const nextInt = /*#__PURE__*/ randomWith((random)=>random.nextInt);
const nextBoolean = /*#__PURE__*/ randomWith((random)=>random.nextBoolean);
const nextRange = (min, max)=>randomWith((random)=>random.nextRange(min, max));
const nextIntBetween = (min, max)=>randomWith((random)=>random.nextIntBetween(min, max));
const shuffle = (elements)=>randomWith((random)=>random.shuffle(elements));
const choice = (elements)=>{
    const array = _arrayJs.fromIterable(elements);
    return _coreJs.map(array.length === 0 ? _coreJs.fail(new _coreJs.NoSuchElementException("Cannot select a random element from an empty array")) : randomWith((random)=>random.nextIntBetween(0, array.length)), (i)=>array[i]);
};
const tracerWith = (f)=>defaultServicesWith((services)=>f(services.unsafeMap.get(_tracerJs.tracerTag.key)));
const withTracer = /*#__PURE__*/ (0, _functionJs.dual)(2, (effect, value)=>_coreJs.fiberRefLocallyWith(currentServices, _contextJs.add(_tracerJs.tracerTag, value))(effect));

},{"../Array.js":"8L2Gk","../Context.js":"c2abN","../Duration.js":"czLLe","../Function.js":"21gOL","../GlobalValue.js":"5w3Hn","./clock.js":"27hJp","./configProvider.js":"103QC","./core.js":"cr3YV","./defaultServices/console.js":"lcu1k","./random.js":"br4fL","./tracer.js":"aAsvB","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"103QC":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ConfigProviderTypeId", ()=>ConfigProviderTypeId);
parcelHelpers.export(exports, "configProviderTag", ()=>configProviderTag);
parcelHelpers.export(exports, "FlatConfigProviderTypeId", ()=>FlatConfigProviderTypeId);
parcelHelpers.export(exports, "make", ()=>make);
parcelHelpers.export(exports, "makeFlat", ()=>makeFlat);
parcelHelpers.export(exports, "fromFlat", ()=>fromFlat);
parcelHelpers.export(exports, "fromEnv", ()=>fromEnv);
parcelHelpers.export(exports, "fromMap", ()=>fromMap);
parcelHelpers.export(exports, "mapInputPath", ()=>mapInputPath);
parcelHelpers.export(exports, "nested", ()=>nested);
parcelHelpers.export(exports, "unnested", ()=>unnested);
parcelHelpers.export(exports, "orElse", ()=>orElse);
parcelHelpers.export(exports, "constantCase", ()=>constantCase);
parcelHelpers.export(exports, "kebabCase", ()=>kebabCase);
parcelHelpers.export(exports, "lowerCase", ()=>lowerCase);
parcelHelpers.export(exports, "snakeCase", ()=>snakeCase);
parcelHelpers.export(exports, "upperCase", ()=>upperCase);
parcelHelpers.export(exports, "within", ()=>within);
parcelHelpers.export(exports, "fromJson", ()=>fromJson);
var _arrayJs = require("../Array.js");
var _contextJs = require("../Context.js");
var _eitherJs = require("../Either.js");
var _functionJs = require("../Function.js");
var _hashMapJs = require("../HashMap.js");
var _hashSetJs = require("../HashSet.js");
var _numberJs = require("../Number.js");
var _optionJs = require("../Option.js");
var _pipeableJs = require("../Pipeable.js");
var _predicateJs = require("../Predicate.js");
var _regExpJs = require("../RegExp.js");
var _configErrorJs = require("./configError.js");
var _pathPatchJs = require("./configProvider/pathPatch.js");
var _coreJs = require("./core.js");
var _configJs = require("./opCodes/config.js");
var _stringUtilsJs = require("./string-utils.js");
const concat = (l, r)=>[
        ...l,
        ...r
    ];
/** @internal */ const ConfigProviderSymbolKey = "effect/ConfigProvider";
const ConfigProviderTypeId = /*#__PURE__*/ Symbol.for(ConfigProviderSymbolKey);
const configProviderTag = /*#__PURE__*/ _contextJs.GenericTag("effect/ConfigProvider");
/** @internal */ const FlatConfigProviderSymbolKey = "effect/ConfigProviderFlat";
const FlatConfigProviderTypeId = /*#__PURE__*/ Symbol.for(FlatConfigProviderSymbolKey);
const make = (options)=>({
        [ConfigProviderTypeId]: ConfigProviderTypeId,
        pipe () {
            return (0, _pipeableJs.pipeArguments)(this, arguments);
        },
        ...options
    });
const makeFlat = (options)=>({
        [FlatConfigProviderTypeId]: FlatConfigProviderTypeId,
        patch: options.patch,
        load: (path, config, split = true)=>options.load(path, config, split),
        enumerateChildren: options.enumerateChildren
    });
const fromFlat = (flat)=>make({
        load: (config)=>_coreJs.flatMap(fromFlatLoop(flat, _arrayJs.empty(), config, false), (chunk)=>_optionJs.match(_arrayJs.head(chunk), {
                    onNone: ()=>_coreJs.fail(_configErrorJs.MissingData(_arrayJs.empty(), `Expected a single value having structure: ${config}`)),
                    onSome: _coreJs.succeed
                })),
        flattened: flat
    });
const fromEnv = (options)=>{
    const { pathDelim, seqDelim } = Object.assign({}, {
        pathDelim: "_",
        seqDelim: ","
    }, options);
    const makePathString = (path)=>(0, _functionJs.pipe)(path, _arrayJs.join(pathDelim));
    const unmakePathString = (pathString)=>pathString.split(pathDelim);
    const getEnv = ()=>({});
    const load = (path, primitive, split = true)=>{
        const pathString = makePathString(path);
        const current = getEnv();
        const valueOpt = pathString in current ? _optionJs.some(current[pathString]) : _optionJs.none();
        return (0, _functionJs.pipe)(valueOpt, _coreJs.mapError(()=>_configErrorJs.MissingData(path, `Expected ${pathString} to exist in the process context`)), _coreJs.flatMap((value)=>parsePrimitive(value, path, primitive, seqDelim, split)));
    };
    const enumerateChildren = (path)=>_coreJs.sync(()=>{
            const current = getEnv();
            const keys = Object.keys(current);
            const keyPaths = keys.map((value)=>unmakePathString(value.toUpperCase()));
            const filteredKeyPaths = keyPaths.filter((keyPath)=>{
                for(let i = 0; i < path.length; i++){
                    const pathComponent = (0, _functionJs.pipe)(path, _arrayJs.unsafeGet(i));
                    const currentElement = keyPath[i];
                    if (currentElement === undefined || pathComponent !== currentElement) return false;
                }
                return true;
            }).flatMap((keyPath)=>keyPath.slice(path.length, path.length + 1));
            return _hashSetJs.fromIterable(filteredKeyPaths);
        });
    return fromFlat(makeFlat({
        load,
        enumerateChildren,
        patch: _pathPatchJs.empty
    }));
};
const fromMap = (map, config)=>{
    const { pathDelim, seqDelim } = Object.assign({
        seqDelim: ",",
        pathDelim: "."
    }, config);
    const makePathString = (path)=>(0, _functionJs.pipe)(path, _arrayJs.join(pathDelim));
    const unmakePathString = (pathString)=>pathString.split(pathDelim);
    const mapWithIndexSplit = splitIndexInKeys(map, (str)=>unmakePathString(str), makePathString);
    const load = (path, primitive, split = true)=>{
        const pathString = makePathString(path);
        const valueOpt = mapWithIndexSplit.has(pathString) ? _optionJs.some(mapWithIndexSplit.get(pathString)) : _optionJs.none();
        return (0, _functionJs.pipe)(valueOpt, _coreJs.mapError(()=>_configErrorJs.MissingData(path, `Expected ${pathString} to exist in the provided map`)), _coreJs.flatMap((value)=>parsePrimitive(value, path, primitive, seqDelim, split)));
    };
    const enumerateChildren = (path)=>_coreJs.sync(()=>{
            const keyPaths = _arrayJs.fromIterable(mapWithIndexSplit.keys()).map(unmakePathString);
            const filteredKeyPaths = keyPaths.filter((keyPath)=>{
                for(let i = 0; i < path.length; i++){
                    const pathComponent = (0, _functionJs.pipe)(path, _arrayJs.unsafeGet(i));
                    const currentElement = keyPath[i];
                    if (currentElement === undefined || pathComponent !== currentElement) return false;
                }
                return true;
            }).flatMap((keyPath)=>keyPath.slice(path.length, path.length + 1));
            return _hashSetJs.fromIterable(filteredKeyPaths);
        });
    return fromFlat(makeFlat({
        load,
        enumerateChildren,
        patch: _pathPatchJs.empty
    }));
};
const extend = (leftDef, rightDef, left, right)=>{
    const leftPad = _arrayJs.unfold(left.length, (index)=>index >= right.length ? _optionJs.none() : _optionJs.some([
            leftDef(index),
            index + 1
        ]));
    const rightPad = _arrayJs.unfold(right.length, (index)=>index >= left.length ? _optionJs.none() : _optionJs.some([
            rightDef(index),
            index + 1
        ]));
    const leftExtension = concat(left, leftPad);
    const rightExtension = concat(right, rightPad);
    return [
        leftExtension,
        rightExtension
    ];
};
const appendConfigPath = (path, config)=>{
    let op = config;
    if (op._tag === "Nested") {
        const out = path.slice();
        while(op._tag === "Nested"){
            out.push(op.name);
            op = op.config;
        }
        return out;
    }
    return path;
};
const fromFlatLoop = (flat, prefix, config, split)=>{
    const op = config;
    switch(op._tag){
        case _configJs.OP_CONSTANT:
            return _coreJs.succeed(_arrayJs.of(op.value));
        case _configJs.OP_DESCRIBED:
            return _coreJs.suspend(()=>fromFlatLoop(flat, prefix, op.config, split));
        case _configJs.OP_FAIL:
            return _coreJs.fail(_configErrorJs.MissingData(prefix, op.message));
        case _configJs.OP_FALLBACK:
            return (0, _functionJs.pipe)(_coreJs.suspend(()=>fromFlatLoop(flat, prefix, op.first, split)), _coreJs.catchAll((error1)=>{
                if (op.condition(error1)) return (0, _functionJs.pipe)(fromFlatLoop(flat, prefix, op.second, split), _coreJs.catchAll((error2)=>_coreJs.fail(_configErrorJs.Or(error1, error2))));
                return _coreJs.fail(error1);
            }));
        case _configJs.OP_LAZY:
            return _coreJs.suspend(()=>fromFlatLoop(flat, prefix, op.config(), split));
        case _configJs.OP_MAP_OR_FAIL:
            return _coreJs.suspend(()=>(0, _functionJs.pipe)(fromFlatLoop(flat, prefix, op.original, split), _coreJs.flatMap(_coreJs.forEachSequential((a)=>(0, _functionJs.pipe)(op.mapOrFail(a), _coreJs.mapError(_configErrorJs.prefixed(appendConfigPath(prefix, op.original))))))));
        case _configJs.OP_NESTED:
            return _coreJs.suspend(()=>fromFlatLoop(flat, concat(prefix, _arrayJs.of(op.name)), op.config, split));
        case _configJs.OP_PRIMITIVE:
            return (0, _functionJs.pipe)(_pathPatchJs.patch(prefix, flat.patch), _coreJs.flatMap((prefix)=>(0, _functionJs.pipe)(flat.load(prefix, op, split), _coreJs.flatMap((values)=>{
                    if (values.length === 0) {
                        const name = (0, _functionJs.pipe)(_arrayJs.last(prefix), _optionJs.getOrElse(()=>"<n/a>"));
                        return _coreJs.fail(_configErrorJs.MissingData([], `Expected ${op.description} with name ${name}`));
                    }
                    return _coreJs.succeed(values);
                }))));
        case _configJs.OP_SEQUENCE:
            return (0, _functionJs.pipe)(_pathPatchJs.patch(prefix, flat.patch), _coreJs.flatMap((patchedPrefix)=>(0, _functionJs.pipe)(flat.enumerateChildren(patchedPrefix), _coreJs.flatMap(indicesFrom), _coreJs.flatMap((indices)=>{
                    if (indices.length === 0) return _coreJs.suspend(()=>_coreJs.map(fromFlatLoop(flat, prefix, op.config, true), _arrayJs.of));
                    return (0, _functionJs.pipe)(_coreJs.forEachSequential(indices, (index)=>fromFlatLoop(flat, _arrayJs.append(prefix, `[${index}]`), op.config, true)), _coreJs.map((chunkChunk)=>{
                        const flattened = _arrayJs.flatten(chunkChunk);
                        if (flattened.length === 0) return _arrayJs.of(_arrayJs.empty());
                        return _arrayJs.of(flattened);
                    }));
                }))));
        case _configJs.OP_HASHMAP:
            return _coreJs.suspend(()=>(0, _functionJs.pipe)(_pathPatchJs.patch(prefix, flat.patch), _coreJs.flatMap((prefix)=>(0, _functionJs.pipe)(flat.enumerateChildren(prefix), _coreJs.flatMap((keys)=>{
                        return (0, _functionJs.pipe)(keys, _coreJs.forEachSequential((key)=>fromFlatLoop(flat, concat(prefix, _arrayJs.of(key)), op.valueConfig, split)), _coreJs.map((matrix)=>{
                            if (matrix.length === 0) return _arrayJs.of(_hashMapJs.empty());
                            return (0, _functionJs.pipe)(transpose(matrix), _arrayJs.map((values)=>_hashMapJs.fromIterable(_arrayJs.zip(_arrayJs.fromIterable(keys), values))));
                        }));
                    })))));
        case _configJs.OP_ZIP_WITH:
            return _coreJs.suspend(()=>(0, _functionJs.pipe)(fromFlatLoop(flat, prefix, op.left, split), _coreJs.either, _coreJs.flatMap((left)=>(0, _functionJs.pipe)(fromFlatLoop(flat, prefix, op.right, split), _coreJs.either, _coreJs.flatMap((right)=>{
                        if (_eitherJs.isLeft(left) && _eitherJs.isLeft(right)) return _coreJs.fail(_configErrorJs.And(left.left, right.left));
                        if (_eitherJs.isLeft(left) && _eitherJs.isRight(right)) return _coreJs.fail(left.left);
                        if (_eitherJs.isRight(left) && _eitherJs.isLeft(right)) return _coreJs.fail(right.left);
                        if (_eitherJs.isRight(left) && _eitherJs.isRight(right)) {
                            const path = (0, _functionJs.pipe)(prefix, _arrayJs.join("."));
                            const fail = fromFlatLoopFail(prefix, path);
                            const [lefts, rights] = extend(fail, fail, (0, _functionJs.pipe)(left.right, _arrayJs.map(_eitherJs.right)), (0, _functionJs.pipe)(right.right, _arrayJs.map(_eitherJs.right)));
                            return (0, _functionJs.pipe)(lefts, _arrayJs.zip(rights), _coreJs.forEachSequential(([left, right])=>(0, _functionJs.pipe)(_coreJs.zip(left, right), _coreJs.map(([left, right])=>op.zip(left, right)))));
                        }
                        throw new Error("BUG: ConfigProvider.fromFlatLoop - please report an issue at https://github.com/Effect-TS/effect/issues");
                    })))));
    }
};
const fromFlatLoopFail = (prefix, path)=>(index)=>_eitherJs.left(_configErrorJs.MissingData(prefix, `The element at index ${index} in a sequence at path "${path}" was missing`));
const mapInputPath = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>fromFlat(mapInputPathFlat(self.flattened, f)));
const mapInputPathFlat = (self, f)=>makeFlat({
        load: (path, config, split = true)=>self.load(path, config, split),
        enumerateChildren: (path)=>self.enumerateChildren(path),
        patch: _pathPatchJs.mapName(self.patch, f)
    });
const nested = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, name)=>fromFlat(makeFlat({
        load: (path, config)=>self.flattened.load(path, config, true),
        enumerateChildren: (path)=>self.flattened.enumerateChildren(path),
        patch: _pathPatchJs.nested(self.flattened.patch, name)
    })));
const unnested = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, name)=>fromFlat(makeFlat({
        load: (path, config)=>self.flattened.load(path, config, true),
        enumerateChildren: (path)=>self.flattened.enumerateChildren(path),
        patch: _pathPatchJs.unnested(self.flattened.patch, name)
    })));
const orElse = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>fromFlat(orElseFlat(self.flattened, ()=>that().flattened)));
const orElseFlat = (self, that)=>makeFlat({
        load: (path, config, split)=>(0, _functionJs.pipe)(_pathPatchJs.patch(path, self.patch), _coreJs.flatMap((patch)=>self.load(patch, config, split)), _coreJs.catchAll((error1)=>(0, _functionJs.pipe)(_coreJs.sync(that), _coreJs.flatMap((that)=>(0, _functionJs.pipe)(_pathPatchJs.patch(path, that.patch), _coreJs.flatMap((patch)=>that.load(patch, config, split)), _coreJs.catchAll((error2)=>_coreJs.fail(_configErrorJs.Or(error1, error2)))))))),
        enumerateChildren: (path)=>(0, _functionJs.pipe)(_pathPatchJs.patch(path, self.patch), _coreJs.flatMap((patch)=>self.enumerateChildren(patch)), _coreJs.either, _coreJs.flatMap((left)=>(0, _functionJs.pipe)(_coreJs.sync(that), _coreJs.flatMap((that)=>(0, _functionJs.pipe)(_pathPatchJs.patch(path, that.patch), _coreJs.flatMap((patch)=>that.enumerateChildren(patch)), _coreJs.either, _coreJs.flatMap((right)=>{
                        if (_eitherJs.isLeft(left) && _eitherJs.isLeft(right)) return _coreJs.fail(_configErrorJs.And(left.left, right.left));
                        if (_eitherJs.isLeft(left) && _eitherJs.isRight(right)) return _coreJs.succeed(right.right);
                        if (_eitherJs.isRight(left) && _eitherJs.isLeft(right)) return _coreJs.succeed(left.right);
                        if (_eitherJs.isRight(left) && _eitherJs.isRight(right)) return _coreJs.succeed((0, _functionJs.pipe)(left.right, _hashSetJs.union(right.right)));
                        throw new Error("BUG: ConfigProvider.orElseFlat - please report an issue at https://github.com/Effect-TS/effect/issues");
                    })))))),
        patch: _pathPatchJs.empty
    });
const constantCase = (self)=>mapInputPath(self, _stringUtilsJs.constantCase);
const kebabCase = (self)=>mapInputPath(self, _stringUtilsJs.kebabCase);
const lowerCase = (self)=>mapInputPath(self, _stringUtilsJs.lowerCase);
const snakeCase = (self)=>mapInputPath(self, _stringUtilsJs.snakeCase);
const upperCase = (self)=>mapInputPath(self, _stringUtilsJs.upperCase);
const within = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, path, f)=>{
    const unnest = _arrayJs.reduce(path, self, (provider, name)=>unnested(provider, name));
    const nest = _arrayJs.reduceRight(path, f(unnest), (provider, name)=>nested(provider, name));
    return orElse(nest, ()=>self);
});
const splitPathString = (text, delim)=>{
    const split = text.split(new RegExp(`\\s*${_regExpJs.escape(delim)}\\s*`));
    return split;
};
const parsePrimitive = (text, path, primitive, delimiter, split)=>{
    if (!split) return (0, _functionJs.pipe)(primitive.parse(text), _coreJs.mapBoth({
        onFailure: _configErrorJs.prefixed(path),
        onSuccess: _arrayJs.of
    }));
    return (0, _functionJs.pipe)(splitPathString(text, delimiter), _coreJs.forEachSequential((char)=>primitive.parse(char.trim())), _coreJs.mapError(_configErrorJs.prefixed(path)));
};
const transpose = (array)=>{
    return Object.keys(array[0]).map((column)=>array.map((row)=>row[column]));
};
const indicesFrom = (quotedIndices)=>(0, _functionJs.pipe)(_coreJs.forEachSequential(quotedIndices, parseQuotedIndex), _coreJs.mapBoth({
        onFailure: ()=>_arrayJs.empty(),
        onSuccess: _arrayJs.sort(_numberJs.Order)
    }), _coreJs.either, _coreJs.map(_eitherJs.merge));
const STR_INDEX_REGEX = /(^.+)(\[(\d+)\])$/;
const QUOTED_INDEX_REGEX = /^(\[(\d+)\])$/;
const parseQuotedIndex = (str)=>{
    const match = str.match(QUOTED_INDEX_REGEX);
    if (match !== null) {
        const matchedIndex = match[2];
        return (0, _functionJs.pipe)(matchedIndex !== undefined && matchedIndex.length > 0 ? _optionJs.some(matchedIndex) : _optionJs.none(), _optionJs.flatMap(parseInteger));
    }
    return _optionJs.none();
};
const splitIndexInKeys = (map, unmakePathString, makePathString)=>{
    const newMap = new Map();
    for (const [pathString, value] of map){
        const keyWithIndex = (0, _functionJs.pipe)(unmakePathString(pathString), _arrayJs.flatMap((key)=>_optionJs.match(splitIndexFrom(key), {
                onNone: ()=>_arrayJs.of(key),
                onSome: ([key, index])=>_arrayJs.make(key, `[${index}]`)
            })));
        newMap.set(makePathString(keyWithIndex), value);
    }
    return newMap;
};
const splitIndexFrom = (key)=>{
    const match = key.match(STR_INDEX_REGEX);
    if (match !== null) {
        const matchedString = match[1];
        const matchedIndex = match[3];
        const optionalString = matchedString !== undefined && matchedString.length > 0 ? _optionJs.some(matchedString) : _optionJs.none();
        const optionalIndex = (0, _functionJs.pipe)(matchedIndex !== undefined && matchedIndex.length > 0 ? _optionJs.some(matchedIndex) : _optionJs.none(), _optionJs.flatMap(parseInteger));
        return _optionJs.all([
            optionalString,
            optionalIndex
        ]);
    }
    return _optionJs.none();
};
const parseInteger = (str)=>{
    const parsedIndex = Number.parseInt(str);
    return Number.isNaN(parsedIndex) ? _optionJs.none() : _optionJs.some(parsedIndex);
};
const keyName = (name)=>({
        _tag: "KeyName",
        name
    });
const keyIndex = (index)=>({
        _tag: "KeyIndex",
        index
    });
const fromJson = (json)=>{
    const hiddenDelimiter = "\ufeff";
    const indexedEntries = _arrayJs.map(getIndexedEntries(json), ([key, value])=>[
            configPathToString(key).join(hiddenDelimiter),
            value
        ]);
    return fromMap(new Map(indexedEntries), {
        pathDelim: hiddenDelimiter,
        seqDelim: hiddenDelimiter
    });
};
const configPathToString = (path)=>{
    const output = [];
    let i = 0;
    while(i < path.length){
        const component = path[i];
        if (component._tag === "KeyName") {
            if (i + 1 < path.length) {
                const nextComponent = path[i + 1];
                if (nextComponent._tag === "KeyIndex") {
                    output.push(`${component.name}[${nextComponent.index}]`);
                    i += 2;
                } else {
                    output.push(component.name);
                    i += 1;
                }
            } else {
                output.push(component.name);
                i += 1;
            }
        }
    }
    return output;
};
const getIndexedEntries = (config)=>{
    const loopAny = (path, value)=>{
        if (typeof value === "string") return _arrayJs.make([
            path,
            value
        ]);
        if (typeof value === "number" || typeof value === "boolean") return _arrayJs.make([
            path,
            String(value)
        ]);
        if (_arrayJs.isArray(value)) return loopArray(path, value);
        if (typeof value === "object" && value !== null) return loopObject(path, value);
        return _arrayJs.empty();
    };
    const loopArray = (path, values)=>_arrayJs.match(values, {
            onEmpty: ()=>_arrayJs.make([
                    path,
                    "<nil>"
                ]),
            onNonEmpty: _arrayJs.flatMap((value, index)=>loopAny(_arrayJs.append(path, keyIndex(index)), value))
        });
    const loopObject = (path, value)=>Object.entries(value).filter(([, value])=>_predicateJs.isNotNullable(value)).flatMap(([key, value])=>{
            const newPath = _arrayJs.append(path, keyName(key));
            const result = loopAny(newPath, value);
            if (_arrayJs.isEmptyReadonlyArray(result)) return _arrayJs.make([
                newPath,
                ""
            ]);
            return result;
        });
    return loopObject(_arrayJs.empty(), config);
};

},{"../Array.js":"8L2Gk","../Context.js":"c2abN","../Either.js":"4amnT","../Function.js":"21gOL","../HashMap.js":"aG8zS","../HashSet.js":"aKFFV","../Number.js":"al4Y3","../Option.js":"6sHA7","../Pipeable.js":"b5RU2","../Predicate.js":"gW5pd","../RegExp.js":"aPf0s","./configError.js":"k3YwG","./configProvider/pathPatch.js":"9rcCs","./core.js":"cr3YV","./opCodes/config.js":"jGvcZ","./string-utils.js":"klLi4","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"al4Y3":[function(require,module,exports,__globalThis) {
/**
 * # Number
 *
 * This module provides utility functions and type class instances for working
 * with the `number` type in TypeScript. It includes functions for basic
 * arithmetic operations, as well as type class instances for `Equivalence` and
 * `Order`.
 *
 * ## Operations Reference
 *
 * | Category     | Operation                                  | Description                                             | Domain                         | Co-domain             |
 * | ------------ | ------------------------------------------ | ------------------------------------------------------- | ------------------------------ | --------------------- |
 * | constructors | {@link module:Number.parse}                | Safely parses a string to a number                      | `string`                       | `Option<number>`      |
 * |              |                                            |                                                         |                                |                       |
 * | math         | {@link module:Number.sum}                  | Adds two numbers                                        | `number`, `number`             | `number`              |
 * | math         | {@link module:Number.sumAll}               | Sums all numbers in a collection                        | `Iterable<number>`             | `number`              |
 * | math         | {@link module:Number.subtract}             | Subtracts one number from another                       | `number`, `number`             | `number`              |
 * | math         | {@link module:Number.multiply}             | Multiplies two numbers                                  | `number`, `number`             | `number`              |
 * | math         | {@link module:Number.multiplyAll}          | Multiplies all numbers in a collection                  | `Iterable<number>`             | `number`              |
 * | math         | {@link module:Number.divide}               | Safely divides handling division by zero                | `number`, `number`             | `Option<number>`      |
 * | math         | {@link module:Number.unsafeDivide}         | Divides but misbehaves for division by zero             | `number`, `number`             | `number`              |
 * | math         | {@link module:Number.remainder}            | Calculates remainder of division                        | `number`, `number`             | `number`              |
 * | math         | {@link module:Number.increment}            | Adds 1 to a number                                      | `number`                       | `number`              |
 * | math         | {@link module:Number.decrement}            | Subtracts 1 from a number                               | `number`                       | `number`              |
 * | math         | {@link module:Number.sign}                 | Determines the sign of a number                         | `number`                       | `Ordering`            |
 * | math         | {@link module:Number.nextPow2}             | Finds the next power of 2                               | `number`                       | `number`              |
 * | math         | {@link module:Number.round}                | Rounds a number with specified precision                | `number`, `number`             | `number`              |
 * |              |                                            |                                                         |                                |                       |
 * | predicates   | {@link module:Number.between}              | Checks if a number is in a range                        | `number`, `{minimum, maximum}` | `boolean`             |
 * | predicates   | {@link module:Number.lessThan}             | Checks if one number is less than another               | `number`, `number`             | `boolean`             |
 * | predicates   | {@link module:Number.lessThanOrEqualTo}    | Checks if one number is less than or equal              | `number`, `number`             | `boolean`             |
 * | predicates   | {@link module:Number.greaterThan}          | Checks if one number is greater than another            | `number`, `number`             | `boolean`             |
 * | predicates   | {@link module:Number.greaterThanOrEqualTo} | Checks if one number is greater or equal                | `number`, `number`             | `boolean`             |
 * |              |                                            |                                                         |                                |                       |
 * | guards       | {@link module:Number.isNumber}             | Type guard for JavaScript numbers                       | `unknown`                      | `boolean`             |
 * |              |                                            |                                                         |                                |                       |
 * | comparison   | {@link module:Number.min}                  | Returns the minimum of two numbers                      | `number`, `number`             | `number`              |
 * | comparison   | {@link module:Number.max}                  | Returns the maximum of two numbers                      | `number`, `number`             | `number`              |
 * | comparison   | {@link module:Number.clamp}                | Restricts a number to a range                           | `number`, `{minimum, maximum}` | `number`              |
 * |              |                                            |                                                         |                                |                       |
 * | instances    | {@link module:Number.Equivalence}          | Equivalence instance for numbers                        |                                | `Equivalence<number>` |
 * | instances    | {@link module:Number.Order}                | Order instance for numbers                              |                                | `Order<number>`       |
 * |              |                                            |                                                         |                                |                       |
 * | errors       | {@link module:Number.DivisionByZeroError}  | Error thrown by unsafeDivide                            |                                |                       |
 *
 * ## Composition Patterns and Type Safety
 *
 * When building function pipelines, understanding how types flow through
 * operations is critical:
 *
 * ### Composing with type-preserving operations
 *
 * Most operations in this module are type-preserving (`number → number`),
 * making them easily composable in pipelines:
 *
 * ```ts
 * import { pipe } from "effect"
 * import * as Number from "effect/Number"
 *
 * const result = pipe(
 *   10,
 *   Number.increment, // number → number
 *   Number.multiply(2), // number → number
 *   Number.round(1) // number → number
 * ) // Result: number (21)
 * ```
 *
 * ### Working with Option results
 *
 * Operations that might fail (like division by zero) return Option types and
 * require Option combinators:
 *
 * ```ts
 * import { pipe, Option } from "effect"
 * import * as Number from "effect/Number"
 *
 * const result = pipe(
 *   10,
 *   Number.divide(0), // number → Option<number>
 *   Option.getOrElse(() => 0) // Option<number> → number
 * ) // Result: number (0)
 * ```
 *
 * ### Composition best practices
 *
 * - Chain type-preserving operations for maximum composability
 * - Use Option combinators when working with potentially failing operations
 * - Consider using Effect for operations that might fail with specific errors
 * - Remember that all operations maintain JavaScript's floating-point precision
 *   limitations
 *
 * @module Number
 * @since 2.0.0
 * @see {@link module:BigInt} for more similar operations on `bigint` types
 * @see {@link module:BigDecimal} for more similar operations on `BigDecimal` types
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isNumber", ()=>isNumber);
parcelHelpers.export(exports, "negate", ()=>negate);
parcelHelpers.export(exports, "sum", ()=>sum);
parcelHelpers.export(exports, "sumAll", ()=>sumAll);
parcelHelpers.export(exports, "subtract", ()=>subtract);
parcelHelpers.export(exports, "multiply", ()=>multiply);
parcelHelpers.export(exports, "multiplyAll", ()=>multiplyAll);
parcelHelpers.export(exports, "divide", ()=>divide);
parcelHelpers.export(exports, "unsafeDivide", ()=>unsafeDivide);
parcelHelpers.export(exports, "increment", ()=>increment);
parcelHelpers.export(exports, "decrement", ()=>decrement);
parcelHelpers.export(exports, "Equivalence", ()=>Equivalence);
parcelHelpers.export(exports, "Order", ()=>Order);
parcelHelpers.export(exports, "lessThan", ()=>lessThan);
parcelHelpers.export(exports, "lessThanOrEqualTo", ()=>lessThanOrEqualTo);
parcelHelpers.export(exports, "greaterThan", ()=>greaterThan);
parcelHelpers.export(exports, "greaterThanOrEqualTo", ()=>greaterThanOrEqualTo);
parcelHelpers.export(exports, "between", ()=>between);
parcelHelpers.export(exports, "clamp", ()=>clamp);
parcelHelpers.export(exports, "min", ()=>min);
parcelHelpers.export(exports, "max", ()=>max);
parcelHelpers.export(exports, "sign", ()=>sign);
parcelHelpers.export(exports, "remainder", ()=>remainder);
parcelHelpers.export(exports, "nextPow2", ()=>nextPow2);
parcelHelpers.export(exports, "parse", ()=>parse);
parcelHelpers.export(exports, "round", ()=>round);
var _equivalenceJs = require("./Equivalence.js");
var _functionJs = require("./Function.js");
var _optionJs = require("./internal/option.js");
var _iterableJs = require("./Iterable.js");
var _orderJs = require("./Order.js");
var _predicateJs = require("./Predicate.js");
const isNumber = _predicateJs.isNumber;
const negate = (n)=>multiply(n, -1);
const sum = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>self + that);
const sumAll = (collection)=>_iterableJs.reduce(collection, 0, sum);
const subtract = /*#__PURE__*/ (0, _functionJs.dual)(2, (minuend, subtrahend)=>minuend - subtrahend);
const multiply = /*#__PURE__*/ (0, _functionJs.dual)(2, (multiplier, multiplicand)=>multiplier * multiplicand);
const multiplyAll = (collection)=>{
    let out = 1;
    for (const n of collection){
        if (n === 0) return 0;
        out *= n;
    }
    return out;
};
const divide = /*#__PURE__*/ (0, _functionJs.dual)(2, (dividend, divisor)=>divisor === 0 ? _optionJs.none : _optionJs.some(dividend / divisor));
const unsafeDivide = /*#__PURE__*/ (0, _functionJs.dual)(2, (dividend, divisor)=>dividend / divisor);
const increment = (n)=>sum(n, 1);
const decrement = (n)=>subtract(n, 1);
const Equivalence = _equivalenceJs.number;
const Order = _orderJs.number;
const lessThan = /*#__PURE__*/ _orderJs.lessThan(Order);
const lessThanOrEqualTo = /*#__PURE__*/ _orderJs.lessThanOrEqualTo(Order);
const greaterThan = /*#__PURE__*/ _orderJs.greaterThan(Order);
const greaterThanOrEqualTo = /*#__PURE__*/ _orderJs.greaterThanOrEqualTo(Order);
const between = /*#__PURE__*/ _orderJs.between(Order);
const clamp = /*#__PURE__*/ _orderJs.clamp(Order);
const min = /*#__PURE__*/ _orderJs.min(Order);
const max = /*#__PURE__*/ _orderJs.max(Order);
const sign = (n)=>Order(n, 0);
const remainder = /*#__PURE__*/ (0, _functionJs.dual)(2, (dividend, divisor)=>{
    // https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034
    const selfDecCount = (dividend.toString().split(".")[1] || "").length;
    const divisorDecCount = (divisor.toString().split(".")[1] || "").length;
    const decCount = selfDecCount > divisorDecCount ? selfDecCount : divisorDecCount;
    const selfInt = parseInt(dividend.toFixed(decCount).replace(".", ""));
    const divisorInt = parseInt(divisor.toFixed(decCount).replace(".", ""));
    return selfInt % divisorInt / Math.pow(10, decCount);
});
const nextPow2 = (n)=>{
    const nextPow = Math.ceil(Math.log(n) / Math.log(2));
    return Math.max(Math.pow(2, nextPow), 2);
};
const parse = (s)=>{
    if (s === "NaN") return _optionJs.some(NaN);
    if (s === "Infinity") return _optionJs.some(Infinity);
    if (s === "-Infinity") return _optionJs.some(-Infinity);
    if (s.trim() === "") return _optionJs.none;
    const n = Number(s);
    return Number.isNaN(n) ? _optionJs.none : _optionJs.some(n);
};
const round = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, precision)=>{
    const factor = Math.pow(10, precision);
    return Math.round(self * factor) / factor;
});

},{"./Equivalence.js":"1WBUa","./Function.js":"21gOL","./internal/option.js":"c4fL5","./Iterable.js":"dJ2mI","./Order.js":"lQMwD","./Predicate.js":"gW5pd","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"aPf0s":[function(require,module,exports,__globalThis) {
/**
 * This module provides utility functions for working with RegExp in TypeScript.
 *
 * @since 2.0.0
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isRegExp", ()=>isRegExp);
parcelHelpers.export(exports, "escape", ()=>escape);
var _predicateJs = require("./Predicate.js");
const isRegExp = _predicateJs.isRegExp;
const escape = (string)=>string.replace(/[/\\^$*+?.()|[\]{}]/g, "\\$&");

},{"./Predicate.js":"gW5pd","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"k3YwG":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ConfigErrorTypeId", ()=>ConfigErrorTypeId);
parcelHelpers.export(exports, "proto", ()=>proto);
parcelHelpers.export(exports, "And", ()=>And);
parcelHelpers.export(exports, "Or", ()=>Or);
parcelHelpers.export(exports, "InvalidData", ()=>InvalidData);
parcelHelpers.export(exports, "MissingData", ()=>MissingData);
parcelHelpers.export(exports, "SourceUnavailable", ()=>SourceUnavailable);
parcelHelpers.export(exports, "Unsupported", ()=>Unsupported);
parcelHelpers.export(exports, "isConfigError", ()=>isConfigError);
parcelHelpers.export(exports, "isAnd", ()=>isAnd);
parcelHelpers.export(exports, "isOr", ()=>isOr);
parcelHelpers.export(exports, "isInvalidData", ()=>isInvalidData);
parcelHelpers.export(exports, "isMissingData", ()=>isMissingData);
parcelHelpers.export(exports, "isSourceUnavailable", ()=>isSourceUnavailable);
parcelHelpers.export(exports, "isUnsupported", ()=>isUnsupported);
parcelHelpers.export(exports, "prefixed", ()=>prefixed);
parcelHelpers.export(exports, "reduceWithContext", ()=>reduceWithContext);
parcelHelpers.export(exports, "isMissingDataOnly", ()=>isMissingDataOnly);
var _arrayJs = require("../Array.js");
var _eitherJs = require("../Either.js");
var _functionJs = require("../Function.js");
var _predicateJs = require("../Predicate.js");
var _configErrorJs = require("./opCodes/configError.js");
/** @internal */ const ConfigErrorSymbolKey = "effect/ConfigError";
const ConfigErrorTypeId = /*#__PURE__*/ Symbol.for(ConfigErrorSymbolKey);
const proto = {
    _tag: "ConfigError",
    [ConfigErrorTypeId]: ConfigErrorTypeId
};
const And = (self, that)=>{
    const error = Object.create(proto);
    error._op = _configErrorJs.OP_AND;
    error.left = self;
    error.right = that;
    Object.defineProperty(error, "toString", {
        enumerable: false,
        value () {
            return `${this.left} and ${this.right}`;
        }
    });
    return error;
};
const Or = (self, that)=>{
    const error = Object.create(proto);
    error._op = _configErrorJs.OP_OR;
    error.left = self;
    error.right = that;
    Object.defineProperty(error, "toString", {
        enumerable: false,
        value () {
            return `${this.left} or ${this.right}`;
        }
    });
    return error;
};
const InvalidData = (path, message, options = {
    pathDelim: "."
})=>{
    const error = Object.create(proto);
    error._op = _configErrorJs.OP_INVALID_DATA;
    error.path = path;
    error.message = message;
    Object.defineProperty(error, "toString", {
        enumerable: false,
        value () {
            const path = (0, _functionJs.pipe)(this.path, _arrayJs.join(options.pathDelim));
            return `(Invalid data at ${path}: "${this.message}")`;
        }
    });
    return error;
};
const MissingData = (path, message, options = {
    pathDelim: "."
})=>{
    const error = Object.create(proto);
    error._op = _configErrorJs.OP_MISSING_DATA;
    error.path = path;
    error.message = message;
    Object.defineProperty(error, "toString", {
        enumerable: false,
        value () {
            const path = (0, _functionJs.pipe)(this.path, _arrayJs.join(options.pathDelim));
            return `(Missing data at ${path}: "${this.message}")`;
        }
    });
    return error;
};
const SourceUnavailable = (path, message, cause, options = {
    pathDelim: "."
})=>{
    const error = Object.create(proto);
    error._op = _configErrorJs.OP_SOURCE_UNAVAILABLE;
    error.path = path;
    error.message = message;
    error.cause = cause;
    Object.defineProperty(error, "toString", {
        enumerable: false,
        value () {
            const path = (0, _functionJs.pipe)(this.path, _arrayJs.join(options.pathDelim));
            return `(Source unavailable at ${path}: "${this.message}")`;
        }
    });
    return error;
};
const Unsupported = (path, message, options = {
    pathDelim: "."
})=>{
    const error = Object.create(proto);
    error._op = _configErrorJs.OP_UNSUPPORTED;
    error.path = path;
    error.message = message;
    Object.defineProperty(error, "toString", {
        enumerable: false,
        value () {
            const path = (0, _functionJs.pipe)(this.path, _arrayJs.join(options.pathDelim));
            return `(Unsupported operation at ${path}: "${this.message}")`;
        }
    });
    return error;
};
const isConfigError = (u)=>(0, _predicateJs.hasProperty)(u, ConfigErrorTypeId);
const isAnd = (self)=>self._op === _configErrorJs.OP_AND;
const isOr = (self)=>self._op === _configErrorJs.OP_OR;
const isInvalidData = (self)=>self._op === _configErrorJs.OP_INVALID_DATA;
const isMissingData = (self)=>self._op === _configErrorJs.OP_MISSING_DATA;
const isSourceUnavailable = (self)=>self._op === _configErrorJs.OP_SOURCE_UNAVAILABLE;
const isUnsupported = (self)=>self._op === _configErrorJs.OP_UNSUPPORTED;
const prefixed = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, prefix)=>{
    switch(self._op){
        case _configErrorJs.OP_AND:
            return And(prefixed(self.left, prefix), prefixed(self.right, prefix));
        case _configErrorJs.OP_OR:
            return Or(prefixed(self.left, prefix), prefixed(self.right, prefix));
        case _configErrorJs.OP_INVALID_DATA:
            return InvalidData([
                ...prefix,
                ...self.path
            ], self.message);
        case _configErrorJs.OP_MISSING_DATA:
            return MissingData([
                ...prefix,
                ...self.path
            ], self.message);
        case _configErrorJs.OP_SOURCE_UNAVAILABLE:
            return SourceUnavailable([
                ...prefix,
                ...self.path
            ], self.message, self.cause);
        case _configErrorJs.OP_UNSUPPORTED:
            return Unsupported([
                ...prefix,
                ...self.path
            ], self.message);
    }
});
/** @internal */ const IsMissingDataOnlyReducer = {
    andCase: (_, left, right)=>left && right,
    orCase: (_, left, right)=>left && right,
    invalidDataCase: (0, _functionJs.constFalse),
    missingDataCase: (0, _functionJs.constTrue),
    sourceUnavailableCase: (0, _functionJs.constFalse),
    unsupportedCase: (0, _functionJs.constFalse)
};
const reduceWithContext = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, context, reducer)=>{
    const input = [
        self
    ];
    const output = [];
    while(input.length > 0){
        const error = input.pop();
        switch(error._op){
            case _configErrorJs.OP_AND:
                input.push(error.right);
                input.push(error.left);
                output.push(_eitherJs.left({
                    _op: "AndCase"
                }));
                break;
            case _configErrorJs.OP_OR:
                input.push(error.right);
                input.push(error.left);
                output.push(_eitherJs.left({
                    _op: "OrCase"
                }));
                break;
            case _configErrorJs.OP_INVALID_DATA:
                output.push(_eitherJs.right(reducer.invalidDataCase(context, error.path, error.message)));
                break;
            case _configErrorJs.OP_MISSING_DATA:
                output.push(_eitherJs.right(reducer.missingDataCase(context, error.path, error.message)));
                break;
            case _configErrorJs.OP_SOURCE_UNAVAILABLE:
                output.push(_eitherJs.right(reducer.sourceUnavailableCase(context, error.path, error.message, error.cause)));
                break;
            case _configErrorJs.OP_UNSUPPORTED:
                output.push(_eitherJs.right(reducer.unsupportedCase(context, error.path, error.message)));
                break;
        }
    }
    const accumulator = [];
    while(output.length > 0){
        const either = output.pop();
        switch(either._op){
            case "Left":
                switch(either.left._op){
                    case "AndCase":
                        {
                            const left = accumulator.pop();
                            const right = accumulator.pop();
                            const value = reducer.andCase(context, left, right);
                            accumulator.push(value);
                            break;
                        }
                    case "OrCase":
                        {
                            const left = accumulator.pop();
                            const right = accumulator.pop();
                            const value = reducer.orCase(context, left, right);
                            accumulator.push(value);
                            break;
                        }
                }
                break;
            case "Right":
                accumulator.push(either.right);
                break;
        }
    }
    if (accumulator.length === 0) throw new Error("BUG: ConfigError.reduceWithContext - please report an issue at https://github.com/Effect-TS/effect/issues");
    return accumulator.pop();
});
const isMissingDataOnly = (self)=>reduceWithContext(self, void 0, IsMissingDataOnlyReducer);

},{"../Array.js":"8L2Gk","../Either.js":"4amnT","../Function.js":"21gOL","../Predicate.js":"gW5pd","./opCodes/configError.js":"4Liwv","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"4Liwv":[function(require,module,exports,__globalThis) {
/** @internal */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "OP_AND", ()=>OP_AND);
parcelHelpers.export(exports, "OP_OR", ()=>OP_OR);
parcelHelpers.export(exports, "OP_INVALID_DATA", ()=>OP_INVALID_DATA);
parcelHelpers.export(exports, "OP_MISSING_DATA", ()=>OP_MISSING_DATA);
parcelHelpers.export(exports, "OP_SOURCE_UNAVAILABLE", ()=>OP_SOURCE_UNAVAILABLE);
parcelHelpers.export(exports, "OP_UNSUPPORTED", ()=>OP_UNSUPPORTED);
const OP_AND = "And";
const OP_OR = "Or";
const OP_INVALID_DATA = "InvalidData";
const OP_MISSING_DATA = "MissingData";
const OP_SOURCE_UNAVAILABLE = "SourceUnavailable";
const OP_UNSUPPORTED = "Unsupported";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"9rcCs":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "empty", ()=>empty);
parcelHelpers.export(exports, "andThen", ()=>andThen);
parcelHelpers.export(exports, "mapName", ()=>mapName);
parcelHelpers.export(exports, "nested", ()=>nested);
parcelHelpers.export(exports, "unnested", ()=>unnested);
parcelHelpers.export(exports, "patch", ()=>patch);
var _arrayJs = require("../../Array.js");
var _eitherJs = require("../../Either.js");
var _functionJs = require("../../Function.js");
var _listJs = require("../../List.js");
var _optionJs = require("../../Option.js");
var _configErrorJs = require("../configError.js");
const empty = {
    _tag: "Empty"
};
const andThen = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>({
        _tag: "AndThen",
        first: self,
        second: that
    }));
const mapName = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>andThen(self, {
        _tag: "MapName",
        f
    }));
const nested = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, name)=>andThen(self, {
        _tag: "Nested",
        name
    }));
const unnested = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, name)=>andThen(self, {
        _tag: "Unnested",
        name
    }));
const patch = /*#__PURE__*/ (0, _functionJs.dual)(2, (path, patch)=>{
    let input = _listJs.of(patch);
    let output = path;
    while(_listJs.isCons(input)){
        const patch = input.head;
        switch(patch._tag){
            case "Empty":
                input = input.tail;
                break;
            case "AndThen":
                input = _listJs.cons(patch.first, _listJs.cons(patch.second, input.tail));
                break;
            case "MapName":
                output = _arrayJs.map(output, patch.f);
                input = input.tail;
                break;
            case "Nested":
                output = _arrayJs.prepend(output, patch.name);
                input = input.tail;
                break;
            case "Unnested":
                {
                    const containsName = (0, _functionJs.pipe)(_arrayJs.head(output), _optionJs.contains(patch.name));
                    if (containsName) {
                        output = _arrayJs.tailNonEmpty(output);
                        input = input.tail;
                    } else return _eitherJs.left(_configErrorJs.MissingData(output, `Expected ${patch.name} to be in path in ConfigProvider#unnested`));
                    break;
                }
        }
    }
    return _eitherJs.right(output);
});

},{"../../Array.js":"8L2Gk","../../Either.js":"4amnT","../../Function.js":"21gOL","../../List.js":"a341T","../../Option.js":"6sHA7","../configError.js":"k3YwG","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"jGvcZ":[function(require,module,exports,__globalThis) {
/** @internal */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "OP_CONSTANT", ()=>OP_CONSTANT);
parcelHelpers.export(exports, "OP_FAIL", ()=>OP_FAIL);
parcelHelpers.export(exports, "OP_FALLBACK", ()=>OP_FALLBACK);
parcelHelpers.export(exports, "OP_DESCRIBED", ()=>OP_DESCRIBED);
parcelHelpers.export(exports, "OP_LAZY", ()=>OP_LAZY);
parcelHelpers.export(exports, "OP_MAP_OR_FAIL", ()=>OP_MAP_OR_FAIL);
parcelHelpers.export(exports, "OP_NESTED", ()=>OP_NESTED);
parcelHelpers.export(exports, "OP_PRIMITIVE", ()=>OP_PRIMITIVE);
parcelHelpers.export(exports, "OP_SEQUENCE", ()=>OP_SEQUENCE);
parcelHelpers.export(exports, "OP_HASHMAP", ()=>OP_HASHMAP);
parcelHelpers.export(exports, "OP_ZIP_WITH", ()=>OP_ZIP_WITH);
const OP_CONSTANT = "Constant";
const OP_FAIL = "Fail";
const OP_FALLBACK = "Fallback";
const OP_DESCRIBED = "Described";
const OP_LAZY = "Lazy";
const OP_MAP_OR_FAIL = "MapOrFail";
const OP_NESTED = "Nested";
const OP_PRIMITIVE = "Primitive";
const OP_SEQUENCE = "Sequence";
const OP_HASHMAP = "HashMap";
const OP_ZIP_WITH = "ZipWith";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"klLi4":[function(require,module,exports,__globalThis) {
/**
 * Adapted from the `change-case` library.
 *
 * Copyright (c) 2014 Blake Embrey (hello@blakeembrey.com)
 */ /** @internal */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "lowerCase", ()=>lowerCase);
parcelHelpers.export(exports, "upperCase", ()=>upperCase);
parcelHelpers.export(exports, "pascalCase", ()=>pascalCase);
parcelHelpers.export(exports, "camelCase", ()=>camelCase);
parcelHelpers.export(exports, "constantCase", ()=>constantCase);
parcelHelpers.export(exports, "kebabCase", ()=>kebabCase);
parcelHelpers.export(exports, "snakeCase", ()=>snakeCase);
const lowerCase = (str)=>str.toLowerCase();
const upperCase = (str)=>str.toUpperCase();
/**
 * Replace `re` in the input string with the replacement value.
 */ const replace = (input, re, value)=>re instanceof RegExp ? input.replace(re, value) : re.reduce((input, re)=>input.replace(re, value), input);
// Support camel case ("camelCase" -> "camel Case" and "CAMELCase" -> "CAMEL Case").
const DEFAULT_SPLIT_REGEXP = [
    /([a-z0-9])([A-Z])/g,
    /([A-Z])([A-Z][a-z])/g
];
// Remove all non-word characters.
const DEFAULT_STRIP_REGEXP = /[^A-Z0-9]+/gi;
/**
 * Normalize the string into something other libraries can manipulate easier.
 */ const noCase = (input, options = {})=>{
    const { delimiter = " ", splitRegexp = DEFAULT_SPLIT_REGEXP, stripRegexp = DEFAULT_STRIP_REGEXP, transform = lowerCase } = options;
    const result = replace(replace(input, splitRegexp, "$1\0$2"), stripRegexp, "\0");
    let start = 0;
    let end = result.length;
    // Trim the delimiter from around the output string.
    while(result.charAt(start) === "\0")start++;
    while(result.charAt(end - 1) === "\0")end--;
    // Transform each token independently.
    return result.slice(start, end).split("\0").map(transform).join(delimiter);
};
const pascalCaseTransform = (input, index)=>{
    const firstChar = input.charAt(0);
    const lowerChars = input.substring(1).toLowerCase();
    if (index > 0 && firstChar >= "0" && firstChar <= "9") return `_${firstChar}${lowerChars}`;
    return `${firstChar.toUpperCase()}${lowerChars}`;
};
const pascalCase = (input, options)=>noCase(input, {
        delimiter: "",
        transform: pascalCaseTransform,
        ...options
    });
const camelCaseTransform = (input, index)=>index === 0 ? input.toLowerCase() : pascalCaseTransform(input, index);
const camelCase = (input, options)=>pascalCase(input, {
        transform: camelCaseTransform,
        ...options
    });
const constantCase = (input, options)=>noCase(input, {
        delimiter: "_",
        transform: upperCase,
        ...options
    });
const kebabCase = (input, options)=>noCase(input, {
        delimiter: "-",
        ...options
    });
const snakeCase = (input, options)=>noCase(input, {
        delimiter: "_",
        ...options
    });

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"lcu1k":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TypeId", ()=>TypeId);
parcelHelpers.export(exports, "consoleTag", ()=>consoleTag);
parcelHelpers.export(exports, "defaultConsole", ()=>defaultConsole);
var _contextJs = require("../../Context.js");
var _coreJs = require("../core.js");
const TypeId = /*#__PURE__*/ Symbol.for("effect/Console");
const consoleTag = /*#__PURE__*/ _contextJs.GenericTag("effect/Console");
const defaultConsole = {
    [TypeId]: TypeId,
    assert (condition, ...args) {
        return _coreJs.sync(()=>{
            console.assert(condition, ...args);
        });
    },
    clear: /*#__PURE__*/ _coreJs.sync(()=>{
        console.clear();
    }),
    count (label) {
        return _coreJs.sync(()=>{
            console.count(label);
        });
    },
    countReset (label) {
        return _coreJs.sync(()=>{
            console.countReset(label);
        });
    },
    debug (...args) {
        return _coreJs.sync(()=>{
            console.debug(...args);
        });
    },
    dir (item, options) {
        return _coreJs.sync(()=>{
            console.dir(item, options);
        });
    },
    dirxml (...args) {
        return _coreJs.sync(()=>{
            console.dirxml(...args);
        });
    },
    error (...args) {
        return _coreJs.sync(()=>{
            console.error(...args);
        });
    },
    group (options) {
        return options?.collapsed ? _coreJs.sync(()=>console.groupCollapsed(options?.label)) : _coreJs.sync(()=>console.group(options?.label));
    },
    groupEnd: /*#__PURE__*/ _coreJs.sync(()=>{
        console.groupEnd();
    }),
    info (...args) {
        return _coreJs.sync(()=>{
            console.info(...args);
        });
    },
    log (...args) {
        return _coreJs.sync(()=>{
            console.log(...args);
        });
    },
    table (tabularData, properties) {
        return _coreJs.sync(()=>{
            console.table(tabularData, properties);
        });
    },
    time (label) {
        return _coreJs.sync(()=>console.time(label));
    },
    timeEnd (label) {
        return _coreJs.sync(()=>console.timeEnd(label));
    },
    timeLog (label, ...args) {
        return _coreJs.sync(()=>{
            console.timeLog(label, ...args);
        });
    },
    trace (...args) {
        return _coreJs.sync(()=>{
            console.trace(...args);
        });
    },
    warn (...args) {
        return _coreJs.sync(()=>{
            console.warn(...args);
        });
    },
    unsafe: console
};

},{"../../Context.js":"c2abN","../core.js":"cr3YV","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"br4fL":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RandomTypeId", ()=>RandomTypeId);
parcelHelpers.export(exports, "randomTag", ()=>randomTag);
parcelHelpers.export(exports, "make", ()=>make);
var _chunkJs = require("../Chunk.js");
var _contextJs = require("../Context.js");
var _functionJs = require("../Function.js");
var _hashJs = require("../Hash.js");
var _utilsJs = require("../Utils.js");
var _coreJs = require("./core.js");
/** @internal */ const RandomSymbolKey = "effect/Random";
const RandomTypeId = /*#__PURE__*/ Symbol.for(RandomSymbolKey);
const randomTag = /*#__PURE__*/ _contextJs.GenericTag("effect/Random");
/** @internal */ class RandomImpl {
    seed;
    [RandomTypeId] = RandomTypeId;
    PRNG;
    constructor(seed){
        this.seed = seed;
        this.PRNG = new _utilsJs.PCGRandom(seed);
    }
    get next() {
        return _coreJs.sync(()=>this.PRNG.number());
    }
    get nextBoolean() {
        return _coreJs.map(this.next, (n)=>n > 0.5);
    }
    get nextInt() {
        return _coreJs.sync(()=>this.PRNG.integer(Number.MAX_SAFE_INTEGER));
    }
    nextRange(min, max) {
        return _coreJs.map(this.next, (n)=>(max - min) * n + min);
    }
    nextIntBetween(min, max) {
        return _coreJs.sync(()=>this.PRNG.integer(max - min) + min);
    }
    shuffle(elements) {
        return shuffleWith(elements, (n)=>this.nextIntBetween(0, n));
    }
}
const shuffleWith = (elements, nextIntBounded)=>{
    return _coreJs.suspend(()=>(0, _functionJs.pipe)(_coreJs.sync(()=>Array.from(elements)), _coreJs.flatMap((buffer)=>{
            const numbers = [];
            for(let i = buffer.length; i >= 2; i = i - 1)numbers.push(i);
            return (0, _functionJs.pipe)(numbers, _coreJs.forEachSequentialDiscard((n)=>(0, _functionJs.pipe)(nextIntBounded(n), _coreJs.map((k)=>swap(buffer, n - 1, k)))), _coreJs.as(_chunkJs.fromIterable(buffer)));
        })));
};
const swap = (buffer, index1, index2)=>{
    const tmp = buffer[index1];
    buffer[index1] = buffer[index2];
    buffer[index2] = tmp;
    return buffer;
};
const make = (seed)=>new RandomImpl(_hashJs.hash(seed));

},{"../Chunk.js":"dL1OO","../Context.js":"c2abN","../Function.js":"21gOL","../Hash.js":"gFMwE","../Utils.js":"dYvz1","./core.js":"cr3YV","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"aAsvB":[function(require,module,exports,__globalThis) {
/**
 * @since 2.0.0
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TracerTypeId", ()=>TracerTypeId);
parcelHelpers.export(exports, "make", ()=>make);
parcelHelpers.export(exports, "tracerTag", ()=>tracerTag);
parcelHelpers.export(exports, "spanTag", ()=>spanTag);
/** @internal */ parcelHelpers.export(exports, "NativeSpan", ()=>NativeSpan);
parcelHelpers.export(exports, "nativeTracer", ()=>nativeTracer);
parcelHelpers.export(exports, "externalSpan", ()=>externalSpan);
parcelHelpers.export(exports, "addSpanStackTrace", ()=>addSpanStackTrace);
parcelHelpers.export(exports, "DisablePropagation", ()=>DisablePropagation);
var _contextJs = require("../Context.js");
var _functionJs = require("../Function.js");
const TracerTypeId = /*#__PURE__*/ Symbol.for("effect/Tracer");
const make = (options)=>({
        [TracerTypeId]: TracerTypeId,
        ...options
    });
const tracerTag = /*#__PURE__*/ _contextJs.GenericTag("effect/Tracer");
const spanTag = /*#__PURE__*/ _contextJs.GenericTag("effect/ParentSpan");
const randomHexString = /*#__PURE__*/ function() {
    const characters = "abcdef0123456789";
    const charactersLength = characters.length;
    return function(length) {
        let result = "";
        for(let i = 0; i < length; i++)result += characters.charAt(Math.floor(Math.random() * charactersLength));
        return result;
    };
}();
class NativeSpan {
    name;
    parent;
    context;
    startTime;
    kind;
    _tag = "Span";
    spanId;
    traceId = "native";
    sampled = true;
    status;
    attributes;
    events = [];
    links;
    constructor(name, parent, context, links, startTime, kind){
        this.name = name;
        this.parent = parent;
        this.context = context;
        this.startTime = startTime;
        this.kind = kind;
        this.status = {
            _tag: "Started",
            startTime
        };
        this.attributes = new Map();
        this.traceId = parent._tag === "Some" ? parent.value.traceId : randomHexString(32);
        this.spanId = randomHexString(16);
        this.links = Array.from(links);
    }
    end(endTime, exit) {
        this.status = {
            _tag: "Ended",
            endTime,
            exit,
            startTime: this.status.startTime
        };
    }
    attribute(key, value) {
        this.attributes.set(key, value);
    }
    event(name, startTime, attributes) {
        this.events.push([
            name,
            startTime,
            attributes ?? {}
        ]);
    }
    addLinks(links) {
        // eslint-disable-next-line no-restricted-syntax
        this.links.push(...links);
    }
}
const nativeTracer = /*#__PURE__*/ make({
    span: (name, parent, context, links, startTime, kind)=>new NativeSpan(name, parent, context, links, startTime, kind),
    context: (f)=>f()
});
const externalSpan = (options)=>({
        _tag: "ExternalSpan",
        spanId: options.spanId,
        traceId: options.traceId,
        sampled: options.sampled ?? true,
        context: options.context ?? _contextJs.empty()
    });
const addSpanStackTrace = (options)=>{
    if (options?.captureStackTrace === false) return options;
    else if (options?.captureStackTrace !== undefined && typeof options.captureStackTrace !== "boolean") return options;
    const limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 3;
    const traceError = new Error();
    Error.stackTraceLimit = limit;
    let cache = false;
    return {
        ...options,
        captureStackTrace: ()=>{
            if (cache !== false) return cache;
            if (traceError.stack !== undefined) {
                const stack = traceError.stack.split("\n");
                if (stack[3] !== undefined) {
                    cache = stack[3].trim();
                    return cache;
                }
            }
        }
    };
};
const DisablePropagation = /*#__PURE__*/ _contextJs.Reference()("effect/Tracer/DisablePropagation", {
    defaultValue: (0, _functionJs.constFalse)
});

},{"../Context.js":"c2abN","../Function.js":"21gOL","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"KnWtw":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ConfigTypeId", ()=>ConfigTypeId);
parcelHelpers.export(exports, "all", ()=>all);
parcelHelpers.export(exports, "array", ()=>array);
parcelHelpers.export(exports, "boolean", ()=>boolean);
parcelHelpers.export(exports, "url", ()=>url);
parcelHelpers.export(exports, "chunk", ()=>chunk);
parcelHelpers.export(exports, "date", ()=>date);
parcelHelpers.export(exports, "fail", ()=>fail);
parcelHelpers.export(exports, "number", ()=>number);
parcelHelpers.export(exports, "integer", ()=>integer);
parcelHelpers.export(exports, "literal", ()=>literal);
parcelHelpers.export(exports, "logLevel", ()=>logLevel);
parcelHelpers.export(exports, "duration", ()=>duration);
parcelHelpers.export(exports, "isConfig", ()=>isConfig);
parcelHelpers.export(exports, "map", ()=>map);
parcelHelpers.export(exports, "mapAttempt", ()=>mapAttempt);
parcelHelpers.export(exports, "mapOrFail", ()=>mapOrFail);
parcelHelpers.export(exports, "nested", ()=>nested);
parcelHelpers.export(exports, "orElse", ()=>orElse);
parcelHelpers.export(exports, "orElseIf", ()=>orElseIf);
parcelHelpers.export(exports, "option", ()=>option);
parcelHelpers.export(exports, "primitive", ()=>primitive);
parcelHelpers.export(exports, "repeat", ()=>repeat);
parcelHelpers.export(exports, "secret", ()=>secret);
parcelHelpers.export(exports, "redacted", ()=>redacted);
parcelHelpers.export(exports, "hashSet", ()=>hashSet);
parcelHelpers.export(exports, "string", ()=>string);
parcelHelpers.export(exports, "nonEmptyString", ()=>nonEmptyString);
parcelHelpers.export(exports, "succeed", ()=>succeed);
parcelHelpers.export(exports, "suspend", ()=>suspend);
parcelHelpers.export(exports, "sync", ()=>sync);
parcelHelpers.export(exports, "hashMap", ()=>hashMap);
parcelHelpers.export(exports, "unwrap", ()=>unwrap);
parcelHelpers.export(exports, "validate", ()=>validate);
parcelHelpers.export(exports, "withDefault", ()=>withDefault);
parcelHelpers.export(exports, "withDescription", ()=>withDescription);
parcelHelpers.export(exports, "zip", ()=>zip);
parcelHelpers.export(exports, "zipWith", ()=>zipWith);
var _configJs = require("./internal/config.js");
const ConfigTypeId = _configJs.ConfigTypeId;
const all = _configJs.all;
const array = _configJs.array;
const boolean = _configJs.boolean;
const url = _configJs.url;
const chunk = _configJs.chunk;
const date = _configJs.date;
const fail = _configJs.fail;
const number = _configJs.number;
const integer = _configJs.integer;
const literal = _configJs.literal;
const logLevel = _configJs.logLevel;
const duration = _configJs.duration;
const isConfig = _configJs.isConfig;
const map = _configJs.map;
const mapAttempt = _configJs.mapAttempt;
const mapOrFail = _configJs.mapOrFail;
const nested = _configJs.nested;
const orElse = _configJs.orElse;
const orElseIf = _configJs.orElseIf;
const option = _configJs.option;
const primitive = _configJs.primitive;
const repeat = _configJs.repeat;
const secret = _configJs.secret;
const redacted = _configJs.redacted;
const hashSet = _configJs.hashSet;
const string = _configJs.string;
const nonEmptyString = _configJs.nonEmptyString;
const succeed = _configJs.succeed;
const suspend = _configJs.suspend;
const sync = _configJs.sync;
const hashMap = _configJs.hashMap;
const unwrap = _configJs.unwrap;
const validate = _configJs.validate;
const withDefault = _configJs.withDefault;
const withDescription = _configJs.withDescription;
const zip = _configJs.zip;
const zipWith = _configJs.zipWith;

},{"./internal/config.js":"k0Eds","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"k0Eds":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ConfigTypeId", ()=>ConfigTypeId);
parcelHelpers.export(exports, "boolean", ()=>boolean);
parcelHelpers.export(exports, "url", ()=>url);
parcelHelpers.export(exports, "array", ()=>array);
parcelHelpers.export(exports, "chunk", ()=>chunk);
parcelHelpers.export(exports, "date", ()=>date);
parcelHelpers.export(exports, "fail", ()=>fail);
parcelHelpers.export(exports, "number", ()=>number);
parcelHelpers.export(exports, "integer", ()=>integer);
parcelHelpers.export(exports, "literal", ()=>literal);
parcelHelpers.export(exports, "logLevel", ()=>logLevel);
parcelHelpers.export(exports, "duration", ()=>duration);
parcelHelpers.export(exports, "map", ()=>map);
parcelHelpers.export(exports, "mapAttempt", ()=>mapAttempt);
parcelHelpers.export(exports, "mapOrFail", ()=>mapOrFail);
parcelHelpers.export(exports, "nested", ()=>nested);
parcelHelpers.export(exports, "orElse", ()=>orElse);
parcelHelpers.export(exports, "orElseIf", ()=>orElseIf);
parcelHelpers.export(exports, "option", ()=>option);
parcelHelpers.export(exports, "primitive", ()=>primitive);
parcelHelpers.export(exports, "repeat", ()=>repeat);
parcelHelpers.export(exports, "secret", ()=>secret);
parcelHelpers.export(exports, "redacted", ()=>redacted);
parcelHelpers.export(exports, "hashSet", ()=>hashSet);
parcelHelpers.export(exports, "string", ()=>string);
parcelHelpers.export(exports, "nonEmptyString", ()=>nonEmptyString);
parcelHelpers.export(exports, "all", ()=>all);
parcelHelpers.export(exports, "succeed", ()=>succeed);
parcelHelpers.export(exports, "suspend", ()=>suspend);
parcelHelpers.export(exports, "sync", ()=>sync);
parcelHelpers.export(exports, "hashMap", ()=>hashMap);
parcelHelpers.export(exports, "isConfig", ()=>isConfig);
parcelHelpers.export(exports, "unwrap", ()=>unwrap);
parcelHelpers.export(exports, "validate", ()=>validate);
parcelHelpers.export(exports, "withDefault", ()=>withDefault);
parcelHelpers.export(exports, "withDescription", ()=>withDescription);
parcelHelpers.export(exports, "zip", ()=>zip);
parcelHelpers.export(exports, "zipWith", ()=>zipWith);
var _chunkJs = require("../Chunk.js");
var _configErrorJs = require("../ConfigError.js");
var _durationJs = require("../Duration.js");
var _eitherJs = require("../Either.js");
var _functionJs = require("../Function.js");
var _hashSetJs = require("../HashSet.js");
var _optionJs = require("../Option.js");
var _predicateJs = require("../Predicate.js");
var _configErrorJs1 = require("./configError.js");
var _coreJs = require("./core.js");
var _defaultServicesJs = require("./defaultServices.js");
var _effectableJs = require("./effectable.js");
var _configJs = require("./opCodes/config.js");
var _redactedJs = require("./redacted.js");
var _secretJs = require("./secret.js");
const ConfigSymbolKey = "effect/Config";
const ConfigTypeId = /*#__PURE__*/ Symbol.for(ConfigSymbolKey);
const configVariance = {
    /* c8 ignore next */ _A: (_)=>_
};
const proto = {
    ..._effectableJs.CommitPrototype,
    [ConfigTypeId]: configVariance,
    commit () {
        return _defaultServicesJs.config(this);
    }
};
const boolean = (name)=>{
    const config = primitive("a boolean property", (text)=>{
        switch(text){
            case "true":
            case "yes":
            case "on":
            case "1":
                return _eitherJs.right(true);
            case "false":
            case "no":
            case "off":
            case "0":
                return _eitherJs.right(false);
            default:
                {
                    const error = _configErrorJs1.InvalidData([], `Expected a boolean value but received ${text}`);
                    return _eitherJs.left(error);
                }
        }
    });
    return name === undefined ? config : nested(config, name);
};
const url = (name)=>{
    const config = primitive("an URL property", (text)=>_eitherJs.try({
            try: ()=>new URL(text),
            catch: (_)=>_configErrorJs1.InvalidData([], `Expected an URL value but received ${text}`)
        }));
    return name === undefined ? config : nested(config, name);
};
const array = (config, name)=>{
    return (0, _functionJs.pipe)(chunk(config, name), map(_chunkJs.toArray));
};
const chunk = (config, name)=>{
    return map(name === undefined ? repeat(config) : nested(repeat(config), name), _chunkJs.unsafeFromArray);
};
const date = (name)=>{
    const config = primitive("a date property", (text)=>{
        const result = Date.parse(text);
        if (Number.isNaN(result)) return _eitherJs.left(_configErrorJs1.InvalidData([], `Expected a Date value but received ${text}`));
        return _eitherJs.right(new Date(result));
    });
    return name === undefined ? config : nested(config, name);
};
const fail = (message)=>{
    const fail = Object.create(proto);
    fail._tag = _configJs.OP_FAIL;
    fail.message = message;
    fail.parse = ()=>_eitherJs.left(_configErrorJs1.Unsupported([], message));
    return fail;
};
const number = (name)=>{
    const config = primitive("a number property", (text)=>{
        const result = Number(text);
        if (Number.isNaN(result)) return _eitherJs.left(_configErrorJs1.InvalidData([], `Expected a number value but received ${text}`));
        return _eitherJs.right(result);
    });
    return name === undefined ? config : nested(config, name);
};
const integer = (name)=>{
    const config = primitive("an integer property", (text)=>{
        const result = Number(text);
        if (!Number.isInteger(result)) return _eitherJs.left(_configErrorJs1.InvalidData([], `Expected an integer value but received ${text}`));
        return _eitherJs.right(result);
    });
    return name === undefined ? config : nested(config, name);
};
const literal = (...literals)=>(name)=>{
        const valuesString = literals.map(String).join(", ");
        const config = primitive(`one of (${valuesString})`, (text)=>{
            const found = literals.find((value)=>String(value) === text);
            if (found === undefined) return _eitherJs.left(_configErrorJs1.InvalidData([], `Expected one of (${valuesString}) but received ${text}`));
            return _eitherJs.right(found);
        });
        return name === undefined ? config : nested(config, name);
    };
const logLevel = (name)=>{
    const config = mapOrFail(string(), (value)=>{
        const label = value.toUpperCase();
        const level = _coreJs.allLogLevels.find((level)=>level.label === label);
        return level === undefined ? _eitherJs.left(_configErrorJs1.InvalidData([], `Expected a log level but received ${value}`)) : _eitherJs.right(level);
    });
    return name === undefined ? config : nested(config, name);
};
const duration = (name)=>{
    const config = mapOrFail(string(), (value)=>{
        const duration = _durationJs.decodeUnknown(value);
        return _eitherJs.fromOption(duration, ()=>_configErrorJs1.InvalidData([], `Expected a duration but received ${value}`));
    });
    return name === undefined ? config : nested(config, name);
};
const map = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>mapOrFail(self, (a)=>_eitherJs.right(f(a))));
const mapAttempt = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>mapOrFail(self, (a)=>{
        try {
            return _eitherJs.right(f(a));
        } catch (error) {
            return _eitherJs.left(_configErrorJs1.InvalidData([], error instanceof Error ? error.message : `${error}`));
        }
    }));
const mapOrFail = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>{
    const mapOrFail = Object.create(proto);
    mapOrFail._tag = _configJs.OP_MAP_OR_FAIL;
    mapOrFail.original = self;
    mapOrFail.mapOrFail = f;
    return mapOrFail;
});
const nested = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, name)=>{
    const nested = Object.create(proto);
    nested._tag = _configJs.OP_NESTED;
    nested.name = name;
    nested.config = self;
    return nested;
});
const orElse = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>{
    const fallback = Object.create(proto);
    fallback._tag = _configJs.OP_FALLBACK;
    fallback.first = self;
    fallback.second = suspend(that);
    fallback.condition = (0, _functionJs.constTrue);
    return fallback;
});
const orElseIf = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, options)=>{
    const fallback = Object.create(proto);
    fallback._tag = _configJs.OP_FALLBACK;
    fallback.first = self;
    fallback.second = suspend(options.orElse);
    fallback.condition = options.if;
    return fallback;
});
const option = (self)=>{
    return (0, _functionJs.pipe)(self, map(_optionJs.some), orElseIf({
        orElse: ()=>succeed(_optionJs.none()),
        if: _configErrorJs.isMissingDataOnly
    }));
};
const primitive = (description, parse)=>{
    const primitive = Object.create(proto);
    primitive._tag = _configJs.OP_PRIMITIVE;
    primitive.description = description;
    primitive.parse = parse;
    return primitive;
};
const repeat = (self)=>{
    const repeat = Object.create(proto);
    repeat._tag = _configJs.OP_SEQUENCE;
    repeat.config = self;
    return repeat;
};
const secret = (name)=>{
    const config = primitive("a secret property", (text)=>_eitherJs.right(_secretJs.fromString(text)));
    return name === undefined ? config : nested(config, name);
};
const redacted = (nameOrConfig)=>{
    const config = isConfig(nameOrConfig) ? nameOrConfig : string(nameOrConfig);
    return map(config, _redactedJs.make);
};
const hashSet = (config, name)=>{
    const newConfig = map(chunk(config), _hashSetJs.fromIterable);
    return name === undefined ? newConfig : nested(newConfig, name);
};
const string = (name)=>{
    const config = primitive("a text property", _eitherJs.right);
    return name === undefined ? config : nested(config, name);
};
const nonEmptyString = (name)=>{
    const config = primitive("a non-empty text property", _eitherJs.liftPredicate((text)=>text.length > 0, ()=>_configErrorJs1.MissingData([], "Expected a non-empty string")));
    return name === undefined ? config : nested(config, name);
};
const all = (arg)=>{
    if (Array.isArray(arg)) return tuple(arg);
    else if (Symbol.iterator in arg) return tuple([
        ...arg
    ]);
    return struct(arg);
};
const struct = (r)=>{
    const entries = Object.entries(r);
    let result = (0, _functionJs.pipe)(entries[0][1], map((value)=>({
            [entries[0][0]]: value
        })));
    if (entries.length === 1) return result;
    const rest = entries.slice(1);
    for (const [key, config] of rest)result = (0, _functionJs.pipe)(result, zipWith(config, (record, value)=>({
            ...record,
            [key]: value
        })));
    return result;
};
const succeed = (value)=>{
    const constant = Object.create(proto);
    constant._tag = _configJs.OP_CONSTANT;
    constant.value = value;
    constant.parse = ()=>_eitherJs.right(value);
    return constant;
};
const suspend = (config)=>{
    const lazy = Object.create(proto);
    lazy._tag = _configJs.OP_LAZY;
    lazy.config = config;
    return lazy;
};
const sync = (value)=>{
    return suspend(()=>succeed(value()));
};
const hashMap = (config, name)=>{
    const table = Object.create(proto);
    table._tag = _configJs.OP_HASHMAP;
    table.valueConfig = config;
    return name === undefined ? table : nested(table, name);
};
const isConfig = (u)=>(0, _predicateJs.hasProperty)(u, ConfigTypeId);
/** @internal */ const tuple = (tuple)=>{
    if (tuple.length === 0) return succeed([]);
    if (tuple.length === 1) return map(tuple[0], (x)=>[
            x
        ]);
    let result = map(tuple[0], (x)=>[
            x
        ]);
    for(let i = 1; i < tuple.length; i++){
        const config = tuple[i];
        result = (0, _functionJs.pipe)(result, zipWith(config, (tuple, value)=>[
                ...tuple,
                value
            ]));
    }
    return result;
};
const unwrap = (wrapped)=>{
    if (isConfig(wrapped)) return wrapped;
    return struct(Object.fromEntries(Object.entries(wrapped).map(([k, a])=>[
            k,
            unwrap(a)
        ])));
};
const validate = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, { message, validation })=>mapOrFail(self, (a)=>{
        if (validation(a)) return _eitherJs.right(a);
        return _eitherJs.left(_configErrorJs1.InvalidData([], message));
    }));
const withDefault = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, def)=>orElseIf(self, {
        orElse: ()=>succeed(def),
        if: _configErrorJs.isMissingDataOnly
    }));
const withDescription = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, description)=>{
    const described = Object.create(proto);
    described._tag = _configJs.OP_DESCRIBED;
    described.config = self;
    described.description = description;
    return described;
});
const zip = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>zipWith(self, that, (a, b)=>[
            a,
            b
        ]));
const zipWith = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, that, f)=>{
    const zipWith = Object.create(proto);
    zipWith._tag = _configJs.OP_ZIP_WITH;
    zipWith.left = self;
    zipWith.right = that;
    zipWith.zip = f;
    return zipWith;
});

},{"../Chunk.js":"dL1OO","../ConfigError.js":"2nBds","../Duration.js":"czLLe","../Either.js":"4amnT","../Function.js":"21gOL","../HashSet.js":"aKFFV","../Option.js":"6sHA7","../Predicate.js":"gW5pd","./configError.js":"k3YwG","./core.js":"cr3YV","./defaultServices.js":"aF4q8","./effectable.js":"8EvvU","./opCodes/config.js":"jGvcZ","./redacted.js":"cJZqF","./secret.js":"49E7Z","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"2nBds":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ConfigErrorTypeId", ()=>ConfigErrorTypeId);
parcelHelpers.export(exports, "And", ()=>And);
parcelHelpers.export(exports, "Or", ()=>Or);
parcelHelpers.export(exports, "MissingData", ()=>MissingData);
parcelHelpers.export(exports, "InvalidData", ()=>InvalidData);
parcelHelpers.export(exports, "SourceUnavailable", ()=>SourceUnavailable);
parcelHelpers.export(exports, "Unsupported", ()=>Unsupported);
parcelHelpers.export(exports, "isConfigError", ()=>isConfigError);
parcelHelpers.export(exports, "isAnd", ()=>isAnd);
parcelHelpers.export(exports, "isOr", ()=>isOr);
parcelHelpers.export(exports, "isInvalidData", ()=>isInvalidData);
parcelHelpers.export(exports, "isMissingData", ()=>isMissingData);
parcelHelpers.export(exports, "isMissingDataOnly", ()=>isMissingDataOnly);
parcelHelpers.export(exports, "isSourceUnavailable", ()=>isSourceUnavailable);
parcelHelpers.export(exports, "isUnsupported", ()=>isUnsupported);
parcelHelpers.export(exports, "prefixed", ()=>prefixed);
parcelHelpers.export(exports, "reduceWithContext", ()=>reduceWithContext);
var _configErrorJs = require("./internal/configError.js");
const ConfigErrorTypeId = _configErrorJs.ConfigErrorTypeId;
const And = _configErrorJs.And;
const Or = _configErrorJs.Or;
const MissingData = _configErrorJs.MissingData;
const InvalidData = _configErrorJs.InvalidData;
const SourceUnavailable = _configErrorJs.SourceUnavailable;
const Unsupported = _configErrorJs.Unsupported;
const isConfigError = _configErrorJs.isConfigError;
const isAnd = _configErrorJs.isAnd;
const isOr = _configErrorJs.isOr;
const isInvalidData = _configErrorJs.isInvalidData;
const isMissingData = _configErrorJs.isMissingData;
const isMissingDataOnly = _configErrorJs.isMissingDataOnly;
const isSourceUnavailable = _configErrorJs.isSourceUnavailable;
const isUnsupported = _configErrorJs.isUnsupported;
const prefixed = _configErrorJs.prefixed;
const reduceWithContext = _configErrorJs.reduceWithContext;

},{"./internal/configError.js":"k3YwG","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"cJZqF":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "redactedRegistry", ()=>redactedRegistry);
parcelHelpers.export(exports, "RedactedTypeId", ()=>RedactedTypeId);
parcelHelpers.export(exports, "proto", ()=>proto);
parcelHelpers.export(exports, "isRedacted", ()=>isRedacted);
parcelHelpers.export(exports, "make", ()=>make);
parcelHelpers.export(exports, "value", ()=>value);
parcelHelpers.export(exports, "unsafeWipe", ()=>unsafeWipe);
var _equalJs = require("../Equal.js");
var _functionJs = require("../Function.js");
var _globalValueJs = require("../GlobalValue.js");
var _hashJs = require("../Hash.js");
var _inspectableJs = require("../Inspectable.js");
var _pipeableJs = require("../Pipeable.js");
var _predicateJs = require("../Predicate.js");
/** @internal */ const RedactedSymbolKey = "effect/Redacted";
const redactedRegistry = /*#__PURE__*/ (0, _globalValueJs.globalValue)("effect/Redacted/redactedRegistry", ()=>new WeakMap());
const RedactedTypeId = /*#__PURE__*/ Symbol.for(RedactedSymbolKey);
const proto = {
    [RedactedTypeId]: {
        _A: (_)=>_
    },
    pipe () {
        return (0, _pipeableJs.pipeArguments)(this, arguments);
    },
    toString () {
        return "<redacted>";
    },
    toJSON () {
        return "<redacted>";
    },
    [(0, _inspectableJs.NodeInspectSymbol)] () {
        return "<redacted>";
    },
    [_hashJs.symbol] () {
        return (0, _functionJs.pipe)(_hashJs.hash(RedactedSymbolKey), _hashJs.combine(_hashJs.hash(redactedRegistry.get(this))), _hashJs.cached(this));
    },
    [_equalJs.symbol] (that) {
        return isRedacted(that) && _equalJs.equals(redactedRegistry.get(this), redactedRegistry.get(that));
    }
};
const isRedacted = (u)=>(0, _predicateJs.hasProperty)(u, RedactedTypeId);
const make = (value)=>{
    const redacted = Object.create(proto);
    redactedRegistry.set(redacted, value);
    return redacted;
};
const value = (self)=>{
    if (redactedRegistry.has(self)) return redactedRegistry.get(self);
    else throw new Error("Unable to get redacted value");
};
const unsafeWipe = (self)=>redactedRegistry.delete(self);

},{"../Equal.js":"gA0qD","../Function.js":"21gOL","../GlobalValue.js":"5w3Hn","../Hash.js":"gFMwE","../Inspectable.js":"1Ur70","../Pipeable.js":"b5RU2","../Predicate.js":"gW5pd","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"49E7Z":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SecretTypeId", ()=>SecretTypeId);
parcelHelpers.export(exports, "isSecret", ()=>isSecret);
parcelHelpers.export(exports, "make", ()=>make);
parcelHelpers.export(exports, "fromIterable", ()=>fromIterable);
parcelHelpers.export(exports, "fromString", ()=>fromString);
parcelHelpers.export(exports, "value", ()=>value);
parcelHelpers.export(exports, "unsafeWipe", ()=>unsafeWipe);
var _arrayJs = require("../Array.js");
var _predicateJs = require("../Predicate.js");
var _redactedJs = require("./redacted.js");
/**
 * @internal
 * @deprecated
 */ const SecretSymbolKey = "effect/Secret";
const SecretTypeId = /*#__PURE__*/ Symbol.for(SecretSymbolKey);
const isSecret = (u)=>(0, _predicateJs.hasProperty)(u, SecretTypeId);
const SecretProto = {
    ..._redactedJs.proto,
    [SecretTypeId]: SecretTypeId
};
const make = (bytes)=>{
    const secret = Object.create(SecretProto);
    Object.defineProperty(secret, "toString", {
        enumerable: false,
        value () {
            return "Secret(<redacted>)";
        }
    });
    Object.defineProperty(secret, "toJSON", {
        enumerable: false,
        value () {
            return "<redacted>";
        }
    });
    Object.defineProperty(secret, "raw", {
        enumerable: false,
        value: bytes
    });
    _redactedJs.redactedRegistry.set(secret, bytes.map((byte)=>String.fromCharCode(byte)).join(""));
    return secret;
};
const fromIterable = (iterable)=>make(_arrayJs.fromIterable(iterable).map((char)=>char.charCodeAt(0)));
const fromString = (text)=>{
    return make(text.split("").map((char)=>char.charCodeAt(0)));
};
const value = (self)=>{
    return self.raw.map((byte)=>String.fromCharCode(byte)).join("");
};
const unsafeWipe = (self)=>{
    for(let i = 0; i < self.raw.length; i++)self.raw[i] = 0;
    _redactedJs.redactedRegistry.delete(self);
};

},{"../Array.js":"8L2Gk","../Predicate.js":"gW5pd","./redacted.js":"cJZqF","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"4hfdQ":[function(require,module,exports,__globalThis) {
/**
 * @since 2.0.0
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TypeId", ()=>TypeId);
parcelHelpers.export(exports, "isCron", ()=>isCron);
parcelHelpers.export(exports, "make", ()=>make);
parcelHelpers.export(exports, "ParseErrorTypeId", ()=>ParseErrorTypeId);
/**
 * Represents a checked exception which occurs when decoding fails.
 *
 * @since 2.0.0
 * @category models
 */ parcelHelpers.export(exports, "ParseError", ()=>ParseError);
parcelHelpers.export(exports, "isParseError", ()=>isParseError);
parcelHelpers.export(exports, "parse", ()=>parse);
parcelHelpers.export(exports, "unsafeParse", ()=>unsafeParse);
parcelHelpers.export(exports, "match", ()=>match);
parcelHelpers.export(exports, "next", ()=>next);
parcelHelpers.export(exports, "sequence", ()=>sequence);
parcelHelpers.export(exports, "Equivalence", ()=>Equivalence);
parcelHelpers.export(exports, "equals", ()=>equals);
var _arrayJs = require("./Array.js");
var _dataJs = require("./Data.js");
var _eitherJs = require("./Either.js");
var _equalJs = require("./Equal.js");
var _equivalenceJs = require("./Equivalence.js");
var _functionJs = require("./Function.js");
var _hashJs = require("./Hash.js");
var _inspectableJs = require("./Inspectable.js");
var _dateTimeJs = require("./internal/dateTime.js");
var _numberJs = require("./Number.js");
var _optionJs = require("./Option.js");
var _pipeableJs = require("./Pipeable.js");
var _predicateJs = require("./Predicate.js");
var _stringJs = require("./String.js");
const TypeId = /*#__PURE__*/ Symbol.for("effect/Cron");
const CronProto = {
    [TypeId]: TypeId,
    [_equalJs.symbol] (that) {
        return isCron(that) && equals(this, that);
    },
    [_hashJs.symbol] () {
        return (0, _functionJs.pipe)(_hashJs.hash(this.tz), _hashJs.combine(_hashJs.array(_arrayJs.fromIterable(this.seconds))), _hashJs.combine(_hashJs.array(_arrayJs.fromIterable(this.minutes))), _hashJs.combine(_hashJs.array(_arrayJs.fromIterable(this.hours))), _hashJs.combine(_hashJs.array(_arrayJs.fromIterable(this.days))), _hashJs.combine(_hashJs.array(_arrayJs.fromIterable(this.months))), _hashJs.combine(_hashJs.array(_arrayJs.fromIterable(this.weekdays))), _hashJs.cached(this));
    },
    toString () {
        return (0, _inspectableJs.format)(this.toJSON());
    },
    toJSON () {
        return {
            _id: "Cron",
            tz: this.tz,
            seconds: _arrayJs.fromIterable(this.seconds),
            minutes: _arrayJs.fromIterable(this.minutes),
            hours: _arrayJs.fromIterable(this.hours),
            days: _arrayJs.fromIterable(this.days),
            months: _arrayJs.fromIterable(this.months),
            weekdays: _arrayJs.fromIterable(this.weekdays)
        };
    },
    [(0, _inspectableJs.NodeInspectSymbol)] () {
        return this.toJSON();
    },
    pipe () {
        return (0, _pipeableJs.pipeArguments)(this, arguments);
    }
};
const isCron = (u)=>(0, _predicateJs.hasProperty)(u, TypeId);
const make = (values)=>{
    const o = Object.create(CronProto);
    o.seconds = new Set(_arrayJs.sort(values.seconds ?? [
        0
    ], _numberJs.Order));
    o.minutes = new Set(_arrayJs.sort(values.minutes, _numberJs.Order));
    o.hours = new Set(_arrayJs.sort(values.hours, _numberJs.Order));
    o.days = new Set(_arrayJs.sort(values.days, _numberJs.Order));
    o.months = new Set(_arrayJs.sort(values.months, _numberJs.Order));
    o.weekdays = new Set(_arrayJs.sort(values.weekdays, _numberJs.Order));
    o.tz = _optionJs.fromNullable(values.tz);
    const seconds = Array.from(o.seconds);
    const minutes = Array.from(o.minutes);
    const hours = Array.from(o.hours);
    const days = Array.from(o.days);
    const months = Array.from(o.months);
    const weekdays = Array.from(o.weekdays);
    o.first = {
        second: seconds[0] ?? 0,
        minute: minutes[0] ?? 0,
        hour: hours[0] ?? 0,
        day: days[0] ?? 1,
        month: (months[0] ?? 1) - 1,
        weekday: weekdays[0] ?? 0
    };
    o.next = {
        second: nextLookupTable(seconds, 60),
        minute: nextLookupTable(minutes, 60),
        hour: nextLookupTable(hours, 24),
        day: nextLookupTable(days, 32),
        month: nextLookupTable(months, 13),
        weekday: nextLookupTable(weekdays, 7)
    };
    return o;
};
const nextLookupTable = (values, size)=>{
    const result = new Array(size).fill(undefined);
    if (values.length === 0) return result;
    let current = undefined;
    let index = values.length - 1;
    for(let i = size - 1; i >= 0; i--){
        while(index >= 0 && values[index] >= i)current = values[index--];
        result[i] = current;
    }
    return result;
};
const ParseErrorTypeId = /*#__PURE__*/ Symbol.for("effect/Cron/errors/ParseError");
class ParseError extends /*#__PURE__*/ _dataJs.TaggedError("CronParseError") {
    /**
   * @since 2.0.0
   */ [ParseErrorTypeId] = ParseErrorTypeId;
}
const isParseError = (u)=>(0, _predicateJs.hasProperty)(u, ParseErrorTypeId);
const parse = (cron, tz)=>{
    const segments = cron.split(" ").filter(_stringJs.isNonEmpty);
    if (segments.length !== 5 && segments.length !== 6) return _eitherJs.left(new ParseError({
        message: `Invalid number of segments in cron expression`,
        input: cron
    }));
    if (segments.length === 5) segments.unshift("0");
    const [seconds, minutes, hours, days, months, weekdays] = segments;
    const zone = tz === undefined || _dateTimeJs.isTimeZone(tz) ? _eitherJs.right(tz) : _eitherJs.fromOption(_dateTimeJs.zoneFromString(tz), ()=>new ParseError({
            message: `Invalid time zone in cron expression`,
            input: tz
        }));
    return _eitherJs.all({
        tz: zone,
        seconds: parseSegment(seconds, secondOptions),
        minutes: parseSegment(minutes, minuteOptions),
        hours: parseSegment(hours, hourOptions),
        days: parseSegment(days, dayOptions),
        months: parseSegment(months, monthOptions),
        weekdays: parseSegment(weekdays, weekdayOptions)
    }).pipe(_eitherJs.map(make));
};
const unsafeParse = (cron, tz)=>_eitherJs.getOrThrowWith(parse(cron, tz), (0, _functionJs.identity));
const match = (cron, date)=>{
    const parts = _dateTimeJs.unsafeMakeZoned(date, {
        timeZone: _optionJs.getOrUndefined(cron.tz)
    }).pipe(_dateTimeJs.toParts);
    if (cron.seconds.size !== 0 && !cron.seconds.has(parts.seconds)) return false;
    if (cron.minutes.size !== 0 && !cron.minutes.has(parts.minutes)) return false;
    if (cron.hours.size !== 0 && !cron.hours.has(parts.hours)) return false;
    if (cron.months.size !== 0 && !cron.months.has(parts.month)) return false;
    if (cron.days.size === 0 && cron.weekdays.size === 0) return true;
    if (cron.weekdays.size === 0) return cron.days.has(parts.day);
    if (cron.days.size === 0) return cron.weekdays.has(parts.weekDay);
    return cron.days.has(parts.day) || cron.weekdays.has(parts.weekDay);
};
const daysInMonth = (date)=>new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth() + 1, 0)).getUTCDate();
const next = (cron, startFrom)=>{
    const tz = _optionJs.getOrUndefined(cron.tz);
    const zoned = _dateTimeJs.unsafeMakeZoned(startFrom ?? new Date(), {
        timeZone: tz
    });
    const utc = tz !== undefined && _dateTimeJs.isTimeZoneNamed(tz) && tz.id === "UTC";
    const adjustDst = utc ? (0, _functionJs.constVoid) : (current)=>{
        const adjusted = _dateTimeJs.unsafeMakeZoned(current, {
            timeZone: zoned.zone,
            adjustForTimeZone: true
        }).pipe(_dateTimeJs.toDate);
        // TODO: This implementation currently only skips forward when transitioning into daylight savings time.
        const drift = current.getTime() - adjusted.getTime();
        if (drift > 0) current.setTime(current.getTime() + drift);
    };
    const result = _dateTimeJs.mutate(zoned, (current)=>{
        current.setUTCSeconds(current.getUTCSeconds() + 1, 0);
        for(let i = 0; i < 10000; i++){
            if (cron.seconds.size !== 0) {
                const currentSecond = current.getUTCSeconds();
                const nextSecond = cron.next.second[currentSecond];
                if (nextSecond === undefined) {
                    current.setUTCMinutes(current.getUTCMinutes() + 1, cron.first.second);
                    adjustDst(current);
                    continue;
                }
                if (nextSecond > currentSecond) {
                    current.setUTCSeconds(nextSecond);
                    adjustDst(current);
                    continue;
                }
            }
            if (cron.minutes.size !== 0) {
                const currentMinute = current.getUTCMinutes();
                const nextMinute = cron.next.minute[currentMinute];
                if (nextMinute === undefined) {
                    current.setUTCHours(current.getUTCHours() + 1, cron.first.minute, cron.first.second);
                    adjustDst(current);
                    continue;
                }
                if (nextMinute > currentMinute) {
                    current.setUTCMinutes(nextMinute, cron.first.second);
                    adjustDst(current);
                    continue;
                }
            }
            if (cron.hours.size !== 0) {
                const currentHour = current.getUTCHours();
                const nextHour = cron.next.hour[currentHour];
                if (nextHour === undefined) {
                    current.setUTCDate(current.getUTCDate() + 1);
                    current.setUTCHours(cron.first.hour, cron.first.minute, cron.first.second);
                    adjustDst(current);
                    continue;
                }
                if (nextHour > currentHour) {
                    current.setUTCHours(nextHour, cron.first.minute, cron.first.second);
                    adjustDst(current);
                    continue;
                }
            }
            if (cron.weekdays.size !== 0 || cron.days.size !== 0) {
                let a = Infinity;
                let b = Infinity;
                if (cron.weekdays.size !== 0) {
                    const currentWeekday = current.getUTCDay();
                    const nextWeekday = cron.next.weekday[currentWeekday];
                    a = nextWeekday === undefined ? 7 - currentWeekday + cron.first.weekday : nextWeekday - currentWeekday;
                }
                if (cron.days.size !== 0 && a !== 0) {
                    const currentDay = current.getUTCDate();
                    const nextDay = cron.next.day[currentDay];
                    b = nextDay === undefined ? daysInMonth(current) - currentDay + cron.first.day : nextDay - currentDay;
                }
                const addDays = Math.min(a, b);
                if (addDays !== 0) {
                    current.setUTCDate(current.getUTCDate() + addDays);
                    current.setUTCHours(cron.first.hour, cron.first.minute, cron.first.second);
                    adjustDst(current);
                    continue;
                }
            }
            if (cron.months.size !== 0) {
                const currentMonth = current.getUTCMonth() + 1;
                const nextMonth = cron.next.month[currentMonth];
                if (nextMonth === undefined) {
                    current.setUTCFullYear(current.getUTCFullYear() + 1);
                    current.setUTCMonth(cron.first.month, cron.first.day);
                    current.setUTCHours(cron.first.hour, cron.first.minute, cron.first.second);
                    adjustDst(current);
                    continue;
                }
                if (nextMonth > currentMonth) {
                    current.setUTCMonth(nextMonth - 1, cron.first.day);
                    current.setUTCHours(cron.first.hour, cron.first.minute, cron.first.second);
                    adjustDst(current);
                    continue;
                }
            }
            return;
        }
        throw new Error("Unable to find next cron date");
    });
    return _dateTimeJs.toDateUtc(result);
};
const sequence = function*(cron, startFrom) {
    while(true)yield startFrom = next(cron, startFrom);
};
const Equivalence = /*#__PURE__*/ _equivalenceJs.make((self, that)=>restrictionsEquals(self.seconds, that.seconds) && restrictionsEquals(self.minutes, that.minutes) && restrictionsEquals(self.hours, that.hours) && restrictionsEquals(self.days, that.days) && restrictionsEquals(self.months, that.months) && restrictionsEquals(self.weekdays, that.weekdays));
const restrictionsArrayEquals = /*#__PURE__*/ _equivalenceJs.array(_equivalenceJs.number);
const restrictionsEquals = (self, that)=>restrictionsArrayEquals(_arrayJs.fromIterable(self), _arrayJs.fromIterable(that));
const equals = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>Equivalence(self, that));
const secondOptions = {
    min: 0,
    max: 59
};
const minuteOptions = {
    min: 0,
    max: 59
};
const hourOptions = {
    min: 0,
    max: 23
};
const dayOptions = {
    min: 1,
    max: 31
};
const monthOptions = {
    min: 1,
    max: 12,
    aliases: {
        jan: 1,
        feb: 2,
        mar: 3,
        apr: 4,
        may: 5,
        jun: 6,
        jul: 7,
        aug: 8,
        sep: 9,
        oct: 10,
        nov: 11,
        dec: 12
    }
};
const weekdayOptions = {
    min: 0,
    max: 6,
    aliases: {
        sun: 0,
        mon: 1,
        tue: 2,
        wed: 3,
        thu: 4,
        fri: 5,
        sat: 6
    }
};
const parseSegment = (input, options)=>{
    const capacity = options.max - options.min + 1;
    const values = new Set();
    const fields = input.split(",");
    for (const field of fields){
        const [raw, step] = splitStep(field);
        if (raw === "*" && step === undefined) return _eitherJs.right(new Set());
        if (step !== undefined) {
            if (!Number.isInteger(step)) return _eitherJs.left(new ParseError({
                message: `Expected step value to be a positive integer`,
                input
            }));
            if (step < 1) return _eitherJs.left(new ParseError({
                message: `Expected step value to be greater than 0`,
                input
            }));
            if (step > options.max) return _eitherJs.left(new ParseError({
                message: `Expected step value to be less than ${options.max}`,
                input
            }));
        }
        if (raw === "*") for(let i = options.min; i <= options.max; i += step ?? 1)values.add(i);
        else {
            const [left, right] = splitRange(raw, options.aliases);
            if (!Number.isInteger(left)) return _eitherJs.left(new ParseError({
                message: `Expected a positive integer`,
                input
            }));
            if (left < options.min || left > options.max) return _eitherJs.left(new ParseError({
                message: `Expected a value between ${options.min} and ${options.max}`,
                input
            }));
            if (right === undefined) values.add(left);
            else {
                if (!Number.isInteger(right)) return _eitherJs.left(new ParseError({
                    message: `Expected a positive integer`,
                    input
                }));
                if (right < options.min || right > options.max) return _eitherJs.left(new ParseError({
                    message: `Expected a value between ${options.min} and ${options.max}`,
                    input
                }));
                if (left > right) return _eitherJs.left(new ParseError({
                    message: `Invalid value range`,
                    input
                }));
                for(let i = left; i <= right; i += step ?? 1)values.add(i);
            }
        }
        if (values.size >= capacity) return _eitherJs.right(new Set());
    }
    return _eitherJs.right(values);
};
const splitStep = (input)=>{
    const seperator = input.indexOf("/");
    if (seperator !== -1) return [
        input.slice(0, seperator),
        Number(input.slice(seperator + 1))
    ];
    return [
        input,
        undefined
    ];
};
const splitRange = (input, aliases)=>{
    const seperator = input.indexOf("-");
    if (seperator !== -1) return [
        aliasOrValue(input.slice(0, seperator), aliases),
        aliasOrValue(input.slice(seperator + 1), aliases)
    ];
    return [
        aliasOrValue(input, aliases),
        undefined
    ];
};
function aliasOrValue(field, aliases) {
    return aliases?.[field.toLocaleLowerCase()] ?? Number(field);
}

},{"./Array.js":"8L2Gk","./Data.js":"4e85E","./Either.js":"4amnT","./Equal.js":"gA0qD","./Equivalence.js":"1WBUa","./Function.js":"21gOL","./Hash.js":"gFMwE","./Inspectable.js":"1Ur70","./internal/dateTime.js":"53jOw","./Number.js":"al4Y3","./Option.js":"6sHA7","./Pipeable.js":"b5RU2","./Predicate.js":"gW5pd","./String.js":"606wn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"4e85E":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "struct", ()=>struct);
parcelHelpers.export(exports, "unsafeStruct", ()=>unsafeStruct);
parcelHelpers.export(exports, "tuple", ()=>tuple);
parcelHelpers.export(exports, "array", ()=>array);
parcelHelpers.export(exports, "unsafeArray", ()=>unsafeArray);
parcelHelpers.export(exports, "case", ()=>/**
 * Provides a constructor for the specified `Case`.
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import { Data, Equal } from "effect"
 *
 * interface Person {
 *   readonly name: string
 * }
 *
 * // Creating a constructor for the specified Case
 * const Person = Data.case<Person>()
 *
 * // Creating instances of Person
 * const mike1 = Person({ name: "Mike" })
 * const mike2 = Person({ name: "Mike" })
 * const john = Person({ name: "John" })
 *
 * // Checking equality
 * assert.deepStrictEqual(Equal.equals(mike1, mike2), true)
 * assert.deepStrictEqual(Equal.equals(mike1, john), false)
 *
 * ```
 * @since 2.0.0
 * @category constructors
 */ _case);
parcelHelpers.export(exports, "tagged", ()=>tagged);
parcelHelpers.export(exports, "Class", ()=>Class);
parcelHelpers.export(exports, "TaggedClass", ()=>TaggedClass);
parcelHelpers.export(exports, "Structural", ()=>Structural);
parcelHelpers.export(exports, "taggedEnum", ()=>taggedEnum);
parcelHelpers.export(exports, "Error", ()=>Error);
parcelHelpers.export(exports, "TaggedError", ()=>TaggedError);
var _coreJs = require("./internal/core.js");
var _dataJs = require("./internal/data.js");
var _effectableJs = require("./internal/effectable.js");
var _predicateJs = require("./Predicate.js");
const struct = _dataJs.struct;
const unsafeStruct = (as)=>Object.setPrototypeOf(as, (0, _effectableJs.StructuralPrototype));
const tuple = (...as)=>unsafeArray(as);
const array = (as)=>unsafeArray(as.slice(0));
const unsafeArray = (as)=>Object.setPrototypeOf(as, _dataJs.ArrayProto);
const _case = ()=>(args)=>args === undefined ? Object.create((0, _effectableJs.StructuralPrototype)) : struct(args);
const tagged = (tag)=>(args)=>{
        const value = args === undefined ? Object.create((0, _effectableJs.StructuralPrototype)) : struct(args);
        value._tag = tag;
        return value;
    };
const Class = _dataJs.Structural;
const TaggedClass = (tag)=>{
    class Base extends Class {
        _tag = tag;
    }
    return Base;
};
const Structural = _dataJs.Structural;
const taggedEnum = ()=>new Proxy({}, {
        get (_target, tag, _receiver) {
            if (tag === "$is") return _predicateJs.isTagged;
            else if (tag === "$match") return taggedMatch;
            return tagged(tag);
        }
    });
function taggedMatch() {
    if (arguments.length === 1) {
        const cases = arguments[0];
        return function(value) {
            return cases[value._tag](value);
        };
    }
    const value = arguments[0];
    const cases = arguments[1];
    return cases[value._tag](value);
}
const Error = /*#__PURE__*/ function() {
    const plainArgsSymbol = /*#__PURE__*/ Symbol.for("effect/Data/Error/plainArgs");
    const O = {
        BaseEffectError: class extends _coreJs.YieldableError {
            constructor(args){
                super(args?.message, args?.cause ? {
                    cause: args.cause
                } : undefined);
                if (args) {
                    Object.assign(this, args);
                    Object.defineProperty(this, plainArgsSymbol, {
                        value: args,
                        enumerable: false
                    });
                }
            }
            toJSON() {
                return {
                    ...this[plainArgsSymbol],
                    ...this
                };
            }
        }
    };
    return O.BaseEffectError;
}();
const TaggedError = (tag)=>{
    const O = {
        BaseEffectError: class extends Error {
            _tag = tag;
        }
    };
    O.BaseEffectError.prototype.name = tag;
    return O.BaseEffectError;
};

},{"./internal/core.js":"cr3YV","./internal/data.js":"fk0Pw","./internal/effectable.js":"8EvvU","./Predicate.js":"gW5pd","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"53jOw":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TypeId", ()=>TypeId);
parcelHelpers.export(exports, "TimeZoneTypeId", ()=>TimeZoneTypeId);
parcelHelpers.export(exports, "makeZonedProto", ()=>makeZonedProto);
parcelHelpers.export(exports, "isDateTime", ()=>isDateTime);
parcelHelpers.export(exports, "isTimeZone", ()=>isTimeZone);
parcelHelpers.export(exports, "isTimeZoneOffset", ()=>isTimeZoneOffset);
parcelHelpers.export(exports, "isTimeZoneNamed", ()=>isTimeZoneNamed);
parcelHelpers.export(exports, "isUtc", ()=>isUtc);
parcelHelpers.export(exports, "isZoned", ()=>isZoned);
parcelHelpers.export(exports, "Equivalence", ()=>Equivalence);
parcelHelpers.export(exports, "Order", ()=>Order);
parcelHelpers.export(exports, "clamp", ()=>clamp);
parcelHelpers.export(exports, "unsafeFromDate", ()=>unsafeFromDate);
parcelHelpers.export(exports, "unsafeMake", ()=>unsafeMake);
parcelHelpers.export(exports, "unsafeMakeZoned", ()=>unsafeMakeZoned);
parcelHelpers.export(exports, "makeZoned", ()=>makeZoned);
parcelHelpers.export(exports, "make", ()=>make);
parcelHelpers.export(exports, "makeZonedFromString", ()=>makeZonedFromString);
parcelHelpers.export(exports, "now", ()=>now);
parcelHelpers.export(exports, "nowAsDate", ()=>nowAsDate);
parcelHelpers.export(exports, "unsafeNow", ()=>unsafeNow);
parcelHelpers.export(exports, "toUtc", ()=>toUtc);
parcelHelpers.export(exports, "setZone", ()=>setZone);
parcelHelpers.export(exports, "setZoneOffset", ()=>setZoneOffset);
parcelHelpers.export(exports, "zoneUnsafeMakeNamed", ()=>zoneUnsafeMakeNamed);
parcelHelpers.export(exports, "zoneMakeOffset", ()=>zoneMakeOffset);
parcelHelpers.export(exports, "zoneMakeNamed", ()=>zoneMakeNamed);
parcelHelpers.export(exports, "zoneMakeNamedEffect", ()=>zoneMakeNamedEffect);
parcelHelpers.export(exports, "zoneMakeLocal", ()=>zoneMakeLocal);
parcelHelpers.export(exports, "zoneFromString", ()=>zoneFromString);
parcelHelpers.export(exports, "zoneToString", ()=>zoneToString);
parcelHelpers.export(exports, "setZoneNamed", ()=>setZoneNamed);
parcelHelpers.export(exports, "unsafeSetZoneNamed", ()=>unsafeSetZoneNamed);
parcelHelpers.export(exports, "distance", ()=>distance);
parcelHelpers.export(exports, "distanceDurationEither", ()=>distanceDurationEither);
parcelHelpers.export(exports, "distanceDuration", ()=>distanceDuration);
parcelHelpers.export(exports, "min", ()=>min);
parcelHelpers.export(exports, "max", ()=>max);
parcelHelpers.export(exports, "greaterThan", ()=>greaterThan);
parcelHelpers.export(exports, "greaterThanOrEqualTo", ()=>greaterThanOrEqualTo);
parcelHelpers.export(exports, "lessThan", ()=>lessThan);
parcelHelpers.export(exports, "lessThanOrEqualTo", ()=>lessThanOrEqualTo);
parcelHelpers.export(exports, "between", ()=>between);
parcelHelpers.export(exports, "isFuture", ()=>isFuture);
parcelHelpers.export(exports, "unsafeIsFuture", ()=>unsafeIsFuture);
parcelHelpers.export(exports, "isPast", ()=>isPast);
parcelHelpers.export(exports, "unsafeIsPast", ()=>unsafeIsPast);
parcelHelpers.export(exports, "toDateUtc", ()=>toDateUtc);
parcelHelpers.export(exports, "toDate", ()=>toDate);
parcelHelpers.export(exports, "zonedOffset", ()=>zonedOffset);
parcelHelpers.export(exports, "zonedOffsetIso", ()=>zonedOffsetIso);
parcelHelpers.export(exports, "toEpochMillis", ()=>toEpochMillis);
parcelHelpers.export(exports, "removeTime", ()=>removeTime);
parcelHelpers.export(exports, "toParts", ()=>toParts);
parcelHelpers.export(exports, "toPartsUtc", ()=>toPartsUtc);
parcelHelpers.export(exports, "getPartUtc", ()=>getPartUtc);
parcelHelpers.export(exports, "getPart", ()=>getPart);
parcelHelpers.export(exports, "setParts", ()=>setParts);
parcelHelpers.export(exports, "setPartsUtc", ()=>setPartsUtc);
parcelHelpers.export(exports, "mutate", ()=>mutate);
parcelHelpers.export(exports, "mutateUtc", ()=>mutateUtc);
parcelHelpers.export(exports, "mapEpochMillis", ()=>mapEpochMillis);
parcelHelpers.export(exports, "withDate", ()=>withDate);
parcelHelpers.export(exports, "withDateUtc", ()=>withDateUtc);
parcelHelpers.export(exports, "match", ()=>match);
parcelHelpers.export(exports, "addDuration", ()=>addDuration);
parcelHelpers.export(exports, "subtractDuration", ()=>subtractDuration);
parcelHelpers.export(exports, "add", ()=>add);
parcelHelpers.export(exports, "subtract", ()=>subtract);
parcelHelpers.export(exports, "startOf", ()=>startOf);
parcelHelpers.export(exports, "endOf", ()=>endOf);
parcelHelpers.export(exports, "nearest", ()=>nearest);
parcelHelpers.export(exports, "format", ()=>format);
parcelHelpers.export(exports, "formatLocal", ()=>formatLocal);
parcelHelpers.export(exports, "formatUtc", ()=>formatUtc);
parcelHelpers.export(exports, "formatIntl", ()=>formatIntl);
parcelHelpers.export(exports, "formatIso", ()=>formatIso);
parcelHelpers.export(exports, "formatIsoDate", ()=>formatIsoDate);
parcelHelpers.export(exports, "formatIsoDateUtc", ()=>formatIsoDateUtc);
parcelHelpers.export(exports, "formatIsoOffset", ()=>formatIsoOffset);
parcelHelpers.export(exports, "formatIsoZoned", ()=>formatIsoZoned);
var _causeJs = require("../Cause.js");
var _clockJs = require("../Clock.js");
var _durationJs = require("../Duration.js");
var _eitherJs = require("../Either.js");
var _equalJs = require("../Equal.js");
var _equivalenceJs = require("../Equivalence.js");
var _functionJs = require("../Function.js");
var _globalValueJs = require("../GlobalValue.js");
var _hashJs = require("../Hash.js");
var _inspectableJs = require("../Inspectable.js");
var _optionJs = require("../Option.js");
var _orderJs = require("../Order.js");
var _pipeableJs = require("../Pipeable.js");
var _predicateJs = require("../Predicate.js");
var _coreEffectJs = require("./core-effect.js");
var _coreJs = require("./core.js");
const TypeId = /*#__PURE__*/ Symbol.for("effect/DateTime");
const TimeZoneTypeId = /*#__PURE__*/ Symbol.for("effect/DateTime/TimeZone");
const Proto = {
    [TypeId]: TypeId,
    pipe () {
        return (0, _pipeableJs.pipeArguments)(this, arguments);
    },
    [_inspectableJs.NodeInspectSymbol] () {
        return this.toString();
    },
    toJSON () {
        return toDateUtc(this).toJSON();
    }
};
const ProtoUtc = {
    ...Proto,
    _tag: "Utc",
    [_hashJs.symbol] () {
        return _hashJs.cached(this, _hashJs.number(this.epochMillis));
    },
    [_equalJs.symbol] (that) {
        return isDateTime(that) && that._tag === "Utc" && this.epochMillis === that.epochMillis;
    },
    toString () {
        return `DateTime.Utc(${toDateUtc(this).toJSON()})`;
    }
};
const ProtoZoned = {
    ...Proto,
    _tag: "Zoned",
    [_hashJs.symbol] () {
        return (0, _functionJs.pipe)(_hashJs.number(this.epochMillis), _hashJs.combine(_hashJs.hash(this.zone)), _hashJs.cached(this));
    },
    [_equalJs.symbol] (that) {
        return isDateTime(that) && that._tag === "Zoned" && this.epochMillis === that.epochMillis && _equalJs.equals(this.zone, that.zone);
    },
    toString () {
        return `DateTime.Zoned(${formatIsoZoned(this)})`;
    }
};
const ProtoTimeZone = {
    [TimeZoneTypeId]: TimeZoneTypeId,
    [_inspectableJs.NodeInspectSymbol] () {
        return this.toString();
    }
};
const ProtoTimeZoneNamed = {
    ...ProtoTimeZone,
    _tag: "Named",
    [_hashJs.symbol] () {
        return _hashJs.cached(this, _hashJs.string(`Named:${this.id}`));
    },
    [_equalJs.symbol] (that) {
        return isTimeZone(that) && that._tag === "Named" && this.id === that.id;
    },
    toString () {
        return `TimeZone.Named(${this.id})`;
    },
    toJSON () {
        return {
            _id: "TimeZone",
            _tag: "Named",
            id: this.id
        };
    }
};
const ProtoTimeZoneOffset = {
    ...ProtoTimeZone,
    _tag: "Offset",
    [_hashJs.symbol] () {
        return _hashJs.cached(this, _hashJs.string(`Offset:${this.offset}`));
    },
    [_equalJs.symbol] (that) {
        return isTimeZone(that) && that._tag === "Offset" && this.offset === that.offset;
    },
    toString () {
        return `TimeZone.Offset(${offsetToString(this.offset)})`;
    },
    toJSON () {
        return {
            _id: "TimeZone",
            _tag: "Offset",
            offset: this.offset
        };
    }
};
const makeZonedProto = (epochMillis, zone, partsUtc)=>{
    const self = Object.create(ProtoZoned);
    self.epochMillis = epochMillis;
    self.zone = zone;
    Object.defineProperty(self, "partsUtc", {
        value: partsUtc,
        enumerable: false,
        writable: true
    });
    Object.defineProperty(self, "adjustedEpochMillis", {
        value: undefined,
        enumerable: false,
        writable: true
    });
    Object.defineProperty(self, "partsAdjusted", {
        value: undefined,
        enumerable: false,
        writable: true
    });
    return self;
};
const isDateTime = (u)=>_predicateJs.hasProperty(u, TypeId);
const isDateTimeArgs = (args)=>isDateTime(args[0]);
const isTimeZone = (u)=>_predicateJs.hasProperty(u, TimeZoneTypeId);
const isTimeZoneOffset = (u)=>isTimeZone(u) && u._tag === "Offset";
const isTimeZoneNamed = (u)=>isTimeZone(u) && u._tag === "Named";
const isUtc = (self)=>self._tag === "Utc";
const isZoned = (self)=>self._tag === "Zoned";
const Equivalence = /*#__PURE__*/ _equivalenceJs.make((a, b)=>a.epochMillis === b.epochMillis);
const Order = /*#__PURE__*/ _orderJs.make((self, that)=>self.epochMillis < that.epochMillis ? -1 : self.epochMillis > that.epochMillis ? 1 : 0);
const clamp = /*#__PURE__*/ _orderJs.clamp(Order);
// =============================================================================
// constructors
// =============================================================================
const makeUtc = (epochMillis)=>{
    const self = Object.create(ProtoUtc);
    self.epochMillis = epochMillis;
    Object.defineProperty(self, "partsUtc", {
        value: undefined,
        enumerable: false,
        writable: true
    });
    return self;
};
const unsafeFromDate = (date)=>{
    const epochMillis = date.getTime();
    if (Number.isNaN(epochMillis)) throw new (0, _causeJs.IllegalArgumentException)("Invalid date");
    return makeUtc(epochMillis);
};
const unsafeMake = (input)=>{
    if (isDateTime(input)) return input;
    else if (input instanceof Date) return unsafeFromDate(input);
    else if (typeof input === "object") {
        const date = new Date(0);
        setPartsDate(date, input);
        return unsafeFromDate(date);
    }
    return unsafeFromDate(new Date(input));
};
const minEpochMillis = -8639999956800000;
const maxEpochMillis = 8639999949600000;
const unsafeMakeZoned = (input, options)=>{
    if (options?.timeZone === undefined && isDateTime(input) && isZoned(input)) return input;
    const self = unsafeMake(input);
    if (self.epochMillis < minEpochMillis || self.epochMillis > maxEpochMillis) throw new (0, _causeJs.IllegalArgumentException)(`Epoch millis out of range: ${self.epochMillis}`);
    let zone;
    if (options?.timeZone === undefined) {
        const offset = new Date(self.epochMillis).getTimezoneOffset() * -60000;
        zone = zoneMakeOffset(offset);
    } else if (isTimeZone(options?.timeZone)) zone = options.timeZone;
    else if (typeof options?.timeZone === "number") zone = zoneMakeOffset(options.timeZone);
    else {
        const parsedZone = zoneFromString(options.timeZone);
        if (_optionJs.isNone(parsedZone)) throw new (0, _causeJs.IllegalArgumentException)(`Invalid time zone: ${options.timeZone}`);
        zone = parsedZone.value;
    }
    if (options?.adjustForTimeZone !== true) return makeZonedProto(self.epochMillis, zone, self.partsUtc);
    return makeZonedFromAdjusted(self.epochMillis, zone);
};
const makeZoned = /*#__PURE__*/ _optionJs.liftThrowable(unsafeMakeZoned);
const make = /*#__PURE__*/ _optionJs.liftThrowable(unsafeMake);
const zonedStringRegex = /^(.{17,35})\[(.+)\]$/;
const makeZonedFromString = (input)=>{
    const match = zonedStringRegex.exec(input);
    if (match === null) {
        const offset = parseOffset(input);
        return offset !== null ? makeZoned(input, {
            timeZone: offset
        }) : _optionJs.none();
    }
    const [, isoString, timeZone] = match;
    return makeZoned(isoString, {
        timeZone
    });
};
const now = /*#__PURE__*/ _coreJs.map(_clockJs.currentTimeMillis, makeUtc);
const nowAsDate = /*#__PURE__*/ _coreJs.map(_clockJs.currentTimeMillis, (millis)=>new Date(millis));
const unsafeNow = ()=>makeUtc(Date.now());
const toUtc = (self)=>makeUtc(self.epochMillis);
const setZone = /*#__PURE__*/ (0, _functionJs.dual)(isDateTimeArgs, (self, zone, options)=>options?.adjustForTimeZone === true ? makeZonedFromAdjusted(self.epochMillis, zone) : makeZonedProto(self.epochMillis, zone, self.partsUtc));
const setZoneOffset = /*#__PURE__*/ (0, _functionJs.dual)(isDateTimeArgs, (self, offset, options)=>setZone(self, zoneMakeOffset(offset), options));
const validZoneCache = /*#__PURE__*/ (0, _globalValueJs.globalValue)("effect/DateTime/validZoneCache", ()=>new Map());
const formatOptions = {
    day: "numeric",
    month: "numeric",
    year: "numeric",
    hour: "numeric",
    minute: "numeric",
    second: "numeric",
    timeZoneName: "longOffset",
    fractionalSecondDigits: 3,
    hourCycle: "h23"
};
const zoneMakeIntl = (format)=>{
    const zoneId = format.resolvedOptions().timeZone;
    if (validZoneCache.has(zoneId)) return validZoneCache.get(zoneId);
    const zone = Object.create(ProtoTimeZoneNamed);
    zone.id = zoneId;
    zone.format = format;
    validZoneCache.set(zoneId, zone);
    return zone;
};
const zoneUnsafeMakeNamed = (zoneId)=>{
    if (validZoneCache.has(zoneId)) return validZoneCache.get(zoneId);
    try {
        return zoneMakeIntl(new Intl.DateTimeFormat("en-US", {
            ...formatOptions,
            timeZone: zoneId
        }));
    } catch (_) {
        throw new (0, _causeJs.IllegalArgumentException)(`Invalid time zone: ${zoneId}`);
    }
};
const zoneMakeOffset = (offset)=>{
    const zone = Object.create(ProtoTimeZoneOffset);
    zone.offset = offset;
    return zone;
};
const zoneMakeNamed = /*#__PURE__*/ _optionJs.liftThrowable(zoneUnsafeMakeNamed);
const zoneMakeNamedEffect = (zoneId)=>_coreEffectJs.try_({
        try: ()=>zoneUnsafeMakeNamed(zoneId),
        catch: (e)=>e
    });
const zoneMakeLocal = ()=>zoneMakeIntl(new Intl.DateTimeFormat("en-US", formatOptions));
const offsetZoneRegex = /^(?:GMT|[+-])/;
const zoneFromString = (zone)=>{
    if (offsetZoneRegex.test(zone)) {
        const offset = parseOffset(zone);
        return offset === null ? _optionJs.none() : _optionJs.some(zoneMakeOffset(offset));
    }
    return zoneMakeNamed(zone);
};
const zoneToString = (self)=>{
    if (self._tag === "Offset") return offsetToString(self.offset);
    return self.id;
};
const setZoneNamed = /*#__PURE__*/ (0, _functionJs.dual)(isDateTimeArgs, (self, zoneId, options)=>_optionJs.map(zoneMakeNamed(zoneId), (zone)=>setZone(self, zone, options)));
const unsafeSetZoneNamed = /*#__PURE__*/ (0, _functionJs.dual)(isDateTimeArgs, (self, zoneId, options)=>setZone(self, zoneUnsafeMakeNamed(zoneId), options));
const distance = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, other)=>toEpochMillis(other) - toEpochMillis(self));
const distanceDurationEither = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, other)=>{
    const diffMillis = distance(self, other);
    return diffMillis > 0 ? _eitherJs.right(_durationJs.millis(diffMillis)) : _eitherJs.left(_durationJs.millis(-diffMillis));
});
const distanceDuration = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, other)=>_durationJs.millis(Math.abs(distance(self, other))));
const min = /*#__PURE__*/ _orderJs.min(Order);
const max = /*#__PURE__*/ _orderJs.max(Order);
const greaterThan = /*#__PURE__*/ _orderJs.greaterThan(Order);
const greaterThanOrEqualTo = /*#__PURE__*/ _orderJs.greaterThanOrEqualTo(Order);
const lessThan = /*#__PURE__*/ _orderJs.lessThan(Order);
const lessThanOrEqualTo = /*#__PURE__*/ _orderJs.lessThanOrEqualTo(Order);
const between = /*#__PURE__*/ _orderJs.between(Order);
const isFuture = (self)=>_coreJs.map(now, lessThan(self));
const unsafeIsFuture = (self)=>lessThan(unsafeNow(), self);
const isPast = (self)=>_coreJs.map(now, greaterThan(self));
const unsafeIsPast = (self)=>greaterThan(unsafeNow(), self);
const toDateUtc = (self)=>new Date(self.epochMillis);
const toDate = (self)=>{
    if (self._tag === "Utc") return new Date(self.epochMillis);
    else if (self.zone._tag === "Offset") return new Date(self.epochMillis + self.zone.offset);
    else if (self.adjustedEpochMillis !== undefined) return new Date(self.adjustedEpochMillis);
    const parts = self.zone.format.formatToParts(self.epochMillis).filter((_)=>_.type !== "literal");
    const date = new Date(0);
    date.setUTCFullYear(Number(parts[2].value), Number(parts[0].value) - 1, Number(parts[1].value));
    date.setUTCHours(Number(parts[3].value), Number(parts[4].value), Number(parts[5].value), Number(parts[6].value));
    self.adjustedEpochMillis = date.getTime();
    return date;
};
const zonedOffset = (self)=>{
    const date = toDate(self);
    return date.getTime() - toEpochMillis(self);
};
const offsetToString = (offset)=>{
    const abs = Math.abs(offset);
    let hours = Math.floor(abs / 3600000);
    let minutes = Math.round(abs % 3600000 / 60000);
    if (minutes === 60) {
        hours += 1;
        minutes = 0;
    }
    return `${offset < 0 ? "-" : "+"}${String(hours).padStart(2, "0")}:${String(minutes).padStart(2, "0")}`;
};
const zonedOffsetIso = (self)=>offsetToString(zonedOffset(self));
const toEpochMillis = (self)=>self.epochMillis;
const removeTime = (self)=>withDate(self, (date)=>{
        date.setUTCHours(0, 0, 0, 0);
        return makeUtc(date.getTime());
    });
// =============================================================================
// parts
// =============================================================================
const dateToParts = (date)=>({
        millis: date.getUTCMilliseconds(),
        seconds: date.getUTCSeconds(),
        minutes: date.getUTCMinutes(),
        hours: date.getUTCHours(),
        day: date.getUTCDate(),
        weekDay: date.getUTCDay(),
        month: date.getUTCMonth() + 1,
        year: date.getUTCFullYear()
    });
const toParts = (self)=>{
    if (self._tag === "Utc") return toPartsUtc(self);
    else if (self.partsAdjusted !== undefined) return self.partsAdjusted;
    self.partsAdjusted = withDate(self, dateToParts);
    return self.partsAdjusted;
};
const toPartsUtc = (self)=>{
    if (self.partsUtc !== undefined) return self.partsUtc;
    self.partsUtc = withDateUtc(self, dateToParts);
    return self.partsUtc;
};
const getPartUtc = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, part)=>toPartsUtc(self)[part]);
const getPart = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, part)=>toParts(self)[part]);
const setPartsDate = (date, parts)=>{
    if (parts.year !== undefined) date.setUTCFullYear(parts.year);
    if (parts.month !== undefined) date.setUTCMonth(parts.month - 1);
    if (parts.day !== undefined) date.setUTCDate(parts.day);
    if (parts.weekDay !== undefined) {
        const diff = parts.weekDay - date.getUTCDay();
        date.setUTCDate(date.getUTCDate() + diff);
    }
    if (parts.hours !== undefined) date.setUTCHours(parts.hours);
    if (parts.minutes !== undefined) date.setUTCMinutes(parts.minutes);
    if (parts.seconds !== undefined) date.setUTCSeconds(parts.seconds);
    if (parts.millis !== undefined) date.setUTCMilliseconds(parts.millis);
};
const setParts = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, parts)=>mutate(self, (date)=>setPartsDate(date, parts)));
const setPartsUtc = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, parts)=>mutateUtc(self, (date)=>setPartsDate(date, parts)));
// =============================================================================
// mapping
// =============================================================================
const makeZonedFromAdjusted = (adjustedMillis, zone)=>{
    const offset = zone._tag === "Offset" ? zone.offset : calculateNamedOffset(adjustedMillis, zone);
    return makeZonedProto(adjustedMillis - offset, zone);
};
const offsetRegex = /([+-])(\d{2}):(\d{2})$/;
const parseOffset = (offset)=>{
    const match = offsetRegex.exec(offset);
    if (match === null) return null;
    const [, sign, hours, minutes] = match;
    return (sign === "+" ? 1 : -1) * (Number(hours) * 60 + Number(minutes)) * 60000;
};
const calculateNamedOffset = (adjustedMillis, zone)=>{
    const offset = zone.format.formatToParts(adjustedMillis).find((_)=>_.type === "timeZoneName")?.value ?? "";
    if (offset === "GMT") return 0;
    const result = parseOffset(offset);
    if (result === null) // fallback to using the adjusted date
    return zonedOffset(makeZonedProto(adjustedMillis, zone));
    return result;
};
const mutate = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>{
    if (self._tag === "Utc") {
        const date = toDateUtc(self);
        f(date);
        return makeUtc(date.getTime());
    }
    const adjustedDate = toDate(self);
    const newAdjustedDate = new Date(adjustedDate.getTime());
    f(newAdjustedDate);
    return makeZonedFromAdjusted(newAdjustedDate.getTime(), self.zone);
});
const mutateUtc = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>mapEpochMillis(self, (millis)=>{
        const date = new Date(millis);
        f(date);
        return date.getTime();
    }));
const mapEpochMillis = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>{
    const millis = f(toEpochMillis(self));
    return self._tag === "Utc" ? makeUtc(millis) : makeZonedProto(millis, self.zone);
});
const withDate = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>f(toDate(self)));
const withDateUtc = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>f(toDateUtc(self)));
const match = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, options)=>self._tag === "Utc" ? options.onUtc(self) : options.onZoned(self));
const addDuration = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, duration)=>mapEpochMillis(self, (millis)=>millis + _durationJs.toMillis(duration)));
const subtractDuration = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, duration)=>mapEpochMillis(self, (millis)=>millis - _durationJs.toMillis(duration)));
const addMillis = (date, amount)=>{
    date.setTime(date.getTime() + amount);
};
const add = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, parts)=>mutate(self, (date)=>{
        if (parts.millis) addMillis(date, parts.millis);
        if (parts.seconds) addMillis(date, parts.seconds * 1000);
        if (parts.minutes) addMillis(date, parts.minutes * 60000);
        if (parts.hours) addMillis(date, parts.hours * 3600000);
        if (parts.days) date.setUTCDate(date.getUTCDate() + parts.days);
        if (parts.weeks) date.setUTCDate(date.getUTCDate() + parts.weeks * 7);
        if (parts.months) {
            const day = date.getUTCDate();
            date.setUTCMonth(date.getUTCMonth() + parts.months + 1, 0);
            if (day < date.getUTCDate()) date.setUTCDate(day);
        }
        if (parts.years) {
            const day = date.getUTCDate();
            const month = date.getUTCMonth();
            date.setUTCFullYear(date.getUTCFullYear() + parts.years, month + 1, 0);
            if (day < date.getUTCDate()) date.setUTCDate(day);
        }
    }));
const subtract = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, parts)=>{
    const newParts = {};
    for(const key in parts)newParts[key] = -1 * parts[key];
    return add(self, newParts);
});
const startOfDate = (date, part, options)=>{
    switch(part){
        case "second":
            date.setUTCMilliseconds(0);
            break;
        case "minute":
            date.setUTCSeconds(0, 0);
            break;
        case "hour":
            date.setUTCMinutes(0, 0, 0);
            break;
        case "day":
            date.setUTCHours(0, 0, 0, 0);
            break;
        case "week":
            {
                const weekStartsOn = options?.weekStartsOn ?? 0;
                const day = date.getUTCDay();
                const diff = (day - weekStartsOn + 7) % 7;
                date.setUTCDate(date.getUTCDate() - diff);
                date.setUTCHours(0, 0, 0, 0);
                break;
            }
        case "month":
            date.setUTCDate(1);
            date.setUTCHours(0, 0, 0, 0);
            break;
        case "year":
            date.setUTCMonth(0, 1);
            date.setUTCHours(0, 0, 0, 0);
            break;
    }
};
const startOf = /*#__PURE__*/ (0, _functionJs.dual)(isDateTimeArgs, (self, part, options)=>mutate(self, (date)=>startOfDate(date, part, options)));
const endOfDate = (date, part, options)=>{
    switch(part){
        case "second":
            date.setUTCMilliseconds(999);
            break;
        case "minute":
            date.setUTCSeconds(59, 999);
            break;
        case "hour":
            date.setUTCMinutes(59, 59, 999);
            break;
        case "day":
            date.setUTCHours(23, 59, 59, 999);
            break;
        case "week":
            {
                const weekStartsOn = options?.weekStartsOn ?? 0;
                const day = date.getUTCDay();
                const diff = (day - weekStartsOn + 7) % 7;
                date.setUTCDate(date.getUTCDate() - diff + 6);
                date.setUTCHours(23, 59, 59, 999);
                break;
            }
        case "month":
            date.setUTCMonth(date.getUTCMonth() + 1, 0);
            date.setUTCHours(23, 59, 59, 999);
            break;
        case "year":
            date.setUTCMonth(11, 31);
            date.setUTCHours(23, 59, 59, 999);
            break;
    }
};
const endOf = /*#__PURE__*/ (0, _functionJs.dual)(isDateTimeArgs, (self, part, options)=>mutate(self, (date)=>endOfDate(date, part, options)));
const nearest = /*#__PURE__*/ (0, _functionJs.dual)(isDateTimeArgs, (self, part, options)=>mutate(self, (date)=>{
        if (part === "milli") return;
        const millis = date.getTime();
        const start = new Date(millis);
        startOfDate(start, part, options);
        const startMillis = start.getTime();
        const end = new Date(millis);
        endOfDate(end, part, options);
        const endMillis = end.getTime() + 1;
        const diffStart = millis - startMillis;
        const diffEnd = endMillis - millis;
        if (diffStart < diffEnd) date.setTime(startMillis);
        else date.setTime(endMillis);
    }));
// =============================================================================
// formatting
// =============================================================================
const intlTimeZone = (self)=>{
    if (self._tag === "Named") return self.id;
    return offsetToString(self.offset);
};
const format = /*#__PURE__*/ (0, _functionJs.dual)(isDateTimeArgs, (self, options)=>{
    try {
        return new Intl.DateTimeFormat(options?.locale, {
            timeZone: self._tag === "Utc" ? "UTC" : intlTimeZone(self.zone),
            ...options
        }).format(self.epochMillis);
    } catch (_) {
        return new Intl.DateTimeFormat(options?.locale, {
            timeZone: "UTC",
            ...options
        }).format(toDate(self));
    }
});
const formatLocal = /*#__PURE__*/ (0, _functionJs.dual)(isDateTimeArgs, (self, options)=>new Intl.DateTimeFormat(options?.locale, options).format(self.epochMillis));
const formatUtc = /*#__PURE__*/ (0, _functionJs.dual)(isDateTimeArgs, (self, options)=>new Intl.DateTimeFormat(options?.locale, {
        ...options,
        timeZone: "UTC"
    }).format(self.epochMillis));
const formatIntl = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, format)=>format.format(self.epochMillis));
const formatIso = (self)=>toDateUtc(self).toISOString();
const formatIsoDate = (self)=>toDate(self).toISOString().slice(0, 10);
const formatIsoDateUtc = (self)=>toDateUtc(self).toISOString().slice(0, 10);
const formatIsoOffset = (self)=>{
    const date = toDate(self);
    return self._tag === "Utc" ? date.toISOString() : `${date.toISOString().slice(0, -1)}${zonedOffsetIso(self)}`;
};
const formatIsoZoned = (self)=>self.zone._tag === "Offset" ? formatIsoOffset(self) : `${formatIsoOffset(self)}[${self.zone.id}]`;

},{"../Cause.js":"gQcQI","../Clock.js":"2Ndj4","../Duration.js":"czLLe","../Either.js":"4amnT","../Equal.js":"gA0qD","../Equivalence.js":"1WBUa","../Function.js":"21gOL","../GlobalValue.js":"5w3Hn","../Hash.js":"gFMwE","../Inspectable.js":"1Ur70","../Option.js":"6sHA7","../Order.js":"lQMwD","../Pipeable.js":"b5RU2","../Predicate.js":"gW5pd","./core-effect.js":"k8F3C","./core.js":"cr3YV","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"k8F3C":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "annotateLogs", ()=>annotateLogs);
parcelHelpers.export(exports, "asSome", ()=>asSome);
parcelHelpers.export(exports, "asSomeError", ()=>asSomeError);
parcelHelpers.export(exports, "try_", ()=>try_);
parcelHelpers.export(exports, "_catch", ()=>_catch);
parcelHelpers.export(exports, "catchAllDefect", ()=>catchAllDefect);
parcelHelpers.export(exports, "catchSomeCause", ()=>catchSomeCause);
parcelHelpers.export(exports, "catchSomeDefect", ()=>catchSomeDefect);
parcelHelpers.export(exports, "catchTag", ()=>catchTag);
parcelHelpers.export(exports, "catchTags", ()=>catchTags);
parcelHelpers.export(exports, "cause", ()=>cause);
parcelHelpers.export(exports, "clockWith", ()=>clockWith);
parcelHelpers.export(exports, "clock", ()=>clock);
parcelHelpers.export(exports, "delay", ()=>delay);
parcelHelpers.export(exports, "descriptorWith", ()=>descriptorWith);
parcelHelpers.export(exports, "allowInterrupt", ()=>allowInterrupt);
parcelHelpers.export(exports, "descriptor", ()=>descriptor);
parcelHelpers.export(exports, "diffFiberRefs", ()=>diffFiberRefs);
parcelHelpers.export(exports, "diffFiberRefsAndRuntimeFlags", ()=>diffFiberRefsAndRuntimeFlags);
parcelHelpers.export(exports, "Do", ()=>Do);
parcelHelpers.export(exports, "bind", ()=>bind);
parcelHelpers.export(exports, "bindTo", ()=>bindTo);
parcelHelpers.export(exports, "let_", ()=>let_);
parcelHelpers.export(exports, "dropUntil", ()=>dropUntil);
parcelHelpers.export(exports, "dropWhile", ()=>dropWhile);
parcelHelpers.export(exports, "contextWith", ()=>contextWith);
parcelHelpers.export(exports, "eventually", ()=>eventually);
parcelHelpers.export(exports, "filterMap", ()=>filterMap);
parcelHelpers.export(exports, "filterOrDie", ()=>filterOrDie);
parcelHelpers.export(exports, "filterOrDieMessage", ()=>filterOrDieMessage);
parcelHelpers.export(exports, "filterOrElse", ()=>filterOrElse);
parcelHelpers.export(exports, "liftPredicate", ()=>liftPredicate);
parcelHelpers.export(exports, "filterOrFail", ()=>filterOrFail);
parcelHelpers.export(exports, "findFirst", ()=>findFirst);
parcelHelpers.export(exports, "firstSuccessOf", ()=>firstSuccessOf);
parcelHelpers.export(exports, "flipWith", ()=>flipWith);
parcelHelpers.export(exports, "match", ()=>match);
parcelHelpers.export(exports, "every", ()=>every);
parcelHelpers.export(exports, "forever", ()=>forever);
parcelHelpers.export(exports, "fiberRefs", ()=>fiberRefs);
parcelHelpers.export(exports, "head", ()=>head);
parcelHelpers.export(exports, "ignore", ()=>ignore);
parcelHelpers.export(exports, "ignoreLogged", ()=>ignoreLogged);
parcelHelpers.export(exports, "inheritFiberRefs", ()=>inheritFiberRefs);
parcelHelpers.export(exports, "isFailure", ()=>isFailure);
parcelHelpers.export(exports, "isSuccess", ()=>isSuccess);
parcelHelpers.export(exports, "iterate", ()=>iterate);
parcelHelpers.export(exports, "logWithLevel", ()=>logWithLevel);
parcelHelpers.export(exports, "log", ()=>log);
parcelHelpers.export(exports, "logTrace", ()=>logTrace);
parcelHelpers.export(exports, "logDebug", ()=>logDebug);
parcelHelpers.export(exports, "logInfo", ()=>logInfo);
parcelHelpers.export(exports, "logWarning", ()=>logWarning);
parcelHelpers.export(exports, "logError", ()=>logError);
parcelHelpers.export(exports, "logFatal", ()=>logFatal);
parcelHelpers.export(exports, "withLogSpan", ()=>withLogSpan);
parcelHelpers.export(exports, "logAnnotations", ()=>logAnnotations);
parcelHelpers.export(exports, "loop", ()=>loop);
parcelHelpers.export(exports, "mapAccum", ()=>mapAccum);
parcelHelpers.export(exports, "mapErrorCause", ()=>mapErrorCause);
parcelHelpers.export(exports, "memoize", ()=>memoize);
parcelHelpers.export(exports, "merge", ()=>merge);
parcelHelpers.export(exports, "negate", ()=>negate);
parcelHelpers.export(exports, "none", ()=>none);
parcelHelpers.export(exports, "once", ()=>once);
parcelHelpers.export(exports, "option", ()=>option);
parcelHelpers.export(exports, "orElseFail", ()=>orElseFail);
parcelHelpers.export(exports, "orElseSucceed", ()=>orElseSucceed);
parcelHelpers.export(exports, "parallelErrors", ()=>parallelErrors);
parcelHelpers.export(exports, "patchFiberRefs", ()=>patchFiberRefs);
parcelHelpers.export(exports, "promise", ()=>promise);
parcelHelpers.export(exports, "provideService", ()=>provideService);
parcelHelpers.export(exports, "provideServiceEffect", ()=>provideServiceEffect);
parcelHelpers.export(exports, "random", ()=>random);
parcelHelpers.export(exports, "reduce", ()=>reduce);
parcelHelpers.export(exports, "reduceRight", ()=>reduceRight);
parcelHelpers.export(exports, "reduceWhile", ()=>reduceWhile);
parcelHelpers.export(exports, "repeatN", ()=>repeatN);
parcelHelpers.export(exports, "sandbox", ()=>sandbox);
parcelHelpers.export(exports, "setFiberRefs", ()=>setFiberRefs);
parcelHelpers.export(exports, "sleep", ()=>sleep);
parcelHelpers.export(exports, "succeedNone", ()=>succeedNone);
parcelHelpers.export(exports, "succeedSome", ()=>succeedSome);
parcelHelpers.export(exports, "summarized", ()=>summarized);
parcelHelpers.export(exports, "tagMetrics", ()=>tagMetrics);
parcelHelpers.export(exports, "labelMetrics", ()=>labelMetrics);
parcelHelpers.export(exports, "takeUntil", ()=>takeUntil);
parcelHelpers.export(exports, "takeWhile", ()=>takeWhile);
parcelHelpers.export(exports, "tapBoth", ()=>tapBoth);
parcelHelpers.export(exports, "tapDefect", ()=>tapDefect);
parcelHelpers.export(exports, "tapError", ()=>tapError);
parcelHelpers.export(exports, "tapErrorTag", ()=>tapErrorTag);
parcelHelpers.export(exports, "tapErrorCause", ()=>tapErrorCause);
parcelHelpers.export(exports, "timed", ()=>timed);
parcelHelpers.export(exports, "timedWith", ()=>timedWith);
parcelHelpers.export(exports, "tracerWith", ()=>tracerWith);
parcelHelpers.export(exports, "tracer", ()=>tracer);
parcelHelpers.export(exports, "tryPromise", ()=>tryPromise);
parcelHelpers.export(exports, "tryMap", ()=>tryMap);
parcelHelpers.export(exports, "tryMapPromise", ()=>tryMapPromise);
parcelHelpers.export(exports, "unless", ()=>unless);
parcelHelpers.export(exports, "unlessEffect", ()=>unlessEffect);
parcelHelpers.export(exports, "unsandbox", ()=>unsandbox);
parcelHelpers.export(exports, "updateFiberRefs", ()=>updateFiberRefs);
parcelHelpers.export(exports, "updateService", ()=>updateService);
parcelHelpers.export(exports, "when", ()=>when);
parcelHelpers.export(exports, "whenFiberRef", ()=>whenFiberRef);
parcelHelpers.export(exports, "whenRef", ()=>whenRef);
parcelHelpers.export(exports, "withMetric", ()=>withMetric);
parcelHelpers.export(exports, "serviceFunctionEffect", ()=>serviceFunctionEffect);
parcelHelpers.export(exports, "serviceFunction", ()=>serviceFunction);
parcelHelpers.export(exports, "serviceFunctions", ()=>serviceFunctions);
parcelHelpers.export(exports, "serviceConstants", ()=>serviceConstants);
parcelHelpers.export(exports, "serviceMembers", ()=>serviceMembers);
parcelHelpers.export(exports, "serviceOption", ()=>serviceOption);
parcelHelpers.export(exports, "serviceOptional", ()=>serviceOptional);
parcelHelpers.export(exports, "annotateCurrentSpan", ()=>annotateCurrentSpan);
parcelHelpers.export(exports, "linkSpanCurrent", ()=>linkSpanCurrent);
parcelHelpers.export(exports, "annotateSpans", ()=>annotateSpans);
parcelHelpers.export(exports, "currentParentSpan", ()=>currentParentSpan);
parcelHelpers.export(exports, "currentSpan", ()=>currentSpan);
parcelHelpers.export(exports, "linkSpans", ()=>linkSpans);
parcelHelpers.export(exports, "unsafeMakeSpan", ()=>unsafeMakeSpan);
parcelHelpers.export(exports, "makeSpan", ()=>makeSpan);
parcelHelpers.export(exports, "spanAnnotations", ()=>spanAnnotations);
parcelHelpers.export(exports, "spanLinks", ()=>spanLinks);
parcelHelpers.export(exports, "endSpan", ()=>endSpan);
parcelHelpers.export(exports, "useSpan", ()=>useSpan);
parcelHelpers.export(exports, "withParentSpan", ()=>withParentSpan);
parcelHelpers.export(exports, "withSpan", ()=>withSpan);
parcelHelpers.export(exports, "functionWithSpan", ()=>functionWithSpan);
parcelHelpers.export(exports, "fromNullable", ()=>fromNullable);
parcelHelpers.export(exports, "optionFromOptional", ()=>optionFromOptional);
var _arrayJs = require("../Array.js");
var _chunkJs = require("../Chunk.js");
var _clockJs = require("../Clock.js");
var _contextJs = require("../Context.js");
var _durationJs = require("../Duration.js");
var _fiberRefsJs = require("../FiberRefs.js");
var _functionJs = require("../Function.js");
var _hashMapJs = require("../HashMap.js");
var _hashSetJs = require("../HashSet.js");
var _listJs = require("../List.js");
var _logLevelJs = require("../LogLevel.js");
var _logSpanJs = require("../LogSpan.js");
var _optionJs = require("../Option.js");
var _predicateJs = require("../Predicate.js");
var _refJs = require("../Ref.js");
var _tracerJs = require("../Tracer.js");
var _utilsJs = require("../Utils.js");
var _causeJs = require("./cause.js");
var _clockJs1 = require("./clock.js");
var _coreJs = require("./core.js");
var _defaultServicesJs = require("./defaultServices.js");
var _doNotationJs = require("./doNotation.js");
var _patchJs = require("./fiberRefs/patch.js");
var _labelJs = require("./metric/label.js");
var _runtimeFlagsJs = require("./runtimeFlags.js");
var _tracerJs1 = require("./tracer.js");
const annotateLogs = /*#__PURE__*/ (0, _functionJs.dual)((args)=>_coreJs.isEffect(args[0]), function() {
    const args = arguments;
    return _coreJs.fiberRefLocallyWith(args[0], _coreJs.currentLogAnnotations, typeof args[1] === "string" ? _hashMapJs.set(args[1], args[2]) : (annotations)=>Object.entries(args[1]).reduce((acc, [key, value])=>_hashMapJs.set(acc, key, value), annotations));
});
const asSome = (self)=>_coreJs.map(self, _optionJs.some);
const asSomeError = (self)=>_coreJs.mapError(self, _optionJs.some);
const try_ = (arg)=>{
    let evaluate;
    let onFailure = undefined;
    if (typeof arg === "function") evaluate = arg;
    else {
        evaluate = arg.try;
        onFailure = arg.catch;
    }
    return _coreJs.suspend(()=>{
        try {
            return _coreJs.succeed((0, _utilsJs.internalCall)(evaluate));
        } catch (error) {
            return _coreJs.fail(onFailure ? (0, _utilsJs.internalCall)(()=>onFailure(error)) : new _coreJs.UnknownException(error, "An unknown error occurred in Effect.try"));
        }
    });
};
const _catch = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, tag, options)=>_coreJs.catchAll(self, (e)=>{
        if (_predicateJs.hasProperty(e, tag) && e[tag] === options.failure) return options.onFailure(e);
        return _coreJs.fail(e);
    }));
const catchAllDefect = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>_coreJs.catchAllCause(self, (cause)=>{
        const option = _causeJs.find(cause, (_)=>_causeJs.isDieType(_) ? _optionJs.some(_) : _optionJs.none());
        switch(option._tag){
            case "None":
                return _coreJs.failCause(cause);
            case "Some":
                return f(option.value.defect);
        }
    }));
const catchSomeCause = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>_coreJs.matchCauseEffect(self, {
        onFailure: (cause)=>{
            const option = f(cause);
            switch(option._tag){
                case "None":
                    return _coreJs.failCause(cause);
                case "Some":
                    return option.value;
            }
        },
        onSuccess: _coreJs.succeed
    }));
const catchSomeDefect = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, pf)=>_coreJs.catchAllCause(self, (cause)=>{
        const option = _causeJs.find(cause, (_)=>_causeJs.isDieType(_) ? _optionJs.some(_) : _optionJs.none());
        switch(option._tag){
            case "None":
                return _coreJs.failCause(cause);
            case "Some":
                {
                    const optionEffect = pf(option.value.defect);
                    return optionEffect._tag === "Some" ? optionEffect.value : _coreJs.failCause(cause);
                }
        }
    }));
const catchTag = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, k, f)=>_coreJs.catchIf(self, _predicateJs.isTagged(k), f));
const catchTags = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, cases)=>{
    let keys;
    return _coreJs.catchIf(self, (e)=>{
        keys ??= Object.keys(cases);
        return _predicateJs.hasProperty(e, "_tag") && _predicateJs.isString(e["_tag"]) && keys.includes(e["_tag"]);
    }, (e)=>cases[e["_tag"]](e));
});
const cause = (self)=>_coreJs.matchCause(self, {
        onFailure: (0, _functionJs.identity),
        onSuccess: ()=>_causeJs.empty
    });
const clockWith = _clockJs.clockWith;
const clock = /*#__PURE__*/ clockWith(_coreJs.succeed);
const delay = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, duration)=>_coreJs.zipRight(_clockJs.sleep(duration), self));
const descriptorWith = (f)=>_coreJs.withFiberRuntime((state, status)=>f({
            id: state.id(),
            status,
            interruptors: _causeJs.interruptors(state.getFiberRef(_coreJs.currentInterruptedCause))
        }));
const allowInterrupt = /*#__PURE__*/ descriptorWith((descriptor)=>_hashSetJs.size(descriptor.interruptors) > 0 ? _coreJs.interrupt : _coreJs.void);
const descriptor = /*#__PURE__*/ descriptorWith(_coreJs.succeed);
const diffFiberRefs = (self)=>summarized(self, fiberRefs, _patchJs.diff);
const diffFiberRefsAndRuntimeFlags = (self)=>summarized(self, _coreJs.zip(fiberRefs, _coreJs.runtimeFlags), ([refs, flags], [refsNew, flagsNew])=>[
            _patchJs.diff(refs, refsNew),
            _runtimeFlagsJs.diff(flags, flagsNew)
        ]);
const Do = /*#__PURE__*/ _coreJs.succeed({});
const bind = /*#__PURE__*/ _doNotationJs.bind(_coreJs.map, _coreJs.flatMap);
const bindTo = /*#__PURE__*/ _doNotationJs.bindTo(_coreJs.map);
const let_ = /*#__PURE__*/ _doNotationJs.let_(_coreJs.map);
const dropUntil = /*#__PURE__*/ (0, _functionJs.dual)(2, (elements, predicate)=>_coreJs.suspend(()=>{
        const iterator = elements[Symbol.iterator]();
        const builder = [];
        let next;
        let dropping = _coreJs.succeed(false);
        let i = 0;
        while((next = iterator.next()) && !next.done){
            const a = next.value;
            const index = i++;
            dropping = _coreJs.flatMap(dropping, (bool)=>{
                if (bool) {
                    builder.push(a);
                    return _coreJs.succeed(true);
                }
                return predicate(a, index);
            });
        }
        return _coreJs.map(dropping, ()=>builder);
    }));
const dropWhile = /*#__PURE__*/ (0, _functionJs.dual)(2, (elements, predicate)=>_coreJs.suspend(()=>{
        const iterator = elements[Symbol.iterator]();
        const builder = [];
        let next;
        let dropping = _coreJs.succeed(true);
        let i = 0;
        while((next = iterator.next()) && !next.done){
            const a = next.value;
            const index = i++;
            dropping = _coreJs.flatMap(dropping, (d)=>_coreJs.map(d ? predicate(a, index) : _coreJs.succeed(false), (b)=>{
                    if (!b) builder.push(a);
                    return b;
                }));
        }
        return _coreJs.map(dropping, ()=>builder);
    }));
const contextWith = (f)=>_coreJs.map(_coreJs.context(), f);
const eventually = (self)=>_coreJs.orElse(self, ()=>_coreJs.flatMap(_coreJs.yieldNow(), ()=>eventually(self)));
const filterMap = /*#__PURE__*/ (0, _functionJs.dual)(2, (elements, pf)=>_coreJs.map(_coreJs.forEachSequential(elements, (0, _functionJs.identity)), _arrayJs.filterMap(pf)));
const filterOrDie = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, predicate, orDieWith)=>filterOrElse(self, predicate, (a)=>_coreJs.dieSync(()=>orDieWith(a))));
const filterOrDieMessage = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, predicate, message)=>filterOrElse(self, predicate, ()=>_coreJs.dieMessage(message)));
const filterOrElse = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, predicate, orElse)=>_coreJs.flatMap(self, (a)=>predicate(a) ? _coreJs.succeed(a) : orElse(a)));
const liftPredicate = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, predicate, orFailWith)=>_coreJs.suspend(()=>predicate(self) ? _coreJs.succeed(self) : _coreJs.fail(orFailWith(self))));
const filterOrFail = /*#__PURE__*/ (0, _functionJs.dual)((args)=>_coreJs.isEffect(args[0]), (self, predicate, orFailWith)=>filterOrElse(self, predicate, (a)=>orFailWith === undefined ? _coreJs.fail(new _coreJs.NoSuchElementException()) : _coreJs.failSync(()=>orFailWith(a))));
const findFirst = /*#__PURE__*/ (0, _functionJs.dual)(2, (elements, predicate)=>_coreJs.suspend(()=>{
        const iterator = elements[Symbol.iterator]();
        const next = iterator.next();
        if (!next.done) return findLoop(iterator, 0, predicate, next.value);
        return _coreJs.succeed(_optionJs.none());
    }));
const findLoop = (iterator, index, f, value)=>_coreJs.flatMap(f(value, index), (result)=>{
        if (result) return _coreJs.succeed(_optionJs.some(value));
        const next = iterator.next();
        if (!next.done) return findLoop(iterator, index + 1, f, next.value);
        return _coreJs.succeed(_optionJs.none());
    });
const firstSuccessOf = (effects)=>_coreJs.suspend(()=>{
        const list = _chunkJs.fromIterable(effects);
        if (!_chunkJs.isNonEmpty(list)) return _coreJs.dieSync(()=>new _coreJs.IllegalArgumentException(`Received an empty collection of effects`));
        return (0, _functionJs.pipe)(_chunkJs.tailNonEmpty(list), _arrayJs.reduce(_chunkJs.headNonEmpty(list), (left, right)=>_coreJs.orElse(left, ()=>right)));
    });
const flipWith = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>_coreJs.flip(f(_coreJs.flip(self))));
const match = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, options)=>_coreJs.matchEffect(self, {
        onFailure: (e)=>_coreJs.succeed(options.onFailure(e)),
        onSuccess: (a)=>_coreJs.succeed(options.onSuccess(a))
    }));
const every = /*#__PURE__*/ (0, _functionJs.dual)(2, (elements, predicate)=>_coreJs.suspend(()=>forAllLoop(elements[Symbol.iterator](), 0, predicate)));
const forAllLoop = (iterator, index, f)=>{
    const next = iterator.next();
    return next.done ? _coreJs.succeed(true) : _coreJs.flatMap(f(next.value, index), (b)=>b ? forAllLoop(iterator, index + 1, f) : _coreJs.succeed(b));
};
const forever = (self)=>{
    const loop = _coreJs.flatMap(_coreJs.flatMap(self, ()=>_coreJs.yieldNow()), ()=>loop);
    return loop;
};
const fiberRefs = /*#__PURE__*/ _coreJs.withFiberRuntime((state)=>_coreJs.succeed(state.getFiberRefs()));
const head = (self)=>_coreJs.flatMap(self, (as)=>{
        const iterator = as[Symbol.iterator]();
        const next = iterator.next();
        if (next.done) return _coreJs.fail(new _coreJs.NoSuchElementException());
        return _coreJs.succeed(next.value);
    });
const ignore = (self)=>match(self, {
        onFailure: (0, _functionJs.constVoid),
        onSuccess: (0, _functionJs.constVoid)
    });
const ignoreLogged = (self)=>_coreJs.matchCauseEffect(self, {
        onFailure: (cause)=>logDebug(cause, "An error was silently ignored because it is not anticipated to be useful"),
        onSuccess: ()=>_coreJs.void
    });
const inheritFiberRefs = (childFiberRefs)=>updateFiberRefs((parentFiberId, parentFiberRefs)=>_fiberRefsJs.joinAs(parentFiberRefs, parentFiberId, childFiberRefs));
const isFailure = (self)=>match(self, {
        onFailure: (0, _functionJs.constTrue),
        onSuccess: (0, _functionJs.constFalse)
    });
const isSuccess = (self)=>match(self, {
        onFailure: (0, _functionJs.constFalse),
        onSuccess: (0, _functionJs.constTrue)
    });
const iterate = (initial, options)=>_coreJs.suspend(()=>{
        if (options.while(initial)) return _coreJs.flatMap(options.body(initial), (z2)=>iterate(z2, options));
        return _coreJs.succeed(initial);
    });
const logWithLevel = (level)=>(...message)=>{
        const levelOption = _optionJs.fromNullable(level);
        let cause = undefined;
        for(let i = 0, len = message.length; i < len; i++){
            const msg = message[i];
            if (_causeJs.isCause(msg)) {
                if (cause !== undefined) cause = _causeJs.sequential(cause, msg);
                else cause = msg;
                message = [
                    ...message.slice(0, i),
                    ...message.slice(i + 1)
                ];
                i--;
            }
        }
        if (cause === undefined) cause = _causeJs.empty;
        return _coreJs.withFiberRuntime((fiberState)=>{
            fiberState.log(message, cause, levelOption);
            return _coreJs.void;
        });
    };
const log = /*#__PURE__*/ logWithLevel();
const logTrace = /*#__PURE__*/ logWithLevel(_logLevelJs.Trace);
const logDebug = /*#__PURE__*/ logWithLevel(_logLevelJs.Debug);
const logInfo = /*#__PURE__*/ logWithLevel(_logLevelJs.Info);
const logWarning = /*#__PURE__*/ logWithLevel(_logLevelJs.Warning);
const logError = /*#__PURE__*/ logWithLevel(_logLevelJs.Error);
const logFatal = /*#__PURE__*/ logWithLevel(_logLevelJs.Fatal);
const withLogSpan = /*#__PURE__*/ (0, _functionJs.dual)(2, (effect, label)=>_coreJs.flatMap(_clockJs.currentTimeMillis, (now)=>_coreJs.fiberRefLocallyWith(effect, _coreJs.currentLogSpan, _listJs.prepend(_logSpanJs.make(label, now)))));
const logAnnotations = /*#__PURE__*/ _coreJs.fiberRefGet(_coreJs.currentLogAnnotations);
const loop = (initial, options)=>options.discard ? loopDiscard(initial, options.while, options.step, options.body) : _coreJs.map(loopInternal(initial, options.while, options.step, options.body), _arrayJs.fromIterable);
const loopInternal = (initial, cont, inc, body)=>_coreJs.suspend(()=>cont(initial) ? _coreJs.flatMap(body(initial), (a)=>_coreJs.map(loopInternal(inc(initial), cont, inc, body), _listJs.prepend(a))) : _coreJs.sync(()=>_listJs.empty()));
const loopDiscard = (initial, cont, inc, body)=>_coreJs.suspend(()=>cont(initial) ? _coreJs.flatMap(body(initial), ()=>loopDiscard(inc(initial), cont, inc, body)) : _coreJs.void);
const mapAccum = /*#__PURE__*/ (0, _functionJs.dual)(3, (elements, initial, f)=>_coreJs.suspend(()=>{
        const iterator = elements[Symbol.iterator]();
        const builder = [];
        let result = _coreJs.succeed(initial);
        let next;
        let i = 0;
        while(!(next = iterator.next()).done){
            const index = i++;
            const value = next.value;
            result = _coreJs.flatMap(result, (state)=>_coreJs.map(f(state, value, index), ([z, b])=>{
                    builder.push(b);
                    return z;
                }));
        }
        return _coreJs.map(result, (z)=>[
                z,
                builder
            ]);
    }));
const mapErrorCause = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>_coreJs.matchCauseEffect(self, {
        onFailure: (c)=>_coreJs.failCauseSync(()=>f(c)),
        onSuccess: _coreJs.succeed
    }));
const memoize = (self)=>(0, _functionJs.pipe)(_coreJs.deferredMake(), _coreJs.flatMap((deferred)=>(0, _functionJs.pipe)(diffFiberRefsAndRuntimeFlags(self), _coreJs.intoDeferred(deferred), once, _coreJs.map((complete)=>_coreJs.zipRight(complete, (0, _functionJs.pipe)(_coreJs.deferredAwait(deferred), _coreJs.flatMap(([patch, a])=>_coreJs.as(_coreJs.zip(patchFiberRefs(patch[0]), _coreJs.updateRuntimeFlags(patch[1])), a))))))));
const merge = (self)=>_coreJs.matchEffect(self, {
        onFailure: (e)=>_coreJs.succeed(e),
        onSuccess: _coreJs.succeed
    });
const negate = (self)=>_coreJs.map(self, (b)=>!b);
const none = (self)=>_coreJs.flatMap(self, (option)=>{
        switch(option._tag){
            case "None":
                return _coreJs.void;
            case "Some":
                return _coreJs.fail(new _coreJs.NoSuchElementException());
        }
    });
const once = (self)=>_coreJs.map(_refJs.make(true), (ref)=>_coreJs.asVoid(_coreJs.whenEffect(self, _refJs.getAndSet(ref, false))));
const option = (self)=>_coreJs.matchEffect(self, {
        onFailure: ()=>_coreJs.succeed(_optionJs.none()),
        onSuccess: (a)=>_coreJs.succeed(_optionJs.some(a))
    });
const orElseFail = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, evaluate)=>_coreJs.orElse(self, ()=>_coreJs.failSync(evaluate)));
const orElseSucceed = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, evaluate)=>_coreJs.orElse(self, ()=>_coreJs.sync(evaluate)));
const parallelErrors = (self)=>_coreJs.matchCauseEffect(self, {
        onFailure: (cause)=>{
            const errors = _arrayJs.fromIterable(_causeJs.failures(cause));
            return errors.length === 0 ? _coreJs.failCause(cause) : _coreJs.fail(errors);
        },
        onSuccess: _coreJs.succeed
    });
const patchFiberRefs = (patch)=>updateFiberRefs((fiberId, fiberRefs)=>(0, _functionJs.pipe)(patch, _patchJs.patch(fiberId, fiberRefs)));
const promise = (evaluate)=>evaluate.length >= 1 ? _coreJs.async((resolve, signal)=>{
        try {
            evaluate(signal).then((a)=>resolve(_coreJs.exitSucceed(a)), (e)=>resolve(_coreJs.exitDie(e)));
        } catch (e) {
            resolve(_coreJs.exitDie(e));
        }
    }) : _coreJs.async((resolve)=>{
        try {
            evaluate().then((a)=>resolve(_coreJs.exitSucceed(a)), (e)=>resolve(_coreJs.exitDie(e)));
        } catch (e) {
            resolve(_coreJs.exitDie(e));
        }
    });
const provideService = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, tag, service)=>_coreJs.contextWithEffect((env)=>_coreJs.provideContext(self, _contextJs.add(env, tag, service))));
const provideServiceEffect = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, tag, effect)=>_coreJs.contextWithEffect((env)=>_coreJs.flatMap(effect, (service)=>_coreJs.provideContext(self, (0, _functionJs.pipe)(env, _contextJs.add(tag, service))))));
const random = /*#__PURE__*/ _defaultServicesJs.randomWith(_coreJs.succeed);
const reduce = /*#__PURE__*/ (0, _functionJs.dual)(3, (elements, zero, f)=>_arrayJs.fromIterable(elements).reduce((acc, el, i)=>_coreJs.flatMap(acc, (a)=>f(a, el, i)), _coreJs.succeed(zero)));
const reduceRight = /*#__PURE__*/ (0, _functionJs.dual)(3, (elements, zero, f)=>_arrayJs.fromIterable(elements).reduceRight((acc, el, i)=>_coreJs.flatMap(acc, (a)=>f(el, a, i)), _coreJs.succeed(zero)));
const reduceWhile = /*#__PURE__*/ (0, _functionJs.dual)(3, (elements, zero, options)=>_coreJs.flatMap(_coreJs.sync(()=>elements[Symbol.iterator]()), (iterator)=>reduceWhileLoop(iterator, 0, zero, options.while, options.body)));
const reduceWhileLoop = (iterator, index, state, predicate, f)=>{
    const next = iterator.next();
    if (!next.done && predicate(state)) return _coreJs.flatMap(f(state, next.value, index), (nextState)=>reduceWhileLoop(iterator, index + 1, nextState, predicate, f));
    return _coreJs.succeed(state);
};
const repeatN = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, n)=>_coreJs.suspend(()=>repeatNLoop(self, n)));
/* @internal */ const repeatNLoop = (self, n)=>_coreJs.flatMap(self, (a)=>n <= 0 ? _coreJs.succeed(a) : _coreJs.zipRight(_coreJs.yieldNow(), repeatNLoop(self, n - 1)));
const sandbox = (self)=>_coreJs.matchCauseEffect(self, {
        onFailure: _coreJs.fail,
        onSuccess: _coreJs.succeed
    });
const setFiberRefs = (fiberRefs)=>_coreJs.suspend(()=>_fiberRefsJs.setAll(fiberRefs));
const sleep = _clockJs.sleep;
const succeedNone = /*#__PURE__*/ _coreJs.succeed(/*#__PURE__*/ _optionJs.none());
const succeedSome = (value)=>_coreJs.succeed(_optionJs.some(value));
const summarized = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, summary, f)=>_coreJs.flatMap(summary, (start)=>_coreJs.flatMap(self, (value)=>_coreJs.map(summary, (end)=>[
                    f(start, end),
                    value
                ]))));
const tagMetrics = /*#__PURE__*/ (0, _functionJs.dual)((args)=>_coreJs.isEffect(args[0]), function() {
    return labelMetrics(arguments[0], typeof arguments[1] === "string" ? [
        _labelJs.make(arguments[1], arguments[2])
    ] : Object.entries(arguments[1]).map(([k, v])=>_labelJs.make(k, v)));
});
const labelMetrics = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, labels)=>_coreJs.fiberRefLocallyWith(self, _coreJs.currentMetricLabels, (old)=>_arrayJs.union(old, labels)));
const takeUntil = /*#__PURE__*/ (0, _functionJs.dual)(2, (elements, predicate)=>_coreJs.suspend(()=>{
        const iterator = elements[Symbol.iterator]();
        const builder = [];
        let next;
        let effect = _coreJs.succeed(false);
        let i = 0;
        while((next = iterator.next()) && !next.done){
            const a = next.value;
            const index = i++;
            effect = _coreJs.flatMap(effect, (bool)=>{
                if (bool) return _coreJs.succeed(true);
                builder.push(a);
                return predicate(a, index);
            });
        }
        return _coreJs.map(effect, ()=>builder);
    }));
const takeWhile = /*#__PURE__*/ (0, _functionJs.dual)(2, (elements, predicate)=>_coreJs.suspend(()=>{
        const iterator = elements[Symbol.iterator]();
        const builder = [];
        let next;
        let taking = _coreJs.succeed(true);
        let i = 0;
        while((next = iterator.next()) && !next.done){
            const a = next.value;
            const index = i++;
            taking = _coreJs.flatMap(taking, (taking)=>(0, _functionJs.pipe)(taking ? predicate(a, index) : _coreJs.succeed(false), _coreJs.map((bool)=>{
                    if (bool) builder.push(a);
                    return bool;
                })));
        }
        return _coreJs.map(taking, ()=>builder);
    }));
const tapBoth = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, { onFailure, onSuccess })=>_coreJs.matchCauseEffect(self, {
        onFailure: (cause)=>{
            const either = _causeJs.failureOrCause(cause);
            switch(either._tag){
                case "Left":
                    return _coreJs.zipRight(onFailure(either.left), _coreJs.failCause(cause));
                case "Right":
                    return _coreJs.failCause(cause);
            }
        },
        onSuccess: (a)=>_coreJs.as(onSuccess(a), a)
    }));
const tapDefect = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>_coreJs.catchAllCause(self, (cause)=>_optionJs.match(_causeJs.keepDefects(cause), {
            onNone: ()=>_coreJs.failCause(cause),
            onSome: (a)=>_coreJs.zipRight(f(a), _coreJs.failCause(cause))
        })));
const tapError = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>_coreJs.matchCauseEffect(self, {
        onFailure: (cause)=>{
            const either = _causeJs.failureOrCause(cause);
            switch(either._tag){
                case "Left":
                    return _coreJs.zipRight(f(either.left), _coreJs.failCause(cause));
                case "Right":
                    return _coreJs.failCause(cause);
            }
        },
        onSuccess: _coreJs.succeed
    }));
const tapErrorTag = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, k, f)=>tapError(self, (e)=>{
        if (_predicateJs.isTagged(e, k)) return f(e);
        return _coreJs.void;
    }));
const tapErrorCause = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>_coreJs.matchCauseEffect(self, {
        onFailure: (cause)=>_coreJs.zipRight(f(cause), _coreJs.failCause(cause)),
        onSuccess: _coreJs.succeed
    }));
const timed = (self)=>timedWith(self, _clockJs.currentTimeNanos);
const timedWith = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, nanos)=>summarized(self, nanos, (start, end)=>_durationJs.nanos(end - start)));
const tracerWith = _tracerJs.tracerWith;
const tracer = /*#__PURE__*/ tracerWith(_coreJs.succeed);
const tryPromise = (arg)=>{
    let evaluate;
    let catcher = undefined;
    if (typeof arg === "function") evaluate = arg;
    else {
        evaluate = arg.try;
        catcher = arg.catch;
    }
    const fail = (e)=>catcher ? _coreJs.failSync(()=>catcher(e)) : _coreJs.fail(new _coreJs.UnknownException(e, "An unknown error occurred in Effect.tryPromise"));
    if (evaluate.length >= 1) return _coreJs.async((resolve, signal)=>{
        try {
            evaluate(signal).then((a)=>resolve(_coreJs.exitSucceed(a)), (e)=>resolve(fail(e)));
        } catch (e) {
            resolve(fail(e));
        }
    });
    return _coreJs.async((resolve)=>{
        try {
            evaluate().then((a)=>resolve(_coreJs.exitSucceed(a)), (e)=>resolve(fail(e)));
        } catch (e) {
            resolve(fail(e));
        }
    });
};
const tryMap = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, options)=>_coreJs.flatMap(self, (a)=>try_({
            try: ()=>options.try(a),
            catch: options.catch
        })));
const tryMapPromise = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, options)=>_coreJs.flatMap(self, (a)=>tryPromise({
            try: options.try.length >= 1 ? (signal)=>options.try(a, signal) : ()=>options.try(a),
            catch: options.catch
        })));
const unless = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, condition)=>_coreJs.suspend(()=>condition() ? succeedNone : asSome(self)));
const unlessEffect = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, condition)=>_coreJs.flatMap(condition, (b)=>b ? succeedNone : asSome(self)));
const unsandbox = (self)=>mapErrorCause(self, _causeJs.flatten);
const updateFiberRefs = (f)=>_coreJs.withFiberRuntime((state)=>{
        state.setFiberRefs(f(state.id(), state.getFiberRefs()));
        return _coreJs.void;
    });
const updateService = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, tag, f)=>_coreJs.mapInputContext(self, (context)=>_contextJs.add(context, tag, f(_contextJs.unsafeGet(context, tag)))));
const when = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, condition)=>_coreJs.suspend(()=>condition() ? _coreJs.map(self, _optionJs.some) : _coreJs.succeed(_optionJs.none())));
const whenFiberRef = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, fiberRef, predicate)=>_coreJs.flatMap(_coreJs.fiberRefGet(fiberRef), (s)=>predicate(s) ? _coreJs.map(self, (a)=>[
                s,
                _optionJs.some(a)
            ]) : _coreJs.succeed([
            s,
            _optionJs.none()
        ])));
const whenRef = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, ref, predicate)=>_coreJs.flatMap(_refJs.get(ref), (s)=>predicate(s) ? _coreJs.map(self, (a)=>[
                s,
                _optionJs.some(a)
            ]) : _coreJs.succeed([
            s,
            _optionJs.none()
        ])));
const withMetric = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, metric)=>metric(self));
const serviceFunctionEffect = (getService, f)=>(...args)=>_coreJs.flatMap(getService, (a)=>f(a)(...args));
const serviceFunction = (getService, f)=>(...args)=>_coreJs.map(getService, (a)=>f(a)(...args));
const serviceFunctions = (getService)=>new Proxy({}, {
        get (_target, prop, _receiver) {
            return (...args)=>_coreJs.flatMap(getService, (s)=>s[prop](...args));
        }
    });
const serviceConstants = (getService)=>new Proxy({}, {
        get (_target, prop, _receiver) {
            return _coreJs.flatMap(getService, (s)=>_coreJs.isEffect(s[prop]) ? s[prop] : _coreJs.succeed(s[prop]));
        }
    });
const serviceMembers = (getService)=>({
        functions: serviceFunctions(getService),
        constants: serviceConstants(getService)
    });
const serviceOption = (tag)=>_coreJs.map(_coreJs.context(), _contextJs.getOption(tag));
const serviceOptional = (tag)=>_coreJs.flatMap(_coreJs.context(), _contextJs.getOption(tag));
const annotateCurrentSpan = function() {
    const args = arguments;
    return ignore(_coreJs.flatMap(currentSpan, (span)=>_coreJs.sync(()=>{
            if (typeof args[0] === "string") span.attribute(args[0], args[1]);
            else for(const key in args[0])span.attribute(key, args[0][key]);
        })));
};
const linkSpanCurrent = function() {
    const args = arguments;
    const links = Array.isArray(args[0]) ? args[0] : [
        {
            _tag: "SpanLink",
            span: args[0],
            attributes: args[1] ?? {}
        }
    ];
    return ignore(_coreJs.flatMap(currentSpan, (span)=>_coreJs.sync(()=>span.addLinks(links))));
};
const annotateSpans = /*#__PURE__*/ (0, _functionJs.dual)((args)=>_coreJs.isEffect(args[0]), function() {
    const args = arguments;
    return _coreJs.fiberRefLocallyWith(args[0], _coreJs.currentTracerSpanAnnotations, typeof args[1] === "string" ? _hashMapJs.set(args[1], args[2]) : (annotations)=>Object.entries(args[1]).reduce((acc, [key, value])=>_hashMapJs.set(acc, key, value), annotations));
});
const currentParentSpan = /*#__PURE__*/ serviceOptional(_tracerJs1.spanTag);
const currentSpan = /*#__PURE__*/ _coreJs.flatMap(/*#__PURE__*/ _coreJs.context(), (context)=>{
    const span = context.unsafeMap.get(_tracerJs1.spanTag.key);
    return span !== undefined && span._tag === "Span" ? _coreJs.succeed(span) : _coreJs.fail(new _coreJs.NoSuchElementException());
});
const linkSpans = /*#__PURE__*/ (0, _functionJs.dual)((args)=>_coreJs.isEffect(args[0]), (self, span, attributes)=>_coreJs.fiberRefLocallyWith(self, _coreJs.currentTracerSpanLinks, _chunkJs.append({
        _tag: "SpanLink",
        span,
        attributes: attributes ?? {}
    })));
const bigint0 = /*#__PURE__*/ BigInt(0);
const filterDisablePropagation = /*#__PURE__*/ _optionJs.flatMap((span)=>_contextJs.get(span.context, _tracerJs1.DisablePropagation) ? span._tag === "Span" ? filterDisablePropagation(span.parent) : _optionJs.none() : _optionJs.some(span));
const unsafeMakeSpan = (fiber, name, options)=>{
    const disablePropagation = !fiber.getFiberRef(_coreJs.currentTracerEnabled) || options.context && _contextJs.get(options.context, _tracerJs1.DisablePropagation);
    const context = fiber.getFiberRef(_coreJs.currentContext);
    const parent = options.parent ? _optionJs.some(options.parent) : options.root ? _optionJs.none() : filterDisablePropagation(_contextJs.getOption(context, _tracerJs1.spanTag));
    let span;
    if (disablePropagation) span = _coreJs.noopSpan({
        name,
        parent,
        context: _contextJs.add(options.context ?? _contextJs.empty(), _tracerJs1.DisablePropagation, true)
    });
    else {
        const services = fiber.getFiberRef(_defaultServicesJs.currentServices);
        const tracer = _contextJs.get(services, _tracerJs1.tracerTag);
        const clock = _contextJs.get(services, _clockJs.Clock);
        const timingEnabled = fiber.getFiberRef(_coreJs.currentTracerTimingEnabled);
        const fiberRefs = fiber.getFiberRefs();
        const annotationsFromEnv = _fiberRefsJs.get(fiberRefs, _coreJs.currentTracerSpanAnnotations);
        const linksFromEnv = _fiberRefsJs.get(fiberRefs, _coreJs.currentTracerSpanLinks);
        const links = linksFromEnv._tag === "Some" ? options.links !== undefined ? [
            ..._chunkJs.toReadonlyArray(linksFromEnv.value),
            ...options.links ?? []
        ] : _chunkJs.toReadonlyArray(linksFromEnv.value) : options.links ?? _arrayJs.empty();
        span = tracer.span(name, parent, options.context ?? _contextJs.empty(), links, timingEnabled ? clock.unsafeCurrentTimeNanos() : bigint0, options.kind ?? "internal");
        if (annotationsFromEnv._tag === "Some") _hashMapJs.forEach(annotationsFromEnv.value, (value, key)=>span.attribute(key, value));
        if (options.attributes !== undefined) Object.entries(options.attributes).forEach(([k, v])=>span.attribute(k, v));
    }
    if (typeof options.captureStackTrace === "function") _causeJs.spanToTrace.set(span, options.captureStackTrace);
    return span;
};
const makeSpan = (name, options)=>{
    options = _tracerJs1.addSpanStackTrace(options);
    return _coreJs.withFiberRuntime((fiber)=>_coreJs.succeed(unsafeMakeSpan(fiber, name, options)));
};
const spanAnnotations = /*#__PURE__*/ _coreJs.fiberRefGet(_coreJs.currentTracerSpanAnnotations);
const spanLinks = /*#__PURE__*/ _coreJs.fiberRefGet(_coreJs.currentTracerSpanLinks);
const endSpan = (span, exit, clock, timingEnabled)=>_coreJs.sync(()=>{
        if (span.status._tag === "Ended") return;
        if (_coreJs.exitIsFailure(exit) && _causeJs.spanToTrace.has(span)) span.attribute("code.stacktrace", _causeJs.spanToTrace.get(span)());
        span.end(timingEnabled ? clock.unsafeCurrentTimeNanos() : bigint0, exit);
    });
const useSpan = (name, ...args)=>{
    const options = _tracerJs1.addSpanStackTrace(args.length === 1 ? undefined : args[0]);
    const evaluate = args[args.length - 1];
    return _coreJs.withFiberRuntime((fiber)=>{
        const span = unsafeMakeSpan(fiber, name, options);
        const timingEnabled = fiber.getFiberRef(_coreJs.currentTracerTimingEnabled);
        const clock = _contextJs.get(fiber.getFiberRef(_defaultServicesJs.currentServices), (0, _clockJs1.clockTag));
        return _coreJs.onExit(evaluate(span), (exit)=>endSpan(span, exit, clock, timingEnabled));
    });
};
const withParentSpan = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, span)=>provideService(self, _tracerJs1.spanTag, span));
const withSpan = function() {
    const dataFirst = typeof arguments[0] !== "string";
    const name = dataFirst ? arguments[1] : arguments[0];
    const options = _tracerJs1.addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
    if (dataFirst) {
        const self = arguments[0];
        return useSpan(name, options, (span)=>withParentSpan(self, span));
    }
    return (self)=>useSpan(name, options, (span)=>withParentSpan(self, span));
};
const functionWithSpan = (options)=>function() {
        let captureStackTrace = options.captureStackTrace ?? false;
        if (options.captureStackTrace !== false) {
            const limit = Error.stackTraceLimit;
            Error.stackTraceLimit = 2;
            const error = new Error();
            Error.stackTraceLimit = limit;
            let cache = false;
            captureStackTrace = ()=>{
                if (cache !== false) return cache;
                if (error.stack) {
                    const stack = error.stack.trim().split("\n");
                    cache = stack.slice(2).join("\n").trim();
                    return cache;
                }
            };
        }
        return _coreJs.suspend(()=>{
            const opts = typeof options.options === "function" ? options.options.apply(null, arguments) : options.options;
            return withSpan(_coreJs.suspend(()=>(0, _utilsJs.internalCall)(()=>options.body.apply(this, arguments))), opts.name, {
                ...opts,
                captureStackTrace
            });
        });
    };
const fromNullable = (value)=>value == null ? _coreJs.fail(new _coreJs.NoSuchElementException()) : _coreJs.succeed(value);
const optionFromOptional = (self)=>_coreJs.catchAll(_coreJs.map(self, _optionJs.some), (error)=>_coreJs.isNoSuchElementException(error) ? succeedNone : _coreJs.fail(error));

},{"../Array.js":"8L2Gk","../Chunk.js":"dL1OO","../Clock.js":"2Ndj4","../Context.js":"c2abN","../Duration.js":"czLLe","../FiberRefs.js":"lIa2I","../Function.js":"21gOL","../HashMap.js":"aG8zS","../HashSet.js":"aKFFV","../List.js":"a341T","../LogLevel.js":"76ZSp","../LogSpan.js":"6mXfM","../Option.js":"6sHA7","../Predicate.js":"gW5pd","../Ref.js":"cqfIo","../Tracer.js":"b4XQ6","../Utils.js":"dYvz1","./cause.js":"l3ev0","./clock.js":"27hJp","./core.js":"cr3YV","./defaultServices.js":"aF4q8","./doNotation.js":"6eyzd","./fiberRefs/patch.js":"lTfKe","./metric/label.js":"hcYDB","./runtimeFlags.js":"9rFhC","./tracer.js":"aAsvB","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"lIa2I":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FiberRefsSym", ()=>FiberRefsSym);
parcelHelpers.export(exports, "delete", ()=>/**
 * Deletes the specified `FiberRef` from the `FibterRefs`.
 *
 * @since 2.0.0
 * @category utils
 */ delete_);
parcelHelpers.export(exports, "fiberRefs", ()=>fiberRefs);
parcelHelpers.export(exports, "forkAs", ()=>forkAs);
parcelHelpers.export(exports, "get", ()=>get);
parcelHelpers.export(exports, "getOrDefault", ()=>getOrDefault);
parcelHelpers.export(exports, "joinAs", ()=>joinAs);
parcelHelpers.export(exports, "setAll", ()=>setAll);
parcelHelpers.export(exports, "updateAs", ()=>updateAs);
parcelHelpers.export(exports, "updateManyAs", ()=>updateManyAs);
parcelHelpers.export(exports, "unsafeMake", ()=>unsafeMake);
parcelHelpers.export(exports, "empty", ()=>empty);
var _fiberRefsJs = require("./internal/fiberRefs.js");
const FiberRefsSym = _fiberRefsJs.FiberRefsSym;
const delete_ = _fiberRefsJs.delete_;
const fiberRefs = _fiberRefsJs.fiberRefs;
const forkAs = _fiberRefsJs.forkAs;
const get = _fiberRefsJs.get;
const getOrDefault = _fiberRefsJs.getOrDefault;
const joinAs = _fiberRefsJs.joinAs;
const setAll = _fiberRefsJs.setAll;
const updateAs = _fiberRefsJs.updateAs;
const updateManyAs = _fiberRefsJs.updateManyAs;
const unsafeMake = _fiberRefsJs.unsafeMake;
const empty = _fiberRefsJs.empty;

},{"./internal/fiberRefs.js":"gt1Z6","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"gt1Z6":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** @internal */ parcelHelpers.export(exports, "unsafeMake", ()=>unsafeMake);
/** @internal */ parcelHelpers.export(exports, "empty", ()=>empty);
parcelHelpers.export(exports, "FiberRefsSym", ()=>FiberRefsSym);
/** @internal */ parcelHelpers.export(exports, "FiberRefsImpl", ()=>FiberRefsImpl);
parcelHelpers.export(exports, "joinAs", ()=>joinAs);
parcelHelpers.export(exports, "forkAs", ()=>forkAs);
parcelHelpers.export(exports, "fiberRefs", ()=>fiberRefs);
parcelHelpers.export(exports, "setAll", ()=>setAll);
parcelHelpers.export(exports, "delete_", ()=>delete_);
parcelHelpers.export(exports, "get", ()=>get);
parcelHelpers.export(exports, "getOrDefault", ()=>getOrDefault);
parcelHelpers.export(exports, "updateAs", ()=>updateAs);
parcelHelpers.export(exports, "updateManyAs", ()=>updateManyAs);
var _arrayJs = require("../Array.js");
var _equalJs = require("../Equal.js");
var _functionJs = require("../Function.js");
var _hashSetJs = require("../HashSet.js");
var _optionJs = require("../Option.js");
var _pipeableJs = require("../Pipeable.js");
var _coreJs = require("./core.js");
function unsafeMake(fiberRefLocals) {
    return new FiberRefsImpl(fiberRefLocals);
}
function empty() {
    return unsafeMake(new Map());
}
const FiberRefsSym = /*#__PURE__*/ Symbol.for("effect/FiberRefs");
class FiberRefsImpl {
    locals;
    [FiberRefsSym] = FiberRefsSym;
    constructor(locals){
        this.locals = locals;
    }
    pipe() {
        return (0, _pipeableJs.pipeArguments)(this, arguments);
    }
}
/** @internal */ const findAncestor = (_ref, _parentStack, _childStack, _childModified = false)=>{
    const ref = _ref;
    let parentStack = _parentStack;
    let childStack = _childStack;
    let childModified = _childModified;
    let ret = undefined;
    while(ret === undefined)if (_arrayJs.isNonEmptyReadonlyArray(parentStack) && _arrayJs.isNonEmptyReadonlyArray(childStack)) {
        const parentFiberId = _arrayJs.headNonEmpty(parentStack)[0];
        const parentAncestors = _arrayJs.tailNonEmpty(parentStack);
        const childFiberId = _arrayJs.headNonEmpty(childStack)[0];
        const childRefValue = _arrayJs.headNonEmpty(childStack)[1];
        const childAncestors = _arrayJs.tailNonEmpty(childStack);
        if (parentFiberId.startTimeMillis < childFiberId.startTimeMillis) {
            childStack = childAncestors;
            childModified = true;
        } else if (parentFiberId.startTimeMillis > childFiberId.startTimeMillis) parentStack = parentAncestors;
        else {
            if (parentFiberId.id < childFiberId.id) {
                childStack = childAncestors;
                childModified = true;
            } else if (parentFiberId.id > childFiberId.id) parentStack = parentAncestors;
            else ret = [
                childRefValue,
                childModified
            ];
        }
    } else ret = [
        ref.initial,
        true
    ];
    return ret;
};
const joinAs = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, fiberId, that)=>{
    const parentFiberRefs = new Map(self.locals);
    that.locals.forEach((childStack, fiberRef)=>{
        const childValue = childStack[0][1];
        if (!childStack[0][0][_equalJs.symbol](fiberId)) {
            if (!parentFiberRefs.has(fiberRef)) {
                if (_equalJs.equals(childValue, fiberRef.initial)) return;
                parentFiberRefs.set(fiberRef, [
                    [
                        fiberId,
                        fiberRef.join(fiberRef.initial, childValue)
                    ]
                ]);
                return;
            }
            const parentStack = parentFiberRefs.get(fiberRef);
            const [ancestor, wasModified] = findAncestor(fiberRef, parentStack, childStack);
            if (wasModified) {
                const patch = fiberRef.diff(ancestor, childValue);
                const oldValue = parentStack[0][1];
                const newValue = fiberRef.join(oldValue, fiberRef.patch(patch)(oldValue));
                if (!_equalJs.equals(oldValue, newValue)) {
                    let newStack;
                    const parentFiberId = parentStack[0][0];
                    if (parentFiberId[_equalJs.symbol](fiberId)) newStack = [
                        [
                            parentFiberId,
                            newValue
                        ],
                        ...parentStack.slice(1)
                    ];
                    else newStack = [
                        [
                            fiberId,
                            newValue
                        ],
                        ...parentStack
                    ];
                    parentFiberRefs.set(fiberRef, newStack);
                }
            }
        }
    });
    return new FiberRefsImpl(parentFiberRefs);
});
const forkAs = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, childId)=>{
    const map = new Map();
    unsafeForkAs(self, map, childId);
    return new FiberRefsImpl(map);
});
const unsafeForkAs = (self, map, fiberId)=>{
    self.locals.forEach((stack, fiberRef)=>{
        const oldValue = stack[0][1];
        const newValue = fiberRef.patch(fiberRef.fork)(oldValue);
        if (_equalJs.equals(oldValue, newValue)) map.set(fiberRef, stack);
        else map.set(fiberRef, [
            [
                fiberId,
                newValue
            ],
            ...stack
        ]);
    });
};
const fiberRefs = (self)=>_hashSetJs.fromIterable(self.locals.keys());
const setAll = (self)=>_coreJs.forEachSequentialDiscard(fiberRefs(self), (fiberRef)=>_coreJs.fiberRefSet(fiberRef, getOrDefault(self, fiberRef)));
const delete_ = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, fiberRef)=>{
    const locals = new Map(self.locals);
    locals.delete(fiberRef);
    return new FiberRefsImpl(locals);
});
const get = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, fiberRef)=>{
    if (!self.locals.has(fiberRef)) return _optionJs.none();
    return _optionJs.some(_arrayJs.headNonEmpty(self.locals.get(fiberRef))[1]);
});
const getOrDefault = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, fiberRef)=>(0, _functionJs.pipe)(get(self, fiberRef), _optionJs.getOrElse(()=>fiberRef.initial)));
const updateAs = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, { fiberId, fiberRef, value })=>{
    if (self.locals.size === 0) return new FiberRefsImpl(new Map([
        [
            fiberRef,
            [
                [
                    fiberId,
                    value
                ]
            ]
        ]
    ]));
    const locals = new Map(self.locals);
    unsafeUpdateAs(locals, fiberId, fiberRef, value);
    return new FiberRefsImpl(locals);
});
const unsafeUpdateAs = (locals, fiberId, fiberRef, value)=>{
    const oldStack = locals.get(fiberRef) ?? [];
    let newStack;
    if (_arrayJs.isNonEmptyReadonlyArray(oldStack)) {
        const [currentId, currentValue] = _arrayJs.headNonEmpty(oldStack);
        if (currentId[_equalJs.symbol](fiberId)) {
            if (_equalJs.equals(currentValue, value)) return;
            else newStack = [
                [
                    fiberId,
                    value
                ],
                ...oldStack.slice(1)
            ];
        } else newStack = [
            [
                fiberId,
                value
            ],
            ...oldStack
        ];
    } else newStack = [
        [
            fiberId,
            value
        ]
    ];
    locals.set(fiberRef, newStack);
};
const updateManyAs = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, { entries, forkAs })=>{
    if (self.locals.size === 0) return new FiberRefsImpl(new Map(entries));
    const locals = new Map(self.locals);
    if (forkAs !== undefined) unsafeForkAs(self, locals, forkAs);
    entries.forEach(([fiberRef, values])=>{
        if (values.length === 1) unsafeUpdateAs(locals, values[0][0], fiberRef, values[0][1]);
        else values.forEach(([fiberId, value])=>{
            unsafeUpdateAs(locals, fiberId, fiberRef, value);
        });
    });
    return new FiberRefsImpl(locals);
});

},{"../Array.js":"8L2Gk","../Equal.js":"gA0qD","../Function.js":"21gOL","../HashSet.js":"aKFFV","../Option.js":"6sHA7","../Pipeable.js":"b5RU2","./core.js":"cr3YV","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"76ZSp":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "All", ()=>All);
parcelHelpers.export(exports, "Fatal", ()=>Fatal);
parcelHelpers.export(exports, "Error", ()=>Error);
parcelHelpers.export(exports, "Warning", ()=>Warning);
parcelHelpers.export(exports, "Info", ()=>Info);
parcelHelpers.export(exports, "Debug", ()=>Debug);
parcelHelpers.export(exports, "Trace", ()=>Trace);
parcelHelpers.export(exports, "None", ()=>None);
parcelHelpers.export(exports, "allLevels", ()=>allLevels);
parcelHelpers.export(exports, "locally", ()=>locally);
parcelHelpers.export(exports, "Order", ()=>Order);
parcelHelpers.export(exports, "lessThan", ()=>lessThan);
parcelHelpers.export(exports, "lessThanEqual", ()=>lessThanEqual);
parcelHelpers.export(exports, "greaterThan", ()=>greaterThan);
parcelHelpers.export(exports, "greaterThanEqual", ()=>greaterThanEqual);
parcelHelpers.export(exports, "fromLiteral", ()=>fromLiteral);
var _functionJs = require("./Function.js");
var _coreJs = require("./internal/core.js");
var _numberJs = require("./Number.js");
var _orderJs = require("./Order.js");
const All = _coreJs.logLevelAll;
const Fatal = _coreJs.logLevelFatal;
const Error = _coreJs.logLevelError;
const Warning = _coreJs.logLevelWarning;
const Info = _coreJs.logLevelInfo;
const Debug = _coreJs.logLevelDebug;
const Trace = _coreJs.logLevelTrace;
const None = _coreJs.logLevelNone;
const allLevels = _coreJs.allLogLevels;
const locally = /*#__PURE__*/ (0, _functionJs.dual)(2, (use, self)=>_coreJs.fiberRefLocally(use, _coreJs.currentLogLevel, self));
const Order = /*#__PURE__*/ (0, _functionJs.pipe)(_numberJs.Order, /*#__PURE__*/ _orderJs.mapInput((level)=>level.ordinal));
const lessThan = /*#__PURE__*/ _orderJs.lessThan(Order);
const lessThanEqual = /*#__PURE__*/ _orderJs.lessThanOrEqualTo(Order);
const greaterThan = /*#__PURE__*/ _orderJs.greaterThan(Order);
const greaterThanEqual = /*#__PURE__*/ _orderJs.greaterThanOrEqualTo(Order);
const fromLiteral = (literal)=>{
    switch(literal){
        case "All":
            return All;
        case "Debug":
            return Debug;
        case "Error":
            return Error;
        case "Fatal":
            return Fatal;
        case "Info":
            return Info;
        case "Trace":
            return Trace;
        case "None":
            return None;
        case "Warning":
            return Warning;
    }
};

},{"./Function.js":"21gOL","./internal/core.js":"cr3YV","./Number.js":"al4Y3","./Order.js":"lQMwD","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"6mXfM":[function(require,module,exports,__globalThis) {
/**
 * @since 2.0.0
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "make", ()=>make);
parcelHelpers.export(exports, "render", ()=>render);
var _logSpanJs = require("./internal/logSpan.js");
const make = _logSpanJs.make;
const render = _logSpanJs.render;

},{"./internal/logSpan.js":"3TBwR","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"3TBwR":[function(require,module,exports,__globalThis) {
/** @internal */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "make", ()=>make);
parcelHelpers.export(exports, "formatLabel", ()=>formatLabel);
parcelHelpers.export(exports, "render", ()=>render);
const make = (label, startTime)=>({
        label,
        startTime
    });
const formatLabel = (key)=>key.replace(/[\s="]/g, "_");
const render = (now)=>(self)=>{
        const label = formatLabel(self.label);
        return `${label}=${now - self.startTime}ms`;
    };

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"cqfIo":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RefTypeId", ()=>RefTypeId);
parcelHelpers.export(exports, "make", ()=>make);
parcelHelpers.export(exports, "get", ()=>get);
parcelHelpers.export(exports, "getAndSet", ()=>getAndSet);
parcelHelpers.export(exports, "getAndUpdate", ()=>getAndUpdate);
parcelHelpers.export(exports, "getAndUpdateSome", ()=>getAndUpdateSome);
parcelHelpers.export(exports, "modify", ()=>modify);
parcelHelpers.export(exports, "modifySome", ()=>modifySome);
parcelHelpers.export(exports, "set", ()=>set);
parcelHelpers.export(exports, "setAndGet", ()=>setAndGet);
parcelHelpers.export(exports, "update", ()=>update);
parcelHelpers.export(exports, "updateAndGet", ()=>updateAndGet);
parcelHelpers.export(exports, "updateSome", ()=>updateSome);
parcelHelpers.export(exports, "updateSomeAndGet", ()=>updateSomeAndGet);
parcelHelpers.export(exports, "unsafeMake", ()=>unsafeMake);
var _refJs = require("./internal/ref.js");
const RefTypeId = _refJs.RefTypeId;
const make = _refJs.make;
const get = _refJs.get;
const getAndSet = _refJs.getAndSet;
const getAndUpdate = _refJs.getAndUpdate;
const getAndUpdateSome = _refJs.getAndUpdateSome;
const modify = _refJs.modify;
const modifySome = _refJs.modifySome;
const set = _refJs.set;
const setAndGet = _refJs.setAndGet;
const update = _refJs.update;
const updateAndGet = _refJs.updateAndGet;
const updateSome = _refJs.updateSome;
const updateSomeAndGet = _refJs.updateSomeAndGet;
const unsafeMake = _refJs.unsafeMake;

},{"./internal/ref.js":"90h4v","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"90h4v":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RefTypeId", ()=>RefTypeId);
parcelHelpers.export(exports, "refVariance", ()=>refVariance);
parcelHelpers.export(exports, "unsafeMake", ()=>unsafeMake);
parcelHelpers.export(exports, "make", ()=>make);
parcelHelpers.export(exports, "get", ()=>get);
parcelHelpers.export(exports, "set", ()=>set);
parcelHelpers.export(exports, "getAndSet", ()=>getAndSet);
parcelHelpers.export(exports, "getAndUpdate", ()=>getAndUpdate);
parcelHelpers.export(exports, "getAndUpdateSome", ()=>getAndUpdateSome);
parcelHelpers.export(exports, "setAndGet", ()=>setAndGet);
parcelHelpers.export(exports, "modify", ()=>modify);
parcelHelpers.export(exports, "modifySome", ()=>modifySome);
parcelHelpers.export(exports, "update", ()=>update);
parcelHelpers.export(exports, "updateAndGet", ()=>updateAndGet);
parcelHelpers.export(exports, "updateSome", ()=>updateSome);
parcelHelpers.export(exports, "updateSomeAndGet", ()=>updateSomeAndGet);
parcelHelpers.export(exports, "unsafeGet", ()=>unsafeGet);
var _effectableJs = require("../Effectable.js");
var _functionJs = require("../Function.js");
var _mutableRefJs = require("../MutableRef.js");
var _optionJs = require("../Option.js");
var _readableJs = require("../Readable.js");
var _coreJs = require("./core.js");
const RefTypeId = /*#__PURE__*/ Symbol.for("effect/Ref");
const refVariance = {
    /* c8 ignore next */ _A: (_)=>_
};
class RefImpl extends _effectableJs.Class {
    ref;
    commit() {
        return this.get;
    }
    [RefTypeId] = refVariance;
    [_readableJs.TypeId] = _readableJs.TypeId;
    constructor(ref){
        super();
        this.ref = ref;
        this.get = _coreJs.sync(()=>_mutableRefJs.get(this.ref));
    }
    get;
    modify(f) {
        return _coreJs.sync(()=>{
            const current = _mutableRefJs.get(this.ref);
            const [b, a] = f(current);
            if (current !== a) _mutableRefJs.set(a)(this.ref);
            return b;
        });
    }
}
const unsafeMake = (value)=>new RefImpl(_mutableRefJs.make(value));
const make = (value)=>_coreJs.sync(()=>unsafeMake(value));
const get = (self)=>self.get;
const set = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, value)=>self.modify(()=>[
            void 0,
            value
        ]));
const getAndSet = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, value)=>self.modify((a)=>[
            a,
            value
        ]));
const getAndUpdate = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>self.modify((a)=>[
            a,
            f(a)
        ]));
const getAndUpdateSome = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, pf)=>self.modify((value)=>{
        const option = pf(value);
        switch(option._tag){
            case "None":
                return [
                    value,
                    value
                ];
            case "Some":
                return [
                    value,
                    option.value
                ];
        }
    }));
const setAndGet = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, value)=>self.modify(()=>[
            value,
            value
        ]));
const modify = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>self.modify(f));
const modifySome = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, fallback, pf)=>self.modify((value)=>{
        const option = pf(value);
        switch(option._tag){
            case "None":
                return [
                    fallback,
                    value
                ];
            case "Some":
                return option.value;
        }
    }));
const update = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>self.modify((a)=>[
            void 0,
            f(a)
        ]));
const updateAndGet = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>self.modify((a)=>{
        const result = f(a);
        return [
            result,
            result
        ];
    }));
const updateSome = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>self.modify((a)=>[
            void 0,
            _optionJs.match(f(a), {
                onNone: ()=>a,
                onSome: (b)=>b
            })
        ]));
const updateSomeAndGet = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, pf)=>self.modify((value)=>{
        const option = pf(value);
        switch(option._tag){
            case "None":
                return [
                    value,
                    value
                ];
            case "Some":
                return [
                    option.value,
                    option.value
                ];
        }
    }));
const unsafeGet = (self)=>_mutableRefJs.get(self.ref);

},{"../Effectable.js":"kxbGz","../Function.js":"21gOL","../MutableRef.js":"aCyaL","../Option.js":"6sHA7","../Readable.js":"5KKZ9","./core.js":"cr3YV","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"kxbGz":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EffectTypeId", ()=>EffectTypeId);
parcelHelpers.export(exports, "StreamTypeId", ()=>StreamTypeId);
parcelHelpers.export(exports, "SinkTypeId", ()=>SinkTypeId);
parcelHelpers.export(exports, "ChannelTypeId", ()=>ChannelTypeId);
parcelHelpers.export(exports, "EffectPrototype", ()=>EffectPrototype);
parcelHelpers.export(exports, "CommitPrototype", ()=>CommitPrototype);
parcelHelpers.export(exports, "StructuralCommitPrototype", ()=>StructuralCommitPrototype);
/**
 * @since 2.0.0
 * @category constructors
 */ parcelHelpers.export(exports, "Class", ()=>Class);
/**
 * @since 2.0.0
 * @category constructors
 */ parcelHelpers.export(exports, "StructuralClass", ()=>StructuralClass);
var _effectableJs = require("./internal/effectable.js");
const EffectTypeId = _effectableJs.EffectTypeId;
const StreamTypeId = _effectableJs.StreamTypeId;
const SinkTypeId = _effectableJs.SinkTypeId;
const ChannelTypeId = _effectableJs.ChannelTypeId;
const EffectPrototype = _effectableJs.EffectPrototype;
const CommitPrototype = _effectableJs.CommitPrototype;
const StructuralCommitPrototype = _effectableJs.StructuralCommitPrototype;
const Base = _effectableJs.Base;
const StructuralBase = _effectableJs.StructuralBase;
class Class extends Base {
}
class StructuralClass extends StructuralBase {
}

},{"./internal/effectable.js":"8EvvU","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"5KKZ9":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TypeId", ()=>TypeId);
parcelHelpers.export(exports, "isReadable", ()=>isReadable);
parcelHelpers.export(exports, "make", ()=>make);
parcelHelpers.export(exports, "map", ()=>map);
parcelHelpers.export(exports, "mapEffect", ()=>mapEffect);
parcelHelpers.export(exports, "unwrap", ()=>unwrap);
var _functionJs = require("./Function.js");
var _coreJs = require("./internal/core.js");
var _pipeableJs = require("./Pipeable.js");
var _predicateJs = require("./Predicate.js");
const TypeId = /*#__PURE__*/ Symbol.for("effect/Readable");
const isReadable = (u)=>(0, _predicateJs.hasProperty)(u, TypeId);
const Proto = {
    [TypeId]: TypeId,
    pipe () {
        return (0, _pipeableJs.pipeArguments)(this, arguments);
    }
};
const make = (get)=>{
    const self = Object.create(Proto);
    self.get = get;
    return self;
};
const map = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>make(_coreJs.map(self.get, f)));
const mapEffect = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>make(_coreJs.flatMap(self.get, f)));
const unwrap = (effect)=>make(_coreJs.flatMap(effect, (s)=>s.get));

},{"./Function.js":"21gOL","./internal/core.js":"cr3YV","./Pipeable.js":"b5RU2","./Predicate.js":"gW5pd","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"b4XQ6":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TracerTypeId", ()=>TracerTypeId);
parcelHelpers.export(exports, "ParentSpan", ()=>ParentSpan);
parcelHelpers.export(exports, "Tracer", ()=>Tracer);
parcelHelpers.export(exports, "make", ()=>make);
parcelHelpers.export(exports, "externalSpan", ()=>externalSpan);
parcelHelpers.export(exports, "tracerWith", ()=>tracerWith);
parcelHelpers.export(exports, "DisablePropagation", ()=>DisablePropagation);
var _defaultServicesJs = require("./internal/defaultServices.js");
var _tracerJs = require("./internal/tracer.js");
const TracerTypeId = _tracerJs.TracerTypeId;
const ParentSpan = _tracerJs.spanTag;
const Tracer = _tracerJs.tracerTag;
const make = _tracerJs.make;
const externalSpan = _tracerJs.externalSpan;
const tracerWith = _defaultServicesJs.tracerWith;
const DisablePropagation = _tracerJs.DisablePropagation;

},{"./internal/defaultServices.js":"aF4q8","./internal/tracer.js":"aAsvB","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"lTfKe":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "OP_EMPTY", ()=>OP_EMPTY);
parcelHelpers.export(exports, "OP_ADD", ()=>OP_ADD);
parcelHelpers.export(exports, "OP_REMOVE", ()=>OP_REMOVE);
parcelHelpers.export(exports, "OP_UPDATE", ()=>OP_UPDATE);
parcelHelpers.export(exports, "OP_AND_THEN", ()=>OP_AND_THEN);
parcelHelpers.export(exports, "empty", ()=>empty);
parcelHelpers.export(exports, "diff", ()=>diff);
parcelHelpers.export(exports, "combine", ()=>combine);
parcelHelpers.export(exports, "patch", ()=>patch);
var _arrayJs = require("../../Array.js");
var _equalJs = require("../../Equal.js");
var _functionJs = require("../../Function.js");
var _fiberRefsJs = require("../fiberRefs.js");
const OP_EMPTY = "Empty";
const OP_ADD = "Add";
const OP_REMOVE = "Remove";
const OP_UPDATE = "Update";
const OP_AND_THEN = "AndThen";
const empty = {
    _tag: OP_EMPTY
};
const diff = (oldValue, newValue)=>{
    const missingLocals = new Map(oldValue.locals);
    let patch = empty;
    for (const [fiberRef, pairs] of newValue.locals.entries()){
        const newValue = _arrayJs.headNonEmpty(pairs)[1];
        const old = missingLocals.get(fiberRef);
        if (old !== undefined) {
            const oldValue = _arrayJs.headNonEmpty(old)[1];
            if (!(0, _equalJs.equals)(oldValue, newValue)) patch = combine({
                _tag: OP_UPDATE,
                fiberRef,
                patch: fiberRef.diff(oldValue, newValue)
            })(patch);
        } else patch = combine({
            _tag: OP_ADD,
            fiberRef,
            value: newValue
        })(patch);
        missingLocals.delete(fiberRef);
    }
    for (const [fiberRef] of missingLocals.entries())patch = combine({
        _tag: OP_REMOVE,
        fiberRef
    })(patch);
    return patch;
};
const combine = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>({
        _tag: OP_AND_THEN,
        first: self,
        second: that
    }));
const patch = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, fiberId, oldValue)=>{
    let fiberRefs = oldValue;
    let patches = _arrayJs.of(self);
    while(_arrayJs.isNonEmptyReadonlyArray(patches)){
        const head = _arrayJs.headNonEmpty(patches);
        const tail = _arrayJs.tailNonEmpty(patches);
        switch(head._tag){
            case OP_EMPTY:
                patches = tail;
                break;
            case OP_ADD:
                fiberRefs = _fiberRefsJs.updateAs(fiberRefs, {
                    fiberId,
                    fiberRef: head.fiberRef,
                    value: head.value
                });
                patches = tail;
                break;
            case OP_REMOVE:
                fiberRefs = _fiberRefsJs.delete_(fiberRefs, head.fiberRef);
                patches = tail;
                break;
            case OP_UPDATE:
                {
                    const value = _fiberRefsJs.getOrDefault(fiberRefs, head.fiberRef);
                    fiberRefs = _fiberRefsJs.updateAs(fiberRefs, {
                        fiberId,
                        fiberRef: head.fiberRef,
                        value: head.fiberRef.patch(head.patch)(value)
                    });
                    patches = tail;
                    break;
                }
            case OP_AND_THEN:
                patches = _arrayJs.prepend(head.first)(_arrayJs.prepend(head.second)(tail));
                break;
        }
    }
    return fiberRefs;
});

},{"../../Array.js":"8L2Gk","../../Equal.js":"gA0qD","../../Function.js":"21gOL","../fiberRefs.js":"gt1Z6","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"hcYDB":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MetricLabelTypeId", ()=>MetricLabelTypeId);
parcelHelpers.export(exports, "make", ()=>make);
parcelHelpers.export(exports, "isMetricLabel", ()=>isMetricLabel);
var _equalJs = require("../../Equal.js");
var _hashJs = require("../../Hash.js");
var _pipeableJs = require("../../Pipeable.js");
var _predicateJs = require("../../Predicate.js");
/** @internal */ const MetricLabelSymbolKey = "effect/MetricLabel";
const MetricLabelTypeId = /*#__PURE__*/ Symbol.for(MetricLabelSymbolKey);
/** @internal */ class MetricLabelImpl {
    key;
    value;
    [MetricLabelTypeId] = MetricLabelTypeId;
    _hash;
    constructor(key, value){
        this.key = key;
        this.value = value;
        this._hash = _hashJs.string(MetricLabelSymbolKey + this.key + this.value);
    }
    [_hashJs.symbol]() {
        return this._hash;
    }
    [_equalJs.symbol](that) {
        return isMetricLabel(that) && this.key === that.key && this.value === that.value;
    }
    pipe() {
        return (0, _pipeableJs.pipeArguments)(this, arguments);
    }
}
const make = (key, value)=>{
    return new MetricLabelImpl(key, value);
};
const isMetricLabel = (u)=>(0, _predicateJs.hasProperty)(u, MetricLabelTypeId);

},{"../../Equal.js":"gA0qD","../../Hash.js":"gFMwE","../../Pipeable.js":"b5RU2","../../Predicate.js":"gW5pd","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"606wn":[function(require,module,exports,__globalThis) {
/**
 * This module provides utility functions and type class instances for working with the `string` type in TypeScript.
 * It includes functions for basic string manipulation, as well as type class instances for
 * `Equivalence` and `Order`.
 *
 * @since 2.0.0
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isString", ()=>isString);
parcelHelpers.export(exports, "Equivalence", ()=>Equivalence);
parcelHelpers.export(exports, "Order", ()=>Order);
parcelHelpers.export(exports, "empty", ()=>empty);
parcelHelpers.export(exports, "concat", ()=>concat);
parcelHelpers.export(exports, "toUpperCase", ()=>toUpperCase);
parcelHelpers.export(exports, "toLowerCase", ()=>toLowerCase);
parcelHelpers.export(exports, "capitalize", ()=>capitalize);
parcelHelpers.export(exports, "uncapitalize", ()=>uncapitalize);
parcelHelpers.export(exports, "replace", ()=>replace);
parcelHelpers.export(exports, "trim", ()=>trim);
parcelHelpers.export(exports, "trimStart", ()=>trimStart);
parcelHelpers.export(exports, "trimEnd", ()=>trimEnd);
parcelHelpers.export(exports, "slice", ()=>slice);
parcelHelpers.export(exports, "isEmpty", ()=>isEmpty);
parcelHelpers.export(exports, "isNonEmpty", ()=>isNonEmpty);
parcelHelpers.export(exports, "length", ()=>length);
parcelHelpers.export(exports, "split", ()=>split);
parcelHelpers.export(exports, "includes", ()=>includes);
parcelHelpers.export(exports, "startsWith", ()=>startsWith);
parcelHelpers.export(exports, "endsWith", ()=>endsWith);
parcelHelpers.export(exports, "charCodeAt", ()=>charCodeAt);
parcelHelpers.export(exports, "substring", ()=>substring);
parcelHelpers.export(exports, "at", ()=>at);
parcelHelpers.export(exports, "charAt", ()=>charAt);
parcelHelpers.export(exports, "codePointAt", ()=>codePointAt);
parcelHelpers.export(exports, "indexOf", ()=>indexOf);
parcelHelpers.export(exports, "lastIndexOf", ()=>lastIndexOf);
parcelHelpers.export(exports, "localeCompare", ()=>localeCompare);
parcelHelpers.export(exports, "match", ()=>match);
parcelHelpers.export(exports, "matchAll", ()=>matchAll);
parcelHelpers.export(exports, "normalize", ()=>normalize);
parcelHelpers.export(exports, "padEnd", ()=>padEnd);
parcelHelpers.export(exports, "padStart", ()=>padStart);
parcelHelpers.export(exports, "repeat", ()=>repeat);
parcelHelpers.export(exports, "replaceAll", ()=>replaceAll);
parcelHelpers.export(exports, "search", ()=>search);
parcelHelpers.export(exports, "toLocaleLowerCase", ()=>toLocaleLowerCase);
parcelHelpers.export(exports, "toLocaleUpperCase", ()=>toLocaleUpperCase);
parcelHelpers.export(exports, "takeLeft", ()=>takeLeft);
parcelHelpers.export(exports, "takeRight", ()=>takeRight);
parcelHelpers.export(exports, "linesIterator", ()=>linesIterator);
parcelHelpers.export(exports, "linesWithSeparators", ()=>linesWithSeparators);
parcelHelpers.export(exports, "stripMarginWith", ()=>stripMarginWith);
parcelHelpers.export(exports, "stripMargin", ()=>stripMargin);
parcelHelpers.export(exports, "snakeToCamel", ()=>snakeToCamel);
parcelHelpers.export(exports, "snakeToPascal", ()=>snakeToPascal);
parcelHelpers.export(exports, "snakeToKebab", ()=>snakeToKebab);
parcelHelpers.export(exports, "camelToSnake", ()=>camelToSnake);
parcelHelpers.export(exports, "pascalToSnake", ()=>pascalToSnake);
parcelHelpers.export(exports, "kebabToSnake", ()=>kebabToSnake);
var _equivalenceJs = require("./Equivalence.js");
var _functionJs = require("./Function.js");
var _arrayJs = require("./internal/array.js");
var _numberJs = require("./Number.js");
var _optionJs = require("./Option.js");
var _orderJs = require("./Order.js");
var _predicateJs = require("./Predicate.js");
const isString = _predicateJs.isString;
const Equivalence = _equivalenceJs.string;
const Order = _orderJs.string;
const empty = "";
const concat = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>self + that);
const toUpperCase = (self)=>self.toUpperCase();
const toLowerCase = (self)=>self.toLowerCase();
const capitalize = (self)=>{
    if (self.length === 0) return self;
    return toUpperCase(self[0]) + self.slice(1);
};
const uncapitalize = (self)=>{
    if (self.length === 0) return self;
    return toLowerCase(self[0]) + self.slice(1);
};
const replace = (searchValue, replaceValue)=>(self)=>self.replace(searchValue, replaceValue);
const trim = (self)=>self.trim();
const trimStart = (self)=>self.trimStart();
const trimEnd = (self)=>self.trimEnd();
const slice = (start, end)=>(self)=>self.slice(start, end);
const isEmpty = (self)=>self.length === 0;
const isNonEmpty = (self)=>self.length > 0;
const length = (self)=>self.length;
const split = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, separator)=>{
    const out = self.split(separator);
    return _arrayJs.isNonEmptyArray(out) ? out : [
        self
    ];
});
const includes = (searchString, position)=>(self)=>self.includes(searchString, position);
const startsWith = (searchString, position)=>(self)=>self.startsWith(searchString, position);
const endsWith = (searchString, position)=>(self)=>self.endsWith(searchString, position);
const charCodeAt = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, index)=>_optionJs.filter(_optionJs.some(self.charCodeAt(index)), (charCode)=>!isNaN(charCode)));
const substring = (start, end)=>(self)=>self.substring(start, end);
const at = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, index)=>_optionJs.fromNullable(self.at(index)));
const charAt = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, index)=>_optionJs.filter(_optionJs.some(self.charAt(index)), isNonEmpty));
const codePointAt = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, index)=>_optionJs.fromNullable(self.codePointAt(index)));
const indexOf = (searchString)=>(self)=>_optionJs.filter(_optionJs.some(self.indexOf(searchString)), _numberJs.greaterThanOrEqualTo(0));
const lastIndexOf = (searchString)=>(self)=>_optionJs.filter(_optionJs.some(self.lastIndexOf(searchString)), _numberJs.greaterThanOrEqualTo(0));
const localeCompare = (that, locales, options)=>(self)=>_numberJs.sign(self.localeCompare(that, locales, options));
const match = (regexp)=>(self)=>_optionJs.fromNullable(self.match(regexp));
const matchAll = (regexp)=>(self)=>self.matchAll(regexp);
const normalize = (form)=>(self)=>self.normalize(form);
const padEnd = (maxLength, fillString)=>(self)=>self.padEnd(maxLength, fillString);
const padStart = (maxLength, fillString)=>(self)=>self.padStart(maxLength, fillString);
const repeat = (count)=>(self)=>self.repeat(count);
const replaceAll = (searchValue, replaceValue)=>(self)=>self.replaceAll(searchValue, replaceValue);
const search = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, regexp)=>_optionJs.filter(_optionJs.some(self.search(regexp)), _numberJs.greaterThanOrEqualTo(0)));
const toLocaleLowerCase = (locale)=>(self)=>self.toLocaleLowerCase(locale);
const toLocaleUpperCase = (locale)=>(self)=>self.toLocaleUpperCase(locale);
const takeLeft = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, n)=>self.slice(0, Math.max(n, 0)));
const takeRight = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, n)=>self.slice(Math.max(0, self.length - Math.floor(n)), Infinity));
const CR = 0x0d;
const LF = 0x0a;
const linesIterator = (self)=>linesSeparated(self, true);
const linesWithSeparators = (s)=>linesSeparated(s, false);
const stripMarginWith = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, marginChar)=>{
    let out = "";
    for (const line of linesWithSeparators(self)){
        let index = 0;
        while(index < line.length && line.charAt(index) <= " ")index = index + 1;
        const stripped = index < line.length && line.charAt(index) === marginChar ? line.substring(index + 1) : line;
        out = out + stripped;
    }
    return out;
});
const stripMargin = (self)=>stripMarginWith(self, "|");
const snakeToCamel = (self)=>{
    let str = self[0];
    for(let i = 1; i < self.length; i++)str += self[i] === "_" ? self[++i].toUpperCase() : self[i];
    return str;
};
const snakeToPascal = (self)=>{
    let str = self[0].toUpperCase();
    for(let i = 1; i < self.length; i++)str += self[i] === "_" ? self[++i].toUpperCase() : self[i];
    return str;
};
const snakeToKebab = (self)=>self.replace(/_/g, "-");
const camelToSnake = (self)=>self.replace(/([A-Z])/g, "_$1").toLowerCase();
const pascalToSnake = (self)=>(self.slice(0, 1) + self.slice(1).replace(/([A-Z])/g, "_$1")).toLowerCase();
const kebabToSnake = (self)=>self.replace(/-/g, "_");
class LinesIterator {
    s;
    stripped;
    index;
    length;
    constructor(s, stripped = false){
        this.s = s;
        this.stripped = stripped;
        this.index = 0;
        this.length = s.length;
    }
    next() {
        if (this.done) return {
            done: true,
            value: undefined
        };
        const start = this.index;
        while(!this.done && !isLineBreak(this.s[this.index]))this.index = this.index + 1;
        let end = this.index;
        if (!this.done) {
            const char = this.s[this.index];
            this.index = this.index + 1;
            if (!this.done && isLineBreak2(char, this.s[this.index])) this.index = this.index + 1;
            if (!this.stripped) end = this.index;
        }
        return {
            done: false,
            value: this.s.substring(start, end)
        };
    }
    [Symbol.iterator]() {
        return new LinesIterator(this.s, this.stripped);
    }
    get done() {
        return this.index >= this.length;
    }
}
/**
 * Test if the provided character is a line break character (i.e. either `"\r"`
 * or `"\n"`).
 */ const isLineBreak = (char)=>{
    const code = char.charCodeAt(0);
    return code === CR || code === LF;
};
/**
 * Test if the provided characters combine to form a carriage return/line-feed
 * (i.e. `"\r\n"`).
 */ const isLineBreak2 = (char0, char1)=>char0.charCodeAt(0) === CR && char1.charCodeAt(0) === LF;
const linesSeparated = (self, stripped)=>new LinesIterator(self, stripped);

},{"./Equivalence.js":"1WBUa","./Function.js":"21gOL","./internal/array.js":"a5YhT","./Number.js":"al4Y3","./Option.js":"6sHA7","./Order.js":"lQMwD","./Predicate.js":"gW5pd","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"dVfBq":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TypeId", ()=>TypeId);
parcelHelpers.export(exports, "TimeZoneTypeId", ()=>TimeZoneTypeId);
parcelHelpers.export(exports, "isDateTime", ()=>isDateTime);
parcelHelpers.export(exports, "isTimeZone", ()=>isTimeZone);
parcelHelpers.export(exports, "isTimeZoneOffset", ()=>isTimeZoneOffset);
parcelHelpers.export(exports, "isTimeZoneNamed", ()=>isTimeZoneNamed);
parcelHelpers.export(exports, "isUtc", ()=>isUtc);
parcelHelpers.export(exports, "isZoned", ()=>isZoned);
parcelHelpers.export(exports, "Equivalence", ()=>Equivalence);
parcelHelpers.export(exports, "Order", ()=>Order);
parcelHelpers.export(exports, "clamp", ()=>clamp);
parcelHelpers.export(exports, "unsafeFromDate", ()=>unsafeFromDate);
parcelHelpers.export(exports, "unsafeMake", ()=>unsafeMake);
parcelHelpers.export(exports, "unsafeMakeZoned", ()=>unsafeMakeZoned);
parcelHelpers.export(exports, "makeZoned", ()=>makeZoned);
parcelHelpers.export(exports, "make", ()=>make);
parcelHelpers.export(exports, "makeZonedFromString", ()=>makeZonedFromString);
parcelHelpers.export(exports, "now", ()=>now);
parcelHelpers.export(exports, "nowAsDate", ()=>nowAsDate);
parcelHelpers.export(exports, "unsafeNow", ()=>unsafeNow);
parcelHelpers.export(exports, "toUtc", ()=>toUtc);
parcelHelpers.export(exports, "setZone", ()=>setZone);
parcelHelpers.export(exports, "setZoneOffset", ()=>setZoneOffset);
parcelHelpers.export(exports, "zoneUnsafeMakeNamed", ()=>zoneUnsafeMakeNamed);
parcelHelpers.export(exports, "zoneMakeOffset", ()=>zoneMakeOffset);
parcelHelpers.export(exports, "zoneMakeNamed", ()=>zoneMakeNamed);
parcelHelpers.export(exports, "zoneMakeNamedEffect", ()=>zoneMakeNamedEffect);
parcelHelpers.export(exports, "zoneMakeLocal", ()=>zoneMakeLocal);
parcelHelpers.export(exports, "zoneFromString", ()=>zoneFromString);
parcelHelpers.export(exports, "zoneToString", ()=>zoneToString);
parcelHelpers.export(exports, "setZoneNamed", ()=>setZoneNamed);
parcelHelpers.export(exports, "unsafeSetZoneNamed", ()=>unsafeSetZoneNamed);
parcelHelpers.export(exports, "distance", ()=>distance);
parcelHelpers.export(exports, "distanceDurationEither", ()=>distanceDurationEither);
parcelHelpers.export(exports, "distanceDuration", ()=>distanceDuration);
parcelHelpers.export(exports, "min", ()=>min);
parcelHelpers.export(exports, "max", ()=>max);
parcelHelpers.export(exports, "greaterThan", ()=>greaterThan);
parcelHelpers.export(exports, "greaterThanOrEqualTo", ()=>greaterThanOrEqualTo);
parcelHelpers.export(exports, "lessThan", ()=>lessThan);
parcelHelpers.export(exports, "lessThanOrEqualTo", ()=>lessThanOrEqualTo);
parcelHelpers.export(exports, "between", ()=>between);
parcelHelpers.export(exports, "isFuture", ()=>isFuture);
parcelHelpers.export(exports, "unsafeIsFuture", ()=>unsafeIsFuture);
parcelHelpers.export(exports, "isPast", ()=>isPast);
parcelHelpers.export(exports, "unsafeIsPast", ()=>unsafeIsPast);
parcelHelpers.export(exports, "toDateUtc", ()=>toDateUtc);
parcelHelpers.export(exports, "toDate", ()=>toDate);
parcelHelpers.export(exports, "zonedOffset", ()=>zonedOffset);
parcelHelpers.export(exports, "zonedOffsetIso", ()=>zonedOffsetIso);
parcelHelpers.export(exports, "toEpochMillis", ()=>toEpochMillis);
parcelHelpers.export(exports, "removeTime", ()=>removeTime);
parcelHelpers.export(exports, "toParts", ()=>toParts);
parcelHelpers.export(exports, "toPartsUtc", ()=>toPartsUtc);
parcelHelpers.export(exports, "getPartUtc", ()=>getPartUtc);
parcelHelpers.export(exports, "getPart", ()=>getPart);
parcelHelpers.export(exports, "setParts", ()=>setParts);
parcelHelpers.export(exports, "setPartsUtc", ()=>setPartsUtc);
// =============================================================================
// current time zone
// =============================================================================
/**
 * @since 3.11.0
 * @category current time zone
 */ parcelHelpers.export(exports, "CurrentTimeZone", ()=>CurrentTimeZone);
parcelHelpers.export(exports, "setZoneCurrent", ()=>setZoneCurrent);
parcelHelpers.export(exports, "withCurrentZone", ()=>withCurrentZone);
parcelHelpers.export(exports, "withCurrentZoneLocal", ()=>withCurrentZoneLocal);
parcelHelpers.export(exports, "withCurrentZoneOffset", ()=>withCurrentZoneOffset);
parcelHelpers.export(exports, "withCurrentZoneNamed", ()=>withCurrentZoneNamed);
parcelHelpers.export(exports, "nowInCurrentZone", ()=>nowInCurrentZone);
parcelHelpers.export(exports, "mutate", ()=>mutate);
parcelHelpers.export(exports, "mutateUtc", ()=>mutateUtc);
parcelHelpers.export(exports, "mapEpochMillis", ()=>mapEpochMillis);
parcelHelpers.export(exports, "withDate", ()=>withDate);
parcelHelpers.export(exports, "withDateUtc", ()=>withDateUtc);
parcelHelpers.export(exports, "match", ()=>match);
parcelHelpers.export(exports, "addDuration", ()=>addDuration);
parcelHelpers.export(exports, "subtractDuration", ()=>subtractDuration);
parcelHelpers.export(exports, "add", ()=>add);
parcelHelpers.export(exports, "subtract", ()=>subtract);
parcelHelpers.export(exports, "startOf", ()=>startOf);
parcelHelpers.export(exports, "endOf", ()=>endOf);
parcelHelpers.export(exports, "nearest", ()=>nearest);
parcelHelpers.export(exports, "format", ()=>format);
parcelHelpers.export(exports, "formatLocal", ()=>formatLocal);
parcelHelpers.export(exports, "formatUtc", ()=>formatUtc);
parcelHelpers.export(exports, "formatIntl", ()=>formatIntl);
parcelHelpers.export(exports, "formatIso", ()=>formatIso);
parcelHelpers.export(exports, "formatIsoDate", ()=>formatIsoDate);
parcelHelpers.export(exports, "formatIsoDateUtc", ()=>formatIsoDateUtc);
parcelHelpers.export(exports, "formatIsoOffset", ()=>formatIsoOffset);
parcelHelpers.export(exports, "formatIsoZoned", ()=>formatIsoZoned);
parcelHelpers.export(exports, "layerCurrentZone", ()=>layerCurrentZone);
parcelHelpers.export(exports, "layerCurrentZoneOffset", ()=>layerCurrentZoneOffset);
parcelHelpers.export(exports, "layerCurrentZoneNamed", ()=>layerCurrentZoneNamed);
parcelHelpers.export(exports, "layerCurrentZoneLocal", ()=>layerCurrentZoneLocal);
var _contextJs = require("./Context.js");
var _effectJs = require("./Effect.js");
var _functionJs = require("./Function.js");
var _dateTimeJs = require("./internal/dateTime.js");
var _layerJs = require("./Layer.js");
const TypeId = _dateTimeJs.TypeId;
const TimeZoneTypeId = _dateTimeJs.TimeZoneTypeId;
const isDateTime = _dateTimeJs.isDateTime;
const isTimeZone = _dateTimeJs.isTimeZone;
const isTimeZoneOffset = _dateTimeJs.isTimeZoneOffset;
const isTimeZoneNamed = _dateTimeJs.isTimeZoneNamed;
const isUtc = _dateTimeJs.isUtc;
const isZoned = _dateTimeJs.isZoned;
const Equivalence = _dateTimeJs.Equivalence;
const Order = _dateTimeJs.Order;
const clamp = _dateTimeJs.clamp;
const unsafeFromDate = _dateTimeJs.unsafeFromDate;
const unsafeMake = _dateTimeJs.unsafeMake;
const unsafeMakeZoned = _dateTimeJs.unsafeMakeZoned;
const makeZoned = _dateTimeJs.makeZoned;
const make = _dateTimeJs.make;
const makeZonedFromString = _dateTimeJs.makeZonedFromString;
const now = _dateTimeJs.now;
const nowAsDate = _dateTimeJs.nowAsDate;
const unsafeNow = _dateTimeJs.unsafeNow;
const toUtc = _dateTimeJs.toUtc;
const setZone = _dateTimeJs.setZone;
const setZoneOffset = _dateTimeJs.setZoneOffset;
const zoneUnsafeMakeNamed = _dateTimeJs.zoneUnsafeMakeNamed;
const zoneMakeOffset = _dateTimeJs.zoneMakeOffset;
const zoneMakeNamed = _dateTimeJs.zoneMakeNamed;
const zoneMakeNamedEffect = _dateTimeJs.zoneMakeNamedEffect;
const zoneMakeLocal = _dateTimeJs.zoneMakeLocal;
const zoneFromString = _dateTimeJs.zoneFromString;
const zoneToString = _dateTimeJs.zoneToString;
const setZoneNamed = _dateTimeJs.setZoneNamed;
const unsafeSetZoneNamed = _dateTimeJs.unsafeSetZoneNamed;
const distance = _dateTimeJs.distance;
const distanceDurationEither = _dateTimeJs.distanceDurationEither;
const distanceDuration = _dateTimeJs.distanceDuration;
const min = _dateTimeJs.min;
const max = _dateTimeJs.max;
const greaterThan = _dateTimeJs.greaterThan;
const greaterThanOrEqualTo = _dateTimeJs.greaterThanOrEqualTo;
const lessThan = _dateTimeJs.lessThan;
const lessThanOrEqualTo = _dateTimeJs.lessThanOrEqualTo;
const between = _dateTimeJs.between;
const isFuture = _dateTimeJs.isFuture;
const unsafeIsFuture = _dateTimeJs.unsafeIsFuture;
const isPast = _dateTimeJs.isPast;
const unsafeIsPast = _dateTimeJs.unsafeIsPast;
const toDateUtc = _dateTimeJs.toDateUtc;
const toDate = _dateTimeJs.toDate;
const zonedOffset = _dateTimeJs.zonedOffset;
const zonedOffsetIso = _dateTimeJs.zonedOffsetIso;
const toEpochMillis = _dateTimeJs.toEpochMillis;
const removeTime = _dateTimeJs.removeTime;
const toParts = _dateTimeJs.toParts;
const toPartsUtc = _dateTimeJs.toPartsUtc;
const getPartUtc = _dateTimeJs.getPartUtc;
const getPart = _dateTimeJs.getPart;
const setParts = _dateTimeJs.setParts;
const setPartsUtc = _dateTimeJs.setPartsUtc;
class CurrentTimeZone extends /*#__PURE__*/ _contextJs.Tag("effect/DateTime/CurrentTimeZone")() {
}
const setZoneCurrent = (self)=>_effectJs.map(CurrentTimeZone, (zone)=>setZone(self, zone));
const withCurrentZone = /*#__PURE__*/ (0, _functionJs.dual)(2, (effect, zone)=>_effectJs.provideService(effect, CurrentTimeZone, zone));
const withCurrentZoneLocal = (effect)=>_effectJs.provideServiceEffect(effect, CurrentTimeZone, _effectJs.sync(zoneMakeLocal));
const withCurrentZoneOffset = /*#__PURE__*/ (0, _functionJs.dual)(2, (effect, offset)=>_effectJs.provideService(effect, CurrentTimeZone, zoneMakeOffset(offset)));
const withCurrentZoneNamed = /*#__PURE__*/ (0, _functionJs.dual)(2, (effect, zone)=>_effectJs.provideServiceEffect(effect, CurrentTimeZone, zoneMakeNamedEffect(zone)));
const nowInCurrentZone = /*#__PURE__*/ _effectJs.flatMap(now, setZoneCurrent);
const mutate = _dateTimeJs.mutate;
const mutateUtc = _dateTimeJs.mutateUtc;
const mapEpochMillis = _dateTimeJs.mapEpochMillis;
const withDate = _dateTimeJs.withDate;
const withDateUtc = _dateTimeJs.withDateUtc;
const match = _dateTimeJs.match;
const addDuration = _dateTimeJs.addDuration;
const subtractDuration = _dateTimeJs.subtractDuration;
const add = _dateTimeJs.add;
const subtract = _dateTimeJs.subtract;
const startOf = _dateTimeJs.startOf;
const endOf = _dateTimeJs.endOf;
const nearest = _dateTimeJs.nearest;
const format = _dateTimeJs.format;
const formatLocal = _dateTimeJs.formatLocal;
const formatUtc = _dateTimeJs.formatUtc;
const formatIntl = _dateTimeJs.formatIntl;
const formatIso = _dateTimeJs.formatIso;
const formatIsoDate = _dateTimeJs.formatIsoDate;
const formatIsoDateUtc = _dateTimeJs.formatIsoDateUtc;
const formatIsoOffset = _dateTimeJs.formatIsoOffset;
const formatIsoZoned = _dateTimeJs.formatIsoZoned;
const layerCurrentZone = (zone)=>_layerJs.succeed(CurrentTimeZone, zone);
const layerCurrentZoneOffset = (offset)=>_layerJs.succeed(CurrentTimeZone, _dateTimeJs.zoneMakeOffset(offset));
const layerCurrentZoneNamed = (zoneId)=>_layerJs.effect(CurrentTimeZone, _dateTimeJs.zoneMakeNamedEffect(zoneId));
const layerCurrentZoneLocal = /*#__PURE__*/ _layerJs.sync(CurrentTimeZone, zoneMakeLocal);

},{"./Context.js":"c2abN","./Effect.js":"j5L8O","./Function.js":"21gOL","./internal/dateTime.js":"53jOw","./Layer.js":"h0tE0","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"j5L8O":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EffectTypeId", ()=>EffectTypeId);
parcelHelpers.export(exports, "isEffect", ()=>isEffect);
parcelHelpers.export(exports, "cachedWithTTL", ()=>cachedWithTTL);
parcelHelpers.export(exports, "cachedInvalidateWithTTL", ()=>cachedInvalidateWithTTL);
parcelHelpers.export(exports, "cached", ()=>cached);
parcelHelpers.export(exports, "cachedFunction", ()=>cachedFunction);
parcelHelpers.export(exports, "once", ()=>once);
parcelHelpers.export(exports, "all", ()=>all);
parcelHelpers.export(exports, "allWith", ()=>allWith);
parcelHelpers.export(exports, "allSuccesses", ()=>allSuccesses);
parcelHelpers.export(exports, "dropUntil", ()=>dropUntil);
parcelHelpers.export(exports, "dropWhile", ()=>dropWhile);
parcelHelpers.export(exports, "takeUntil", ()=>takeUntil);
parcelHelpers.export(exports, "takeWhile", ()=>takeWhile);
parcelHelpers.export(exports, "every", ()=>every);
parcelHelpers.export(exports, "exists", ()=>exists);
parcelHelpers.export(exports, "filter", ()=>filter);
parcelHelpers.export(exports, "filterMap", ()=>filterMap);
parcelHelpers.export(exports, "findFirst", ()=>findFirst);
parcelHelpers.export(exports, "forEach", ()=>forEach);
parcelHelpers.export(exports, "head", ()=>head);
parcelHelpers.export(exports, "mergeAll", ()=>mergeAll);
parcelHelpers.export(exports, "partition", ()=>partition);
parcelHelpers.export(exports, "reduce", ()=>reduce);
parcelHelpers.export(exports, "reduceWhile", ()=>reduceWhile);
parcelHelpers.export(exports, "reduceRight", ()=>reduceRight);
parcelHelpers.export(exports, "reduceEffect", ()=>reduceEffect);
parcelHelpers.export(exports, "replicate", ()=>replicate);
parcelHelpers.export(exports, "replicateEffect", ()=>replicateEffect);
parcelHelpers.export(exports, "validateAll", ()=>validateAll);
parcelHelpers.export(exports, "validateFirst", ()=>validateFirst);
parcelHelpers.export(exports, "async", ()=>async);
parcelHelpers.export(exports, "asyncEffect", ()=>asyncEffect);
parcelHelpers.export(exports, "custom", ()=>custom);
parcelHelpers.export(exports, "withFiberRuntime", ()=>withFiberRuntime);
parcelHelpers.export(exports, "fail", ()=>fail);
parcelHelpers.export(exports, "failSync", ()=>failSync);
parcelHelpers.export(exports, "failCause", ()=>failCause);
parcelHelpers.export(exports, "failCauseSync", ()=>failCauseSync);
parcelHelpers.export(exports, "die", ()=>die);
parcelHelpers.export(exports, "dieMessage", ()=>dieMessage);
parcelHelpers.export(exports, "dieSync", ()=>dieSync);
parcelHelpers.export(exports, "gen", ()=>gen);
parcelHelpers.export(exports, "never", ()=>never);
parcelHelpers.export(exports, "none", ()=>none);
parcelHelpers.export(exports, "promise", ()=>promise);
parcelHelpers.export(exports, "succeed", ()=>succeed);
parcelHelpers.export(exports, "succeedNone", ()=>succeedNone);
parcelHelpers.export(exports, "succeedSome", ()=>succeedSome);
parcelHelpers.export(exports, "suspend", ()=>suspend);
parcelHelpers.export(exports, "sync", ()=>sync);
parcelHelpers.export(exports, "void", ()=>/**
 * Represents an effect that does nothing and produces no value.
 *
 * **When to Use**
 *
 * Use this effect when you need to represent an effect that does nothing.
 * This is useful in scenarios where you need to satisfy an effect-based
 * interface or control program flow without performing any operations. For
 * example, it can be used in situations where you want to return an effect
 * from a function but do not need to compute or return any result.
 *
 * @since 2.0.0
 * @category Creating Effects
 */ _void);
parcelHelpers.export(exports, "yieldNow", ()=>yieldNow);
parcelHelpers.export(exports, "catch", ()=>/**
 * Recovers from a specified error by catching it and handling it with a provided function.
 *
 * **Details**
 *
 * This function allows you to recover from specific errors that occur during
 * the execution of an effect. It works by catching a specific type of error
 * (identified by a discriminator) and then handling it using a provided
 * handler function. The handler can return a new effect that helps recover
 * from the error, allowing the program to continue. If the error doesn't
 * match the specified type, the function allows the original effect to
 * continue as it was.
 *
 * **Example**
 *
 * ```ts
 * import { Console, Effect } from "effect"
 *
 * class NetworkError {
 *   readonly _tag = "NetworkError"
 * }
 * class ValidationError {
 *   readonly _tag = "ValidationError"
 * }
 *
 * // Simulate an effect that may fail
 * const task: Effect.Effect<never, NetworkError | ValidationError, never> = Effect.fail(new NetworkError())
 *
 * const program = Effect.gen(function*() {
 *   const result = yield* Effect.catch(task, "_tag", {
 *     failure: "NetworkError",
 *     onFailure: (error) => Effect.succeed(`recovered from error: ${error._tag}`)
 *   })
 *   console.log(`Result: ${result}`)
 * })
 *
 * Effect.runFork(program)
 * // Output: Result: recovered from error: NetworkError
 * ```
 *
 * @see {@link catchTag} for a version that can recover from errors based on a `_tag` discriminator.
 *
 * @since 2.0.0
 * @category Error handling
 */ _catch);
parcelHelpers.export(exports, "catchAll", ()=>catchAll);
parcelHelpers.export(exports, "catchAllCause", ()=>catchAllCause);
parcelHelpers.export(exports, "catchAllDefect", ()=>catchAllDefect);
parcelHelpers.export(exports, "catchIf", ()=>catchIf);
parcelHelpers.export(exports, "catchSome", ()=>catchSome);
parcelHelpers.export(exports, "catchSomeCause", ()=>catchSomeCause);
parcelHelpers.export(exports, "catchSomeDefect", ()=>catchSomeDefect);
parcelHelpers.export(exports, "catchTag", ()=>catchTag);
parcelHelpers.export(exports, "catchTags", ()=>catchTags);
parcelHelpers.export(exports, "cause", ()=>cause);
parcelHelpers.export(exports, "eventually", ()=>eventually);
parcelHelpers.export(exports, "ignore", ()=>ignore);
parcelHelpers.export(exports, "ignoreLogged", ()=>ignoreLogged);
parcelHelpers.export(exports, "parallelErrors", ()=>parallelErrors);
parcelHelpers.export(exports, "sandbox", ()=>sandbox);
parcelHelpers.export(exports, "retry", ()=>retry);
parcelHelpers.export(exports, "retryOrElse", ()=>retryOrElse);
parcelHelpers.export(exports, "try", ()=>/**
 * Creates an `Effect` that represents a synchronous computation that might
 * fail.
 *
 * **When to Use**
 *
 * In situations where you need to perform synchronous operations that might
 * fail, such as parsing JSON, you can use the `try` constructor. This
 * constructor is designed to handle operations that could throw exceptions by
 * capturing those exceptions and transforming them into manageable errors.
 *
 * **Error Handling**
 *
 * There are two ways to handle errors with `try`:
 *
 * 1. If you don't provide a `catch` function, the error is caught and the
 *    effect fails with an `UnknownException`.
 * 2. If you provide a `catch` function, the error is caught and the `catch`
 *    function maps it to an error of type `E`.
 *
 * **Example** (Safe JSON Parsing)
 *
 * ```ts
 * import { Effect } from "effect"
 *
 * const parse = (input: string) =>
 *   // This might throw an error if input is not valid JSON
 *   Effect.try(() => JSON.parse(input))
 *
 * //      ┌─── Effect<any, UnknownException, never>
 * //      ▼
 * const program = parse("")
 *
 * ```
 *
 * **Example** (Custom Error Handling)
 *
 * ```ts
 * import { Effect } from "effect"
 *
 * const parse = (input: string) =>
 *   Effect.try({
 *     // JSON.parse may throw for bad input
 *     try: () => JSON.parse(input),
 *     // remap the error
 *     catch: (unknown) => new Error(`something went wrong ${unknown}`)
 *   })
 *
 * //      ┌─── Effect<any, Error, never>
 * //      ▼
 * const program = parse("")
 * ```
 *
 * @see {@link sync} if the effectful computation is synchronous and does not
 * throw errors.
 *
 * @since 2.0.0
 * @category Creating Effects
 */ try_);
parcelHelpers.export(exports, "tryMap", ()=>tryMap);
parcelHelpers.export(exports, "tryMapPromise", ()=>tryMapPromise);
parcelHelpers.export(exports, "tryPromise", ()=>tryPromise);
parcelHelpers.export(exports, "unsandbox", ()=>unsandbox);
parcelHelpers.export(exports, "allowInterrupt", ()=>allowInterrupt);
parcelHelpers.export(exports, "checkInterruptible", ()=>checkInterruptible);
parcelHelpers.export(exports, "disconnect", ()=>disconnect);
parcelHelpers.export(exports, "interrupt", ()=>interrupt);
parcelHelpers.export(exports, "interruptWith", ()=>interruptWith);
parcelHelpers.export(exports, "interruptible", ()=>interruptible);
parcelHelpers.export(exports, "interruptibleMask", ()=>interruptibleMask);
parcelHelpers.export(exports, "onInterrupt", ()=>onInterrupt);
parcelHelpers.export(exports, "uninterruptible", ()=>uninterruptible);
parcelHelpers.export(exports, "uninterruptibleMask", ()=>uninterruptibleMask);
parcelHelpers.export(exports, "liftPredicate", ()=>liftPredicate);
parcelHelpers.export(exports, "as", ()=>as);
parcelHelpers.export(exports, "asSome", ()=>asSome);
parcelHelpers.export(exports, "asSomeError", ()=>asSomeError);
parcelHelpers.export(exports, "asVoid", ()=>asVoid);
parcelHelpers.export(exports, "flip", ()=>flip);
parcelHelpers.export(exports, "flipWith", ()=>flipWith);
parcelHelpers.export(exports, "map", ()=>map);
parcelHelpers.export(exports, "mapAccum", ()=>mapAccum);
parcelHelpers.export(exports, "mapBoth", ()=>mapBoth);
parcelHelpers.export(exports, "mapError", ()=>mapError);
parcelHelpers.export(exports, "mapErrorCause", ()=>mapErrorCause);
parcelHelpers.export(exports, "merge", ()=>merge);
parcelHelpers.export(exports, "negate", ()=>negate);
parcelHelpers.export(exports, "acquireRelease", ()=>acquireRelease);
parcelHelpers.export(exports, "acquireReleaseInterruptible", ()=>acquireReleaseInterruptible);
parcelHelpers.export(exports, "acquireUseRelease", ()=>acquireUseRelease);
parcelHelpers.export(exports, "addFinalizer", ()=>addFinalizer);
parcelHelpers.export(exports, "ensuring", ()=>ensuring);
parcelHelpers.export(exports, "onError", ()=>onError);
parcelHelpers.export(exports, "onExit", ()=>onExit);
parcelHelpers.export(exports, "parallelFinalizers", ()=>parallelFinalizers);
parcelHelpers.export(exports, "sequentialFinalizers", ()=>sequentialFinalizers);
parcelHelpers.export(exports, "finalizersMask", ()=>finalizersMask);
parcelHelpers.export(exports, "scope", ()=>scope);
parcelHelpers.export(exports, "scopeWith", ()=>scopeWith);
parcelHelpers.export(exports, "scopedWith", ()=>scopedWith);
parcelHelpers.export(exports, "scoped", ()=>scoped);
parcelHelpers.export(exports, "using", ()=>using);
parcelHelpers.export(exports, "withEarlyRelease", ()=>withEarlyRelease);
parcelHelpers.export(exports, "awaitAllChildren", ()=>awaitAllChildren);
parcelHelpers.export(exports, "daemonChildren", ()=>daemonChildren);
parcelHelpers.export(exports, "descriptor", ()=>descriptor);
parcelHelpers.export(exports, "descriptorWith", ()=>descriptorWith);
parcelHelpers.export(exports, "diffFiberRefs", ()=>diffFiberRefs);
parcelHelpers.export(exports, "ensuringChild", ()=>ensuringChild);
parcelHelpers.export(exports, "ensuringChildren", ()=>ensuringChildren);
parcelHelpers.export(exports, "fiberId", ()=>fiberId);
parcelHelpers.export(exports, "fiberIdWith", ()=>fiberIdWith);
parcelHelpers.export(exports, "fork", ()=>fork);
parcelHelpers.export(exports, "forkDaemon", ()=>forkDaemon);
parcelHelpers.export(exports, "forkAll", ()=>forkAll);
parcelHelpers.export(exports, "forkIn", ()=>forkIn);
parcelHelpers.export(exports, "forkScoped", ()=>forkScoped);
parcelHelpers.export(exports, "forkWithErrorHandler", ()=>forkWithErrorHandler);
parcelHelpers.export(exports, "fromFiber", ()=>fromFiber);
parcelHelpers.export(exports, "fromFiberEffect", ()=>fromFiberEffect);
parcelHelpers.export(exports, "supervised", ()=>supervised);
parcelHelpers.export(exports, "transplant", ()=>transplant);
parcelHelpers.export(exports, "withConcurrency", ()=>withConcurrency);
parcelHelpers.export(exports, "withScheduler", ()=>withScheduler);
parcelHelpers.export(exports, "withSchedulingPriority", ()=>withSchedulingPriority);
parcelHelpers.export(exports, "withMaxOpsBeforeYield", ()=>withMaxOpsBeforeYield);
parcelHelpers.export(exports, "clock", ()=>clock);
parcelHelpers.export(exports, "clockWith", ()=>clockWith);
parcelHelpers.export(exports, "withClockScoped", ()=>withClockScoped);
parcelHelpers.export(exports, "withClock", ()=>withClock);
parcelHelpers.export(exports, "console", ()=>console);
parcelHelpers.export(exports, "consoleWith", ()=>consoleWith);
parcelHelpers.export(exports, "withConsoleScoped", ()=>withConsoleScoped);
parcelHelpers.export(exports, "withConsole", ()=>withConsole);
parcelHelpers.export(exports, "delay", ()=>delay);
parcelHelpers.export(exports, "sleep", ()=>sleep);
parcelHelpers.export(exports, "timed", ()=>timed);
parcelHelpers.export(exports, "timedWith", ()=>timedWith);
parcelHelpers.export(exports, "timeout", ()=>timeout);
parcelHelpers.export(exports, "timeoutOption", ()=>timeoutOption);
parcelHelpers.export(exports, "timeoutFail", ()=>timeoutFail);
parcelHelpers.export(exports, "timeoutFailCause", ()=>timeoutFailCause);
parcelHelpers.export(exports, "timeoutTo", ()=>timeoutTo);
parcelHelpers.export(exports, "configProviderWith", ()=>configProviderWith);
parcelHelpers.export(exports, "withConfigProvider", ()=>withConfigProvider);
parcelHelpers.export(exports, "withConfigProviderScoped", ()=>withConfigProviderScoped);
parcelHelpers.export(exports, "context", ()=>context);
parcelHelpers.export(exports, "contextWith", ()=>contextWith);
parcelHelpers.export(exports, "contextWithEffect", ()=>contextWithEffect);
parcelHelpers.export(exports, "mapInputContext", ()=>mapInputContext);
parcelHelpers.export(exports, "provide", ()=>provide);
parcelHelpers.export(exports, "provideService", ()=>provideService);
parcelHelpers.export(exports, "provideServiceEffect", ()=>provideServiceEffect);
parcelHelpers.export(exports, "serviceFunction", ()=>serviceFunction);
parcelHelpers.export(exports, "serviceFunctionEffect", ()=>serviceFunctionEffect);
parcelHelpers.export(exports, "serviceFunctions", ()=>serviceFunctions);
parcelHelpers.export(exports, "serviceConstants", ()=>serviceConstants);
parcelHelpers.export(exports, "serviceMembers", ()=>serviceMembers);
parcelHelpers.export(exports, "serviceOption", ()=>serviceOption);
parcelHelpers.export(exports, "serviceOptional", ()=>serviceOptional);
parcelHelpers.export(exports, "updateService", ()=>updateService);
parcelHelpers.export(exports, "Do", ()=>Do);
parcelHelpers.export(exports, "bind", ()=>bind);
parcelHelpers.export(exports, "bindAll", ()=>bindAll);
parcelHelpers.export(exports, "bindTo", ()=>bindTo);
parcelHelpers.export(exports, "let", ()=>/**
 * The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.
 *
 * Here's how the do simulation works:
 *
 * 1. Start the do simulation using the `Do` value
 * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Effect` values
 * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope
 * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values
 *
 * **Example**
 *
 * ```ts
 * import * as assert from "node:assert"
 * import { Effect, pipe } from "effect"
 *
 * const result = pipe(
 *   Effect.Do,
 *   Effect.bind("x", () => Effect.succeed(2)),
 *   Effect.bind("y", () => Effect.succeed(3)),
 *   Effect.let("sum", ({ x, y }) => x + y)
 * )
 * assert.deepStrictEqual(Effect.runSync(result), { x: 2, y: 3, sum: 5 })
 *
 * ```
 *
 * @see {@link Do}
 * @see {@link bind}
 * @see {@link bindTo}
 *
 * @category Do notation
 * @since 2.0.0
 */ let_);
parcelHelpers.export(exports, "option", ()=>option);
parcelHelpers.export(exports, "either", ()=>either);
parcelHelpers.export(exports, "exit", ()=>exit);
parcelHelpers.export(exports, "intoDeferred", ()=>intoDeferred);
parcelHelpers.export(exports, "if", ()=>/**
 * Executes one of two effects based on a condition evaluated by an effectful predicate.
 *
 * Use `if` to run one of two effects depending on whether the predicate effect
 * evaluates to `true` or `false`. If the predicate is `true`, the `onTrue` effect
 * is executed. If it is `false`, the `onFalse` effect is executed instead.
 *
 * **Example** (Simulating a Coin Flip)
 *
 * ```ts
 * import { Effect, Random, Console } from "effect"
 *
 * const flipTheCoin = Effect.if(Random.nextBoolean, {
 *   onTrue: () => Console.log("Head"), // Runs if the predicate is true
 *   onFalse: () => Console.log("Tail") // Runs if the predicate is false
 * })
 *
 * Effect.runFork(flipTheCoin)
 * ```
 *
 * @since 2.0.0
 * @category Conditional Operators
 */ if_);
parcelHelpers.export(exports, "filterOrDie", ()=>filterOrDie);
parcelHelpers.export(exports, "filterOrDieMessage", ()=>filterOrDieMessage);
parcelHelpers.export(exports, "filterOrElse", ()=>filterOrElse);
parcelHelpers.export(exports, "filterOrFail", ()=>filterOrFail);
parcelHelpers.export(exports, "filterEffectOrElse", ()=>filterEffectOrElse);
parcelHelpers.export(exports, "filterEffectOrFail", ()=>filterEffectOrFail);
parcelHelpers.export(exports, "unless", ()=>unless);
parcelHelpers.export(exports, "unlessEffect", ()=>unlessEffect);
parcelHelpers.export(exports, "when", ()=>when);
parcelHelpers.export(exports, "whenEffect", ()=>whenEffect);
parcelHelpers.export(exports, "whenFiberRef", ()=>whenFiberRef);
parcelHelpers.export(exports, "whenRef", ()=>whenRef);
parcelHelpers.export(exports, "flatMap", ()=>flatMap);
parcelHelpers.export(exports, "andThen", ()=>andThen);
parcelHelpers.export(exports, "flatten", ()=>flatten);
parcelHelpers.export(exports, "race", ()=>race);
parcelHelpers.export(exports, "raceAll", ()=>raceAll);
parcelHelpers.export(exports, "raceFirst", ()=>raceFirst);
parcelHelpers.export(exports, "raceWith", ()=>raceWith);
parcelHelpers.export(exports, "summarized", ()=>summarized);
parcelHelpers.export(exports, "tap", ()=>tap);
parcelHelpers.export(exports, "tapBoth", ()=>tapBoth);
parcelHelpers.export(exports, "tapDefect", ()=>tapDefect);
parcelHelpers.export(exports, "tapError", ()=>tapError);
parcelHelpers.export(exports, "tapErrorTag", ()=>tapErrorTag);
parcelHelpers.export(exports, "tapErrorCause", ()=>tapErrorCause);
parcelHelpers.export(exports, "forever", ()=>forever);
parcelHelpers.export(exports, "iterate", ()=>iterate);
parcelHelpers.export(exports, "loop", ()=>loop);
parcelHelpers.export(exports, "repeat", ()=>repeat);
parcelHelpers.export(exports, "repeatN", ()=>repeatN);
parcelHelpers.export(exports, "repeatOrElse", ()=>repeatOrElse);
parcelHelpers.export(exports, "schedule", ()=>schedule);
parcelHelpers.export(exports, "scheduleForked", ()=>scheduleForked);
parcelHelpers.export(exports, "scheduleFrom", ()=>scheduleFrom);
parcelHelpers.export(exports, "whileLoop", ()=>whileLoop);
parcelHelpers.export(exports, "getFiberRefs", ()=>getFiberRefs);
parcelHelpers.export(exports, "inheritFiberRefs", ()=>inheritFiberRefs);
parcelHelpers.export(exports, "locally", ()=>locally);
parcelHelpers.export(exports, "locallyWith", ()=>locallyWith);
parcelHelpers.export(exports, "locallyScoped", ()=>locallyScoped);
parcelHelpers.export(exports, "locallyScopedWith", ()=>locallyScopedWith);
parcelHelpers.export(exports, "patchFiberRefs", ()=>patchFiberRefs);
parcelHelpers.export(exports, "setFiberRefs", ()=>setFiberRefs);
parcelHelpers.export(exports, "updateFiberRefs", ()=>updateFiberRefs);
parcelHelpers.export(exports, "isFailure", ()=>isFailure);
parcelHelpers.export(exports, "isSuccess", ()=>isSuccess);
parcelHelpers.export(exports, "match", ()=>match);
parcelHelpers.export(exports, "matchCause", ()=>matchCause);
parcelHelpers.export(exports, "matchCauseEffect", ()=>matchCauseEffect);
parcelHelpers.export(exports, "matchEffect", ()=>matchEffect);
parcelHelpers.export(exports, "log", ()=>log);
parcelHelpers.export(exports, "logWithLevel", ()=>logWithLevel);
parcelHelpers.export(exports, "logTrace", ()=>logTrace);
parcelHelpers.export(exports, "logDebug", ()=>logDebug);
parcelHelpers.export(exports, "logInfo", ()=>logInfo);
parcelHelpers.export(exports, "logWarning", ()=>logWarning);
parcelHelpers.export(exports, "logError", ()=>logError);
parcelHelpers.export(exports, "logFatal", ()=>logFatal);
parcelHelpers.export(exports, "withLogSpan", ()=>withLogSpan);
parcelHelpers.export(exports, "annotateLogs", ()=>annotateLogs);
parcelHelpers.export(exports, "annotateLogsScoped", ()=>annotateLogsScoped);
parcelHelpers.export(exports, "logAnnotations", ()=>logAnnotations);
parcelHelpers.export(exports, "withUnhandledErrorLogLevel", ()=>withUnhandledErrorLogLevel);
parcelHelpers.export(exports, "whenLogLevel", ()=>whenLogLevel);
parcelHelpers.export(exports, "orDie", ()=>orDie);
parcelHelpers.export(exports, "orDieWith", ()=>orDieWith);
parcelHelpers.export(exports, "orElse", ()=>orElse);
parcelHelpers.export(exports, "orElseFail", ()=>orElseFail);
parcelHelpers.export(exports, "orElseSucceed", ()=>orElseSucceed);
parcelHelpers.export(exports, "firstSuccessOf", ()=>firstSuccessOf);
parcelHelpers.export(exports, "random", ()=>random);
parcelHelpers.export(exports, "randomWith", ()=>randomWith);
parcelHelpers.export(exports, "withRandom", ()=>withRandom);
parcelHelpers.export(exports, "withRandomScoped", ()=>withRandomScoped);
parcelHelpers.export(exports, "runtime", ()=>runtime);
parcelHelpers.export(exports, "getRuntimeFlags", ()=>getRuntimeFlags);
parcelHelpers.export(exports, "patchRuntimeFlags", ()=>patchRuntimeFlags);
parcelHelpers.export(exports, "withRuntimeFlagsPatch", ()=>withRuntimeFlagsPatch);
parcelHelpers.export(exports, "withRuntimeFlagsPatchScoped", ()=>withRuntimeFlagsPatchScoped);
parcelHelpers.export(exports, "tagMetrics", ()=>tagMetrics);
parcelHelpers.export(exports, "labelMetrics", ()=>labelMetrics);
parcelHelpers.export(exports, "tagMetricsScoped", ()=>tagMetricsScoped);
parcelHelpers.export(exports, "labelMetricsScoped", ()=>labelMetricsScoped);
parcelHelpers.export(exports, "metricLabels", ()=>metricLabels);
parcelHelpers.export(exports, "withMetric", ()=>withMetric);
parcelHelpers.export(exports, "unsafeMakeSemaphore", ()=>unsafeMakeSemaphore);
parcelHelpers.export(exports, "makeSemaphore", ()=>makeSemaphore);
parcelHelpers.export(exports, "unsafeMakeLatch", ()=>unsafeMakeLatch);
parcelHelpers.export(exports, "makeLatch", ()=>makeLatch);
parcelHelpers.export(exports, "runFork", ()=>runFork);
parcelHelpers.export(exports, "runCallback", ()=>runCallback);
parcelHelpers.export(exports, "runPromise", ()=>runPromise);
parcelHelpers.export(exports, "runPromiseExit", ()=>runPromiseExit);
parcelHelpers.export(exports, "runSync", ()=>runSync);
parcelHelpers.export(exports, "runSyncExit", ()=>runSyncExit);
parcelHelpers.export(exports, "validate", ()=>validate);
parcelHelpers.export(exports, "validateWith", ()=>validateWith);
parcelHelpers.export(exports, "zip", ()=>zip);
parcelHelpers.export(exports, "zipLeft", ()=>zipLeft);
parcelHelpers.export(exports, "zipRight", ()=>zipRight);
parcelHelpers.export(exports, "zipWith", ()=>zipWith);
parcelHelpers.export(exports, "ap", ()=>ap);
parcelHelpers.export(exports, "blocked", ()=>blocked);
parcelHelpers.export(exports, "runRequestBlock", ()=>runRequestBlock);
parcelHelpers.export(exports, "step", ()=>step);
parcelHelpers.export(exports, "request", ()=>request);
parcelHelpers.export(exports, "cacheRequestResult", ()=>cacheRequestResult);
parcelHelpers.export(exports, "withRequestBatching", ()=>withRequestBatching);
parcelHelpers.export(exports, "withRequestCaching", ()=>withRequestCaching);
parcelHelpers.export(exports, "withRequestCache", ()=>withRequestCache);
parcelHelpers.export(exports, "tracer", ()=>tracer);
parcelHelpers.export(exports, "tracerWith", ()=>tracerWith);
parcelHelpers.export(exports, "withTracer", ()=>withTracer);
parcelHelpers.export(exports, "withTracerScoped", ()=>withTracerScoped);
parcelHelpers.export(exports, "withTracerEnabled", ()=>withTracerEnabled);
parcelHelpers.export(exports, "withTracerTiming", ()=>withTracerTiming);
parcelHelpers.export(exports, "annotateSpans", ()=>annotateSpans);
parcelHelpers.export(exports, "annotateCurrentSpan", ()=>annotateCurrentSpan);
parcelHelpers.export(exports, "currentSpan", ()=>currentSpan);
parcelHelpers.export(exports, "currentParentSpan", ()=>currentParentSpan);
parcelHelpers.export(exports, "spanAnnotations", ()=>spanAnnotations);
parcelHelpers.export(exports, "spanLinks", ()=>spanLinks);
parcelHelpers.export(exports, "linkSpans", ()=>linkSpans);
parcelHelpers.export(exports, "linkSpanCurrent", ()=>linkSpanCurrent);
parcelHelpers.export(exports, "makeSpan", ()=>makeSpan);
parcelHelpers.export(exports, "makeSpanScoped", ()=>makeSpanScoped);
parcelHelpers.export(exports, "useSpan", ()=>useSpan);
parcelHelpers.export(exports, "withSpan", ()=>withSpan);
parcelHelpers.export(exports, "functionWithSpan", ()=>functionWithSpan);
parcelHelpers.export(exports, "withSpanScoped", ()=>withSpanScoped);
parcelHelpers.export(exports, "withParentSpan", ()=>withParentSpan);
parcelHelpers.export(exports, "fromNullable", ()=>fromNullable);
parcelHelpers.export(exports, "optionFromOptional", ()=>optionFromOptional);
parcelHelpers.export(exports, "transposeOption", ()=>transposeOption);
parcelHelpers.export(exports, "transposeMapOption", ()=>transposeMapOption);
parcelHelpers.export(exports, "Tag", ()=>Tag);
parcelHelpers.export(exports, "Service", ()=>Service);
parcelHelpers.export(exports, "fn", ()=>fn);
parcelHelpers.export(exports, "fnUntraced", ()=>fnUntraced);
var _functionJs = require("./Function.js");
var _causeJs = require("./internal/cause.js");
var _consoleJs = require("./internal/console.js");
var _contextJs = require("./internal/context.js");
var _coreEffectJs = require("./internal/core-effect.js");
var _coreJs = require("./internal/core.js");
var _defaultServicesJs = require("./internal/defaultServices.js");
var _circularJs = require("./internal/effect/circular.js");
var _fiberRuntimeJs = require("./internal/fiberRuntime.js");
var _layerJs = require("./internal/layer.js");
var _optionJs = require("./internal/option.js");
var _queryJs = require("./internal/query.js");
var _runtimeJs = require("./internal/runtime.js");
var _scheduleJs = require("./internal/schedule.js");
var _tracerJs = require("./internal/tracer.js");
var _requestJs = require("./Request.js");
var _schedulerJs = require("./Scheduler.js");
var _utilsJs = require("./Utils.js");
const EffectTypeId = _coreJs.EffectTypeId;
const isEffect = _coreJs.isEffect;
const cachedWithTTL = _circularJs.cached;
const cachedInvalidateWithTTL = _circularJs.cachedInvalidateWithTTL;
const cached = _coreEffectJs.memoize;
const cachedFunction = _circularJs.cachedFunction;
const once = _coreEffectJs.once;
const all = _fiberRuntimeJs.all;
const allWith = _fiberRuntimeJs.allWith;
const allSuccesses = _fiberRuntimeJs.allSuccesses;
const dropUntil = _coreEffectJs.dropUntil;
const dropWhile = _coreEffectJs.dropWhile;
const takeUntil = _coreEffectJs.takeUntil;
const takeWhile = _coreEffectJs.takeWhile;
const every = _coreEffectJs.every;
const exists = _fiberRuntimeJs.exists;
const filter = _fiberRuntimeJs.filter;
const filterMap = _coreEffectJs.filterMap;
const findFirst = _coreEffectJs.findFirst;
const forEach = _fiberRuntimeJs.forEach;
const head = _coreEffectJs.head;
const mergeAll = _fiberRuntimeJs.mergeAll;
const partition = _fiberRuntimeJs.partition;
const reduce = _coreEffectJs.reduce;
const reduceWhile = _coreEffectJs.reduceWhile;
const reduceRight = _coreEffectJs.reduceRight;
const reduceEffect = _fiberRuntimeJs.reduceEffect;
const replicate = _fiberRuntimeJs.replicate;
const replicateEffect = _fiberRuntimeJs.replicateEffect;
const validateAll = _fiberRuntimeJs.validateAll;
const validateFirst = _fiberRuntimeJs.validateFirst;
const async = _coreJs.async;
const asyncEffect = _runtimeJs.asyncEffect;
const custom = _coreJs.custom;
const withFiberRuntime = _coreJs.withFiberRuntime;
const fail = _coreJs.fail;
const failSync = _coreJs.failSync;
const failCause = _coreJs.failCause;
const failCauseSync = _coreJs.failCauseSync;
const die = _coreJs.die;
const dieMessage = _coreJs.dieMessage;
const dieSync = _coreJs.dieSync;
const gen = _coreJs.gen;
const never = _coreJs.never;
const none = _coreEffectJs.none;
const promise = _coreEffectJs.promise;
const succeed = _coreJs.succeed;
const succeedNone = _coreEffectJs.succeedNone;
const succeedSome = _coreEffectJs.succeedSome;
const suspend = _coreJs.suspend;
const sync = _coreJs.sync;
const _void = _coreJs.void;
const yieldNow = _coreJs.yieldNow;
const _catch = _coreEffectJs._catch;
const catchAll = _coreJs.catchAll;
const catchAllCause = _coreJs.catchAllCause;
const catchAllDefect = _coreEffectJs.catchAllDefect;
const catchIf = _coreJs.catchIf;
const catchSome = _coreJs.catchSome;
const catchSomeCause = _coreEffectJs.catchSomeCause;
const catchSomeDefect = _coreEffectJs.catchSomeDefect;
const catchTag = _coreEffectJs.catchTag;
const catchTags = _coreEffectJs.catchTags;
const cause = _coreEffectJs.cause;
const eventually = _coreEffectJs.eventually;
const ignore = _coreEffectJs.ignore;
const ignoreLogged = _coreEffectJs.ignoreLogged;
const parallelErrors = _coreEffectJs.parallelErrors;
const sandbox = _coreEffectJs.sandbox;
const retry = _scheduleJs.retry_combined;
const retryOrElse = _scheduleJs.retryOrElse_Effect;
const try_ = _coreEffectJs.try_;
const tryMap = _coreEffectJs.tryMap;
const tryMapPromise = _coreEffectJs.tryMapPromise;
const tryPromise = _coreEffectJs.tryPromise;
const unsandbox = _coreEffectJs.unsandbox;
const allowInterrupt = _coreEffectJs.allowInterrupt;
const checkInterruptible = _coreJs.checkInterruptible;
const disconnect = _fiberRuntimeJs.disconnect;
const interrupt = _coreJs.interrupt;
const interruptWith = _coreJs.interruptWith;
const interruptible = _coreJs.interruptible;
const interruptibleMask = _coreJs.interruptibleMask;
const onInterrupt = _coreJs.onInterrupt;
const uninterruptible = _coreJs.uninterruptible;
const uninterruptibleMask = _coreJs.uninterruptibleMask;
const liftPredicate = _coreEffectJs.liftPredicate;
const as = _coreJs.as;
const asSome = _coreEffectJs.asSome;
const asSomeError = _coreEffectJs.asSomeError;
const asVoid = _coreJs.asVoid;
const flip = _coreJs.flip;
const flipWith = _coreEffectJs.flipWith;
const map = _coreJs.map;
const mapAccum = _coreEffectJs.mapAccum;
const mapBoth = _coreJs.mapBoth;
const mapError = _coreJs.mapError;
const mapErrorCause = _coreEffectJs.mapErrorCause;
const merge = _coreEffectJs.merge;
const negate = _coreEffectJs.negate;
const acquireRelease = _fiberRuntimeJs.acquireRelease;
const acquireReleaseInterruptible = _fiberRuntimeJs.acquireReleaseInterruptible;
const acquireUseRelease = _coreJs.acquireUseRelease;
const addFinalizer = _fiberRuntimeJs.addFinalizer;
const ensuring = _fiberRuntimeJs.ensuring;
const onError = _coreJs.onError;
const onExit = _coreJs.onExit;
const parallelFinalizers = _fiberRuntimeJs.parallelFinalizers;
const sequentialFinalizers = _fiberRuntimeJs.sequentialFinalizers;
const finalizersMask = _fiberRuntimeJs.finalizersMask;
const scope = _fiberRuntimeJs.scope;
const scopeWith = _fiberRuntimeJs.scopeWith;
const scopedWith = _fiberRuntimeJs.scopedWith;
const scoped = _fiberRuntimeJs.scopedEffect;
const using = _fiberRuntimeJs.using;
const withEarlyRelease = _fiberRuntimeJs.withEarlyRelease;
const awaitAllChildren = _circularJs.awaitAllChildren;
const daemonChildren = _fiberRuntimeJs.daemonChildren;
const descriptor = _coreEffectJs.descriptor;
const descriptorWith = _coreEffectJs.descriptorWith;
const diffFiberRefs = _coreEffectJs.diffFiberRefs;
const ensuringChild = _circularJs.ensuringChild;
const ensuringChildren = _circularJs.ensuringChildren;
const fiberId = _coreJs.fiberId;
const fiberIdWith = _coreJs.fiberIdWith;
const fork = _fiberRuntimeJs.fork;
const forkDaemon = _fiberRuntimeJs.forkDaemon;
const forkAll = _circularJs.forkAll;
const forkIn = _circularJs.forkIn;
const forkScoped = _circularJs.forkScoped;
const forkWithErrorHandler = _fiberRuntimeJs.forkWithErrorHandler;
const fromFiber = _circularJs.fromFiber;
const fromFiberEffect = _circularJs.fromFiberEffect;
const supervised = _circularJs.supervised;
const transplant = _coreJs.transplant;
const withConcurrency = _coreJs.withConcurrency;
const withScheduler = _schedulerJs.withScheduler;
const withSchedulingPriority = _coreJs.withSchedulingPriority;
const withMaxOpsBeforeYield = _coreJs.withMaxOpsBeforeYield;
const clock = _coreEffectJs.clock;
const clockWith = _coreEffectJs.clockWith;
const withClockScoped = _fiberRuntimeJs.withClockScoped;
const withClock = _defaultServicesJs.withClock;
const console = _consoleJs.console;
const consoleWith = _consoleJs.consoleWith;
const withConsoleScoped = _consoleJs.withConsoleScoped;
const withConsole = _consoleJs.withConsole;
const delay = _coreEffectJs.delay;
const sleep = _coreEffectJs.sleep;
const timed = _coreEffectJs.timed;
const timedWith = _coreEffectJs.timedWith;
const timeout = _circularJs.timeout;
const timeoutOption = _circularJs.timeoutOption;
const timeoutFail = _circularJs.timeoutFail;
const timeoutFailCause = _circularJs.timeoutFailCause;
const timeoutTo = _circularJs.timeoutTo;
const configProviderWith = _defaultServicesJs.configProviderWith;
const withConfigProvider = _defaultServicesJs.withConfigProvider;
const withConfigProviderScoped = _fiberRuntimeJs.withConfigProviderScoped;
const context = _coreJs.context;
const contextWith = _coreEffectJs.contextWith;
const contextWithEffect = _coreJs.contextWithEffect;
const mapInputContext = _coreJs.mapInputContext;
const provide = _layerJs.effect_provide;
const provideService = _coreEffectJs.provideService;
const provideServiceEffect = _coreEffectJs.provideServiceEffect;
const serviceFunction = _coreEffectJs.serviceFunction;
const serviceFunctionEffect = _coreEffectJs.serviceFunctionEffect;
const serviceFunctions = _coreEffectJs.serviceFunctions;
const serviceConstants = _coreEffectJs.serviceConstants;
const serviceMembers = _coreEffectJs.serviceMembers;
const serviceOption = _coreEffectJs.serviceOption;
const serviceOptional = _coreEffectJs.serviceOptional;
const updateService = _coreEffectJs.updateService;
const Do = _coreEffectJs.Do;
const bind = _coreEffectJs.bind;
const bindAll = _circularJs.bindAll;
const bindTo = _coreEffectJs.bindTo;
const let_ = _coreEffectJs.let_;
const option = _coreEffectJs.option;
const either = _coreJs.either;
const exit = _coreJs.exit;
const intoDeferred = _coreJs.intoDeferred;
const if_ = _coreJs.if_;
const filterOrDie = _coreEffectJs.filterOrDie;
const filterOrDieMessage = _coreEffectJs.filterOrDieMessage;
const filterOrElse = _coreEffectJs.filterOrElse;
const filterOrFail = _coreEffectJs.filterOrFail;
const filterEffectOrElse = _coreJs.filterEffectOrElse;
const filterEffectOrFail = _coreJs.filterEffectOrFail;
const unless = _coreEffectJs.unless;
const unlessEffect = _coreEffectJs.unlessEffect;
const when = _coreEffectJs.when;
const whenEffect = _coreJs.whenEffect;
const whenFiberRef = _coreEffectJs.whenFiberRef;
const whenRef = _coreEffectJs.whenRef;
const flatMap = _coreJs.flatMap;
const andThen = _coreJs.andThen;
const flatten = _coreJs.flatten;
const race = _fiberRuntimeJs.race;
const raceAll = _fiberRuntimeJs.raceAll;
const raceFirst = _circularJs.raceFirst;
const raceWith = _fiberRuntimeJs.raceWith;
const summarized = _coreEffectJs.summarized;
const tap = _coreJs.tap;
const tapBoth = _coreEffectJs.tapBoth;
const tapDefect = _coreEffectJs.tapDefect;
const tapError = _coreEffectJs.tapError;
const tapErrorTag = _coreEffectJs.tapErrorTag;
const tapErrorCause = _coreEffectJs.tapErrorCause;
const forever = _coreEffectJs.forever;
const iterate = _coreEffectJs.iterate;
const loop = _coreEffectJs.loop;
const repeat = _scheduleJs.repeat_combined;
const repeatN = _coreEffectJs.repeatN;
const repeatOrElse = _scheduleJs.repeatOrElse_Effect;
const schedule = _scheduleJs.schedule_Effect;
const scheduleForked = _circularJs.scheduleForked;
const scheduleFrom = _scheduleJs.scheduleFrom_Effect;
const whileLoop = _coreJs.whileLoop;
const getFiberRefs = _coreEffectJs.fiberRefs;
const inheritFiberRefs = _coreEffectJs.inheritFiberRefs;
const locally = _coreJs.fiberRefLocally;
const locallyWith = _coreJs.fiberRefLocallyWith;
const locallyScoped = _fiberRuntimeJs.fiberRefLocallyScoped;
const locallyScopedWith = _fiberRuntimeJs.fiberRefLocallyScopedWith;
const patchFiberRefs = _coreEffectJs.patchFiberRefs;
const setFiberRefs = _coreEffectJs.setFiberRefs;
const updateFiberRefs = _coreEffectJs.updateFiberRefs;
const isFailure = _coreEffectJs.isFailure;
const isSuccess = _coreEffectJs.isSuccess;
const match = _coreEffectJs.match;
const matchCause = _coreJs.matchCause;
const matchCauseEffect = _coreJs.matchCauseEffect;
const matchEffect = _coreJs.matchEffect;
const log = _coreEffectJs.log;
const logWithLevel = (level, ...message)=>_coreEffectJs.logWithLevel(level)(...message);
const logTrace = _coreEffectJs.logTrace;
const logDebug = _coreEffectJs.logDebug;
const logInfo = _coreEffectJs.logInfo;
const logWarning = _coreEffectJs.logWarning;
const logError = _coreEffectJs.logError;
const logFatal = _coreEffectJs.logFatal;
const withLogSpan = _coreEffectJs.withLogSpan;
const annotateLogs = _coreEffectJs.annotateLogs;
const annotateLogsScoped = _fiberRuntimeJs.annotateLogsScoped;
const logAnnotations = _coreEffectJs.logAnnotations;
const withUnhandledErrorLogLevel = _coreJs.withUnhandledErrorLogLevel;
const whenLogLevel = _fiberRuntimeJs.whenLogLevel;
const orDie = _coreJs.orDie;
const orDieWith = _coreJs.orDieWith;
const orElse = _coreJs.orElse;
const orElseFail = _coreEffectJs.orElseFail;
const orElseSucceed = _coreEffectJs.orElseSucceed;
const firstSuccessOf = _coreEffectJs.firstSuccessOf;
const random = _coreEffectJs.random;
const randomWith = _defaultServicesJs.randomWith;
const withRandom = _defaultServicesJs.withRandom;
const withRandomScoped = _fiberRuntimeJs.withRandomScoped;
const runtime = _runtimeJs.runtime;
const getRuntimeFlags = _coreJs.runtimeFlags;
const patchRuntimeFlags = _coreJs.updateRuntimeFlags;
const withRuntimeFlagsPatch = _coreJs.withRuntimeFlags;
const withRuntimeFlagsPatchScoped = _fiberRuntimeJs.withRuntimeFlagsScoped;
const tagMetrics = _coreEffectJs.tagMetrics;
const labelMetrics = _coreEffectJs.labelMetrics;
const tagMetricsScoped = _fiberRuntimeJs.tagMetricsScoped;
const labelMetricsScoped = _fiberRuntimeJs.labelMetricsScoped;
const metricLabels = _coreJs.metricLabels;
const withMetric = _coreEffectJs.withMetric;
const unsafeMakeSemaphore = _circularJs.unsafeMakeSemaphore;
const makeSemaphore = _circularJs.makeSemaphore;
const unsafeMakeLatch = _circularJs.unsafeMakeLatch;
const makeLatch = _circularJs.makeLatch;
const runFork = _runtimeJs.unsafeForkEffect;
const runCallback = _runtimeJs.unsafeRunEffect;
const runPromise = _runtimeJs.unsafeRunPromiseEffect;
const runPromiseExit = _runtimeJs.unsafeRunPromiseExitEffect;
const runSync = _runtimeJs.unsafeRunSyncEffect;
const runSyncExit = _runtimeJs.unsafeRunSyncExitEffect;
const validate = _fiberRuntimeJs.validate;
const validateWith = _fiberRuntimeJs.validateWith;
const zip = _fiberRuntimeJs.zipOptions;
const zipLeft = _fiberRuntimeJs.zipLeftOptions;
const zipRight = _fiberRuntimeJs.zipRightOptions;
const zipWith = _fiberRuntimeJs.zipWithOptions;
const ap = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>zipWith(self, that, (f, a)=>f(a)));
const blocked = _coreJs.blocked;
const runRequestBlock = _coreJs.runRequestBlock;
const step = _coreJs.step;
const request = /*#__PURE__*/ (0, _functionJs.dual)((args)=>_requestJs.isRequest(args[0]), _queryJs.fromRequest);
const cacheRequestResult = _queryJs.cacheRequest;
const withRequestBatching = _coreJs.withRequestBatching;
const withRequestCaching = _queryJs.withRequestCaching;
const withRequestCache = _queryJs.withRequestCache;
const tracer = _coreEffectJs.tracer;
const tracerWith = _defaultServicesJs.tracerWith;
const withTracer = _defaultServicesJs.withTracer;
const withTracerScoped = _fiberRuntimeJs.withTracerScoped;
const withTracerEnabled = _coreJs.withTracerEnabled;
const withTracerTiming = _coreJs.withTracerTiming;
const annotateSpans = _coreEffectJs.annotateSpans;
const annotateCurrentSpan = _coreEffectJs.annotateCurrentSpan;
const currentSpan = _coreEffectJs.currentSpan;
const currentParentSpan = _coreEffectJs.currentParentSpan;
const spanAnnotations = _coreEffectJs.spanAnnotations;
const spanLinks = _coreEffectJs.spanLinks;
const linkSpans = _coreEffectJs.linkSpans;
const linkSpanCurrent = _coreEffectJs.linkSpanCurrent;
const makeSpan = _coreEffectJs.makeSpan;
const makeSpanScoped = _fiberRuntimeJs.makeSpanScoped;
const useSpan = _coreEffectJs.useSpan;
const withSpan = _coreEffectJs.withSpan;
const functionWithSpan = _coreEffectJs.functionWithSpan;
const withSpanScoped = _fiberRuntimeJs.withSpanScoped;
const withParentSpan = _coreEffectJs.withParentSpan;
const fromNullable = _coreEffectJs.fromNullable;
const optionFromOptional = _coreEffectJs.optionFromOptional;
const transposeOption = (self)=>{
    return _optionJs.isNone(self) ? succeedNone : map(self.value, _optionJs.some);
};
const transposeMapOption = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>_optionJs.isNone(self) ? succeedNone : map(f(self.value), _optionJs.some));
const makeTagProxy = (TagClass)=>{
    const cache = new Map();
    return new Proxy(TagClass, {
        get (target, prop, receiver) {
            if (prop in target) return Reflect.get(target, prop, receiver);
            if (cache.has(prop)) return cache.get(prop);
            const fn = (...args)=>_coreJs.andThen(target, (s)=>{
                    if (typeof s[prop] === "function") {
                        cache.set(prop, (...args)=>_coreJs.andThen(target, (s)=>s[prop](...args)));
                        return s[prop](...args);
                    }
                    cache.set(prop, _coreJs.andThen(target, (s)=>s[prop]));
                    return s[prop];
                });
            const cn = _coreJs.andThen(target, (s)=>s[prop]);
            Object.assign(fn, cn);
            Object.setPrototypeOf(fn, Object.getPrototypeOf(cn));
            cache.set(prop, fn);
            return fn;
        }
    });
};
const Tag = (id)=>()=>{
        const limit = Error.stackTraceLimit;
        Error.stackTraceLimit = 2;
        const creationError = new Error();
        Error.stackTraceLimit = limit;
        function TagClass() {}
        Object.setPrototypeOf(TagClass, (0, _contextJs.TagProto));
        TagClass.key = id;
        Object.defineProperty(TagClass, "use", {
            get () {
                return (body)=>_coreJs.andThen(this, body);
            }
        });
        Object.defineProperty(TagClass, "stack", {
            get () {
                return creationError.stack;
            }
        });
        return makeTagProxy(TagClass);
    };
const Service = function() {
    return function() {
        const [id, maker] = arguments;
        const proxy = "accessors" in maker ? maker["accessors"] : false;
        const limit = Error.stackTraceLimit;
        Error.stackTraceLimit = 2;
        const creationError = new Error();
        Error.stackTraceLimit = limit;
        let patchState = "unchecked";
        const TagClass = function(service) {
            if (patchState === "unchecked") {
                const proto = Object.getPrototypeOf(service);
                if (proto === Object.prototype || proto === null) patchState = "plain";
                else {
                    const selfProto = Object.getPrototypeOf(this);
                    Object.setPrototypeOf(selfProto, proto);
                    patchState = "patched";
                }
            }
            if (patchState === "plain") Object.assign(this, service);
            else if (patchState === "patched") {
                Object.setPrototypeOf(service, Object.getPrototypeOf(this));
                return service;
            }
        };
        TagClass.prototype._tag = id;
        Object.defineProperty(TagClass, "make", {
            get () {
                return (service)=>new this(service);
            }
        });
        Object.defineProperty(TagClass, "use", {
            get () {
                return (body)=>_coreJs.andThen(this, body);
            }
        });
        TagClass.key = id;
        Object.assign(TagClass, (0, _contextJs.TagProto));
        Object.defineProperty(TagClass, "stack", {
            get () {
                return creationError.stack;
            }
        });
        const hasDeps = "dependencies" in maker && maker.dependencies.length > 0;
        const layerName = hasDeps ? "DefaultWithoutDependencies" : "Default";
        let layerCache;
        if ("effect" in maker) Object.defineProperty(TagClass, layerName, {
            get () {
                return layerCache ??= _layerJs.fromEffect(TagClass, map(maker.effect, (_)=>new this(_)));
            }
        });
        else if ("scoped" in maker) Object.defineProperty(TagClass, layerName, {
            get () {
                return layerCache ??= _layerJs.scoped(TagClass, map(maker.scoped, (_)=>new this(_)));
            }
        });
        else if ("sync" in maker) Object.defineProperty(TagClass, layerName, {
            get () {
                return layerCache ??= _layerJs.sync(TagClass, ()=>new this(maker.sync()));
            }
        });
        else Object.defineProperty(TagClass, layerName, {
            get () {
                return layerCache ??= _layerJs.succeed(TagClass, new this(maker.succeed));
            }
        });
        if (hasDeps) {
            let layerWithDepsCache;
            Object.defineProperty(TagClass, "Default", {
                get () {
                    return layerWithDepsCache ??= _layerJs.provide(this.DefaultWithoutDependencies, maker.dependencies);
                }
            });
        }
        return proxy === true ? makeTagProxy(TagClass) : TagClass;
    };
};
const fn = function(nameOrBody, ...pipeables) {
    const limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 2;
    const errorDef = new Error();
    Error.stackTraceLimit = limit;
    if (typeof nameOrBody !== "string") return defineLength(nameOrBody.length, function(...args) {
        const limit = Error.stackTraceLimit;
        Error.stackTraceLimit = 2;
        const errorCall = new Error();
        Error.stackTraceLimit = limit;
        return fnApply({
            self: this,
            body: nameOrBody,
            args,
            pipeables,
            spanName: "<anonymous>",
            spanOptions: {
                context: _tracerJs.DisablePropagation.context(true)
            },
            errorDef,
            errorCall
        });
    });
    const name = nameOrBody;
    const options = pipeables[0];
    return (body, ...pipeables)=>defineLength(body.length, function(...args) {
            const limit = Error.stackTraceLimit;
            Error.stackTraceLimit = 2;
            const errorCall = new Error();
            Error.stackTraceLimit = limit;
            return fnApply({
                self: this,
                body,
                args,
                pipeables,
                spanName: name,
                spanOptions: options,
                errorDef,
                errorCall
            });
        });
};
function defineLength(length, fn) {
    return Object.defineProperty(fn, "length", {
        value: length,
        configurable: true
    });
}
function fnApply(options) {
    let effect;
    let fnError = undefined;
    if ((0, _utilsJs.isGeneratorFunction)(options.body)) effect = _coreJs.fromIterator(()=>options.body.apply(options.self, options.args));
    else try {
        effect = options.body.apply(options.self, options.args);
    } catch (error) {
        fnError = error;
        effect = die(error);
    }
    if (options.pipeables.length > 0) try {
        for (const x of options.pipeables)effect = x(effect, ...options.args);
    } catch (error) {
        effect = fnError ? failCause(_causeJs.sequential(_causeJs.die(fnError), _causeJs.die(error))) : die(error);
    }
    let cache = false;
    const captureStackTrace = ()=>{
        if (cache !== false) return cache;
        if (options.errorCall.stack) {
            const stackDef = options.errorDef.stack.trim().split("\n");
            const stackCall = options.errorCall.stack.trim().split("\n");
            let endStackDef = stackDef.slice(2).join("\n").trim();
            if (!endStackDef.includes(`(`)) endStackDef = endStackDef.replace(/at (.*)/, "at ($1)");
            let endStackCall = stackCall.slice(2).join("\n").trim();
            if (!endStackCall.includes(`(`)) endStackCall = endStackCall.replace(/at (.*)/, "at ($1)");
            cache = `${endStackDef}\n${endStackCall}`;
            return cache;
        }
    };
    const opts = options.spanOptions && "captureStackTrace" in options.spanOptions ? options.spanOptions : {
        captureStackTrace,
        ...options.spanOptions
    };
    return withSpan(effect, options.spanName, opts);
}
const fnUntraced = _coreJs.fnUntraced;

},{"./Function.js":"21gOL","./internal/cause.js":"l3ev0","./internal/console.js":"5ouyz","./internal/context.js":"g5r35","./internal/core-effect.js":"k8F3C","./internal/core.js":"cr3YV","./internal/defaultServices.js":"aF4q8","./internal/effect/circular.js":"VvDt4","./internal/fiberRuntime.js":"2spXK","./internal/layer.js":"aHmA5","./internal/option.js":"c4fL5","./internal/query.js":"4BGGH","./internal/runtime.js":"criei","./internal/schedule.js":"laYcX","./internal/tracer.js":"aAsvB","./Request.js":"ggSSM","./Scheduler.js":"hR5Dj","./Utils.js":"dYvz1","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"5ouyz":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "console", ()=>console);
parcelHelpers.export(exports, "consoleWith", ()=>consoleWith);
parcelHelpers.export(exports, "withConsole", ()=>withConsole);
parcelHelpers.export(exports, "withConsoleScoped", ()=>withConsoleScoped);
parcelHelpers.export(exports, "setConsole", ()=>setConsole);
parcelHelpers.export(exports, "assert", ()=>assert);
parcelHelpers.export(exports, "clear", ()=>clear);
parcelHelpers.export(exports, "count", ()=>count);
parcelHelpers.export(exports, "countReset", ()=>countReset);
parcelHelpers.export(exports, "debug", ()=>debug);
parcelHelpers.export(exports, "dir", ()=>dir);
parcelHelpers.export(exports, "dirxml", ()=>dirxml);
parcelHelpers.export(exports, "error", ()=>error);
parcelHelpers.export(exports, "group", ()=>group);
parcelHelpers.export(exports, "info", ()=>info);
parcelHelpers.export(exports, "log", ()=>log);
parcelHelpers.export(exports, "table", ()=>table);
parcelHelpers.export(exports, "time", ()=>time);
parcelHelpers.export(exports, "timeLog", ()=>timeLog);
parcelHelpers.export(exports, "trace", ()=>trace);
parcelHelpers.export(exports, "warn", ()=>warn);
parcelHelpers.export(exports, "withGroup", ()=>withGroup);
parcelHelpers.export(exports, "withTime", ()=>withTime);
var _contextJs = require("../Context.js");
var _functionJs = require("../Function.js");
var _coreJs = require("./core.js");
var _defaultServicesJs = require("./defaultServices.js");
var _consoleJs = require("./defaultServices/console.js");
var _fiberRuntimeJs = require("./fiberRuntime.js");
var _layerJs = require("./layer.js");
const console = /*#__PURE__*/ _coreJs.map(/*#__PURE__*/ _coreJs.fiberRefGet(_defaultServicesJs.currentServices), /*#__PURE__*/ _contextJs.get(_consoleJs.consoleTag));
const consoleWith = (f)=>_coreJs.fiberRefGetWith(_defaultServicesJs.currentServices, (services)=>f(_contextJs.get(services, _consoleJs.consoleTag)));
const withConsole = /*#__PURE__*/ (0, _functionJs.dual)(2, (effect, value)=>_coreJs.fiberRefLocallyWith(effect, _defaultServicesJs.currentServices, _contextJs.add(_consoleJs.consoleTag, value)));
const withConsoleScoped = (console)=>_fiberRuntimeJs.fiberRefLocallyScopedWith(_defaultServicesJs.currentServices, _contextJs.add(_consoleJs.consoleTag, console));
const setConsole = (console)=>_layerJs.scopedDiscard(_fiberRuntimeJs.fiberRefLocallyScopedWith(_defaultServicesJs.currentServices, _contextJs.add(_consoleJs.consoleTag, console)));
const assert = (condition, ...args)=>consoleWith((_)=>_.assert(condition, ...args));
const clear = /*#__PURE__*/ consoleWith((_)=>_.clear);
const count = (label)=>consoleWith((_)=>_.count(label));
const countReset = (label)=>consoleWith((_)=>_.countReset(label));
const debug = (...args)=>consoleWith((_)=>_.debug(...args));
const dir = (item, options)=>consoleWith((_)=>_.dir(item, options));
const dirxml = (...args)=>consoleWith((_)=>_.dirxml(...args));
const error = (...args)=>consoleWith((_)=>_.error(...args));
const group = (options)=>consoleWith((_)=>_fiberRuntimeJs.acquireRelease(_.group(options), ()=>_.groupEnd));
const info = (...args)=>consoleWith((_)=>_.info(...args));
const log = (...args)=>consoleWith((_)=>_.log(...args));
const table = (tabularData, properties)=>consoleWith((_)=>_.table(tabularData, properties));
const time = (label)=>consoleWith((_)=>_fiberRuntimeJs.acquireRelease(_.time(label), ()=>_.timeEnd(label)));
const timeLog = (label, ...args)=>consoleWith((_)=>_.timeLog(label, ...args));
const trace = (...args)=>consoleWith((_)=>_.trace(...args));
const warn = (...args)=>consoleWith((_)=>_.warn(...args));
const withGroup = /*#__PURE__*/ (0, _functionJs.dual)((args)=>_coreJs.isEffect(args[0]), (self, options)=>consoleWith((_)=>_coreJs.acquireUseRelease(_.group(options), ()=>self, ()=>_.groupEnd)));
const withTime = /*#__PURE__*/ (0, _functionJs.dual)((args)=>_coreJs.isEffect(args[0]), (self, label)=>consoleWith((_)=>_coreJs.acquireUseRelease(_.time(label), ()=>self, ()=>_.timeEnd(label))));

},{"../Context.js":"c2abN","../Function.js":"21gOL","./core.js":"cr3YV","./defaultServices.js":"aF4q8","./defaultServices/console.js":"lcu1k","./fiberRuntime.js":"2spXK","./layer.js":"aHmA5","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"2spXK":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fiberStarted", ()=>fiberStarted);
parcelHelpers.export(exports, "fiberActive", ()=>fiberActive);
parcelHelpers.export(exports, "fiberSuccesses", ()=>fiberSuccesses);
parcelHelpers.export(exports, "fiberFailures", ()=>fiberFailures);
parcelHelpers.export(exports, "fiberLifetimes", ()=>fiberLifetimes);
/** @internal */ parcelHelpers.export(exports, "FiberRuntime", ()=>FiberRuntime);
parcelHelpers.export(exports, "currentMinimumLogLevel", ()=>currentMinimumLogLevel);
parcelHelpers.export(exports, "loggerWithConsoleLog", ()=>loggerWithConsoleLog);
parcelHelpers.export(exports, "loggerWithLeveledLog", ()=>loggerWithLeveledLog);
parcelHelpers.export(exports, "loggerWithConsoleError", ()=>loggerWithConsoleError);
parcelHelpers.export(exports, "defaultLogger", ()=>defaultLogger);
parcelHelpers.export(exports, "jsonLogger", ()=>jsonLogger);
parcelHelpers.export(exports, "logFmtLogger", ()=>logFmtLogger);
parcelHelpers.export(exports, "prettyLogger", ()=>prettyLogger);
parcelHelpers.export(exports, "structuredLogger", ()=>structuredLogger);
parcelHelpers.export(exports, "tracerLogger", ()=>tracerLogger);
parcelHelpers.export(exports, "loggerWithSpanAnnotations", ()=>loggerWithSpanAnnotations);
parcelHelpers.export(exports, "currentLoggers", ()=>currentLoggers);
parcelHelpers.export(exports, "batchedLogger", ()=>batchedLogger);
parcelHelpers.export(exports, "annotateLogsScoped", ()=>annotateLogsScoped);
parcelHelpers.export(exports, "whenLogLevel", ()=>whenLogLevel);
parcelHelpers.export(exports, "acquireRelease", ()=>acquireRelease);
parcelHelpers.export(exports, "acquireReleaseInterruptible", ()=>acquireReleaseInterruptible);
parcelHelpers.export(exports, "addFinalizer", ()=>addFinalizer);
parcelHelpers.export(exports, "daemonChildren", ()=>daemonChildren);
parcelHelpers.export(exports, "exists", ()=>exists);
parcelHelpers.export(exports, "filter", ()=>filter);
parcelHelpers.export(exports, "all", ()=>all);
parcelHelpers.export(exports, "allWith", ()=>allWith);
parcelHelpers.export(exports, "allSuccesses", ()=>allSuccesses);
parcelHelpers.export(exports, "replicate", ()=>replicate);
parcelHelpers.export(exports, "replicateEffect", ()=>replicateEffect);
parcelHelpers.export(exports, "forEach", ()=>forEach);
parcelHelpers.export(exports, "forEachParUnbounded", ()=>forEachParUnbounded);
parcelHelpers.export(exports, "forEachConcurrentDiscard", ()=>forEachConcurrentDiscard);
parcelHelpers.export(exports, "forEachParN", ()=>forEachParN);
parcelHelpers.export(exports, "fork", ()=>fork);
parcelHelpers.export(exports, "forkDaemon", ()=>forkDaemon);
parcelHelpers.export(exports, "forkWithErrorHandler", ()=>forkWithErrorHandler);
parcelHelpers.export(exports, "unsafeFork", ()=>unsafeFork);
parcelHelpers.export(exports, "unsafeForkUnstarted", ()=>unsafeForkUnstarted);
parcelHelpers.export(exports, "unsafeMakeChildFiber", ()=>unsafeMakeChildFiber);
parcelHelpers.export(exports, "mergeAll", ()=>mergeAll);
parcelHelpers.export(exports, "partition", ()=>partition);
parcelHelpers.export(exports, "validateAll", ()=>validateAll);
parcelHelpers.export(exports, "raceAll", ()=>raceAll);
parcelHelpers.export(exports, "reduceEffect", ()=>reduceEffect);
parcelHelpers.export(exports, "parallelFinalizers", ()=>parallelFinalizers);
parcelHelpers.export(exports, "parallelNFinalizers", ()=>parallelNFinalizers);
parcelHelpers.export(exports, "finalizersMask", ()=>finalizersMask);
parcelHelpers.export(exports, "finalizersMaskInternal", ()=>finalizersMaskInternal);
parcelHelpers.export(exports, "scopeWith", ()=>scopeWith);
parcelHelpers.export(exports, "scopedWith", ()=>scopedWith);
parcelHelpers.export(exports, "scopedEffect", ()=>scopedEffect);
parcelHelpers.export(exports, "sequentialFinalizers", ()=>sequentialFinalizers);
parcelHelpers.export(exports, "tagMetricsScoped", ()=>tagMetricsScoped);
parcelHelpers.export(exports, "labelMetricsScoped", ()=>labelMetricsScoped);
parcelHelpers.export(exports, "using", ()=>using);
parcelHelpers.export(exports, "validate", ()=>validate);
parcelHelpers.export(exports, "validateWith", ()=>validateWith);
parcelHelpers.export(exports, "validateAllPar", ()=>validateAllPar);
parcelHelpers.export(exports, "validateAllParDiscard", ()=>validateAllParDiscard);
parcelHelpers.export(exports, "validateFirst", ()=>validateFirst);
parcelHelpers.export(exports, "withClockScoped", ()=>withClockScoped);
parcelHelpers.export(exports, "withRandomScoped", ()=>withRandomScoped);
parcelHelpers.export(exports, "withConfigProviderScoped", ()=>withConfigProviderScoped);
parcelHelpers.export(exports, "withEarlyRelease", ()=>withEarlyRelease);
parcelHelpers.export(exports, "zipOptions", ()=>zipOptions);
parcelHelpers.export(exports, "zipLeftOptions", ()=>zipLeftOptions);
parcelHelpers.export(exports, "zipRightOptions", ()=>zipRightOptions);
parcelHelpers.export(exports, "zipWithOptions", ()=>zipWithOptions);
parcelHelpers.export(exports, "withRuntimeFlagsScoped", ()=>withRuntimeFlagsScoped);
parcelHelpers.export(exports, "scopeTag", ()=>scopeTag);
parcelHelpers.export(exports, "scope", ()=>scope);
parcelHelpers.export(exports, "scopeMake", ()=>scopeMake);
parcelHelpers.export(exports, "scopeExtend", ()=>scopeExtend);
parcelHelpers.export(exports, "scopeUse", ()=>scopeUse);
parcelHelpers.export(exports, "fiberRefUnsafeMakeSupervisor", ()=>fiberRefUnsafeMakeSupervisor);
parcelHelpers.export(exports, "fiberRefLocallyScoped", ()=>fiberRefLocallyScoped);
parcelHelpers.export(exports, "fiberRefLocallyScopedWith", ()=>fiberRefLocallyScopedWith);
parcelHelpers.export(exports, "fiberRefMake", ()=>fiberRefMake);
parcelHelpers.export(exports, "fiberRefMakeWith", ()=>fiberRefMakeWith);
parcelHelpers.export(exports, "fiberRefMakeContext", ()=>fiberRefMakeContext);
parcelHelpers.export(exports, "fiberRefMakeRuntimeFlags", ()=>fiberRefMakeRuntimeFlags);
parcelHelpers.export(exports, "currentRuntimeFlags", ()=>currentRuntimeFlags);
parcelHelpers.export(exports, "currentSupervisor", ()=>currentSupervisor);
parcelHelpers.export(exports, "fiberAwaitAll", ()=>fiberAwaitAll);
parcelHelpers.export(exports, "fiberAll", ()=>fiberAll);
parcelHelpers.export(exports, "fiberInterruptFork", ()=>fiberInterruptFork);
parcelHelpers.export(exports, "fiberJoinAll", ()=>fiberJoinAll);
parcelHelpers.export(exports, "fiberScoped", ()=>fiberScoped);
parcelHelpers.export(exports, "raceWith", ()=>raceWith);
parcelHelpers.export(exports, "disconnect", ()=>disconnect);
parcelHelpers.export(exports, "race", ()=>race);
parcelHelpers.export(exports, "raceFibersWith", ()=>raceFibersWith);
parcelHelpers.export(exports, "ensuring", ()=>ensuring);
parcelHelpers.export(exports, "invokeWithInterrupt", ()=>invokeWithInterrupt);
parcelHelpers.export(exports, "interruptWhenPossible", ()=>interruptWhenPossible);
parcelHelpers.export(exports, "makeSpanScoped", ()=>makeSpanScoped);
parcelHelpers.export(exports, "withTracerScoped", ()=>withTracerScoped);
parcelHelpers.export(exports, "withSpanScoped", ()=>withSpanScoped);
var _arrayJs = require("../Array.js");
var _booleanJs = require("../Boolean.js");
var _chunkJs = require("../Chunk.js");
var _contextJs = require("../Context.js");
var _deferredJs = require("../Deferred.js");
var _effectableJs = require("../Effectable.js");
var _executionStrategyJs = require("../ExecutionStrategy.js");
var _fiberIdJs = require("../FiberId.js");
var _fiberRefsJs = require("../FiberRefs.js");
var _fiberRefsPatchJs = require("../FiberRefsPatch.js");
var _fiberStatusJs = require("../FiberStatus.js");
var _functionJs = require("../Function.js");
var _globalValueJs = require("../GlobalValue.js");
var _hashMapJs = require("../HashMap.js");
var _hashSetJs = require("../HashSet.js");
var _inspectableJs = require("../Inspectable.js");
var _logLevelJs = require("../LogLevel.js");
var _microJs = require("../Micro.js");
var _mutableRefJs = require("../MutableRef.js");
var _optionJs = require("../Option.js");
var _pipeableJs = require("../Pipeable.js");
var _predicateJs = require("../Predicate.js");
var _refJs = require("../Ref.js");
var _runtimeFlagsPatchJs = require("../RuntimeFlagsPatch.js");
var _schedulerJs = require("../Scheduler.js");
var _utilsJs = require("../Utils.js");
var _blockedRequestsJs = require("./blockedRequests.js");
var _causeJs = require("./cause.js");
var _clockJs = require("./clock.js");
var _completedRequestMapJs = require("./completedRequestMap.js");
var _concurrencyJs = require("./concurrency.js");
var _configProviderJs = require("./configProvider.js");
var _coreEffectJs = require("./core-effect.js");
var _coreJs = require("./core.js");
var _defaultServicesJs = require("./defaultServices.js");
var _consoleJs = require("./defaultServices/console.js");
var _executionStrategyJs1 = require("./executionStrategy.js");
var _fiberJs = require("./fiber.js");
var _fiberMessageJs = require("./fiberMessage.js");
var _fiberRefsJs1 = require("./fiberRefs.js");
var _fiberScopeJs = require("./fiberScope.js");
var _loggerJs = require("./logger.js");
var _metricJs = require("./metric.js");
var _boundariesJs = require("./metric/boundaries.js");
var _labelJs = require("./metric/label.js");
var _effectJs = require("./opCodes/effect.js");
var _randomJs = require("./random.js");
var _requestJs = require("./request.js");
var _runtimeFlagsJs = require("./runtimeFlags.js");
var _supervisorJs = require("./supervisor.js");
var _patchJs = require("./supervisor/patch.js");
var _tracerJs = require("./tracer.js");
var _versionJs = require("./version.js");
const fiberStarted = /*#__PURE__*/ _metricJs.counter("effect_fiber_started", {
    incremental: true
});
const fiberActive = /*#__PURE__*/ _metricJs.counter("effect_fiber_active");
const fiberSuccesses = /*#__PURE__*/ _metricJs.counter("effect_fiber_successes", {
    incremental: true
});
const fiberFailures = /*#__PURE__*/ _metricJs.counter("effect_fiber_failures", {
    incremental: true
});
const fiberLifetimes = /*#__PURE__*/ _metricJs.tagged(/*#__PURE__*/ _metricJs.histogram("effect_fiber_lifetimes", /*#__PURE__*/ _boundariesJs.exponential({
    start: 0.5,
    factor: 2,
    count: 35
})), "time_unit", "milliseconds");
/** @internal */ const EvaluationSignalContinue = "Continue";
/** @internal */ const EvaluationSignalDone = "Done";
/** @internal */ const EvaluationSignalYieldNow = "Yield";
const runtimeFiberVariance = {
    /* c8 ignore next */ _E: (_)=>_,
    /* c8 ignore next */ _A: (_)=>_
};
const absurd = (_)=>{
    throw new Error(`BUG: FiberRuntime - ${_inspectableJs.toStringUnknown(_)} - please report an issue at https://github.com/Effect-TS/effect/issues`);
};
const YieldedOp = /*#__PURE__*/ Symbol.for("effect/internal/fiberRuntime/YieldedOp");
const yieldedOpChannel = /*#__PURE__*/ (0, _globalValueJs.globalValue)("effect/internal/fiberRuntime/yieldedOpChannel", ()=>({
        currentOp: null
    }));
const contOpSuccess = {
    [_effectJs.OP_ON_SUCCESS]: (_, cont, value)=>{
        return (0, _utilsJs.internalCall)(()=>cont.effect_instruction_i1(value));
    },
    ["OnStep"]: (_, _cont, value)=>{
        return _coreJs.exitSucceed(_coreJs.exitSucceed(value));
    },
    [_effectJs.OP_ON_SUCCESS_AND_FAILURE]: (_, cont, value)=>{
        return (0, _utilsJs.internalCall)(()=>cont.effect_instruction_i2(value));
    },
    [_effectJs.OP_REVERT_FLAGS]: (self, cont, value)=>{
        self.patchRuntimeFlags(self.currentRuntimeFlags, cont.patch);
        if (_runtimeFlagsJs.interruptible(self.currentRuntimeFlags) && self.isInterrupted()) return _coreJs.exitFailCause(self.getInterruptedCause());
        else return _coreJs.exitSucceed(value);
    },
    [_effectJs.OP_WHILE]: (self, cont, value)=>{
        (0, _utilsJs.internalCall)(()=>cont.effect_instruction_i2(value));
        if ((0, _utilsJs.internalCall)(()=>cont.effect_instruction_i0())) {
            self.pushStack(cont);
            return (0, _utilsJs.internalCall)(()=>cont.effect_instruction_i1());
        } else return _coreJs.void;
    },
    [_effectJs.OP_ITERATOR]: (self, cont, value)=>{
        const state = (0, _utilsJs.internalCall)(()=>cont.effect_instruction_i0.next(value));
        if (state.done) return _coreJs.exitSucceed(state.value);
        self.pushStack(cont);
        return (0, _utilsJs.yieldWrapGet)(state.value);
    }
};
const drainQueueWhileRunningTable = {
    [_fiberMessageJs.OP_INTERRUPT_SIGNAL]: (self, runtimeFlags, cur, message)=>{
        self.processNewInterruptSignal(message.cause);
        return _runtimeFlagsJs.interruptible(runtimeFlags) ? _coreJs.exitFailCause(message.cause) : cur;
    },
    [_fiberMessageJs.OP_RESUME]: (_self, _runtimeFlags, _cur, _message)=>{
        throw new Error("It is illegal to have multiple concurrent run loops in a single fiber");
    },
    [_fiberMessageJs.OP_STATEFUL]: (self, runtimeFlags, cur, message)=>{
        message.onFiber(self, _fiberStatusJs.running(runtimeFlags));
        return cur;
    },
    [_fiberMessageJs.OP_YIELD_NOW]: (_self, _runtimeFlags, cur, _message)=>{
        return _coreJs.flatMap(_coreJs.yieldNow(), ()=>cur);
    }
};
/**
 * Executes all requests, submitting requests to each data source in parallel.
 */ const runBlockedRequests = (self)=>_coreJs.forEachSequentialDiscard(_blockedRequestsJs.flatten(self), (requestsByRequestResolver)=>forEachConcurrentDiscard(_blockedRequestsJs.sequentialCollectionToChunk(requestsByRequestResolver), ([dataSource, sequential])=>{
            const map = new Map();
            const arr = [];
            for (const block of sequential){
                arr.push(_chunkJs.toReadonlyArray(block));
                for (const entry of block)map.set(entry.request, entry);
            }
            const flat = arr.flat();
            return _coreJs.fiberRefLocally(invokeWithInterrupt(dataSource.runAll(arr), flat, ()=>flat.forEach((entry)=>{
                    entry.listeners.interrupted = true;
                })), (0, _completedRequestMapJs.currentRequestMap), map);
        }, false, false));
const _version = /*#__PURE__*/ _versionJs.getCurrentVersion();
class FiberRuntime extends _effectableJs.Class {
    [_fiberJs.FiberTypeId] = _fiberJs.fiberVariance;
    [_fiberJs.RuntimeFiberTypeId] = runtimeFiberVariance;
    _fiberRefs;
    _fiberId;
    _queue = /*#__PURE__*/ new Array();
    _children = null;
    _observers = /*#__PURE__*/ new Array();
    _running = false;
    _stack = [];
    _asyncInterruptor = null;
    _asyncBlockingOn = null;
    _exitValue = null;
    _steps = [];
    _isYielding = false;
    currentRuntimeFlags;
    currentOpCount = 0;
    currentSupervisor;
    currentScheduler;
    currentTracer;
    currentSpan;
    currentContext;
    currentDefaultServices;
    constructor(fiberId, fiberRefs0, runtimeFlags0){
        super();
        this.currentRuntimeFlags = runtimeFlags0;
        this._fiberId = fiberId;
        this._fiberRefs = fiberRefs0;
        if (_runtimeFlagsJs.runtimeMetrics(runtimeFlags0)) {
            const tags = this.getFiberRef(_coreJs.currentMetricLabels);
            fiberStarted.unsafeUpdate(1, tags);
            fiberActive.unsafeUpdate(1, tags);
        }
        this.refreshRefCache();
    }
    commit() {
        return _fiberJs.join(this);
    }
    /**
   * The identity of the fiber.
   */ id() {
        return this._fiberId;
    }
    /**
   * Begins execution of the effect associated with this fiber on in the
   * background. This can be called to "kick off" execution of a fiber after
   * it has been created.
   */ resume(effect) {
        this.tell(_fiberMessageJs.resume(effect));
    }
    /**
   * The status of the fiber.
   */ get status() {
        return this.ask((_, status)=>status);
    }
    /**
   * Gets the fiber runtime flags.
   */ get runtimeFlags() {
        return this.ask((state, status)=>{
            if (_fiberStatusJs.isDone(status)) return state.currentRuntimeFlags;
            return status.runtimeFlags;
        });
    }
    /**
   * Returns the current `FiberScope` for the fiber.
   */ scope() {
        return _fiberScopeJs.unsafeMake(this);
    }
    /**
   * Retrieves the immediate children of the fiber.
   */ get children() {
        return this.ask((fiber)=>Array.from(fiber.getChildren()));
    }
    /**
   * Gets the fiber's set of children.
   */ getChildren() {
        if (this._children === null) this._children = new Set();
        return this._children;
    }
    /**
   * Retrieves the interrupted cause of the fiber, which will be `Cause.empty`
   * if the fiber has not been interrupted.
   *
   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
   * on this fiber, then values derived from the fiber's state (including the
   * log annotations and log level) may not be up-to-date.
   */ getInterruptedCause() {
        return this.getFiberRef(_coreJs.currentInterruptedCause);
    }
    /**
   * Retrieves the whole set of fiber refs.
   */ fiberRefs() {
        return this.ask((fiber)=>fiber.getFiberRefs());
    }
    /**
   * Returns an effect that will contain information computed from the fiber
   * state and status while running on the fiber.
   *
   * This allows the outside world to interact safely with mutable fiber state
   * without locks or immutable data.
   */ ask(f) {
        return _coreJs.suspend(()=>{
            const deferred = _coreJs.deferredUnsafeMake(this._fiberId);
            this.tell(_fiberMessageJs.stateful((fiber, status)=>{
                _coreJs.deferredUnsafeDone(deferred, _coreJs.sync(()=>f(fiber, status)));
            }));
            return _coreJs.deferredAwait(deferred);
        });
    }
    /**
   * Adds a message to be processed by the fiber on the fiber.
   */ tell(message) {
        this._queue.push(message);
        if (!this._running) {
            this._running = true;
            this.drainQueueLaterOnExecutor();
        }
    }
    get await() {
        return _coreJs.async((resume)=>{
            const cb = (exit)=>resume(_coreJs.succeed(exit));
            this.tell(_fiberMessageJs.stateful((fiber, _)=>{
                if (fiber._exitValue !== null) cb(this._exitValue);
                else fiber.addObserver(cb);
            }));
            return _coreJs.sync(()=>this.tell(_fiberMessageJs.stateful((fiber, _)=>{
                    fiber.removeObserver(cb);
                })));
        }, this.id());
    }
    get inheritAll() {
        return _coreJs.withFiberRuntime((parentFiber, parentStatus)=>{
            const parentFiberId = parentFiber.id();
            const parentFiberRefs = parentFiber.getFiberRefs();
            const parentRuntimeFlags = parentStatus.runtimeFlags;
            const childFiberRefs = this.getFiberRefs();
            const updatedFiberRefs = _fiberRefsJs1.joinAs(parentFiberRefs, parentFiberId, childFiberRefs);
            parentFiber.setFiberRefs(updatedFiberRefs);
            const updatedRuntimeFlags = parentFiber.getFiberRef(currentRuntimeFlags);
            const patch = (0, _functionJs.pipe)(_runtimeFlagsJs.diff(parentRuntimeFlags, updatedRuntimeFlags), // Do not inherit WindDown or Interruption!
            _runtimeFlagsPatchJs.exclude(_runtimeFlagsJs.Interruption), _runtimeFlagsPatchJs.exclude(_runtimeFlagsJs.WindDown));
            return _coreJs.updateRuntimeFlags(patch);
        });
    }
    /**
   * Tentatively observes the fiber, but returns immediately if it is not
   * already done.
   */ get poll() {
        return _coreJs.sync(()=>_optionJs.fromNullable(this._exitValue));
    }
    /**
   * Unsafely observes the fiber, but returns immediately if it is not
   * already done.
   */ unsafePoll() {
        return this._exitValue;
    }
    /**
   * In the background, interrupts the fiber as if interrupted from the specified fiber.
   */ interruptAsFork(fiberId) {
        return _coreJs.sync(()=>this.tell(_fiberMessageJs.interruptSignal(_causeJs.interrupt(fiberId))));
    }
    /**
   * In the background, interrupts the fiber as if interrupted from the specified fiber.
   */ unsafeInterruptAsFork(fiberId) {
        this.tell(_fiberMessageJs.interruptSignal(_causeJs.interrupt(fiberId)));
    }
    /**
   * Adds an observer to the list of observers.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */ addObserver(observer) {
        if (this._exitValue !== null) observer(this._exitValue);
        else this._observers.push(observer);
    }
    /**
   * Removes the specified observer from the list of observers that will be
   * notified when the fiber exits.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */ removeObserver(observer) {
        this._observers = this._observers.filter((o)=>o !== observer);
    }
    /**
   * Retrieves all fiber refs of the fiber.
   *
   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
   * on this fiber, then values derived from the fiber's state (including the
   * log annotations and log level) may not be up-to-date.
   */ getFiberRefs() {
        this.setFiberRef(currentRuntimeFlags, this.currentRuntimeFlags);
        return this._fiberRefs;
    }
    /**
   * Deletes the specified fiber ref.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */ unsafeDeleteFiberRef(fiberRef) {
        this._fiberRefs = _fiberRefsJs1.delete_(this._fiberRefs, fiberRef);
    }
    /**
   * Retrieves the state of the fiber ref, or else its initial value.
   *
   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
   * on this fiber, then values derived from the fiber's state (including the
   * log annotations and log level) may not be up-to-date.
   */ getFiberRef(fiberRef) {
        if (this._fiberRefs.locals.has(fiberRef)) return this._fiberRefs.locals.get(fiberRef)[0][1];
        return fiberRef.initial;
    }
    /**
   * Sets the fiber ref to the specified value.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */ setFiberRef(fiberRef, value) {
        this._fiberRefs = _fiberRefsJs1.updateAs(this._fiberRefs, {
            fiberId: this._fiberId,
            fiberRef,
            value
        });
        this.refreshRefCache();
    }
    refreshRefCache() {
        this.currentDefaultServices = this.getFiberRef(_defaultServicesJs.currentServices);
        this.currentTracer = this.currentDefaultServices.unsafeMap.get(_tracerJs.tracerTag.key);
        this.currentSupervisor = this.getFiberRef(currentSupervisor);
        this.currentScheduler = this.getFiberRef((0, _schedulerJs.currentScheduler));
        this.currentContext = this.getFiberRef(_coreJs.currentContext);
        this.currentSpan = this.currentContext.unsafeMap.get(_tracerJs.spanTag.key);
    }
    /**
   * Wholesale replaces all fiber refs of this fiber.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */ setFiberRefs(fiberRefs) {
        this._fiberRefs = fiberRefs;
        this.refreshRefCache();
    }
    /**
   * Adds a reference to the specified fiber inside the children set.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */ addChild(child) {
        this.getChildren().add(child);
    }
    /**
   * Removes a reference to the specified fiber inside the children set.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */ removeChild(child) {
        this.getChildren().delete(child);
    }
    /**
   * Transfers all children of this fiber that are currently running to the
   * specified fiber scope.
   *
   * **NOTE**: This method must be invoked by the fiber itself after it has
   * evaluated the effects but prior to exiting.
   */ transferChildren(scope) {
        const children = this._children;
        // Clear the children of the current fiber
        this._children = null;
        if (children !== null && children.size > 0) {
            for (const child of children)// If the child is still running, add it to the scope
            if (child._exitValue === null) scope.add(this.currentRuntimeFlags, child);
        }
    }
    /**
   * On the current thread, executes all messages in the fiber's inbox. This
   * method may return before all work is done, in the event the fiber executes
   * an asynchronous operation.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */ drainQueueOnCurrentThread() {
        let recurse = true;
        while(recurse){
            let evaluationSignal = EvaluationSignalContinue;
            const prev = globalThis[_fiberJs.currentFiberURI];
            globalThis[_fiberJs.currentFiberURI] = this;
            try {
                while(evaluationSignal === EvaluationSignalContinue)evaluationSignal = this._queue.length === 0 ? EvaluationSignalDone : this.evaluateMessageWhileSuspended(this._queue.splice(0, 1)[0]);
            } finally{
                this._running = false;
                globalThis[_fiberJs.currentFiberURI] = prev;
            }
            // Maybe someone added something to the queue between us checking, and us
            // giving up the drain. If so, we need to restart the draining, but only
            // if we beat everyone else to the restart:
            if (this._queue.length > 0 && !this._running) {
                this._running = true;
                if (evaluationSignal === EvaluationSignalYieldNow) {
                    this.drainQueueLaterOnExecutor();
                    recurse = false;
                } else recurse = true;
            } else recurse = false;
        }
    }
    /**
   * Schedules the execution of all messages in the fiber's inbox.
   *
   * This method will return immediately after the scheduling
   * operation is completed, but potentially before such messages have been
   * executed.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */ drainQueueLaterOnExecutor() {
        this.currentScheduler.scheduleTask(this.run, this.getFiberRef(_coreJs.currentSchedulingPriority));
    }
    /**
   * Drains the fiber's message queue while the fiber is actively running,
   * returning the next effect to execute, which may be the input effect if no
   * additional effect needs to be executed.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */ drainQueueWhileRunning(runtimeFlags, cur0) {
        let cur = cur0;
        while(this._queue.length > 0){
            const message = this._queue.splice(0, 1)[0];
            // @ts-expect-error
            cur = drainQueueWhileRunningTable[message._tag](this, runtimeFlags, cur, message);
        }
        return cur;
    }
    /**
   * Determines if the fiber is interrupted.
   *
   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
   * on this fiber, then values derived from the fiber's state (including the
   * log annotations and log level) may not be up-to-date.
   */ isInterrupted() {
        return !_causeJs.isEmpty(this.getFiberRef(_coreJs.currentInterruptedCause));
    }
    /**
   * Adds an interruptor to the set of interruptors that are interrupting this
   * fiber.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */ addInterruptedCause(cause) {
        const oldSC = this.getFiberRef(_coreJs.currentInterruptedCause);
        this.setFiberRef(_coreJs.currentInterruptedCause, _causeJs.sequential(oldSC, cause));
    }
    /**
   * Processes a new incoming interrupt signal.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */ processNewInterruptSignal(cause) {
        this.addInterruptedCause(cause);
        this.sendInterruptSignalToAllChildren();
    }
    /**
   * Interrupts all children of the current fiber, returning an effect that will
   * await the exit of the children. This method will return null if the fiber
   * has no children.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */ sendInterruptSignalToAllChildren() {
        if (this._children === null || this._children.size === 0) return false;
        let told = false;
        for (const child of this._children){
            child.tell(_fiberMessageJs.interruptSignal(_causeJs.interrupt(this.id())));
            told = true;
        }
        return told;
    }
    /**
   * Interrupts all children of the current fiber, returning an effect that will
   * await the exit of the children. This method will return null if the fiber
   * has no children.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */ interruptAllChildren() {
        if (this.sendInterruptSignalToAllChildren()) {
            const it = this._children.values();
            this._children = null;
            let isDone = false;
            const body = ()=>{
                const next = it.next();
                if (!next.done) return _coreJs.asVoid(next.value.await);
                else return _coreJs.sync(()=>{
                    isDone = true;
                });
            };
            return _coreJs.whileLoop({
                while: ()=>!isDone,
                body,
                step: ()=>{
                //
                }
            });
        }
        return null;
    }
    reportExitValue(exit) {
        if (_runtimeFlagsJs.runtimeMetrics(this.currentRuntimeFlags)) {
            const tags = this.getFiberRef(_coreJs.currentMetricLabels);
            const startTimeMillis = this.id().startTimeMillis;
            const endTimeMillis = Date.now();
            fiberLifetimes.unsafeUpdate(endTimeMillis - startTimeMillis, tags);
            fiberActive.unsafeUpdate(-1, tags);
            switch(exit._tag){
                case _effectJs.OP_SUCCESS:
                    fiberSuccesses.unsafeUpdate(1, tags);
                    break;
                case _effectJs.OP_FAILURE:
                    fiberFailures.unsafeUpdate(1, tags);
                    break;
            }
        }
        if (exit._tag === "Failure") {
            const level = this.getFiberRef(_coreJs.currentUnhandledErrorLogLevel);
            if (!_causeJs.isInterruptedOnly(exit.cause) && level._tag === "Some") this.log("Fiber terminated with an unhandled error", exit.cause, level);
        }
    }
    setExitValue(exit) {
        this._exitValue = exit;
        this.reportExitValue(exit);
        for(let i = this._observers.length - 1; i >= 0; i--)this._observers[i](exit);
        this._observers = [];
    }
    getLoggers() {
        return this.getFiberRef(currentLoggers);
    }
    log(message, cause, overrideLogLevel) {
        const logLevel = _optionJs.isSome(overrideLogLevel) ? overrideLogLevel.value : this.getFiberRef(_coreJs.currentLogLevel);
        const minimumLogLevel = this.getFiberRef(currentMinimumLogLevel);
        if (_logLevelJs.greaterThan(minimumLogLevel, logLevel)) return;
        const spans = this.getFiberRef(_coreJs.currentLogSpan);
        const annotations = this.getFiberRef(_coreJs.currentLogAnnotations);
        const loggers = this.getLoggers();
        const contextMap = this.getFiberRefs();
        if (_hashSetJs.size(loggers) > 0) {
            const clockService = _contextJs.get(this.getFiberRef(_defaultServicesJs.currentServices), _clockJs.clockTag);
            const date = new Date(clockService.unsafeCurrentTimeMillis());
            _inspectableJs.withRedactableContext(contextMap, ()=>{
                for (const logger of loggers)logger.log({
                    fiberId: this.id(),
                    logLevel,
                    message,
                    cause,
                    context: contextMap,
                    spans,
                    annotations,
                    date
                });
            });
        }
    }
    /**
   * Evaluates a single message on the current thread, while the fiber is
   * suspended. This method should only be called while evaluation of the
   * fiber's effect is suspended due to an asynchronous operation.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */ evaluateMessageWhileSuspended(message) {
        switch(message._tag){
            case _fiberMessageJs.OP_YIELD_NOW:
                return EvaluationSignalYieldNow;
            case _fiberMessageJs.OP_INTERRUPT_SIGNAL:
                this.processNewInterruptSignal(message.cause);
                if (this._asyncInterruptor !== null) {
                    this._asyncInterruptor(_coreJs.exitFailCause(message.cause));
                    this._asyncInterruptor = null;
                }
                return EvaluationSignalContinue;
            case _fiberMessageJs.OP_RESUME:
                this._asyncInterruptor = null;
                this._asyncBlockingOn = null;
                this.evaluateEffect(message.effect);
                return EvaluationSignalContinue;
            case _fiberMessageJs.OP_STATEFUL:
                message.onFiber(this, this._exitValue !== null ? _fiberStatusJs.done : _fiberStatusJs.suspended(this.currentRuntimeFlags, this._asyncBlockingOn));
                return EvaluationSignalContinue;
            default:
                return absurd(message);
        }
    }
    /**
   * Evaluates an effect until completion, potentially asynchronously.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */ evaluateEffect(effect0) {
        this.currentSupervisor.onResume(this);
        try {
            let effect = _runtimeFlagsJs.interruptible(this.currentRuntimeFlags) && this.isInterrupted() ? _coreJs.exitFailCause(this.getInterruptedCause()) : effect0;
            while(effect !== null){
                const eff = effect;
                const exit = this.runLoop(eff);
                if (exit === YieldedOp) {
                    const op = yieldedOpChannel.currentOp;
                    yieldedOpChannel.currentOp = null;
                    if (op._op === _effectJs.OP_YIELD) {
                        if (_runtimeFlagsJs.cooperativeYielding(this.currentRuntimeFlags)) {
                            this.tell(_fiberMessageJs.yieldNow());
                            this.tell(_fiberMessageJs.resume(_coreJs.exitVoid));
                            effect = null;
                        } else effect = _coreJs.exitVoid;
                    } else if (op._op === _effectJs.OP_ASYNC) // Terminate this evaluation, async resumption will continue evaluation:
                    effect = null;
                } else {
                    this.currentRuntimeFlags = (0, _functionJs.pipe)(this.currentRuntimeFlags, _runtimeFlagsJs.enable(_runtimeFlagsJs.WindDown));
                    const interruption = this.interruptAllChildren();
                    if (interruption !== null) effect = _coreJs.flatMap(interruption, ()=>exit);
                    else {
                        if (this._queue.length === 0) // No more messages to process, so we will allow the fiber to end life:
                        this.setExitValue(exit);
                        else // There are messages, possibly added by the final op executed by
                        // the fiber. To be safe, we should execute those now before we
                        // allow the fiber to end life:
                        this.tell(_fiberMessageJs.resume(exit));
                        effect = null;
                    }
                }
            }
        } finally{
            this.currentSupervisor.onSuspend(this);
        }
    }
    /**
   * Begins execution of the effect associated with this fiber on the current
   * thread. This can be called to "kick off" execution of a fiber after it has
   * been created, in hopes that the effect can be executed synchronously.
   *
   * This is not the normal way of starting a fiber, but it is useful when the
   * express goal of executing the fiber is to synchronously produce its exit.
   */ start(effect) {
        if (!this._running) {
            this._running = true;
            const prev = globalThis[_fiberJs.currentFiberURI];
            globalThis[_fiberJs.currentFiberURI] = this;
            try {
                this.evaluateEffect(effect);
            } finally{
                this._running = false;
                globalThis[_fiberJs.currentFiberURI] = prev;
                // Because we're special casing `start`, we have to be responsible
                // for spinning up the fiber if there were new messages added to
                // the queue between the completion of the effect and the transition
                // to the not running state.
                if (this._queue.length > 0) this.drainQueueLaterOnExecutor();
            }
        } else this.tell(_fiberMessageJs.resume(effect));
    }
    /**
   * Begins execution of the effect associated with this fiber on in the
   * background, and on the correct thread pool. This can be called to "kick
   * off" execution of a fiber after it has been created, in hopes that the
   * effect can be executed synchronously.
   */ startFork(effect) {
        this.tell(_fiberMessageJs.resume(effect));
    }
    /**
   * Takes the current runtime flags, patches them to return the new runtime
   * flags, and then makes any changes necessary to fiber state based on the
   * specified patch.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */ patchRuntimeFlags(oldRuntimeFlags, patch) {
        const newRuntimeFlags = _runtimeFlagsJs.patch(oldRuntimeFlags, patch);
        globalThis[_fiberJs.currentFiberURI] = this;
        this.currentRuntimeFlags = newRuntimeFlags;
        return newRuntimeFlags;
    }
    /**
   * Initiates an asynchronous operation, by building a callback that will
   * resume execution, and then feeding that callback to the registration
   * function, handling error cases and repeated resumptions appropriately.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */ initiateAsync(runtimeFlags, asyncRegister) {
        let alreadyCalled = false;
        const callback = (effect)=>{
            if (!alreadyCalled) {
                alreadyCalled = true;
                this.tell(_fiberMessageJs.resume(effect));
            }
        };
        if (_runtimeFlagsJs.interruptible(runtimeFlags)) this._asyncInterruptor = callback;
        try {
            asyncRegister(callback);
        } catch (e) {
            callback(_coreJs.failCause(_causeJs.die(e)));
        }
    }
    pushStack(cont) {
        this._stack.push(cont);
        if (cont._op === "OnStep") this._steps.push({
            refs: this.getFiberRefs(),
            flags: this.currentRuntimeFlags
        });
    }
    popStack() {
        const item = this._stack.pop();
        if (item) {
            if (item._op === "OnStep") this._steps.pop();
            return item;
        }
        return;
    }
    getNextSuccessCont() {
        let frame = this.popStack();
        while(frame){
            if (frame._op !== _effectJs.OP_ON_FAILURE) return frame;
            frame = this.popStack();
        }
    }
    getNextFailCont() {
        let frame = this.popStack();
        while(frame){
            if (frame._op !== _effectJs.OP_ON_SUCCESS && frame._op !== _effectJs.OP_WHILE && frame._op !== _effectJs.OP_ITERATOR) return frame;
            frame = this.popStack();
        }
    }
    [_effectJs.OP_TAG](op) {
        return _coreJs.sync(()=>_contextJs.unsafeGet(this.currentContext, op));
    }
    ["Left"](op) {
        return _coreJs.fail(op.left);
    }
    ["None"](_) {
        return _coreJs.fail(new _coreJs.NoSuchElementException());
    }
    ["Right"](op) {
        return _coreJs.exitSucceed(op.right);
    }
    ["Some"](op) {
        return _coreJs.exitSucceed(op.value);
    }
    ["Micro"](op) {
        return _coreJs.unsafeAsync((microResume)=>{
            let resume = microResume;
            const fiber = _microJs.runFork(_microJs.provideContext(op, this.currentContext));
            fiber.addObserver((exit)=>{
                if (exit._tag === "Success") return resume(_coreJs.exitSucceed(exit.value));
                switch(exit.cause._tag){
                    case "Interrupt":
                        return resume(_coreJs.exitFailCause(_causeJs.interrupt(_fiberIdJs.none)));
                    case "Fail":
                        return resume(_coreJs.fail(exit.cause.error));
                    case "Die":
                        return resume(_coreJs.die(exit.cause.defect));
                }
            });
            return _coreJs.unsafeAsync((abortResume)=>{
                resume = (_)=>{
                    abortResume(_coreJs.void);
                };
                fiber.unsafeInterrupt();
            });
        });
    }
    [_effectJs.OP_SYNC](op) {
        const value = (0, _utilsJs.internalCall)(()=>op.effect_instruction_i0());
        const cont = this.getNextSuccessCont();
        if (cont !== undefined) {
            if (!(cont._op in contOpSuccess)) // @ts-expect-error
            absurd(cont);
            // @ts-expect-error
            return contOpSuccess[cont._op](this, cont, value);
        } else {
            yieldedOpChannel.currentOp = _coreJs.exitSucceed(value);
            return YieldedOp;
        }
    }
    [_effectJs.OP_SUCCESS](op) {
        const oldCur = op;
        const cont = this.getNextSuccessCont();
        if (cont !== undefined) {
            if (!(cont._op in contOpSuccess)) // @ts-expect-error
            absurd(cont);
            // @ts-expect-error
            return contOpSuccess[cont._op](this, cont, oldCur.effect_instruction_i0);
        } else {
            yieldedOpChannel.currentOp = oldCur;
            return YieldedOp;
        }
    }
    [_effectJs.OP_FAILURE](op) {
        const cause = op.effect_instruction_i0;
        const cont = this.getNextFailCont();
        if (cont !== undefined) switch(cont._op){
            case _effectJs.OP_ON_FAILURE:
            case _effectJs.OP_ON_SUCCESS_AND_FAILURE:
                if (!(_runtimeFlagsJs.interruptible(this.currentRuntimeFlags) && this.isInterrupted())) return (0, _utilsJs.internalCall)(()=>cont.effect_instruction_i1(cause));
                else return _coreJs.exitFailCause(_causeJs.stripFailures(cause));
            case "OnStep":
                if (!(_runtimeFlagsJs.interruptible(this.currentRuntimeFlags) && this.isInterrupted())) return _coreJs.exitSucceed(_coreJs.exitFailCause(cause));
                else return _coreJs.exitFailCause(_causeJs.stripFailures(cause));
            case _effectJs.OP_REVERT_FLAGS:
                this.patchRuntimeFlags(this.currentRuntimeFlags, cont.patch);
                if (_runtimeFlagsJs.interruptible(this.currentRuntimeFlags) && this.isInterrupted()) return _coreJs.exitFailCause(_causeJs.sequential(cause, this.getInterruptedCause()));
                else return _coreJs.exitFailCause(cause);
            default:
                absurd(cont);
        }
        else {
            yieldedOpChannel.currentOp = _coreJs.exitFailCause(cause);
            return YieldedOp;
        }
    }
    [_effectJs.OP_WITH_RUNTIME](op) {
        return (0, _utilsJs.internalCall)(()=>op.effect_instruction_i0(this, _fiberStatusJs.running(this.currentRuntimeFlags)));
    }
    ["Blocked"](op) {
        const refs = this.getFiberRefs();
        const flags = this.currentRuntimeFlags;
        if (this._steps.length > 0) {
            const frames = [];
            const snap = this._steps[this._steps.length - 1];
            let frame = this.popStack();
            while(frame && frame._op !== "OnStep"){
                frames.push(frame);
                frame = this.popStack();
            }
            this.setFiberRefs(snap.refs);
            this.currentRuntimeFlags = snap.flags;
            const patchRefs = _fiberRefsPatchJs.diff(snap.refs, refs);
            const patchFlags = _runtimeFlagsJs.diff(snap.flags, flags);
            return _coreJs.exitSucceed(_coreJs.blocked(op.effect_instruction_i0, _coreJs.withFiberRuntime((newFiber)=>{
                while(frames.length > 0)newFiber.pushStack(frames.pop());
                newFiber.setFiberRefs(_fiberRefsPatchJs.patch(newFiber.id(), newFiber.getFiberRefs())(patchRefs));
                newFiber.currentRuntimeFlags = _runtimeFlagsJs.patch(patchFlags)(newFiber.currentRuntimeFlags);
                return op.effect_instruction_i1;
            })));
        }
        return _coreJs.uninterruptibleMask((restore)=>_coreJs.flatMap(forkDaemon(_coreJs.runRequestBlock(op.effect_instruction_i0)), ()=>restore(op.effect_instruction_i1)));
    }
    ["RunBlocked"](op) {
        return runBlockedRequests(op.effect_instruction_i0);
    }
    [_effectJs.OP_UPDATE_RUNTIME_FLAGS](op) {
        const updateFlags = op.effect_instruction_i0;
        const oldRuntimeFlags = this.currentRuntimeFlags;
        const newRuntimeFlags = _runtimeFlagsJs.patch(oldRuntimeFlags, updateFlags);
        // One more chance to short circuit: if we're immediately going
        // to interrupt. Interruption will cause immediate reversion of
        // the flag, so as long as we "peek ahead", there's no need to
        // set them to begin with.
        if (_runtimeFlagsJs.interruptible(newRuntimeFlags) && this.isInterrupted()) return _coreJs.exitFailCause(this.getInterruptedCause());
        else {
            // Impossible to short circuit, so record the changes
            this.patchRuntimeFlags(this.currentRuntimeFlags, updateFlags);
            if (op.effect_instruction_i1) {
                // Since we updated the flags, we need to revert them
                const revertFlags = _runtimeFlagsJs.diff(newRuntimeFlags, oldRuntimeFlags);
                this.pushStack(new _coreJs.RevertFlags(revertFlags, op));
                return (0, _utilsJs.internalCall)(()=>op.effect_instruction_i1(oldRuntimeFlags));
            } else return _coreJs.exitVoid;
        }
    }
    [_effectJs.OP_ON_SUCCESS](op) {
        this.pushStack(op);
        return op.effect_instruction_i0;
    }
    ["OnStep"](op) {
        this.pushStack(op);
        return op.effect_instruction_i0;
    }
    [_effectJs.OP_ON_FAILURE](op) {
        this.pushStack(op);
        return op.effect_instruction_i0;
    }
    [_effectJs.OP_ON_SUCCESS_AND_FAILURE](op) {
        this.pushStack(op);
        return op.effect_instruction_i0;
    }
    [_effectJs.OP_ASYNC](op) {
        this._asyncBlockingOn = op.effect_instruction_i1;
        this.initiateAsync(this.currentRuntimeFlags, op.effect_instruction_i0);
        yieldedOpChannel.currentOp = op;
        return YieldedOp;
    }
    [_effectJs.OP_YIELD](op) {
        this._isYielding = false;
        yieldedOpChannel.currentOp = op;
        return YieldedOp;
    }
    [_effectJs.OP_WHILE](op) {
        const check = op.effect_instruction_i0;
        const body = op.effect_instruction_i1;
        if (check()) {
            this.pushStack(op);
            return body();
        } else return _coreJs.exitVoid;
    }
    [_effectJs.OP_ITERATOR](op) {
        return contOpSuccess[_effectJs.OP_ITERATOR](this, op, undefined);
    }
    [_effectJs.OP_COMMIT](op) {
        return (0, _utilsJs.internalCall)(()=>op.commit());
    }
    /**
   * The main run-loop for evaluating effects.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */ runLoop(effect0) {
        let cur = effect0;
        this.currentOpCount = 0;
        while(true){
            if ((this.currentRuntimeFlags & (0, _runtimeFlagsJs.OpSupervision)) !== 0) this.currentSupervisor.onEffect(this, cur);
            if (this._queue.length > 0) cur = this.drainQueueWhileRunning(this.currentRuntimeFlags, cur);
            if (!this._isYielding) {
                this.currentOpCount += 1;
                const shouldYield = this.currentScheduler.shouldYield(this);
                if (shouldYield !== false) {
                    this._isYielding = true;
                    this.currentOpCount = 0;
                    const oldCur = cur;
                    cur = _coreJs.flatMap(_coreJs.yieldNow({
                        priority: shouldYield
                    }), ()=>oldCur);
                }
            }
            try {
                // @ts-expect-error
                cur = this.currentTracer.context(()=>{
                    if (_version !== cur[_coreJs.EffectTypeId]._V) return _coreJs.dieMessage(`Cannot execute an Effect versioned ${cur[_coreJs.EffectTypeId]._V} with a Runtime of version ${_versionJs.getCurrentVersion()}`);
                    // @ts-expect-error
                    return this[cur._op](cur);
                }, this);
                if (cur === YieldedOp) {
                    const op = yieldedOpChannel.currentOp;
                    if (op._op === _effectJs.OP_YIELD || op._op === _effectJs.OP_ASYNC) return YieldedOp;
                    yieldedOpChannel.currentOp = null;
                    return op._op === _effectJs.OP_SUCCESS || op._op === _effectJs.OP_FAILURE ? op : _coreJs.exitFailCause(_causeJs.die(op));
                }
            } catch (e) {
                if (cur !== YieldedOp && !_predicateJs.hasProperty(cur, "_op") || !(cur._op in this)) cur = _coreJs.dieMessage(`Not a valid effect: ${_inspectableJs.toStringUnknown(cur)}`);
                else if (_coreJs.isInterruptedException(e)) cur = _coreJs.exitFailCause(_causeJs.sequential(_causeJs.die(e), _causeJs.interrupt(_fiberIdJs.none)));
                else cur = _coreJs.die(e);
            }
        }
    }
    run = ()=>{
        this.drainQueueOnCurrentThread();
    };
}
const currentMinimumLogLevel = /*#__PURE__*/ (0, _globalValueJs.globalValue)("effect/FiberRef/currentMinimumLogLevel", ()=>_coreJs.fiberRefUnsafeMake(_logLevelJs.fromLiteral("Info")));
const loggerWithConsoleLog = (self)=>_loggerJs.makeLogger((opts)=>{
        const services = _fiberRefsJs.getOrDefault(opts.context, _defaultServicesJs.currentServices);
        _contextJs.get(services, (0, _consoleJs.consoleTag)).unsafe.log(self.log(opts));
    });
const loggerWithLeveledLog = (self)=>_loggerJs.makeLogger((opts)=>{
        const services = _fiberRefsJs.getOrDefault(opts.context, _defaultServicesJs.currentServices);
        const unsafeLogger = _contextJs.get(services, (0, _consoleJs.consoleTag)).unsafe;
        switch(opts.logLevel._tag){
            case "Debug":
                return unsafeLogger.debug(self.log(opts));
            case "Info":
                return unsafeLogger.info(self.log(opts));
            case "Trace":
                return unsafeLogger.trace(self.log(opts));
            case "Warning":
                return unsafeLogger.warn(self.log(opts));
            case "Error":
            case "Fatal":
                return unsafeLogger.error(self.log(opts));
            default:
                return unsafeLogger.log(self.log(opts));
        }
    });
const loggerWithConsoleError = (self)=>_loggerJs.makeLogger((opts)=>{
        const services = _fiberRefsJs.getOrDefault(opts.context, _defaultServicesJs.currentServices);
        _contextJs.get(services, (0, _consoleJs.consoleTag)).unsafe.error(self.log(opts));
    });
const defaultLogger = /*#__PURE__*/ (0, _globalValueJs.globalValue)(/*#__PURE__*/ Symbol.for("effect/Logger/defaultLogger"), ()=>loggerWithConsoleLog(_loggerJs.stringLogger));
const jsonLogger = /*#__PURE__*/ (0, _globalValueJs.globalValue)(/*#__PURE__*/ Symbol.for("effect/Logger/jsonLogger"), ()=>loggerWithConsoleLog(_loggerJs.jsonLogger));
const logFmtLogger = /*#__PURE__*/ (0, _globalValueJs.globalValue)(/*#__PURE__*/ Symbol.for("effect/Logger/logFmtLogger"), ()=>loggerWithConsoleLog(_loggerJs.logfmtLogger));
const prettyLogger = /*#__PURE__*/ (0, _globalValueJs.globalValue)(/*#__PURE__*/ Symbol.for("effect/Logger/prettyLogger"), ()=>_loggerJs.prettyLoggerDefault);
const structuredLogger = /*#__PURE__*/ (0, _globalValueJs.globalValue)(/*#__PURE__*/ Symbol.for("effect/Logger/structuredLogger"), ()=>loggerWithConsoleLog(_loggerJs.structuredLogger));
const tracerLogger = /*#__PURE__*/ (0, _globalValueJs.globalValue)(/*#__PURE__*/ Symbol.for("effect/Logger/tracerLogger"), ()=>_loggerJs.makeLogger(({ annotations, cause, context, fiberId, logLevel, message })=>{
        const span = _contextJs.getOption(_fiberRefsJs1.getOrDefault(context, _coreJs.currentContext), _tracerJs.spanTag);
        if (span._tag === "None" || span.value._tag === "ExternalSpan") return;
        const clockService = _contextJs.unsafeGet(_fiberRefsJs1.getOrDefault(context, _defaultServicesJs.currentServices), _clockJs.clockTag);
        const attributes = {};
        for (const [key, value] of annotations)attributes[key] = value;
        attributes["effect.fiberId"] = _fiberIdJs.threadName(fiberId);
        attributes["effect.logLevel"] = logLevel.label;
        if (cause !== null && cause._tag !== "Empty") attributes["effect.cause"] = _causeJs.pretty(cause, {
            renderErrorCause: true
        });
        span.value.event(_inspectableJs.toStringUnknown(Array.isArray(message) ? message[0] : message), clockService.unsafeCurrentTimeNanos(), attributes);
    }));
const loggerWithSpanAnnotations = (self)=>_loggerJs.mapInputOptions(self, (options)=>{
        const span = _optionJs.flatMap(_fiberRefsJs1.get(options.context, _coreJs.currentContext), _contextJs.getOption(_tracerJs.spanTag));
        if (span._tag === "None") return options;
        return {
            ...options,
            annotations: (0, _functionJs.pipe)(options.annotations, _hashMapJs.set("effect.traceId", span.value.traceId), _hashMapJs.set("effect.spanId", span.value.spanId), span.value._tag === "Span" ? _hashMapJs.set("effect.spanName", span.value.name) : (0, _functionJs.identity))
        };
    });
const currentLoggers = /*#__PURE__*/ (0, _globalValueJs.globalValue)(/*#__PURE__*/ Symbol.for("effect/FiberRef/currentLoggers"), ()=>_coreJs.fiberRefUnsafeMakeHashSet(_hashSetJs.make(defaultLogger, tracerLogger)));
const batchedLogger = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, window, f)=>_coreJs.flatMap(scope, (scope)=>{
        let buffer = [];
        const flush = _coreJs.suspend(()=>{
            if (buffer.length === 0) return _coreJs.void;
            const arr = buffer;
            buffer = [];
            return f(arr);
        });
        return _coreJs.uninterruptibleMask((restore)=>(0, _functionJs.pipe)(_coreEffectJs.sleep(window), _coreJs.zipRight(flush), _coreEffectJs.forever, restore, forkDaemon, _coreJs.flatMap((fiber)=>_coreJs.scopeAddFinalizer(scope, _coreJs.interruptFiber(fiber))), _coreJs.zipRight(addFinalizer(()=>flush)), _coreJs.as(_loggerJs.makeLogger((options)=>{
                buffer.push(self.log(options));
            }))));
    }));
const annotateLogsScoped = function() {
    if (typeof arguments[0] === "string") return fiberRefLocallyScopedWith(_coreJs.currentLogAnnotations, _hashMapJs.set(arguments[0], arguments[1]));
    const entries = Object.entries(arguments[0]);
    return fiberRefLocallyScopedWith(_coreJs.currentLogAnnotations, _hashMapJs.mutate((annotations)=>{
        for(let i = 0; i < entries.length; i++){
            const [key, value] = entries[i];
            _hashMapJs.set(annotations, key, value);
        }
        return annotations;
    }));
};
const whenLogLevel = /*#__PURE__*/ (0, _functionJs.dual)(2, (effect, level)=>{
    const requiredLogLevel = typeof level === "string" ? _logLevelJs.fromLiteral(level) : level;
    return _coreJs.withFiberRuntime((fiberState)=>{
        const minimumLogLevel = fiberState.getFiberRef(currentMinimumLogLevel);
        // Imitate the behaviour of `FiberRuntime.log`
        if (_logLevelJs.greaterThan(minimumLogLevel, requiredLogLevel)) return _coreJs.succeed(_optionJs.none());
        return _coreJs.map(effect, _optionJs.some);
    });
});
const acquireRelease = /*#__PURE__*/ (0, _functionJs.dual)((args)=>_coreJs.isEffect(args[0]), (acquire, release)=>_coreJs.uninterruptible(_coreJs.tap(acquire, (a)=>addFinalizer((exit)=>release(a, exit)))));
const acquireReleaseInterruptible = /*#__PURE__*/ (0, _functionJs.dual)((args)=>_coreJs.isEffect(args[0]), (acquire, release)=>ensuring(acquire, addFinalizer((exit)=>release(exit))));
const addFinalizer = (finalizer)=>_coreJs.withFiberRuntime((runtime)=>{
        const acquireRefs = runtime.getFiberRefs();
        const acquireFlags = runtime.currentRuntimeFlags;
        return _coreJs.flatMap(scope, (scope)=>_coreJs.scopeAddFinalizerExit(scope, (exit)=>_coreJs.withFiberRuntime((runtimeFinalizer)=>{
                    const preRefs = runtimeFinalizer.getFiberRefs();
                    const preFlags = runtimeFinalizer.currentRuntimeFlags;
                    const patchRefs = _fiberRefsPatchJs.diff(preRefs, acquireRefs);
                    const patchFlags = _runtimeFlagsJs.diff(preFlags, acquireFlags);
                    const inverseRefs = _fiberRefsPatchJs.diff(acquireRefs, preRefs);
                    runtimeFinalizer.setFiberRefs(_fiberRefsPatchJs.patch(patchRefs, runtimeFinalizer.id(), acquireRefs));
                    return ensuring(_coreJs.withRuntimeFlags(finalizer(exit), patchFlags), _coreJs.sync(()=>{
                        runtimeFinalizer.setFiberRefs(_fiberRefsPatchJs.patch(inverseRefs, runtimeFinalizer.id(), runtimeFinalizer.getFiberRefs()));
                    }));
                })));
    });
const daemonChildren = (self)=>{
    const forkScope = _coreJs.fiberRefLocally(_coreJs.currentForkScopeOverride, _optionJs.some(_fiberScopeJs.globalScope));
    return forkScope(self);
};
/** @internal */ const _existsParFound = /*#__PURE__*/ Symbol.for("effect/Effect/existsPar/found");
const exists = /*#__PURE__*/ (0, _functionJs.dual)((args)=>_predicateJs.isIterable(args[0]) && !_coreJs.isEffect(args[0]), (elements, predicate, options)=>_concurrencyJs.matchSimple(options?.concurrency, ()=>_coreJs.suspend(()=>existsLoop(elements[Symbol.iterator](), 0, predicate)), ()=>_coreJs.matchEffect(forEach(elements, (a, i)=>_coreJs.if_(predicate(a, i), {
                onTrue: ()=>_coreJs.fail(_existsParFound),
                onFalse: ()=>_coreJs.void
            }), options), {
            onFailure: (e)=>e === _existsParFound ? _coreJs.succeed(true) : _coreJs.fail(e),
            onSuccess: ()=>_coreJs.succeed(false)
        })));
const existsLoop = (iterator, index, f)=>{
    const next = iterator.next();
    if (next.done) return _coreJs.succeed(false);
    return (0, _functionJs.pipe)(_coreJs.flatMap(f(next.value, index), (b)=>b ? _coreJs.succeed(b) : existsLoop(iterator, index + 1, f)));
};
const filter = /*#__PURE__*/ (0, _functionJs.dual)((args)=>_predicateJs.isIterable(args[0]) && !_coreJs.isEffect(args[0]), (elements, predicate, options)=>{
    const predicate_ = options?.negate ? (a, i)=>_coreJs.map(predicate(a, i), _booleanJs.not) : predicate;
    return _concurrencyJs.matchSimple(options?.concurrency, ()=>_coreJs.suspend(()=>_arrayJs.fromIterable(elements).reduceRight((effect, a, i)=>_coreJs.zipWith(effect, _coreJs.suspend(()=>predicate_(a, i)), (list, b)=>b ? [
                        a,
                        ...list
                    ] : list), _coreJs.sync(()=>new Array()))), ()=>_coreJs.map(forEach(elements, (a, i)=>_coreJs.map(predicate_(a, i), (b)=>b ? _optionJs.some(a) : _optionJs.none()), options), _arrayJs.getSomes));
});
// === all
const allResolveInput = (input)=>{
    if (Array.isArray(input) || _predicateJs.isIterable(input)) return [
        input,
        _optionJs.none()
    ];
    const keys = Object.keys(input);
    const size = keys.length;
    return [
        keys.map((k)=>input[k]),
        _optionJs.some((values)=>{
            const res = {};
            for(let i = 0; i < size; i++)res[keys[i]] = values[i];
            return res;
        })
    ];
};
const allValidate = (effects, reconcile, options)=>{
    const eitherEffects = [];
    for (const effect of effects)eitherEffects.push(_coreJs.either(effect));
    return _coreJs.flatMap(forEach(eitherEffects, (0, _functionJs.identity), {
        concurrency: options?.concurrency,
        batching: options?.batching,
        concurrentFinalizers: options?.concurrentFinalizers
    }), (eithers)=>{
        const none = _optionJs.none();
        const size = eithers.length;
        const errors = new Array(size);
        const successes = new Array(size);
        let errored = false;
        for(let i = 0; i < size; i++){
            const either = eithers[i];
            if (either._tag === "Left") {
                errors[i] = _optionJs.some(either.left);
                errored = true;
            } else {
                successes[i] = either.right;
                errors[i] = none;
            }
        }
        if (errored) return reconcile._tag === "Some" ? _coreJs.fail(reconcile.value(errors)) : _coreJs.fail(errors);
        else if (options?.discard) return _coreJs.void;
        return reconcile._tag === "Some" ? _coreJs.succeed(reconcile.value(successes)) : _coreJs.succeed(successes);
    });
};
const allEither = (effects, reconcile, options)=>{
    const eitherEffects = [];
    for (const effect of effects)eitherEffects.push(_coreJs.either(effect));
    if (options?.discard) return forEach(eitherEffects, (0, _functionJs.identity), {
        concurrency: options?.concurrency,
        batching: options?.batching,
        discard: true,
        concurrentFinalizers: options?.concurrentFinalizers
    });
    return _coreJs.map(forEach(eitherEffects, (0, _functionJs.identity), {
        concurrency: options?.concurrency,
        batching: options?.batching,
        concurrentFinalizers: options?.concurrentFinalizers
    }), (eithers)=>reconcile._tag === "Some" ? reconcile.value(eithers) : eithers);
};
const all = (arg, options)=>{
    const [effects, reconcile] = allResolveInput(arg);
    if (options?.mode === "validate") return allValidate(effects, reconcile, options);
    else if (options?.mode === "either") return allEither(effects, reconcile, options);
    return options?.discard !== true && reconcile._tag === "Some" ? _coreJs.map(forEach(effects, (0, _functionJs.identity), options), reconcile.value) : forEach(effects, (0, _functionJs.identity), options);
};
const allWith = (options)=>(arg)=>all(arg, options);
const allSuccesses = (elements, options)=>_coreJs.map(all(_arrayJs.fromIterable(elements).map(_coreJs.exit), options), _arrayJs.filterMap((exit)=>_coreJs.exitIsSuccess(exit) ? _optionJs.some(exit.effect_instruction_i0) : _optionJs.none()));
const replicate = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, n)=>Array.from({
        length: n
    }, ()=>self));
const replicateEffect = /*#__PURE__*/ (0, _functionJs.dual)((args)=>_coreJs.isEffect(args[0]), (self, n, options)=>all(replicate(self, n), options));
const forEach = /*#__PURE__*/ (0, _functionJs.dual)((args)=>_predicateJs.isIterable(args[0]), (self, f, options)=>_coreJs.withFiberRuntime((r)=>{
        const isRequestBatchingEnabled = options?.batching === true || options?.batching === "inherit" && r.getFiberRef(_coreJs.currentRequestBatching);
        if (options?.discard) return _concurrencyJs.match(options.concurrency, ()=>finalizersMaskInternal(_executionStrategyJs.sequential, options?.concurrentFinalizers)((restore)=>isRequestBatchingEnabled ? forEachConcurrentDiscard(self, (a, i)=>restore(f(a, i)), true, false, 1) : _coreJs.forEachSequentialDiscard(self, (a, i)=>restore(f(a, i)))), ()=>finalizersMaskInternal(_executionStrategyJs.parallel, options?.concurrentFinalizers)((restore)=>forEachConcurrentDiscard(self, (a, i)=>restore(f(a, i)), isRequestBatchingEnabled, false)), (n)=>finalizersMaskInternal(_executionStrategyJs.parallelN(n), options?.concurrentFinalizers)((restore)=>forEachConcurrentDiscard(self, (a, i)=>restore(f(a, i)), isRequestBatchingEnabled, false, n)));
        return _concurrencyJs.match(options?.concurrency, ()=>finalizersMaskInternal(_executionStrategyJs.sequential, options?.concurrentFinalizers)((restore)=>isRequestBatchingEnabled ? forEachParN(self, 1, (a, i)=>restore(f(a, i)), true) : _coreJs.forEachSequential(self, (a, i)=>restore(f(a, i)))), ()=>finalizersMaskInternal(_executionStrategyJs.parallel, options?.concurrentFinalizers)((restore)=>forEachParUnbounded(self, (a, i)=>restore(f(a, i)), isRequestBatchingEnabled)), (n)=>finalizersMaskInternal(_executionStrategyJs.parallelN(n), options?.concurrentFinalizers)((restore)=>forEachParN(self, n, (a, i)=>restore(f(a, i)), isRequestBatchingEnabled)));
    }));
const forEachParUnbounded = (self, f, batching)=>_coreJs.suspend(()=>{
        const as = _arrayJs.fromIterable(self);
        const array = new Array(as.length);
        const fn = (a, i)=>_coreJs.flatMap(f(a, i), (b)=>_coreJs.sync(()=>array[i] = b));
        return _coreJs.zipRight(forEachConcurrentDiscard(as, fn, batching, false), _coreJs.succeed(array));
    });
const forEachConcurrentDiscard = (self, f, batching, processAll, n)=>_coreJs.uninterruptibleMask((restore)=>_coreJs.transplant((graft)=>_coreJs.withFiberRuntime((parent)=>{
                let todos = Array.from(self).reverse();
                let target = todos.length;
                if (target === 0) return _coreJs.void;
                let counter = 0;
                let interrupted = false;
                const fibersCount = n ? Math.min(todos.length, n) : todos.length;
                const fibers = new Set();
                const results = new Array();
                const interruptAll = ()=>fibers.forEach((fiber)=>{
                        fiber.currentScheduler.scheduleTask(()=>{
                            fiber.unsafeInterruptAsFork(parent.id());
                        }, 0);
                    });
                const startOrder = new Array();
                const joinOrder = new Array();
                const residual = new Array();
                const collectExits = ()=>{
                    const exits = results.filter(({ exit })=>exit._tag === "Failure").sort((a, b)=>a.index < b.index ? -1 : a.index === b.index ? 0 : 1).map(({ exit })=>exit);
                    if (exits.length === 0) exits.push(_coreJs.exitVoid);
                    return exits;
                };
                const runFiber = (eff, interruptImmediately = false)=>{
                    const runnable = _coreJs.uninterruptible(graft(eff));
                    const fiber = unsafeForkUnstarted(runnable, parent, parent.currentRuntimeFlags, _fiberScopeJs.globalScope);
                    parent.currentScheduler.scheduleTask(()=>{
                        if (interruptImmediately) fiber.unsafeInterruptAsFork(parent.id());
                        fiber.resume(runnable);
                    }, 0);
                    return fiber;
                };
                const onInterruptSignal = ()=>{
                    if (!processAll) {
                        target -= todos.length;
                        todos = [];
                    }
                    interrupted = true;
                    interruptAll();
                };
                const stepOrExit = batching ? _coreJs.step : _coreJs.exit;
                const processingFiber = runFiber(_coreJs.async((resume)=>{
                    const pushResult = (res, index)=>{
                        if (res._op === "Blocked") residual.push(res);
                        else {
                            results.push({
                                index,
                                exit: res
                            });
                            if (res._op === "Failure" && !interrupted) onInterruptSignal();
                        }
                    };
                    const next = ()=>{
                        if (todos.length > 0) {
                            const a = todos.pop();
                            let index = counter++;
                            const returnNextElement = ()=>{
                                const a = todos.pop();
                                index = counter++;
                                return _coreJs.flatMap(_coreJs.yieldNow(), ()=>_coreJs.flatMap(stepOrExit(restore(f(a, index))), onRes));
                            };
                            const onRes = (res)=>{
                                if (todos.length > 0) {
                                    pushResult(res, index);
                                    if (todos.length > 0) return returnNextElement();
                                }
                                return _coreJs.succeed(res);
                            };
                            const todo = _coreJs.flatMap(stepOrExit(restore(f(a, index))), onRes);
                            const fiber = runFiber(todo);
                            startOrder.push(fiber);
                            fibers.add(fiber);
                            if (interrupted) fiber.currentScheduler.scheduleTask(()=>{
                                fiber.unsafeInterruptAsFork(parent.id());
                            }, 0);
                            fiber.addObserver((wrapped)=>{
                                let exit;
                                if (wrapped._op === "Failure") exit = wrapped;
                                else exit = wrapped.effect_instruction_i0;
                                joinOrder.push(fiber);
                                fibers.delete(fiber);
                                pushResult(exit, index);
                                if (results.length === target) resume(_coreJs.succeed(_optionJs.getOrElse(_coreJs.exitCollectAll(collectExits(), {
                                    parallel: true
                                }), ()=>_coreJs.exitVoid)));
                                else if (residual.length + results.length === target) {
                                    const exits = collectExits();
                                    const requests = residual.map((blocked)=>blocked.effect_instruction_i0).reduce(_blockedRequestsJs.par);
                                    resume(_coreJs.succeed(_coreJs.blocked(requests, forEachConcurrentDiscard([
                                        _optionJs.getOrElse(_coreJs.exitCollectAll(exits, {
                                            parallel: true
                                        }), ()=>_coreJs.exitVoid),
                                        ...residual.map((blocked)=>blocked.effect_instruction_i1)
                                    ], (i)=>i, batching, true, n))));
                                } else next();
                            });
                        }
                    };
                    for(let i = 0; i < fibersCount; i++)next();
                }));
                return _coreJs.asVoid(_coreJs.onExit(_coreJs.flatten(restore(_fiberJs.join(processingFiber))), _coreJs.exitMatch({
                    onFailure: (cause)=>{
                        onInterruptSignal();
                        const target = residual.length + 1;
                        const concurrency = Math.min(typeof n === "number" ? n : residual.length, residual.length);
                        const toPop = Array.from(residual);
                        return _coreJs.async((cb)=>{
                            const exits = [];
                            let count = 0;
                            let index = 0;
                            const check = (index, hitNext)=>(exit)=>{
                                    exits[index] = exit;
                                    count++;
                                    if (count === target) cb(_coreJs.exitSucceed(_coreJs.exitFailCause(cause)));
                                    if (toPop.length > 0 && hitNext) next();
                                };
                            const next = ()=>{
                                runFiber(toPop.pop(), true).addObserver(check(index, true));
                                index++;
                            };
                            processingFiber.addObserver(check(index, false));
                            index++;
                            for(let i = 0; i < concurrency; i++)next();
                        });
                    },
                    onSuccess: ()=>_coreJs.forEachSequential(joinOrder, (f)=>f.inheritAll)
                })));
            })));
const forEachParN = (self, n, f, batching)=>_coreJs.suspend(()=>{
        const as = _arrayJs.fromIterable(self);
        const array = new Array(as.length);
        const fn = (a, i)=>_coreJs.map(f(a, i), (b)=>array[i] = b);
        return _coreJs.zipRight(forEachConcurrentDiscard(as, fn, batching, false, n), _coreJs.succeed(array));
    });
const fork = (self)=>_coreJs.withFiberRuntime((state, status)=>_coreJs.succeed(unsafeFork(self, state, status.runtimeFlags)));
const forkDaemon = (self)=>forkWithScopeOverride(self, _fiberScopeJs.globalScope);
const forkWithErrorHandler = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, handler)=>fork(_coreJs.onError(self, (cause)=>{
        const either = _causeJs.failureOrCause(cause);
        switch(either._tag){
            case "Left":
                return handler(either.left);
            case "Right":
                return _coreJs.failCause(either.right);
        }
    })));
const unsafeFork = (effect, parentFiber, parentRuntimeFlags, overrideScope = null)=>{
    const childFiber = unsafeMakeChildFiber(effect, parentFiber, parentRuntimeFlags, overrideScope);
    childFiber.resume(effect);
    return childFiber;
};
const unsafeForkUnstarted = (effect, parentFiber, parentRuntimeFlags, overrideScope = null)=>{
    const childFiber = unsafeMakeChildFiber(effect, parentFiber, parentRuntimeFlags, overrideScope);
    return childFiber;
};
const unsafeMakeChildFiber = (effect, parentFiber, parentRuntimeFlags, overrideScope = null)=>{
    const childId = _fiberIdJs.unsafeMake();
    const parentFiberRefs = parentFiber.getFiberRefs();
    const childFiberRefs = _fiberRefsJs1.forkAs(parentFiberRefs, childId);
    const childFiber = new FiberRuntime(childId, childFiberRefs, parentRuntimeFlags);
    const childContext = _fiberRefsJs1.getOrDefault(childFiberRefs, _coreJs.currentContext);
    const supervisor = childFiber.currentSupervisor;
    supervisor.onStart(childContext, effect, _optionJs.some(parentFiber), childFiber);
    childFiber.addObserver((exit)=>supervisor.onEnd(exit, childFiber));
    const parentScope = overrideScope !== null ? overrideScope : (0, _functionJs.pipe)(parentFiber.getFiberRef(_coreJs.currentForkScopeOverride), _optionJs.getOrElse(()=>parentFiber.scope()));
    parentScope.add(parentRuntimeFlags, childFiber);
    return childFiber;
};
/* @internal */ const forkWithScopeOverride = (self, scopeOverride)=>_coreJs.withFiberRuntime((parentFiber, parentStatus)=>_coreJs.succeed(unsafeFork(self, parentFiber, parentStatus.runtimeFlags, scopeOverride)));
const mergeAll = /*#__PURE__*/ (0, _functionJs.dual)((args)=>_predicateJs.isFunction(args[2]), (elements, zero, f, options)=>_concurrencyJs.matchSimple(options?.concurrency, ()=>_arrayJs.fromIterable(elements).reduce((acc, a, i)=>_coreJs.zipWith(acc, a, (acc, a)=>f(acc, a, i)), _coreJs.succeed(zero)), ()=>_coreJs.flatMap(_refJs.make(zero), (acc)=>_coreJs.flatMap(forEach(elements, (effect, i)=>_coreJs.flatMap(effect, (a)=>_refJs.update(acc, (b)=>f(b, a, i))), options), ()=>_refJs.get(acc)))));
const partition = /*#__PURE__*/ (0, _functionJs.dual)((args)=>_predicateJs.isIterable(args[0]), (elements, f, options)=>(0, _functionJs.pipe)(forEach(elements, (a, i)=>_coreJs.either(f(a, i)), options), _coreJs.map((chunk)=>_coreJs.partitionMap(chunk, (0, _functionJs.identity)))));
const validateAll = /*#__PURE__*/ (0, _functionJs.dual)((args)=>_predicateJs.isIterable(args[0]), (elements, f, options)=>_coreJs.flatMap(partition(elements, f, {
        concurrency: options?.concurrency,
        batching: options?.batching,
        concurrentFinalizers: options?.concurrentFinalizers
    }), ([es, bs])=>_arrayJs.isNonEmptyArray(es) ? _coreJs.fail(es) : options?.discard ? _coreJs.void : _coreJs.succeed(bs)));
const raceAll = (all)=>{
    const list = _chunkJs.fromIterable(all);
    if (!_chunkJs.isNonEmpty(list)) return _coreJs.dieSync(()=>new _coreJs.IllegalArgumentException(`Received an empty collection of effects`));
    const self = _chunkJs.headNonEmpty(list);
    const effects = _chunkJs.tailNonEmpty(list);
    const inheritAll = (res)=>(0, _functionJs.pipe)(_fiberJs.inheritAll(res[1]), _coreJs.as(res[0]));
    return (0, _functionJs.pipe)(_coreJs.deferredMake(), _coreJs.flatMap((done)=>(0, _functionJs.pipe)(_refJs.make(effects.length), _coreJs.flatMap((fails)=>_coreJs.uninterruptibleMask((restore)=>(0, _functionJs.pipe)(fork(_coreJs.interruptible(self)), _coreJs.flatMap((head)=>(0, _functionJs.pipe)(effects, _coreJs.forEachSequential((effect)=>fork(_coreJs.interruptible(effect))), _coreJs.map((fibers)=>_chunkJs.unsafeFromArray(fibers)), _coreJs.map((tail)=>(0, _functionJs.pipe)(tail, _chunkJs.prepend(head))), _coreJs.tap((fibers)=>(0, _functionJs.pipe)(fibers, _arrayJs.reduce(_coreJs.void, (effect, fiber)=>(0, _functionJs.pipe)(effect, _coreJs.zipRight((0, _functionJs.pipe)(_fiberJs._await(fiber), _coreJs.flatMap(raceAllArbiter(fibers, fiber, done, fails)), fork, _coreJs.asVoid)))))), _coreJs.flatMap((fibers)=>(0, _functionJs.pipe)(restore((0, _functionJs.pipe)(_deferredJs.await(done), _coreJs.flatMap(inheritAll))), _coreJs.onInterrupt(()=>(0, _functionJs.pipe)(fibers, _arrayJs.reduce(_coreJs.void, (effect, fiber)=>(0, _functionJs.pipe)(effect, _coreJs.zipLeft(_coreJs.interruptFiber(fiber))))))))))))))));
};
const raceAllArbiter = (fibers, winner, deferred, fails)=>(exit)=>_coreJs.exitMatchEffect(exit, {
            onFailure: (cause)=>(0, _functionJs.pipe)(_refJs.modify(fails, (fails)=>[
                        fails === 0 ? (0, _functionJs.pipe)(_coreJs.deferredFailCause(deferred, cause), _coreJs.asVoid) : _coreJs.void,
                        fails - 1
                    ]), _coreJs.flatten),
            onSuccess: (value)=>(0, _functionJs.pipe)(_coreJs.deferredSucceed(deferred, [
                    value,
                    winner
                ]), _coreJs.flatMap((set)=>set ? (0, _functionJs.pipe)(_chunkJs.fromIterable(fibers), _arrayJs.reduce(_coreJs.void, (effect, fiber)=>fiber === winner ? effect : (0, _functionJs.pipe)(effect, _coreJs.zipLeft(_coreJs.interruptFiber(fiber))))) : _coreJs.void))
        });
const reduceEffect = /*#__PURE__*/ (0, _functionJs.dual)((args)=>_predicateJs.isIterable(args[0]) && !_coreJs.isEffect(args[0]), (elements, zero, f, options)=>_concurrencyJs.matchSimple(options?.concurrency, ()=>_arrayJs.fromIterable(elements).reduce((acc, a, i)=>_coreJs.zipWith(acc, a, (acc, a)=>f(acc, a, i)), zero), ()=>_coreJs.suspend(()=>(0, _functionJs.pipe)(mergeAll([
                zero,
                ...elements
            ], _optionJs.none(), (acc, elem, i)=>{
                switch(acc._tag){
                    case "None":
                        return _optionJs.some(elem);
                    case "Some":
                        return _optionJs.some(f(acc.value, elem, i));
                }
            }, options), _coreJs.map((option)=>{
                switch(option._tag){
                    case "None":
                        throw new Error("BUG: Effect.reduceEffect - please report an issue at https://github.com/Effect-TS/effect/issues");
                    case "Some":
                        return option.value;
                }
            })))));
const parallelFinalizers = (self)=>_coreJs.contextWithEffect((context)=>_optionJs.match(_contextJs.getOption(context, scopeTag), {
            onNone: ()=>self,
            onSome: (scope)=>{
                switch(scope.strategy._tag){
                    case "Parallel":
                        return self;
                    case "Sequential":
                    case "ParallelN":
                        return _coreJs.flatMap(_coreJs.scopeFork(scope, _executionStrategyJs.parallel), (inner)=>scopeExtend(self, inner));
                }
            }
        }));
const parallelNFinalizers = (parallelism)=>(self)=>_coreJs.contextWithEffect((context)=>_optionJs.match(_contextJs.getOption(context, scopeTag), {
                onNone: ()=>self,
                onSome: (scope)=>{
                    if (scope.strategy._tag === "ParallelN" && scope.strategy.parallelism === parallelism) return self;
                    return _coreJs.flatMap(_coreJs.scopeFork(scope, _executionStrategyJs.parallelN(parallelism)), (inner)=>scopeExtend(self, inner));
                }
            }));
const finalizersMask = (strategy)=>(self)=>finalizersMaskInternal(strategy, true)(self);
const finalizersMaskInternal = (strategy, concurrentFinalizers)=>(self)=>_coreJs.contextWithEffect((context)=>_optionJs.match(_contextJs.getOption(context, scopeTag), {
                onNone: ()=>self((0, _functionJs.identity)),
                onSome: (scope)=>{
                    if (concurrentFinalizers === true) {
                        const patch = strategy._tag === "Parallel" ? parallelFinalizers : strategy._tag === "Sequential" ? sequentialFinalizers : parallelNFinalizers(strategy.parallelism);
                        switch(scope.strategy._tag){
                            case "Parallel":
                                return patch(self(parallelFinalizers));
                            case "Sequential":
                                return patch(self(sequentialFinalizers));
                            case "ParallelN":
                                return patch(self(parallelNFinalizers(scope.strategy.parallelism)));
                        }
                    } else return self((0, _functionJs.identity));
                }
            }));
const scopeWith = (f)=>_coreJs.flatMap(scopeTag, f);
const scopedWith = (f)=>_coreJs.flatMap(scopeMake(), (scope)=>_coreJs.onExit(f(scope), (exit)=>scope.close(exit)));
const scopedEffect = (effect)=>_coreJs.flatMap(scopeMake(), (scope)=>scopeUse(effect, scope));
const sequentialFinalizers = (self)=>_coreJs.contextWithEffect((context)=>_optionJs.match(_contextJs.getOption(context, scopeTag), {
            onNone: ()=>self,
            onSome: (scope)=>{
                switch(scope.strategy._tag){
                    case "Sequential":
                        return self;
                    case "Parallel":
                    case "ParallelN":
                        return _coreJs.flatMap(_coreJs.scopeFork(scope, _executionStrategyJs.sequential), (inner)=>scopeExtend(self, inner));
                }
            }
        }));
const tagMetricsScoped = (key, value)=>labelMetricsScoped([
        _labelJs.make(key, value)
    ]);
const labelMetricsScoped = (labels)=>fiberRefLocallyScopedWith(_coreJs.currentMetricLabels, (old)=>_arrayJs.union(old, labels));
const using = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, use)=>scopedWith((scope)=>_coreJs.flatMap(scopeExtend(self, scope), use)));
const validate = /*#__PURE__*/ (0, _functionJs.dual)((args)=>_coreJs.isEffect(args[1]), (self, that, options)=>validateWith(self, that, (a, b)=>[
            a,
            b
        ], options));
const validateWith = /*#__PURE__*/ (0, _functionJs.dual)((args)=>_coreJs.isEffect(args[1]), (self, that, f, options)=>_coreJs.flatten(zipWithOptions(_coreJs.exit(self), _coreJs.exit(that), (ea, eb)=>_coreJs.exitZipWith(ea, eb, {
            onSuccess: f,
            onFailure: (ca, cb)=>options?.concurrent ? _causeJs.parallel(ca, cb) : _causeJs.sequential(ca, cb)
        }), options)));
const validateAllPar = /*#__PURE__*/ (0, _functionJs.dual)(2, (elements, f)=>_coreJs.flatMap(partition(elements, f), ([es, bs])=>es.length === 0 ? _coreJs.succeed(bs) : _coreJs.fail(es)));
const validateAllParDiscard = /*#__PURE__*/ (0, _functionJs.dual)(2, (elements, f)=>_coreJs.flatMap(partition(elements, f), ([es, _])=>es.length === 0 ? _coreJs.void : _coreJs.fail(es)));
const validateFirst = /*#__PURE__*/ (0, _functionJs.dual)((args)=>_predicateJs.isIterable(args[0]), (elements, f, options)=>_coreJs.flip(forEach(elements, (a, i)=>_coreJs.flip(f(a, i)), options)));
const withClockScoped = (c)=>fiberRefLocallyScopedWith(_defaultServicesJs.currentServices, _contextJs.add(_clockJs.clockTag, c));
const withRandomScoped = (value)=>fiberRefLocallyScopedWith(_defaultServicesJs.currentServices, _contextJs.add((0, _randomJs.randomTag), value));
const withConfigProviderScoped = (provider)=>fiberRefLocallyScopedWith(_defaultServicesJs.currentServices, _contextJs.add((0, _configProviderJs.configProviderTag), provider));
const withEarlyRelease = (self)=>scopeWith((parent)=>_coreJs.flatMap(_coreJs.scopeFork(parent, _executionStrategyJs1.sequential), (child)=>(0, _functionJs.pipe)(self, scopeExtend(child), _coreJs.map((value)=>[
                    _coreJs.fiberIdWith((fiberId)=>_coreJs.scopeClose(child, _coreJs.exitInterrupt(fiberId))),
                    value
                ]))));
const zipOptions = /*#__PURE__*/ (0, _functionJs.dual)((args)=>_coreJs.isEffect(args[1]), (self, that, options)=>zipWithOptions(self, that, (a, b)=>[
            a,
            b
        ], options));
const zipLeftOptions = /*#__PURE__*/ (0, _functionJs.dual)((args)=>_coreJs.isEffect(args[1]), (self, that, options)=>{
    if (options?.concurrent !== true && (options?.batching === undefined || options.batching === false)) return _coreJs.zipLeft(self, that);
    return zipWithOptions(self, that, (a, _)=>a, options);
});
const zipRightOptions = /*#__PURE__*/ (0, _functionJs.dual)((args)=>_coreJs.isEffect(args[1]), (self, that, options)=>{
    if (options?.concurrent !== true && (options?.batching === undefined || options.batching === false)) return _coreJs.zipRight(self, that);
    return zipWithOptions(self, that, (_, b)=>b, options);
});
const zipWithOptions = /*#__PURE__*/ (0, _functionJs.dual)((args)=>_coreJs.isEffect(args[1]), (self, that, f, options)=>_coreJs.map(all([
        self,
        that
    ], {
        concurrency: options?.concurrent ? 2 : 1,
        batching: options?.batching,
        concurrentFinalizers: options?.concurrentFinalizers
    }), ([a, a2])=>f(a, a2)));
const withRuntimeFlagsScoped = (update)=>{
    if (update === _runtimeFlagsPatchJs.empty) return _coreJs.void;
    return (0, _functionJs.pipe)(_coreJs.runtimeFlags, _coreJs.flatMap((runtimeFlags)=>{
        const updatedRuntimeFlags = _runtimeFlagsJs.patch(runtimeFlags, update);
        const revertRuntimeFlags = _runtimeFlagsJs.diff(updatedRuntimeFlags, runtimeFlags);
        return (0, _functionJs.pipe)(_coreJs.updateRuntimeFlags(update), _coreJs.zipRight(addFinalizer(()=>_coreJs.updateRuntimeFlags(revertRuntimeFlags))), _coreJs.asVoid);
    }), _coreJs.uninterruptible);
};
const scopeTag = /*#__PURE__*/ _contextJs.GenericTag("effect/Scope");
const scope = scopeTag;
const scopeUnsafeAddFinalizer = (scope, fin)=>{
    if (scope.state._tag === "Open") scope.state.finalizers.set({}, fin);
};
const ScopeImplProto = {
    [_coreJs.ScopeTypeId]: _coreJs.ScopeTypeId,
    [_coreJs.CloseableScopeTypeId]: _coreJs.CloseableScopeTypeId,
    pipe () {
        return (0, _pipeableJs.pipeArguments)(this, arguments);
    },
    fork (strategy) {
        return _coreJs.sync(()=>{
            const newScope = scopeUnsafeMake(strategy);
            if (this.state._tag === "Closed") {
                newScope.state = this.state;
                return newScope;
            }
            const key = {};
            const fin = (exit)=>newScope.close(exit);
            this.state.finalizers.set(key, fin);
            scopeUnsafeAddFinalizer(newScope, (_)=>_coreJs.sync(()=>{
                    if (this.state._tag === "Open") this.state.finalizers.delete(key);
                }));
            return newScope;
        });
    },
    close (exit) {
        return _coreJs.suspend(()=>{
            if (this.state._tag === "Closed") return _coreJs.void;
            const finalizers = Array.from(this.state.finalizers.values()).reverse();
            this.state = {
                _tag: "Closed",
                exit
            };
            if (finalizers.length === 0) return _coreJs.void;
            return _executionStrategyJs1.isSequential(this.strategy) ? (0, _functionJs.pipe)(_coreJs.forEachSequential(finalizers, (fin)=>_coreJs.exit(fin(exit))), _coreJs.flatMap((results)=>(0, _functionJs.pipe)(_coreJs.exitCollectAll(results), _optionJs.map(_coreJs.exitAsVoid), _optionJs.getOrElse(()=>_coreJs.exitVoid)))) : _executionStrategyJs1.isParallel(this.strategy) ? (0, _functionJs.pipe)(forEachParUnbounded(finalizers, (fin)=>_coreJs.exit(fin(exit)), false), _coreJs.flatMap((results)=>(0, _functionJs.pipe)(_coreJs.exitCollectAll(results, {
                    parallel: true
                }), _optionJs.map(_coreJs.exitAsVoid), _optionJs.getOrElse(()=>_coreJs.exitVoid)))) : (0, _functionJs.pipe)(forEachParN(finalizers, this.strategy.parallelism, (fin)=>_coreJs.exit(fin(exit)), false), _coreJs.flatMap((results)=>(0, _functionJs.pipe)(_coreJs.exitCollectAll(results, {
                    parallel: true
                }), _optionJs.map(_coreJs.exitAsVoid), _optionJs.getOrElse(()=>_coreJs.exitVoid))));
        });
    },
    addFinalizer (fin) {
        return _coreJs.suspend(()=>{
            if (this.state._tag === "Closed") return fin(this.state.exit);
            this.state.finalizers.set({}, fin);
            return _coreJs.void;
        });
    }
};
const scopeUnsafeMake = (strategy = _executionStrategyJs1.sequential)=>{
    const scope = Object.create(ScopeImplProto);
    scope.strategy = strategy;
    scope.state = {
        _tag: "Open",
        finalizers: new Map()
    };
    return scope;
};
const scopeMake = (strategy = _executionStrategyJs1.sequential)=>_coreJs.sync(()=>scopeUnsafeMake(strategy));
const scopeExtend = /*#__PURE__*/ (0, _functionJs.dual)(2, (effect, scope)=>_coreJs.mapInputContext(effect, // @ts-expect-error
    _contextJs.merge(_contextJs.make(scopeTag, scope))));
const scopeUse = /*#__PURE__*/ (0, _functionJs.dual)(2, (effect, scope)=>(0, _functionJs.pipe)(effect, scopeExtend(scope), _coreJs.onExit((exit)=>scope.close(exit))));
const fiberRefUnsafeMakeSupervisor = (initial)=>_coreJs.fiberRefUnsafeMakePatch(initial, {
        differ: _patchJs.differ,
        fork: _patchJs.empty
    });
const fiberRefLocallyScoped = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, value)=>_coreJs.asVoid(acquireRelease(_coreJs.flatMap(_coreJs.fiberRefGet(self), (oldValue)=>_coreJs.as(_coreJs.fiberRefSet(self, value), oldValue)), (oldValue)=>_coreJs.fiberRefSet(self, oldValue))));
const fiberRefLocallyScopedWith = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>_coreJs.fiberRefGetWith(self, (a)=>fiberRefLocallyScoped(self, f(a))));
const fiberRefMake = (initial, options)=>fiberRefMakeWith(()=>_coreJs.fiberRefUnsafeMake(initial, options));
const fiberRefMakeWith = (ref)=>acquireRelease(_coreJs.tap(_coreJs.sync(ref), (ref)=>_coreJs.fiberRefUpdate(ref, (0, _functionJs.identity))), (fiberRef)=>_coreJs.fiberRefDelete(fiberRef));
const fiberRefMakeContext = (initial)=>fiberRefMakeWith(()=>_coreJs.fiberRefUnsafeMakeContext(initial));
const fiberRefMakeRuntimeFlags = (initial)=>fiberRefMakeWith(()=>_coreJs.fiberRefUnsafeMakeRuntimeFlags(initial));
const currentRuntimeFlags = /*#__PURE__*/ _coreJs.fiberRefUnsafeMakeRuntimeFlags(_runtimeFlagsJs.none);
const currentSupervisor = /*#__PURE__*/ fiberRefUnsafeMakeSupervisor(_supervisorJs.none);
const fiberAwaitAll = (fibers)=>forEach(fibers, _fiberJs._await);
const fiberAll = (fibers)=>{
    const _fiberAll = {
        ..._effectableJs.CommitPrototype,
        commit () {
            return _fiberJs.join(this);
        },
        [_fiberJs.FiberTypeId]: _fiberJs.fiberVariance,
        id: ()=>_arrayJs.fromIterable(fibers).reduce((id, fiber)=>_fiberIdJs.combine(id, fiber.id()), _fiberIdJs.none),
        await: _coreJs.exit(forEachParUnbounded(fibers, (fiber)=>_coreJs.flatten(fiber.await), false)),
        children: _coreJs.map(forEachParUnbounded(fibers, (fiber)=>fiber.children, false), _arrayJs.flatten),
        inheritAll: _coreJs.forEachSequentialDiscard(fibers, (fiber)=>fiber.inheritAll),
        poll: _coreJs.map(_coreJs.forEachSequential(fibers, (fiber)=>fiber.poll), _arrayJs.reduceRight(_optionJs.some(_coreJs.exitSucceed(new Array())), (optionB, optionA)=>{
            switch(optionA._tag){
                case "None":
                    return _optionJs.none();
                case "Some":
                    switch(optionB._tag){
                        case "None":
                            return _optionJs.none();
                        case "Some":
                            return _optionJs.some(_coreJs.exitZipWith(optionA.value, optionB.value, {
                                onSuccess: (a, chunk)=>[
                                        a,
                                        ...chunk
                                    ],
                                onFailure: _causeJs.parallel
                            }));
                    }
            }
        })),
        interruptAsFork: (fiberId)=>_coreJs.forEachSequentialDiscard(fibers, (fiber)=>fiber.interruptAsFork(fiberId))
    };
    return _fiberAll;
};
const fiberInterruptFork = (self)=>_coreJs.asVoid(forkDaemon(_coreJs.interruptFiber(self)));
const fiberJoinAll = (fibers)=>_fiberJs.join(fiberAll(fibers));
const fiberScoped = (self)=>acquireRelease(_coreJs.succeed(self), _coreJs.interruptFiber);
const raceWith = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, other, options)=>raceFibersWith(self, other, {
        onSelfWin: (winner, loser)=>_coreJs.flatMap(winner.await, (exit)=>{
                switch(exit._tag){
                    case _effectJs.OP_SUCCESS:
                        return _coreJs.flatMap(winner.inheritAll, ()=>options.onSelfDone(exit, loser));
                    case _effectJs.OP_FAILURE:
                        return options.onSelfDone(exit, loser);
                }
            }),
        onOtherWin: (winner, loser)=>_coreJs.flatMap(winner.await, (exit)=>{
                switch(exit._tag){
                    case _effectJs.OP_SUCCESS:
                        return _coreJs.flatMap(winner.inheritAll, ()=>options.onOtherDone(exit, loser));
                    case _effectJs.OP_FAILURE:
                        return options.onOtherDone(exit, loser);
                }
            })
    }));
const disconnect = (self)=>_coreJs.uninterruptibleMask((restore)=>_coreJs.fiberIdWith((fiberId)=>_coreJs.flatMap(forkDaemon(restore(self)), (fiber)=>(0, _functionJs.pipe)(restore(_fiberJs.join(fiber)), _coreJs.onInterrupt(()=>(0, _functionJs.pipe)(fiber, _fiberJs.interruptAsFork(fiberId)))))));
const race = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>_coreJs.fiberIdWith((parentFiberId)=>raceWith(self, that, {
            onSelfDone: (exit, right)=>_coreJs.exitMatchEffect(exit, {
                    onFailure: (cause)=>(0, _functionJs.pipe)(_fiberJs.join(right), _coreEffectJs.mapErrorCause((cause2)=>_causeJs.parallel(cause, cause2))),
                    onSuccess: (value)=>(0, _functionJs.pipe)(right, _coreJs.interruptAsFiber(parentFiberId), _coreJs.as(value))
                }),
            onOtherDone: (exit, left)=>_coreJs.exitMatchEffect(exit, {
                    onFailure: (cause)=>(0, _functionJs.pipe)(_fiberJs.join(left), _coreEffectJs.mapErrorCause((cause2)=>_causeJs.parallel(cause2, cause))),
                    onSuccess: (value)=>(0, _functionJs.pipe)(left, _coreJs.interruptAsFiber(parentFiberId), _coreJs.as(value))
                })
        })));
const raceFibersWith = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, other, options)=>_coreJs.withFiberRuntime((parentFiber, parentStatus)=>{
        const parentRuntimeFlags = parentStatus.runtimeFlags;
        const raceIndicator = _mutableRefJs.make(true);
        const leftFiber = unsafeMakeChildFiber(self, parentFiber, parentRuntimeFlags, options.selfScope);
        const rightFiber = unsafeMakeChildFiber(other, parentFiber, parentRuntimeFlags, options.otherScope);
        return _coreJs.async((cb)=>{
            leftFiber.addObserver(()=>completeRace(leftFiber, rightFiber, options.onSelfWin, raceIndicator, cb));
            rightFiber.addObserver(()=>completeRace(rightFiber, leftFiber, options.onOtherWin, raceIndicator, cb));
            leftFiber.startFork(self);
            rightFiber.startFork(other);
        }, _fiberIdJs.combine(leftFiber.id(), rightFiber.id()));
    }));
const completeRace = (winner, loser, cont, ab, cb)=>{
    if (_mutableRefJs.compareAndSet(true, false)(ab)) cb(cont(winner, loser));
};
const ensuring = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, finalizer)=>_coreJs.uninterruptibleMask((restore)=>_coreJs.matchCauseEffect(restore(self), {
            onFailure: (cause1)=>_coreJs.matchCauseEffect(finalizer, {
                    onFailure: (cause2)=>_coreJs.failCause(_causeJs.sequential(cause1, cause2)),
                    onSuccess: ()=>_coreJs.failCause(cause1)
                }),
            onSuccess: (a)=>_coreJs.as(finalizer, a)
        })));
const invokeWithInterrupt = (self, entries, onInterrupt)=>_coreJs.fiberIdWith((id)=>_coreJs.flatMap(_coreJs.flatMap(forkDaemon(_coreJs.interruptible(self)), (processing)=>_coreJs.async((cb)=>{
                const counts = entries.map((_)=>_.listeners.count);
                const checkDone = ()=>{
                    if (counts.every((count)=>count === 0)) {
                        if (entries.every((_)=>{
                            if (_.result.state.current._tag === "Pending") return true;
                            else if (_.result.state.current._tag === "Done" && _coreJs.exitIsExit(_.result.state.current.effect) && _.result.state.current.effect._tag === "Failure" && _causeJs.isInterrupted(_.result.state.current.effect.cause)) return true;
                            else return false;
                        })) {
                            cleanup.forEach((f)=>f());
                            onInterrupt?.();
                            cb(_coreJs.interruptFiber(processing));
                        }
                    }
                };
                processing.addObserver((exit)=>{
                    cleanup.forEach((f)=>f());
                    cb(exit);
                });
                const cleanup = entries.map((r, i)=>{
                    const observer = (count)=>{
                        counts[i] = count;
                        checkDone();
                    };
                    r.listeners.addObserver(observer);
                    return ()=>r.listeners.removeObserver(observer);
                });
                checkDone();
                return _coreJs.sync(()=>{
                    cleanup.forEach((f)=>f());
                });
            })), ()=>_coreJs.suspend(()=>{
                const residual = entries.flatMap((entry)=>{
                    if (!entry.state.completed) return [
                        entry
                    ];
                    return [];
                });
                return _coreJs.forEachSequentialDiscard(residual, (entry)=>(0, _requestJs.complete)(entry.request, _coreJs.exitInterrupt(id)));
            })));
const interruptWhenPossible = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, all)=>_coreJs.fiberRefGetWith((0, _completedRequestMapJs.currentRequestMap), (map)=>_coreJs.suspend(()=>{
            const entries = _arrayJs.fromIterable(all).flatMap((_)=>map.has(_) ? [
                    map.get(_)
                ] : []);
            return invokeWithInterrupt(self, entries);
        })));
const makeSpanScoped = (name, options)=>{
    options = _tracerJs.addSpanStackTrace(options);
    return _coreJs.uninterruptible(_coreJs.withFiberRuntime((fiber)=>{
        const scope = _contextJs.unsafeGet(fiber.getFiberRef(_coreJs.currentContext), scopeTag);
        const span = _coreEffectJs.unsafeMakeSpan(fiber, name, options);
        const timingEnabled = fiber.getFiberRef(_coreJs.currentTracerTimingEnabled);
        const clock_ = _contextJs.get(fiber.getFiberRef(_defaultServicesJs.currentServices), _clockJs.clockTag);
        return _coreJs.as(_coreJs.scopeAddFinalizerExit(scope, (exit)=>_coreEffectJs.endSpan(span, exit, clock_, timingEnabled)), span);
    }));
};
const withTracerScoped = (value)=>fiberRefLocallyScopedWith(_defaultServicesJs.currentServices, _contextJs.add(_tracerJs.tracerTag, value));
const withSpanScoped = function() {
    const dataFirst = typeof arguments[0] !== "string";
    const name = dataFirst ? arguments[1] : arguments[0];
    const options = _tracerJs.addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
    if (dataFirst) {
        const self = arguments[0];
        return _coreJs.flatMap(makeSpanScoped(name, _tracerJs.addSpanStackTrace(options)), (span)=>_coreEffectJs.provideService(self, _tracerJs.spanTag, span));
    }
    return (self)=>_coreJs.flatMap(makeSpanScoped(name, _tracerJs.addSpanStackTrace(options)), (span)=>_coreEffectJs.provideService(self, _tracerJs.spanTag, span));
};

},{"../Array.js":"8L2Gk","../Boolean.js":"40R3H","../Chunk.js":"dL1OO","../Context.js":"c2abN","../Deferred.js":"cfKDq","../Effectable.js":"kxbGz","../ExecutionStrategy.js":"8SBwj","../FiberId.js":"4K4GG","../FiberRefs.js":"lIa2I","../FiberRefsPatch.js":"2QlCD","../FiberStatus.js":"9ksVG","../Function.js":"21gOL","../GlobalValue.js":"5w3Hn","../HashMap.js":"aG8zS","../HashSet.js":"aKFFV","../Inspectable.js":"1Ur70","../LogLevel.js":"76ZSp","../Micro.js":"6DzVc","../MutableRef.js":"aCyaL","../Option.js":"6sHA7","../Pipeable.js":"b5RU2","../Predicate.js":"gW5pd","../Ref.js":"cqfIo","../RuntimeFlagsPatch.js":"bY5hN","../Scheduler.js":"hR5Dj","../Utils.js":"dYvz1","./blockedRequests.js":"2UYO5","./cause.js":"l3ev0","./clock.js":"27hJp","./completedRequestMap.js":"dFrk6","./concurrency.js":"TC4N9","./configProvider.js":"103QC","./core-effect.js":"k8F3C","./core.js":"cr3YV","./defaultServices.js":"aF4q8","./defaultServices/console.js":"lcu1k","./executionStrategy.js":"hbtwH","./fiber.js":"65P25","./fiberMessage.js":"j6Tm3","./fiberRefs.js":"gt1Z6","./fiberScope.js":"f4YSV","./logger.js":"11rih","./metric.js":"6Hb5Q","./metric/boundaries.js":"dvuqu","./metric/label.js":"hcYDB","./opCodes/effect.js":"9RoDl","./random.js":"br4fL","./request.js":"j7pmc","./runtimeFlags.js":"9rFhC","./supervisor.js":"bryLt","./supervisor/patch.js":"2Cdn0","./tracer.js":"aAsvB","./version.js":"euXJO","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"cfKDq":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DeferredTypeId", ()=>DeferredTypeId);
parcelHelpers.export(exports, "make", ()=>make);
parcelHelpers.export(exports, "makeAs", ()=>makeAs);
parcelHelpers.export(exports, "await", ()=>/**
 * Retrieves the value of the `Deferred`, suspending the fiber running the
 * workflow until the result is available.
 *
 * @since 2.0.0
 * @category getters
 */ _await);
parcelHelpers.export(exports, "complete", ()=>complete);
parcelHelpers.export(exports, "completeWith", ()=>completeWith);
parcelHelpers.export(exports, "done", ()=>done);
parcelHelpers.export(exports, "fail", ()=>fail);
parcelHelpers.export(exports, "failSync", ()=>failSync);
parcelHelpers.export(exports, "failCause", ()=>failCause);
parcelHelpers.export(exports, "failCauseSync", ()=>failCauseSync);
parcelHelpers.export(exports, "die", ()=>die);
parcelHelpers.export(exports, "dieSync", ()=>dieSync);
parcelHelpers.export(exports, "interrupt", ()=>interrupt);
parcelHelpers.export(exports, "interruptWith", ()=>interruptWith);
parcelHelpers.export(exports, "isDone", ()=>isDone);
parcelHelpers.export(exports, "poll", ()=>poll);
parcelHelpers.export(exports, "succeed", ()=>succeed);
parcelHelpers.export(exports, "sync", ()=>sync);
parcelHelpers.export(exports, "unsafeMake", ()=>unsafeMake);
parcelHelpers.export(exports, "unsafeDone", ()=>unsafeDone);
var _coreJs = require("./internal/core.js");
var _deferredJs = require("./internal/deferred.js");
const DeferredTypeId = _deferredJs.DeferredTypeId;
const make = _coreJs.deferredMake;
const makeAs = _coreJs.deferredMakeAs;
const _await = _coreJs.deferredAwait;
const complete = _coreJs.deferredComplete;
const completeWith = _coreJs.deferredCompleteWith;
const done = _coreJs.deferredDone;
const fail = _coreJs.deferredFail;
const failSync = _coreJs.deferredFailSync;
const failCause = _coreJs.deferredFailCause;
const failCauseSync = _coreJs.deferredFailCauseSync;
const die = _coreJs.deferredDie;
const dieSync = _coreJs.deferredDieSync;
const interrupt = _coreJs.deferredInterrupt;
const interruptWith = _coreJs.deferredInterruptWith;
const isDone = _coreJs.deferredIsDone;
const poll = _coreJs.deferredPoll;
const succeed = _coreJs.deferredSucceed;
const sync = _coreJs.deferredSync;
const unsafeMake = _coreJs.deferredUnsafeMake;
const unsafeDone = _coreJs.deferredUnsafeDone;

},{"./internal/core.js":"cr3YV","./internal/deferred.js":"1Hftc","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"8SBwj":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "sequential", ()=>sequential);
parcelHelpers.export(exports, "parallel", ()=>parallel);
parcelHelpers.export(exports, "parallelN", ()=>parallelN);
parcelHelpers.export(exports, "isSequential", ()=>isSequential);
parcelHelpers.export(exports, "isParallel", ()=>isParallel);
parcelHelpers.export(exports, "isParallelN", ()=>isParallelN);
parcelHelpers.export(exports, "match", ()=>match);
var _executionStrategyJs = require("./internal/executionStrategy.js");
const sequential = _executionStrategyJs.sequential;
const parallel = _executionStrategyJs.parallel;
const parallelN = _executionStrategyJs.parallelN;
const isSequential = _executionStrategyJs.isSequential;
const isParallel = _executionStrategyJs.isParallel;
const isParallelN = _executionStrategyJs.isParallelN;
const match = _executionStrategyJs.match;

},{"./internal/executionStrategy.js":"hbtwH","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"hbtwH":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "OP_SEQUENTIAL", ()=>OP_SEQUENTIAL);
parcelHelpers.export(exports, "OP_PARALLEL", ()=>OP_PARALLEL);
parcelHelpers.export(exports, "OP_PARALLEL_N", ()=>OP_PARALLEL_N);
parcelHelpers.export(exports, "sequential", ()=>sequential);
parcelHelpers.export(exports, "parallel", ()=>parallel);
parcelHelpers.export(exports, "parallelN", ()=>parallelN);
parcelHelpers.export(exports, "isSequential", ()=>isSequential);
parcelHelpers.export(exports, "isParallel", ()=>isParallel);
parcelHelpers.export(exports, "isParallelN", ()=>isParallelN);
parcelHelpers.export(exports, "match", ()=>match);
var _functionJs = require("../Function.js");
const OP_SEQUENTIAL = "Sequential";
const OP_PARALLEL = "Parallel";
const OP_PARALLEL_N = "ParallelN";
const sequential = {
    _tag: OP_SEQUENTIAL
};
const parallel = {
    _tag: OP_PARALLEL
};
const parallelN = (parallelism)=>({
        _tag: OP_PARALLEL_N,
        parallelism
    });
const isSequential = (self)=>self._tag === OP_SEQUENTIAL;
const isParallel = (self)=>self._tag === OP_PARALLEL;
const isParallelN = (self)=>self._tag === OP_PARALLEL_N;
const match = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, options)=>{
    switch(self._tag){
        case OP_SEQUENTIAL:
            return options.onSequential();
        case OP_PARALLEL:
            return options.onParallel();
        case OP_PARALLEL_N:
            return options.onParallelN(self.parallelism);
    }
});

},{"../Function.js":"21gOL","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"2QlCD":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "empty", ()=>empty);
parcelHelpers.export(exports, "diff", ()=>diff);
parcelHelpers.export(exports, "combine", ()=>combine);
parcelHelpers.export(exports, "patch", ()=>patch);
var _patchJs = require("./internal/fiberRefs/patch.js");
const empty = _patchJs.empty;
const diff = _patchJs.diff;
const combine = _patchJs.combine;
const patch = _patchJs.patch;

},{"./internal/fiberRefs/patch.js":"lTfKe","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"9ksVG":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FiberStatusTypeId", ()=>FiberStatusTypeId);
parcelHelpers.export(exports, "done", ()=>done);
parcelHelpers.export(exports, "running", ()=>running);
parcelHelpers.export(exports, "suspended", ()=>suspended);
parcelHelpers.export(exports, "isFiberStatus", ()=>isFiberStatus);
parcelHelpers.export(exports, "isDone", ()=>isDone);
parcelHelpers.export(exports, "isRunning", ()=>isRunning);
parcelHelpers.export(exports, "isSuspended", ()=>isSuspended);
var _fiberStatusJs = require("./internal/fiberStatus.js");
const FiberStatusTypeId = _fiberStatusJs.FiberStatusTypeId;
const done = _fiberStatusJs.done;
const running = _fiberStatusJs.running;
const suspended = _fiberStatusJs.suspended;
const isFiberStatus = _fiberStatusJs.isFiberStatus;
const isDone = _fiberStatusJs.isDone;
const isRunning = _fiberStatusJs.isRunning;
const isSuspended = _fiberStatusJs.isSuspended;

},{"./internal/fiberStatus.js":"cNYk8","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"cNYk8":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FiberStatusTypeId", ()=>FiberStatusTypeId);
parcelHelpers.export(exports, "OP_DONE", ()=>OP_DONE);
parcelHelpers.export(exports, "OP_RUNNING", ()=>OP_RUNNING);
parcelHelpers.export(exports, "OP_SUSPENDED", ()=>OP_SUSPENDED);
parcelHelpers.export(exports, "done", ()=>done);
parcelHelpers.export(exports, "running", ()=>running);
parcelHelpers.export(exports, "suspended", ()=>suspended);
parcelHelpers.export(exports, "isFiberStatus", ()=>isFiberStatus);
parcelHelpers.export(exports, "isDone", ()=>isDone);
parcelHelpers.export(exports, "isRunning", ()=>isRunning);
parcelHelpers.export(exports, "isSuspended", ()=>isSuspended);
var _equalJs = require("../Equal.js");
var _functionJs = require("../Function.js");
var _hashJs = require("../Hash.js");
var _predicateJs = require("../Predicate.js");
const FiberStatusSymbolKey = "effect/FiberStatus";
const FiberStatusTypeId = /*#__PURE__*/ Symbol.for(FiberStatusSymbolKey);
const OP_DONE = "Done";
const OP_RUNNING = "Running";
const OP_SUSPENDED = "Suspended";
const DoneHash = /*#__PURE__*/ _hashJs.string(`${FiberStatusSymbolKey}-${OP_DONE}`);
/** @internal */ class Done {
    [FiberStatusTypeId] = FiberStatusTypeId;
    _tag = OP_DONE;
    [_hashJs.symbol]() {
        return DoneHash;
    }
    [_equalJs.symbol](that) {
        return isFiberStatus(that) && that._tag === OP_DONE;
    }
}
/** @internal */ class Running {
    runtimeFlags;
    [FiberStatusTypeId] = FiberStatusTypeId;
    _tag = OP_RUNNING;
    constructor(runtimeFlags){
        this.runtimeFlags = runtimeFlags;
    }
    [_hashJs.symbol]() {
        return (0, _functionJs.pipe)(_hashJs.hash(FiberStatusSymbolKey), _hashJs.combine(_hashJs.hash(this._tag)), _hashJs.combine(_hashJs.hash(this.runtimeFlags)), _hashJs.cached(this));
    }
    [_equalJs.symbol](that) {
        return isFiberStatus(that) && that._tag === OP_RUNNING && this.runtimeFlags === that.runtimeFlags;
    }
}
/** @internal */ class Suspended {
    runtimeFlags;
    blockingOn;
    [FiberStatusTypeId] = FiberStatusTypeId;
    _tag = OP_SUSPENDED;
    constructor(runtimeFlags, blockingOn){
        this.runtimeFlags = runtimeFlags;
        this.blockingOn = blockingOn;
    }
    [_hashJs.symbol]() {
        return (0, _functionJs.pipe)(_hashJs.hash(FiberStatusSymbolKey), _hashJs.combine(_hashJs.hash(this._tag)), _hashJs.combine(_hashJs.hash(this.runtimeFlags)), _hashJs.combine(_hashJs.hash(this.blockingOn)), _hashJs.cached(this));
    }
    [_equalJs.symbol](that) {
        return isFiberStatus(that) && that._tag === OP_SUSPENDED && this.runtimeFlags === that.runtimeFlags && _equalJs.equals(this.blockingOn, that.blockingOn);
    }
}
const done = /*#__PURE__*/ new Done();
const running = (runtimeFlags)=>new Running(runtimeFlags);
const suspended = (runtimeFlags, blockingOn)=>new Suspended(runtimeFlags, blockingOn);
const isFiberStatus = (u)=>(0, _predicateJs.hasProperty)(u, FiberStatusTypeId);
const isDone = (self)=>self._tag === OP_DONE;
const isRunning = (self)=>self._tag === OP_RUNNING;
const isSuspended = (self)=>self._tag === OP_SUSPENDED;

},{"../Equal.js":"gA0qD","../Function.js":"21gOL","../Hash.js":"gFMwE","../Predicate.js":"gW5pd","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"6DzVc":[function(require,module,exports,__globalThis) {
/**
 * A lightweight alternative to the `Effect` data type, with a subset of the functionality.
 *
 * @since 3.4.0
 * @experimental
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TypeId", ()=>TypeId);
parcelHelpers.export(exports, "MicroExitTypeId", ()=>MicroExitTypeId);
parcelHelpers.export(exports, "isMicro", ()=>isMicro);
parcelHelpers.export(exports, "MicroCauseTypeId", ()=>MicroCauseTypeId);
parcelHelpers.export(exports, "isMicroCause", ()=>isMicroCause);
parcelHelpers.export(exports, "causeFail", ()=>causeFail);
parcelHelpers.export(exports, "causeDie", ()=>causeDie);
parcelHelpers.export(exports, "causeInterrupt", ()=>causeInterrupt);
parcelHelpers.export(exports, "causeIsFail", ()=>causeIsFail);
parcelHelpers.export(exports, "causeIsDie", ()=>causeIsDie);
parcelHelpers.export(exports, "causeIsInterrupt", ()=>causeIsInterrupt);
parcelHelpers.export(exports, "causeSquash", ()=>causeSquash);
parcelHelpers.export(exports, "causeWithTrace", ()=>causeWithTrace);
parcelHelpers.export(exports, "MicroFiberTypeId", ()=>MicroFiberTypeId);
parcelHelpers.export(exports, "fiberAwait", ()=>fiberAwait);
parcelHelpers.export(exports, "fiberJoin", ()=>fiberJoin);
parcelHelpers.export(exports, "fiberInterrupt", ()=>fiberInterrupt);
parcelHelpers.export(exports, "fiberInterruptAll", ()=>fiberInterruptAll);
parcelHelpers.export(exports, "succeed", ()=>succeed);
parcelHelpers.export(exports, "failCause", ()=>failCause);
parcelHelpers.export(exports, "fail", ()=>fail);
parcelHelpers.export(exports, "sync", ()=>sync);
parcelHelpers.export(exports, "suspend", ()=>suspend);
parcelHelpers.export(exports, "yieldNowWith", ()=>yieldNowWith);
parcelHelpers.export(exports, "yieldNow", ()=>yieldNow);
parcelHelpers.export(exports, "succeedSome", ()=>succeedSome);
parcelHelpers.export(exports, "succeedNone", ()=>succeedNone);
parcelHelpers.export(exports, "failCauseSync", ()=>failCauseSync);
parcelHelpers.export(exports, "die", ()=>die);
parcelHelpers.export(exports, "failSync", ()=>failSync);
parcelHelpers.export(exports, "fromOption", ()=>fromOption);
parcelHelpers.export(exports, "fromEither", ()=>fromEither);
parcelHelpers.export(exports, "void", ()=>/**
 * A `Micro` effect that will succeed with `void` (`undefined`).
 *
 * @since 3.4.0
 * @experimental
 * @category constructors
 */ void_);
parcelHelpers.export(exports, "try", ()=>/**
 * The `Micro` equivalent of a try / catch block, which allows you to map
 * thrown errors to a specific error type.
 *
 * @example
 * ```ts
 * import { Micro } from "effect"
 *
 * Micro.try({
 *   try: () => { throw new Error("boom") },
 *   catch: (cause) => new Error("caught", { cause })
 * })
 * ```
 *
 * @since 3.4.0
 * @experimental
 * @category constructors
 */ try_);
parcelHelpers.export(exports, "promise", ()=>promise);
parcelHelpers.export(exports, "tryPromise", ()=>tryPromise);
parcelHelpers.export(exports, "withMicroFiber", ()=>withMicroFiber);
parcelHelpers.export(exports, "yieldFlush", ()=>yieldFlush);
parcelHelpers.export(exports, "async", ()=>async);
parcelHelpers.export(exports, "never", ()=>never);
parcelHelpers.export(exports, "gen", ()=>gen);
parcelHelpers.export(exports, "as", ()=>as);
parcelHelpers.export(exports, "asSome", ()=>asSome);
parcelHelpers.export(exports, "flip", ()=>flip);
parcelHelpers.export(exports, "andThen", ()=>andThen);
parcelHelpers.export(exports, "tap", ()=>tap);
parcelHelpers.export(exports, "asVoid", ()=>asVoid);
parcelHelpers.export(exports, "exit", ()=>exit);
parcelHelpers.export(exports, "sandbox", ()=>sandbox);
parcelHelpers.export(exports, "raceAll", ()=>raceAll);
parcelHelpers.export(exports, "raceAllFirst", ()=>raceAllFirst);
parcelHelpers.export(exports, "race", ()=>race);
parcelHelpers.export(exports, "raceFirst", ()=>raceFirst);
parcelHelpers.export(exports, "flatMap", ()=>flatMap);
parcelHelpers.export(exports, "flatten", ()=>flatten);
parcelHelpers.export(exports, "map", ()=>map);
parcelHelpers.export(exports, "isMicroExit", ()=>isMicroExit);
parcelHelpers.export(exports, "exitSucceed", ()=>exitSucceed);
parcelHelpers.export(exports, "exitFailCause", ()=>exitFailCause);
parcelHelpers.export(exports, "exitInterrupt", ()=>exitInterrupt);
parcelHelpers.export(exports, "exitFail", ()=>exitFail);
parcelHelpers.export(exports, "exitDie", ()=>exitDie);
parcelHelpers.export(exports, "exitIsSuccess", ()=>exitIsSuccess);
parcelHelpers.export(exports, "exitIsFailure", ()=>exitIsFailure);
parcelHelpers.export(exports, "exitIsInterrupt", ()=>exitIsInterrupt);
parcelHelpers.export(exports, "exitIsFail", ()=>exitIsFail);
parcelHelpers.export(exports, "exitIsDie", ()=>exitIsDie);
parcelHelpers.export(exports, "exitVoid", ()=>exitVoid);
parcelHelpers.export(exports, "exitVoidAll", ()=>exitVoidAll);
/**
 * @since 3.5.9
 * @experimental
 * @category scheduler
 */ parcelHelpers.export(exports, "MicroSchedulerDefault", ()=>MicroSchedulerDefault);
parcelHelpers.export(exports, "service", ()=>service);
parcelHelpers.export(exports, "serviceOption", ()=>serviceOption);
parcelHelpers.export(exports, "updateContext", ()=>updateContext);
parcelHelpers.export(exports, "updateService", ()=>updateService);
parcelHelpers.export(exports, "context", ()=>context);
parcelHelpers.export(exports, "provideContext", ()=>provideContext);
parcelHelpers.export(exports, "provideService", ()=>provideService);
parcelHelpers.export(exports, "provideServiceEffect", ()=>provideServiceEffect);
// ========================================================================
// References
// ========================================================================
/**
 * @since 3.11.0
 * @experimental
 * @category references
 */ parcelHelpers.export(exports, "MaxOpsBeforeYield", ()=>MaxOpsBeforeYield);
/**
 * @since 3.11.0
 * @experimental
 * @category environment refs
 */ parcelHelpers.export(exports, "CurrentConcurrency", ()=>CurrentConcurrency);
/**
 * @since 3.11.0
 * @experimental
 * @category environment refs
 */ parcelHelpers.export(exports, "CurrentScheduler", ()=>CurrentScheduler);
parcelHelpers.export(exports, "withConcurrency", ()=>withConcurrency);
parcelHelpers.export(exports, "zip", ()=>zip);
parcelHelpers.export(exports, "zipWith", ()=>zipWith);
parcelHelpers.export(exports, "filterOrFailCause", ()=>filterOrFailCause);
parcelHelpers.export(exports, "filterOrFail", ()=>filterOrFail);
parcelHelpers.export(exports, "when", ()=>when);
parcelHelpers.export(exports, "repeatExit", ()=>repeatExit);
parcelHelpers.export(exports, "repeat", ()=>repeat);
parcelHelpers.export(exports, "replicate", ()=>replicate);
parcelHelpers.export(exports, "replicateEffect", ()=>replicateEffect);
parcelHelpers.export(exports, "forever", ()=>forever);
parcelHelpers.export(exports, "scheduleRecurs", ()=>scheduleRecurs);
parcelHelpers.export(exports, "scheduleSpaced", ()=>scheduleSpaced);
parcelHelpers.export(exports, "scheduleExponential", ()=>scheduleExponential);
parcelHelpers.export(exports, "scheduleAddDelay", ()=>scheduleAddDelay);
parcelHelpers.export(exports, "scheduleWithMaxDelay", ()=>scheduleWithMaxDelay);
parcelHelpers.export(exports, "scheduleWithMaxElapsed", ()=>scheduleWithMaxElapsed);
parcelHelpers.export(exports, "scheduleUnion", ()=>scheduleUnion);
parcelHelpers.export(exports, "scheduleIntersect", ()=>scheduleIntersect);
parcelHelpers.export(exports, "catchAllCause", ()=>catchAllCause);
parcelHelpers.export(exports, "catchCauseIf", ()=>catchCauseIf);
parcelHelpers.export(exports, "catchAll", ()=>catchAll);
parcelHelpers.export(exports, "catchAllDefect", ()=>catchAllDefect);
parcelHelpers.export(exports, "tapErrorCause", ()=>tapErrorCause);
parcelHelpers.export(exports, "tapErrorCauseIf", ()=>tapErrorCauseIf);
parcelHelpers.export(exports, "tapError", ()=>tapError);
parcelHelpers.export(exports, "tapDefect", ()=>tapDefect);
parcelHelpers.export(exports, "catchIf", ()=>catchIf);
parcelHelpers.export(exports, "catchTag", ()=>catchTag);
parcelHelpers.export(exports, "mapErrorCause", ()=>mapErrorCause);
parcelHelpers.export(exports, "mapError", ()=>mapError);
parcelHelpers.export(exports, "orDie", ()=>orDie);
parcelHelpers.export(exports, "orElseSucceed", ()=>orElseSucceed);
parcelHelpers.export(exports, "ignore", ()=>ignore);
parcelHelpers.export(exports, "ignoreLogged", ()=>ignoreLogged);
parcelHelpers.export(exports, "option", ()=>option);
parcelHelpers.export(exports, "either", ()=>either);
parcelHelpers.export(exports, "retry", ()=>retry);
parcelHelpers.export(exports, "withTrace", ()=>withTrace);
parcelHelpers.export(exports, "matchCauseEffect", ()=>matchCauseEffect);
parcelHelpers.export(exports, "matchCause", ()=>matchCause);
parcelHelpers.export(exports, "matchEffect", ()=>matchEffect);
parcelHelpers.export(exports, "match", ()=>match);
parcelHelpers.export(exports, "sleep", ()=>sleep);
parcelHelpers.export(exports, "delay", ()=>delay);
parcelHelpers.export(exports, "timeoutOrElse", ()=>timeoutOrElse);
parcelHelpers.export(exports, "timeout", ()=>timeout);
parcelHelpers.export(exports, "timeoutOption", ()=>timeoutOption);
parcelHelpers.export(exports, "MicroScopeTypeId", ()=>MicroScopeTypeId);
parcelHelpers.export(exports, "MicroScope", ()=>MicroScope);
parcelHelpers.export(exports, "scopeMake", ()=>scopeMake);
parcelHelpers.export(exports, "scopeUnsafeMake", ()=>scopeUnsafeMake);
parcelHelpers.export(exports, "scope", ()=>scope);
parcelHelpers.export(exports, "provideScope", ()=>provideScope);
parcelHelpers.export(exports, "scoped", ()=>scoped);
parcelHelpers.export(exports, "acquireRelease", ()=>acquireRelease);
parcelHelpers.export(exports, "addFinalizer", ()=>addFinalizer);
parcelHelpers.export(exports, "onExit", ()=>onExit);
parcelHelpers.export(exports, "ensuring", ()=>ensuring);
parcelHelpers.export(exports, "onExitIf", ()=>onExitIf);
parcelHelpers.export(exports, "onError", ()=>onError);
parcelHelpers.export(exports, "onInterrupt", ()=>onInterrupt);
parcelHelpers.export(exports, "acquireUseRelease", ()=>acquireUseRelease);
parcelHelpers.export(exports, "interrupt", ()=>interrupt);
parcelHelpers.export(exports, "uninterruptible", ()=>uninterruptible);
parcelHelpers.export(exports, "interruptible", ()=>interruptible);
parcelHelpers.export(exports, "uninterruptibleMask", ()=>uninterruptibleMask);
parcelHelpers.export(exports, "all", ()=>all);
parcelHelpers.export(exports, "whileLoop", ()=>whileLoop);
parcelHelpers.export(exports, "forEach", ()=>forEach);
parcelHelpers.export(exports, "filter", ()=>filter);
parcelHelpers.export(exports, "filterMap", ()=>filterMap);
parcelHelpers.export(exports, "Do", ()=>Do);
parcelHelpers.export(exports, "bindTo", ()=>bindTo);
parcelHelpers.export(exports, "bind", ()=>bind);
parcelHelpers.export(exports, "let", ()=>/**
 * Bind the result of a synchronous computation to the given name.
 *
 * @since 3.4.0
 * @experimental
 * @category do notation
 */ let_);
parcelHelpers.export(exports, "fork", ()=>fork);
parcelHelpers.export(exports, "forkDaemon", ()=>forkDaemon);
parcelHelpers.export(exports, "forkIn", ()=>forkIn);
parcelHelpers.export(exports, "forkScoped", ()=>forkScoped);
parcelHelpers.export(exports, "runFork", ()=>runFork);
parcelHelpers.export(exports, "runPromiseExit", ()=>runPromiseExit);
parcelHelpers.export(exports, "runPromise", ()=>runPromise);
parcelHelpers.export(exports, "runSyncExit", ()=>runSyncExit);
parcelHelpers.export(exports, "runSync", ()=>runSync);
parcelHelpers.export(exports, "Error", ()=>Error);
parcelHelpers.export(exports, "TaggedError", ()=>TaggedError);
/**
 * Represents a checked exception which occurs when an expected element was
 * unable to be found.
 *
 * @since 3.4.4
 * @experimental
 * @category errors
 */ parcelHelpers.export(exports, "NoSuchElementException", ()=>NoSuchElementException);
/**
 * Represents a checked exception which occurs when a timeout occurs.
 *
 * @since 3.4.4
 * @experimental
 * @category errors
 */ parcelHelpers.export(exports, "TimeoutException", ()=>TimeoutException);
var _arrayJs = require("./Array.js");
var _contextJs = require("./Context.js");
var _effectableJs = require("./Effectable.js");
var _eitherJs = require("./Either.js");
var _equalJs = require("./Equal.js");
var _functionJs = require("./Function.js");
var _globalValueJs = require("./GlobalValue.js");
var _hashJs = require("./Hash.js");
var _inspectableJs = require("./Inspectable.js");
var _contextJs1 = require("./internal/context.js");
var _doNotationJs = require("./internal/doNotation.js");
var _effectableJs1 = require("./internal/effectable.js");
var _optionJs = require("./Option.js");
var _pipeableJs = require("./Pipeable.js");
var _predicateJs = require("./Predicate.js");
var _utilsJs = require("./Utils.js");
const TypeId = /*#__PURE__*/ Symbol.for("effect/Micro");
const MicroExitTypeId = /*#__PURE__*/ Symbol.for("effect/Micro/MicroExit");
const isMicro = (u)=>typeof u === "object" && u !== null && TypeId in u;
const MicroCauseTypeId = /*#__PURE__*/ Symbol.for("effect/Micro/MicroCause");
const isMicroCause = (self)=>(0, _predicateJs.hasProperty)(self, MicroCauseTypeId);
const microCauseVariance = {
    _E: (0, _functionJs.identity)
};
class MicroCauseImpl extends globalThis.Error {
    _tag;
    traces;
    [MicroCauseTypeId];
    constructor(_tag, originalError, traces){
        const causeName = `MicroCause.${_tag}`;
        let name;
        let message;
        let stack;
        if (originalError instanceof globalThis.Error) {
            name = `(${causeName}) ${originalError.name}`;
            message = originalError.message;
            const messageLines = message.split("\n").length;
            stack = originalError.stack ? `(${causeName}) ${originalError.stack.split("\n").slice(0, messageLines + 3).join("\n")}` : `${name}: ${message}`;
        } else {
            name = causeName;
            message = (0, _inspectableJs.toStringUnknown)(originalError, 0);
            stack = `${name}: ${message}`;
        }
        if (traces.length > 0) stack += `\n    ${traces.join("\n    ")}`;
        super(message);
        this._tag = _tag;
        this.traces = traces;
        this[MicroCauseTypeId] = microCauseVariance;
        this.name = name;
        this.stack = stack;
    }
    pipe() {
        return (0, _pipeableJs.pipeArguments)(this, arguments);
    }
    toString() {
        return this.stack;
    }
    [(0, _inspectableJs.NodeInspectSymbol)]() {
        return this.stack;
    }
}
class Fail extends MicroCauseImpl {
    error;
    constructor(error, traces = []){
        super("Fail", error, traces);
        this.error = error;
    }
}
const causeFail = (error, traces = [])=>new Fail(error, traces);
class Die extends MicroCauseImpl {
    defect;
    constructor(defect, traces = []){
        super("Die", defect, traces);
        this.defect = defect;
    }
}
const causeDie = (defect, traces = [])=>new Die(defect, traces);
class Interrupt extends MicroCauseImpl {
    constructor(traces = []){
        super("Interrupt", "interrupted", traces);
    }
}
const causeInterrupt = (traces = [])=>new Interrupt(traces);
const causeIsFail = (self)=>self._tag === "Fail";
const causeIsDie = (self)=>self._tag === "Die";
const causeIsInterrupt = (self)=>self._tag === "Interrupt";
const causeSquash = (self)=>self._tag === "Fail" ? self.error : self._tag === "Die" ? self.defect : self;
const causeWithTrace = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, trace)=>{
    const traces = [
        ...self.traces,
        trace
    ];
    switch(self._tag){
        case "Die":
            return causeDie(self.defect, traces);
        case "Interrupt":
            return causeInterrupt(traces);
        case "Fail":
            return causeFail(self.error, traces);
    }
});
const MicroFiberTypeId = /*#__PURE__*/ Symbol.for("effect/Micro/MicroFiber");
const fiberVariance = {
    _A: (0, _functionJs.identity),
    _E: (0, _functionJs.identity)
};
class MicroFiberImpl {
    context;
    interruptible;
    [MicroFiberTypeId];
    _stack = [];
    _observers = [];
    _exit;
    _children;
    currentOpCount = 0;
    constructor(context, interruptible = true){
        this.context = context;
        this.interruptible = interruptible;
        this[MicroFiberTypeId] = fiberVariance;
    }
    getRef(ref) {
        return _contextJs1.unsafeGetReference(this.context, ref);
    }
    addObserver(cb) {
        if (this._exit) {
            cb(this._exit);
            return 0, _functionJs.constVoid;
        }
        this._observers.push(cb);
        return ()=>{
            const index = this._observers.indexOf(cb);
            if (index >= 0) this._observers.splice(index, 1);
        };
    }
    _interrupted = false;
    unsafeInterrupt() {
        if (this._exit) return;
        this._interrupted = true;
        if (this.interruptible) this.evaluate(exitInterrupt);
    }
    unsafePoll() {
        return this._exit;
    }
    evaluate(effect) {
        if (this._exit) return;
        else if (this._yielded !== undefined) {
            const yielded = this._yielded;
            this._yielded = undefined;
            yielded();
        }
        const exit = this.runLoop(effect);
        if (exit === Yield) return;
        // the interruptChildren middlware is added in Micro.fork, so it can be
        // tree-shaken if not used
        const interruptChildren = fiberMiddleware.interruptChildren && fiberMiddleware.interruptChildren(this);
        if (interruptChildren !== undefined) return this.evaluate(flatMap(interruptChildren, ()=>exit));
        this._exit = exit;
        for(let i = 0; i < this._observers.length; i++)this._observers[i](exit);
        this._observers.length = 0;
    }
    runLoop(effect) {
        let yielding = false;
        let current = effect;
        this.currentOpCount = 0;
        try {
            while(true){
                this.currentOpCount++;
                if (!yielding && this.getRef(CurrentScheduler).shouldYield(this)) {
                    yielding = true;
                    const prev = current;
                    current = flatMap(yieldNow, ()=>prev);
                }
                current = current[evaluate](this);
                if (current === Yield) {
                    const yielded = this._yielded;
                    if (MicroExitTypeId in yielded) {
                        this._yielded = undefined;
                        return yielded;
                    }
                    return Yield;
                }
            }
        } catch (error) {
            if (!(0, _predicateJs.hasProperty)(current, evaluate)) return exitDie(`MicroFiber.runLoop: Not a valid effect: ${String(current)}`);
            return exitDie(error);
        }
    }
    getCont(symbol) {
        while(true){
            const op = this._stack.pop();
            if (!op) return undefined;
            const cont = op[ensureCont] && op[ensureCont](this);
            if (cont) return {
                [symbol]: cont
            };
            if (op[symbol]) return op;
        }
    }
    // cancel the yielded operation, or for the yielded exit value
    _yielded = undefined;
    yieldWith(value) {
        this._yielded = value;
        return Yield;
    }
    children() {
        return this._children ??= new Set();
    }
}
const fiberMiddleware = /*#__PURE__*/ (0, _globalValueJs.globalValue)("effect/Micro/fiberMiddleware", ()=>({
        interruptChildren: undefined
    }));
const fiberInterruptChildren = (fiber)=>{
    if (fiber._children === undefined || fiber._children.size === 0) return undefined;
    return fiberInterruptAll(fiber._children);
};
const fiberAwait = (self)=>async((resume)=>sync(self.addObserver((exit)=>resume(succeed(exit)))));
const fiberJoin = (self)=>flatten(fiberAwait(self));
const fiberInterrupt = (self)=>suspend(()=>{
        self.unsafeInterrupt();
        return asVoid(fiberAwait(self));
    });
const fiberInterruptAll = (fibers)=>suspend(()=>{
        for (const fiber of fibers)fiber.unsafeInterrupt();
        const iter = fibers[Symbol.iterator]();
        const wait = suspend(()=>{
            let result = iter.next();
            while(!result.done){
                if (result.value.unsafePoll()) {
                    result = iter.next();
                    continue;
                }
                const fiber = result.value;
                return async((resume)=>{
                    fiber.addObserver((_)=>{
                        resume(wait);
                    });
                });
            }
            return exitVoid;
        });
        return wait;
    });
const identifier = /*#__PURE__*/ Symbol.for("effect/Micro/identifier");
const args = /*#__PURE__*/ Symbol.for("effect/Micro/args");
const evaluate = /*#__PURE__*/ Symbol.for("effect/Micro/evaluate");
const successCont = /*#__PURE__*/ Symbol.for("effect/Micro/successCont");
const failureCont = /*#__PURE__*/ Symbol.for("effect/Micro/failureCont");
const ensureCont = /*#__PURE__*/ Symbol.for("effect/Micro/ensureCont");
const Yield = /*#__PURE__*/ Symbol.for("effect/Micro/Yield");
const microVariance = {
    _A: (0, _functionJs.identity),
    _E: (0, _functionJs.identity),
    _R: (0, _functionJs.identity)
};
const MicroProto = {
    ..._effectableJs.EffectPrototype,
    _op: "Micro",
    [TypeId]: microVariance,
    pipe () {
        return (0, _pipeableJs.pipeArguments)(this, arguments);
    },
    [Symbol.iterator] () {
        return new (0, _utilsJs.SingleShotGen)(new (0, _utilsJs.YieldWrap)(this));
    },
    toJSON () {
        return {
            _id: "Micro",
            op: this[identifier],
            ...args in this ? {
                args: this[args]
            } : undefined
        };
    },
    toString () {
        return (0, _inspectableJs.format)(this);
    },
    [(0, _inspectableJs.NodeInspectSymbol)] () {
        return (0, _inspectableJs.format)(this);
    }
};
function defaultEvaluate(_fiber) {
    return exitDie(`Micro.evaluate: Not implemented`);
}
const makePrimitiveProto = (options)=>({
        ...MicroProto,
        [identifier]: options.op,
        [evaluate]: options.eval ?? defaultEvaluate,
        [successCont]: options.contA,
        [failureCont]: options.contE,
        [ensureCont]: options.ensure
    });
const makePrimitive = (options)=>{
    const Proto = makePrimitiveProto(options);
    return function() {
        const self = Object.create(Proto);
        self[args] = options.single === false ? arguments : arguments[0];
        return self;
    };
};
const makeExit = (options)=>{
    const Proto = {
        ...makePrimitiveProto(options),
        [MicroExitTypeId]: MicroExitTypeId,
        _tag: options.op,
        get [options.prop] () {
            return this[args];
        },
        toJSON () {
            return {
                _id: "MicroExit",
                _tag: options.op,
                [options.prop]: this[args]
            };
        },
        [_equalJs.symbol] (that) {
            return isMicroExit(that) && that._tag === options.op && _equalJs.equals(this[args], that[args]);
        },
        [_hashJs.symbol] () {
            return _hashJs.cached(this, _hashJs.combine(_hashJs.string(options.op))(_hashJs.hash(this[args])));
        }
    };
    return function(value) {
        const self = Object.create(Proto);
        self[args] = value;
        self[successCont] = undefined;
        self[failureCont] = undefined;
        self[ensureCont] = undefined;
        return self;
    };
};
const succeed = /*#__PURE__*/ makeExit({
    op: "Success",
    prop: "value",
    eval (fiber) {
        const cont = fiber.getCont(successCont);
        return cont ? cont[successCont](this[args], fiber) : fiber.yieldWith(this);
    }
});
const failCause = /*#__PURE__*/ makeExit({
    op: "Failure",
    prop: "cause",
    eval (fiber) {
        let cont = fiber.getCont(failureCont);
        while(causeIsInterrupt(this[args]) && cont && fiber.interruptible)cont = fiber.getCont(failureCont);
        return cont ? cont[failureCont](this[args], fiber) : fiber.yieldWith(this);
    }
});
const fail = (error)=>failCause(causeFail(error));
const sync = /*#__PURE__*/ makePrimitive({
    op: "Sync",
    eval (fiber) {
        const value = this[args]();
        const cont = fiber.getCont(successCont);
        return cont ? cont[successCont](value, fiber) : fiber.yieldWith(exitSucceed(value));
    }
});
const suspend = /*#__PURE__*/ makePrimitive({
    op: "Suspend",
    eval (_fiber) {
        return this[args]();
    }
});
const yieldNowWith = /*#__PURE__*/ makePrimitive({
    op: "Yield",
    eval (fiber) {
        let resumed = false;
        fiber.getRef(CurrentScheduler).scheduleTask(()=>{
            if (resumed) return;
            fiber.evaluate(exitVoid);
        }, this[args] ?? 0);
        return fiber.yieldWith(()=>{
            resumed = true;
        });
    }
});
const yieldNow = /*#__PURE__*/ yieldNowWith(0);
const succeedSome = (a)=>succeed(_optionJs.some(a));
const succeedNone = /*#__PURE__*/ succeed(/*#__PURE__*/ _optionJs.none());
const failCauseSync = (evaluate)=>suspend(()=>failCause(evaluate()));
const die = (defect)=>exitDie(defect);
const failSync = (error)=>suspend(()=>fail(error()));
const fromOption = (option)=>option._tag === "Some" ? succeed(option.value) : fail(new NoSuchElementException({}));
const fromEither = (either)=>either._tag === "Right" ? succeed(either.right) : fail(either.left);
const void_ = /*#__PURE__*/ succeed(void 0);
const try_ = (options)=>suspend(()=>{
        try {
            return succeed(options.try());
        } catch (err) {
            return fail(options.catch(err));
        }
    });
const promise = (evaluate)=>asyncOptions(function(resume, signal) {
        evaluate(signal).then((a)=>resume(succeed(a)), (e)=>resume(die(e)));
    }, evaluate.length !== 0);
const tryPromise = (options)=>asyncOptions(function(resume, signal) {
        try {
            options.try(signal).then((a)=>resume(succeed(a)), (e)=>resume(fail(options.catch(e))));
        } catch (err) {
            resume(fail(options.catch(err)));
        }
    }, options.try.length !== 0);
const withMicroFiber = /*#__PURE__*/ makePrimitive({
    op: "WithMicroFiber",
    eval (fiber) {
        return this[args](fiber);
    }
});
const yieldFlush = /*#__PURE__*/ withMicroFiber((fiber)=>{
    fiber.getRef(CurrentScheduler).flush();
    return exitVoid;
});
const asyncOptions = /*#__PURE__*/ makePrimitive({
    op: "Async",
    single: false,
    eval (fiber) {
        const register = this[args][0];
        let resumed = false;
        let yielded = false;
        const controller = this[args][1] ? new AbortController() : undefined;
        const onCancel = register((effect)=>{
            if (resumed) return;
            resumed = true;
            if (yielded) fiber.evaluate(effect);
            else yielded = effect;
        }, controller?.signal);
        if (yielded !== false) return yielded;
        yielded = true;
        fiber._yielded = ()=>{
            resumed = true;
        };
        if (controller === undefined && onCancel === undefined) return Yield;
        fiber._stack.push(asyncFinalizer(()=>{
            resumed = true;
            controller?.abort();
            return onCancel ?? exitVoid;
        }));
        return Yield;
    }
});
const asyncFinalizer = /*#__PURE__*/ makePrimitive({
    op: "AsyncFinalizer",
    ensure (fiber) {
        if (fiber.interruptible) {
            fiber.interruptible = false;
            fiber._stack.push(setInterruptible(true));
        }
    },
    contE (cause, _fiber) {
        return causeIsInterrupt(cause) ? flatMap(this[args](), ()=>failCause(cause)) : failCause(cause);
    }
});
const async = (register)=>asyncOptions(register, register.length >= 2);
const never = /*#__PURE__*/ async(function() {
    const interval = setInterval((0, _functionJs.constVoid), 2147483646);
    return sync(()=>clearInterval(interval));
});
const gen = (...args)=>suspend(()=>fromIterator(args.length === 1 ? args[0]() : args[1].call(args[0])));
const fromIterator = /*#__PURE__*/ makePrimitive({
    op: "Iterator",
    contA (value, fiber) {
        const state = this[args].next(value);
        if (state.done) return succeed(state.value);
        fiber._stack.push(this);
        return (0, _utilsJs.yieldWrapGet)(state.value);
    },
    eval (fiber) {
        return this[successCont](undefined, fiber);
    }
});
const as = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, value)=>map(self, (_)=>value));
const asSome = (self)=>map(self, _optionJs.some);
const flip = (self)=>matchEffect(self, {
        onFailure: succeed,
        onSuccess: fail
    });
const andThen = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>flatMap(self, (a)=>{
        const value = isMicro(f) ? f : typeof f === "function" ? f(a) : f;
        return isMicro(value) ? value : succeed(value);
    }));
const tap = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>flatMap(self, (a)=>{
        const value = isMicro(f) ? f : typeof f === "function" ? f(a) : f;
        return isMicro(value) ? as(value, a) : succeed(a);
    }));
const asVoid = (self)=>flatMap(self, (_)=>exitVoid);
const exit = (self)=>matchCause(self, {
        onFailure: exitFailCause,
        onSuccess: exitSucceed
    });
const sandbox = (self)=>catchAllCause(self, fail);
const raceAll = (all)=>withMicroFiber((parent)=>async((resume)=>{
            const effects = _arrayJs.fromIterable(all);
            const len = effects.length;
            let doneCount = 0;
            let done = false;
            const fibers = new Set();
            const causes = [];
            const onExit = (exit)=>{
                doneCount++;
                if (exit._tag === "Failure") {
                    causes.push(exit.cause);
                    if (doneCount >= len) resume(failCause(causes[0]));
                    return;
                }
                done = true;
                resume(fibers.size === 0 ? exit : flatMap(uninterruptible(fiberInterruptAll(fibers)), ()=>exit));
            };
            for(let i = 0; i < len; i++){
                if (done) break;
                const fiber = unsafeFork(parent, interruptible(effects[i]), true, true);
                fibers.add(fiber);
                fiber.addObserver((exit)=>{
                    fibers.delete(fiber);
                    onExit(exit);
                });
            }
            return fiberInterruptAll(fibers);
        }));
const raceAllFirst = (all)=>withMicroFiber((parent)=>async((resume)=>{
            let done = false;
            const fibers = new Set();
            const onExit = (exit)=>{
                done = true;
                resume(fibers.size === 0 ? exit : flatMap(fiberInterruptAll(fibers), ()=>exit));
            };
            for (const effect of all){
                if (done) break;
                const fiber = unsafeFork(parent, interruptible(effect), true, true);
                fibers.add(fiber);
                fiber.addObserver((exit)=>{
                    fibers.delete(fiber);
                    onExit(exit);
                });
            }
            return fiberInterruptAll(fibers);
        }));
const race = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>raceAll([
        self,
        that
    ]));
const raceFirst = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>raceAllFirst([
        self,
        that
    ]));
const flatMap = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>{
    const onSuccess = Object.create(OnSuccessProto);
    onSuccess[args] = self;
    onSuccess[successCont] = f;
    return onSuccess;
});
const OnSuccessProto = /*#__PURE__*/ makePrimitiveProto({
    op: "OnSuccess",
    eval (fiber) {
        fiber._stack.push(this);
        return this[args];
    }
});
const flatten = (self)=>flatMap(self, (0, _functionJs.identity));
const map = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>flatMap(self, (a)=>succeed(f(a))));
const isMicroExit = (u)=>(0, _predicateJs.hasProperty)(u, MicroExitTypeId);
const exitSucceed = succeed;
const exitFailCause = failCause;
const exitInterrupt = /*#__PURE__*/ exitFailCause(/*#__PURE__*/ causeInterrupt());
const exitFail = (e)=>exitFailCause(causeFail(e));
const exitDie = (defect)=>exitFailCause(causeDie(defect));
const exitIsSuccess = (self)=>self._tag === "Success";
const exitIsFailure = (self)=>self._tag === "Failure";
const exitIsInterrupt = (self)=>exitIsFailure(self) && self.cause._tag === "Interrupt";
const exitIsFail = (self)=>exitIsFailure(self) && self.cause._tag === "Fail";
const exitIsDie = (self)=>exitIsFailure(self) && self.cause._tag === "Die";
const exitVoid = /*#__PURE__*/ exitSucceed(void 0);
const exitVoidAll = (exits)=>{
    for (const exit of exits){
        if (exit._tag === "Failure") return exit;
    }
    return exitVoid;
};
const setImmediate = "setImmediate" in globalThis ? globalThis.setImmediate : (f)=>setTimeout(f, 0);
class MicroSchedulerDefault {
    tasks = [];
    running = false;
    /**
   * @since 3.5.9
   */ scheduleTask(task, _priority) {
        this.tasks.push(task);
        if (!this.running) {
            this.running = true;
            setImmediate(this.afterScheduled);
        }
    }
    /**
   * @since 3.5.9
   */ afterScheduled = ()=>{
        this.running = false;
        this.runTasks();
    };
    /**
   * @since 3.5.9
   */ runTasks() {
        const tasks = this.tasks;
        this.tasks = [];
        for(let i = 0, len = tasks.length; i < len; i++)tasks[i]();
    }
    /**
   * @since 3.5.9
   */ shouldYield(fiber) {
        return fiber.currentOpCount >= fiber.getRef(MaxOpsBeforeYield);
    }
    /**
   * @since 3.5.9
   */ flush() {
        while(this.tasks.length > 0)this.runTasks();
    }
}
const service = (tag)=>withMicroFiber((fiber)=>succeed(_contextJs.unsafeGet(fiber.context, tag)));
const serviceOption = (tag)=>withMicroFiber((fiber)=>succeed(_contextJs.getOption(fiber.context, tag)));
const updateContext = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>withMicroFiber((fiber)=>{
        const prev = fiber.context;
        fiber.context = f(prev);
        return onExit(self, ()=>{
            fiber.context = prev;
            return void_;
        });
    }));
const updateService = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, tag, f)=>withMicroFiber((fiber)=>{
        const prev = _contextJs.unsafeGet(fiber.context, tag);
        fiber.context = _contextJs.add(fiber.context, tag, f(prev));
        return onExit(self, ()=>{
            fiber.context = _contextJs.add(fiber.context, tag, prev);
            return void_;
        });
    }));
const context = ()=>getContext;
const getContext = /*#__PURE__*/ withMicroFiber((fiber)=>succeed(fiber.context));
const provideContext = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, provided)=>updateContext(self, _contextJs.merge(provided)));
const provideService = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, tag, service)=>updateContext(self, _contextJs.add(tag, service)));
const provideServiceEffect = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, tag, acquire)=>flatMap(acquire, (service)=>provideService(self, tag, service)));
class MaxOpsBeforeYield extends /*#__PURE__*/ _contextJs.Reference()("effect/Micro/currentMaxOpsBeforeYield", {
    defaultValue: ()=>2048
}) {
}
class CurrentConcurrency extends /*#__PURE__*/ _contextJs.Reference()("effect/Micro/currentConcurrency", {
    defaultValue: ()=>"unbounded"
}) {
}
class CurrentScheduler extends /*#__PURE__*/ _contextJs.Reference()("effect/Micro/currentScheduler", {
    defaultValue: ()=>new MicroSchedulerDefault()
}) {
}
const withConcurrency = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, concurrency)=>provideService(self, CurrentConcurrency, concurrency));
const zip = /*#__PURE__*/ (0, _functionJs.dual)((args)=>isMicro(args[1]), (self, that, options)=>zipWith(self, that, (a, a2)=>[
            a,
            a2
        ], options));
const zipWith = /*#__PURE__*/ (0, _functionJs.dual)((args)=>isMicro(args[1]), (self, that, f, options)=>options?.concurrent ? map(all([
        self,
        that
    ], {
        concurrency: 2
    }), ([a, a2])=>f(a, a2)) : flatMap(self, (a)=>map(that, (a2)=>f(a, a2))));
const filterOrFailCause = /*#__PURE__*/ (0, _functionJs.dual)((args)=>isMicro(args[0]), (self, refinement, orFailWith)=>flatMap(self, (a)=>refinement(a) ? succeed(a) : failCause(orFailWith(a))));
const filterOrFail = /*#__PURE__*/ (0, _functionJs.dual)((args)=>isMicro(args[0]), (self, refinement, orFailWith)=>flatMap(self, (a)=>refinement(a) ? succeed(a) : fail(orFailWith(a))));
const when = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, condition)=>flatMap(isMicro(condition) ? condition : sync(condition), (pass)=>pass ? asSome(self) : succeedNone));
const repeatExit = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, options)=>suspend(()=>{
        const startedAt = options.schedule ? Date.now() : 0;
        let attempt = 0;
        const loop = flatMap(exit(self), (exit)=>{
            if (options.while !== undefined && !options.while(exit)) return exit;
            else if (options.times !== undefined && attempt >= options.times) return exit;
            attempt++;
            let delayEffect = yieldNow;
            if (options.schedule !== undefined) {
                const elapsed = Date.now() - startedAt;
                const duration = options.schedule(attempt, elapsed);
                if (_optionJs.isNone(duration)) return exit;
                delayEffect = sleep(duration.value);
            }
            return flatMap(delayEffect, ()=>loop);
        });
        return loop;
    }));
const repeat = /*#__PURE__*/ (0, _functionJs.dual)((args)=>isMicro(args[0]), (self, options)=>repeatExit(self, {
        ...options,
        while: (exit)=>exit._tag === "Success" && (options?.while === undefined || options.while(exit.value))
    }));
const replicate = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, n)=>Array.from({
        length: n
    }, ()=>self));
const replicateEffect = /*#__PURE__*/ (0, _functionJs.dual)((args)=>isMicro(args[0]), (self, n, options)=>all(replicate(self, n), options));
const forever = (self)=>repeat(self);
const scheduleRecurs = (n)=>(attempt)=>attempt <= n ? _optionJs.some(0) : _optionJs.none();
const scheduleSpaced = (millis)=>()=>_optionJs.some(millis);
const scheduleExponential = (baseMillis, factor = 2)=>(attempt)=>_optionJs.some(Math.pow(factor, attempt) * baseMillis);
const scheduleAddDelay = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>(attempt, elapsed)=>_optionJs.map(self(attempt, elapsed), (duration)=>duration + f()));
const scheduleWithMaxDelay = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, max)=>(attempt, elapsed)=>_optionJs.map(self(attempt, elapsed), (duration)=>Math.min(duration, max)));
const scheduleWithMaxElapsed = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, max)=>(attempt, elapsed)=>elapsed < max ? self(attempt, elapsed) : _optionJs.none());
const scheduleUnion = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>(attempt, elapsed)=>_optionJs.zipWith(self(attempt, elapsed), that(attempt, elapsed), (d1, d2)=>Math.min(d1, d2)));
const scheduleIntersect = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>(attempt, elapsed)=>_optionJs.zipWith(self(attempt, elapsed), that(attempt, elapsed), (d1, d2)=>Math.max(d1, d2)));
const catchAllCause = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>{
    const onFailure = Object.create(OnFailureProto);
    onFailure[args] = self;
    onFailure[failureCont] = f;
    return onFailure;
});
const OnFailureProto = /*#__PURE__*/ makePrimitiveProto({
    op: "OnFailure",
    eval (fiber) {
        fiber._stack.push(this);
        return this[args];
    }
});
const catchCauseIf = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, predicate, f)=>catchAllCause(self, (cause)=>predicate(cause) ? f(cause) : failCause(cause)));
const catchAll = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>catchCauseIf(self, causeIsFail, (cause)=>f(cause.error)));
const catchAllDefect = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>catchCauseIf(self, causeIsDie, (die)=>f(die.defect)));
const tapErrorCause = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>tapErrorCauseIf(self, (0, _functionJs.constTrue), f));
const tapErrorCauseIf = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, refinement, f)=>catchCauseIf(self, refinement, (cause)=>andThen(f(cause), failCause(cause))));
const tapError = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>tapErrorCauseIf(self, causeIsFail, (fail)=>f(fail.error)));
const tapDefect = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>tapErrorCauseIf(self, causeIsDie, (die)=>f(die.defect)));
const catchIf = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, predicate, f)=>catchCauseIf(self, (f)=>causeIsFail(f) && predicate(f.error), (fail)=>f(fail.error)));
const catchTag = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, k, f)=>catchIf(self, (0, _predicateJs.isTagged)(k), f));
const mapErrorCause = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>catchAllCause(self, (cause)=>failCause(f(cause))));
const mapError = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>catchAll(self, (error)=>fail(f(error))));
const orDie = (self)=>catchAll(self, die);
const orElseSucceed = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>catchAll(self, (_)=>sync(f)));
const ignore = (self)=>matchEffect(self, {
        onFailure: (_)=>void_,
        onSuccess: (_)=>void_
    });
const ignoreLogged = (self)=>matchEffect(self, {
        // eslint-disable-next-line no-console
        onFailure: (error)=>sync(()=>console.error(error)),
        onSuccess: (_)=>void_
    });
const option = (self)=>match(self, {
        onFailure: _optionJs.none,
        onSuccess: _optionJs.some
    });
const either = (self)=>match(self, {
        onFailure: _eitherJs.left,
        onSuccess: _eitherJs.right
    });
const retry = /*#__PURE__*/ (0, _functionJs.dual)((args)=>isMicro(args[0]), (self, options)=>repeatExit(self, {
        ...options,
        while: (exit)=>exit._tag === "Failure" && exit.cause._tag === "Fail" && (options?.while === undefined || options.while(exit.cause.error))
    }));
const withTrace = function() {
    const prevLimit = globalThis.Error.stackTraceLimit;
    globalThis.Error.stackTraceLimit = 2;
    const error = new globalThis.Error();
    globalThis.Error.stackTraceLimit = prevLimit;
    function generate(name, cause) {
        const stack = error.stack;
        if (!stack) return cause;
        const line = stack.split("\n")[2]?.trim().replace(/^at /, "");
        if (!line) return cause;
        const lineMatch = line.match(/\((.*)\)$/);
        return causeWithTrace(cause, `at ${name} (${lineMatch ? lineMatch[1] : line})`);
    }
    const f = (name)=>(self)=>onError(self, (cause)=>failCause(generate(name, cause)));
    if (arguments.length === 2) return f(arguments[1])(arguments[0]);
    return f(arguments[0]);
};
const matchCauseEffect = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, options)=>{
    const primitive = Object.create(OnSuccessAndFailureProto);
    primitive[args] = self;
    primitive[successCont] = options.onSuccess;
    primitive[failureCont] = options.onFailure;
    return primitive;
});
const OnSuccessAndFailureProto = /*#__PURE__*/ makePrimitiveProto({
    op: "OnSuccessAndFailure",
    eval (fiber) {
        fiber._stack.push(this);
        return this[args];
    }
});
const matchCause = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, options)=>matchCauseEffect(self, {
        onFailure: (cause)=>sync(()=>options.onFailure(cause)),
        onSuccess: (value)=>sync(()=>options.onSuccess(value))
    }));
const matchEffect = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, options)=>matchCauseEffect(self, {
        onFailure: (cause)=>cause._tag === "Fail" ? options.onFailure(cause.error) : failCause(cause),
        onSuccess: options.onSuccess
    }));
const match = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, options)=>matchEffect(self, {
        onFailure: (error)=>sync(()=>options.onFailure(error)),
        onSuccess: (value)=>sync(()=>options.onSuccess(value))
    }));
const sleep = (millis)=>async((resume)=>{
        const timeout = setTimeout(()=>{
            resume(void_);
        }, millis);
        return sync(()=>{
            clearTimeout(timeout);
        });
    });
const delay = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, millis)=>andThen(sleep(millis), self));
const timeoutOrElse = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, options)=>raceFirst(self, andThen(interruptible(sleep(options.duration)), options.onTimeout)));
const timeout = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, millis)=>timeoutOrElse(self, {
        duration: millis,
        onTimeout: ()=>fail(new TimeoutException())
    }));
const timeoutOption = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, millis)=>raceFirst(asSome(self), as(interruptible(sleep(millis)), _optionJs.none())));
const MicroScopeTypeId = /*#__PURE__*/ Symbol.for("effect/Micro/MicroScope");
const MicroScope = /*#__PURE__*/ _contextJs.GenericTag("effect/Micro/MicroScope");
class MicroScopeImpl {
    [MicroScopeTypeId];
    state = {
        _tag: "Open",
        finalizers: /*#__PURE__*/ new Set()
    };
    constructor(){
        this[MicroScopeTypeId] = MicroScopeTypeId;
    }
    unsafeAddFinalizer(finalizer) {
        if (this.state._tag === "Open") this.state.finalizers.add(finalizer);
    }
    addFinalizer(finalizer) {
        return suspend(()=>{
            if (this.state._tag === "Open") {
                this.state.finalizers.add(finalizer);
                return void_;
            }
            return finalizer(this.state.exit);
        });
    }
    unsafeRemoveFinalizer(finalizer) {
        if (this.state._tag === "Open") this.state.finalizers.delete(finalizer);
    }
    close(microExit) {
        return suspend(()=>{
            if (this.state._tag === "Open") {
                const finalizers = Array.from(this.state.finalizers).reverse();
                this.state = {
                    _tag: "Closed",
                    exit: microExit
                };
                return flatMap(forEach(finalizers, (finalizer)=>exit(finalizer(microExit))), exitVoidAll);
            }
            return void_;
        });
    }
    get fork() {
        return sync(()=>{
            const newScope = new MicroScopeImpl();
            if (this.state._tag === "Closed") {
                newScope.state = this.state;
                return newScope;
            }
            function fin(exit) {
                return newScope.close(exit);
            }
            this.state.finalizers.add(fin);
            newScope.unsafeAddFinalizer((_)=>sync(()=>this.unsafeRemoveFinalizer(fin)));
            return newScope;
        });
    }
}
const scopeMake = /*#__PURE__*/ sync(()=>new MicroScopeImpl());
const scopeUnsafeMake = ()=>new MicroScopeImpl();
const scope = /*#__PURE__*/ service(MicroScope);
const provideScope = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, scope)=>provideService(self, MicroScope, scope));
const scoped = (self)=>suspend(()=>{
        const scope = new MicroScopeImpl();
        return onExit(provideService(self, MicroScope, scope), (exit)=>scope.close(exit));
    });
const acquireRelease = (acquire, release)=>uninterruptible(flatMap(scope, (scope)=>tap(acquire, (a)=>scope.addFinalizer((exit)=>release(a, exit)))));
const addFinalizer = (finalizer)=>flatMap(scope, (scope)=>scope.addFinalizer(finalizer));
const onExit = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>uninterruptibleMask((restore)=>matchCauseEffect(restore(self), {
            onFailure: (cause)=>flatMap(f(exitFailCause(cause)), ()=>failCause(cause)),
            onSuccess: (a)=>flatMap(f(exitSucceed(a)), ()=>succeed(a))
        })));
const ensuring = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, finalizer)=>onExit(self, (_)=>finalizer));
const onExitIf = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, refinement, f)=>onExit(self, (exit)=>refinement(exit) ? f(exit) : exitVoid));
const onError = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>onExitIf(self, exitIsFailure, (exit)=>f(exit.cause)));
const onInterrupt = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, finalizer)=>onExitIf(self, exitIsInterrupt, (_)=>finalizer));
const acquireUseRelease = (acquire, use, release)=>uninterruptibleMask((restore)=>flatMap(acquire, (a)=>flatMap(exit(restore(use(a))), (exit)=>andThen(release(a, exit), exit))));
const interrupt = /*#__PURE__*/ failCause(/*#__PURE__*/ causeInterrupt());
const uninterruptible = (self)=>withMicroFiber((fiber)=>{
        if (!fiber.interruptible) return self;
        fiber.interruptible = false;
        fiber._stack.push(setInterruptible(true));
        return self;
    });
const setInterruptible = /*#__PURE__*/ makePrimitive({
    op: "SetInterruptible",
    ensure (fiber) {
        fiber.interruptible = this[args];
        if (fiber._interrupted && fiber.interruptible) return ()=>exitInterrupt;
    }
});
const interruptible = (self)=>withMicroFiber((fiber)=>{
        if (fiber.interruptible) return self;
        fiber.interruptible = true;
        fiber._stack.push(setInterruptible(false));
        if (fiber._interrupted) return exitInterrupt;
        return self;
    });
const uninterruptibleMask = (f)=>withMicroFiber((fiber)=>{
        if (!fiber.interruptible) return f((0, _functionJs.identity));
        fiber.interruptible = false;
        fiber._stack.push(setInterruptible(true));
        return f(interruptible);
    });
const all = (arg, options)=>{
    if (Array.isArray(arg) || (0, _predicateJs.isIterable)(arg)) return forEach(arg, (0, _functionJs.identity), options);
    else if (options?.discard) return forEach(Object.values(arg), (0, _functionJs.identity), options);
    return suspend(()=>{
        const out = {};
        return as(forEach(Object.entries(arg), ([key, effect])=>map(effect, (value)=>{
                out[key] = value;
            }), {
            discard: true,
            concurrency: options?.concurrency
        }), out);
    });
};
const whileLoop = /*#__PURE__*/ makePrimitive({
    op: "While",
    contA (value, fiber) {
        this[args].step(value);
        if (this[args].while()) {
            fiber._stack.push(this);
            return this[args].body();
        }
        return exitVoid;
    },
    eval (fiber) {
        if (this[args].while()) {
            fiber._stack.push(this);
            return this[args].body();
        }
        return exitVoid;
    }
});
const forEach = (iterable, f, options)=>withMicroFiber((parent)=>{
        const concurrencyOption = options?.concurrency === "inherit" ? parent.getRef(CurrentConcurrency) : options?.concurrency ?? 1;
        const concurrency = concurrencyOption === "unbounded" ? Number.POSITIVE_INFINITY : Math.max(1, concurrencyOption);
        const items = _arrayJs.fromIterable(iterable);
        let length = items.length;
        if (length === 0) return options?.discard ? void_ : succeed([]);
        const out = options?.discard ? undefined : new Array(length);
        let index = 0;
        if (concurrency === 1) return as(whileLoop({
            while: ()=>index < items.length,
            body: ()=>f(items[index], index),
            step: out ? (b)=>out[index++] = b : (_)=>index++
        }), out);
        return async((resume)=>{
            const fibers = new Set();
            let result = undefined;
            let inProgress = 0;
            let doneCount = 0;
            let pumping = false;
            let interrupted = false;
            function pump() {
                pumping = true;
                while(inProgress < concurrency && index < length){
                    const currentIndex = index;
                    const item = items[currentIndex];
                    index++;
                    inProgress++;
                    try {
                        const child = unsafeFork(parent, f(item, currentIndex), true, true);
                        fibers.add(child);
                        child.addObserver((exit)=>{
                            fibers.delete(child);
                            if (interrupted) return;
                            else if (exit._tag === "Failure") {
                                if (result === undefined) {
                                    result = exit;
                                    length = index;
                                    fibers.forEach((fiber)=>fiber.unsafeInterrupt());
                                }
                            } else if (out !== undefined) out[currentIndex] = exit.value;
                            doneCount++;
                            inProgress--;
                            if (doneCount === length) resume(result ?? succeed(out));
                            else if (!pumping && inProgress < concurrency) pump();
                        });
                    } catch (err) {
                        result = exitDie(err);
                        length = index;
                        fibers.forEach((fiber)=>fiber.unsafeInterrupt());
                    }
                }
                pumping = false;
            }
            pump();
            return suspend(()=>{
                interrupted = true;
                index = length;
                return fiberInterruptAll(fibers);
            });
        });
    });
const filter = (iterable, f, options)=>filterMap(iterable, (a)=>map(f(a), (pass)=>{
            pass = options?.negate ? !pass : pass;
            return pass ? _optionJs.some(a) : _optionJs.none();
        }), options);
const filterMap = (iterable, f, options)=>suspend(()=>{
        const out = [];
        return as(forEach(iterable, (a)=>map(f(a), (o)=>{
                if (o._tag === "Some") out.push(o.value);
            }), {
            discard: true,
            concurrency: options?.concurrency
        }), out);
    });
const Do = /*#__PURE__*/ succeed({});
const bindTo = /*#__PURE__*/ _doNotationJs.bindTo(map);
const bind = /*#__PURE__*/ _doNotationJs.bind(map, flatMap);
const let_ = /*#__PURE__*/ _doNotationJs.let_(map);
const fork = (self)=>withMicroFiber((fiber)=>{
        fiberMiddleware.interruptChildren ??= fiberInterruptChildren;
        return succeed(unsafeFork(fiber, self));
    });
const unsafeFork = (parent, effect, immediate = false, daemon = false)=>{
    const child = new MicroFiberImpl(parent.context, parent.interruptible);
    if (!daemon) {
        parent.children().add(child);
        child.addObserver(()=>parent.children().delete(child));
    }
    if (immediate) child.evaluate(effect);
    else parent.getRef(CurrentScheduler).scheduleTask(()=>child.evaluate(effect), 0);
    return child;
};
const forkDaemon = (self)=>withMicroFiber((fiber)=>succeed(unsafeFork(fiber, self, false, true)));
const forkIn = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, scope)=>uninterruptibleMask((restore)=>flatMap(scope.fork, (scope)=>tap(restore(forkDaemon(onExit(self, (exit)=>scope.close(exit)))), (fiber)=>scope.addFinalizer((_)=>fiberInterrupt(fiber))))));
const forkScoped = (self)=>flatMap(scope, (scope)=>forkIn(self, scope));
const runFork = (effect, options)=>{
    const fiber = new MicroFiberImpl(CurrentScheduler.context(options?.scheduler ?? new MicroSchedulerDefault()));
    fiber.evaluate(effect);
    if (options?.signal) {
        if (options.signal.aborted) fiber.unsafeInterrupt();
        else {
            const abort = ()=>fiber.unsafeInterrupt();
            options.signal.addEventListener("abort", abort, {
                once: true
            });
            fiber.addObserver(()=>options.signal.removeEventListener("abort", abort));
        }
    }
    return fiber;
};
const runPromiseExit = (effect, options)=>new Promise((resolve, _reject)=>{
        const handle = runFork(effect, options);
        handle.addObserver(resolve);
    });
const runPromise = (effect, options)=>runPromiseExit(effect, options).then((exit)=>{
        if (exit._tag === "Failure") throw exit.cause;
        return exit.value;
    });
const runSyncExit = (effect)=>{
    const scheduler = new MicroSchedulerDefault();
    const fiber = runFork(effect, {
        scheduler
    });
    scheduler.flush();
    return fiber._exit ?? exitDie(fiber);
};
const runSync = (effect)=>{
    const exit = runSyncExit(effect);
    if (exit._tag === "Failure") throw exit.cause;
    return exit.value;
};
const YieldableError = /*#__PURE__*/ function() {
    class YieldableError extends globalThis.Error {
    }
    Object.assign(YieldableError.prototype, MicroProto, (0, _effectableJs1.StructuralPrototype), {
        [identifier]: "Failure",
        [evaluate] () {
            return fail(this);
        },
        toString () {
            return this.message ? `${this.name}: ${this.message}` : this.name;
        },
        toJSON () {
            return {
                ...this
            };
        },
        [(0, _inspectableJs.NodeInspectSymbol)] () {
            const stack = this.stack;
            if (stack) return `${this.toString()}\n${stack.split("\n").slice(1).join("\n")}`;
            return this.toString();
        }
    });
    return YieldableError;
}();
const Error = /*#__PURE__*/ function() {
    return class extends YieldableError {
        constructor(args){
            super();
            if (args) Object.assign(this, args);
        }
    };
}();
const TaggedError = (tag)=>{
    class Base extends Error {
        _tag = tag;
    }
    Base.prototype.name = tag;
    return Base;
};
class NoSuchElementException extends /*#__PURE__*/ TaggedError("NoSuchElementException") {
}
class TimeoutException extends /*#__PURE__*/ TaggedError("TimeoutException") {
}

},{"./Array.js":"8L2Gk","./Context.js":"c2abN","./Effectable.js":"kxbGz","./Either.js":"4amnT","./Equal.js":"gA0qD","./Function.js":"21gOL","./GlobalValue.js":"5w3Hn","./Hash.js":"gFMwE","./Inspectable.js":"1Ur70","./internal/context.js":"g5r35","./internal/doNotation.js":"6eyzd","./internal/effectable.js":"8EvvU","./Option.js":"6sHA7","./Pipeable.js":"b5RU2","./Predicate.js":"gW5pd","./Utils.js":"dYvz1","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"hR5Dj":[function(require,module,exports,__globalThis) {
/**
 * @since 2.0.0
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @since 2.0.0
 * @category utils
 */ parcelHelpers.export(exports, "PriorityBuckets", ()=>PriorityBuckets);
/**
 * @since 2.0.0
 * @category constructors
 */ parcelHelpers.export(exports, "MixedScheduler", ()=>MixedScheduler);
parcelHelpers.export(exports, "defaultScheduler", ()=>defaultScheduler);
/**
 * @since 2.0.0
 * @category constructors
 */ parcelHelpers.export(exports, "SyncScheduler", ()=>SyncScheduler);
/**
 * @since 2.0.0
 * @category constructors
 */ parcelHelpers.export(exports, "ControlledScheduler", ()=>ControlledScheduler);
parcelHelpers.export(exports, "makeMatrix", ()=>makeMatrix);
parcelHelpers.export(exports, "defaultShouldYield", ()=>defaultShouldYield);
parcelHelpers.export(exports, "make", ()=>make);
parcelHelpers.export(exports, "makeBatched", ()=>makeBatched);
parcelHelpers.export(exports, "timer", ()=>timer);
parcelHelpers.export(exports, "timerBatched", ()=>timerBatched);
parcelHelpers.export(exports, "currentScheduler", ()=>currentScheduler);
parcelHelpers.export(exports, "withScheduler", ()=>withScheduler);
var _functionJs = require("./Function.js");
var _globalValueJs = require("./GlobalValue.js");
var _coreJs = require("./internal/core.js");
class PriorityBuckets {
    /**
   * @since 2.0.0
   */ buckets = [];
    /**
   * @since 2.0.0
   */ scheduleTask(task, priority) {
        const length = this.buckets.length;
        let bucket = undefined;
        let index = 0;
        for(; index < length; index++){
            if (this.buckets[index][0] <= priority) bucket = this.buckets[index];
            else break;
        }
        if (bucket && bucket[0] === priority) bucket[1].push(task);
        else if (index === length) this.buckets.push([
            priority,
            [
                task
            ]
        ]);
        else this.buckets.splice(index, 0, [
            priority,
            [
                task
            ]
        ]);
    }
}
class MixedScheduler {
    maxNextTickBeforeTimer;
    /**
   * @since 2.0.0
   */ running = false;
    /**
   * @since 2.0.0
   */ tasks = /*#__PURE__*/ new PriorityBuckets();
    constructor(/**
   * @since 2.0.0
   */ maxNextTickBeforeTimer){
        this.maxNextTickBeforeTimer = maxNextTickBeforeTimer;
    }
    /**
   * @since 2.0.0
   */ starveInternal(depth) {
        const tasks = this.tasks.buckets;
        this.tasks.buckets = [];
        for (const [_, toRun] of tasks)for(let i = 0; i < toRun.length; i++)toRun[i]();
        if (this.tasks.buckets.length === 0) this.running = false;
        else this.starve(depth);
    }
    /**
   * @since 2.0.0
   */ starve(depth = 0) {
        if (depth >= this.maxNextTickBeforeTimer) setTimeout(()=>this.starveInternal(0), 0);
        else Promise.resolve(void 0).then(()=>this.starveInternal(depth + 1));
    }
    /**
   * @since 2.0.0
   */ shouldYield(fiber) {
        return fiber.currentOpCount > fiber.getFiberRef(_coreJs.currentMaxOpsBeforeYield) ? fiber.getFiberRef(_coreJs.currentSchedulingPriority) : false;
    }
    /**
   * @since 2.0.0
   */ scheduleTask(task, priority) {
        this.tasks.scheduleTask(task, priority);
        if (!this.running) {
            this.running = true;
            this.starve();
        }
    }
}
const defaultScheduler = /*#__PURE__*/ (0, _globalValueJs.globalValue)(/*#__PURE__*/ Symbol.for("effect/Scheduler/defaultScheduler"), ()=>new MixedScheduler(2048));
class SyncScheduler {
    /**
   * @since 2.0.0
   */ tasks = /*#__PURE__*/ new PriorityBuckets();
    /**
   * @since 2.0.0
   */ deferred = false;
    /**
   * @since 2.0.0
   */ scheduleTask(task, priority) {
        if (this.deferred) defaultScheduler.scheduleTask(task, priority);
        else this.tasks.scheduleTask(task, priority);
    }
    /**
   * @since 2.0.0
   */ shouldYield(fiber) {
        return fiber.currentOpCount > fiber.getFiberRef(_coreJs.currentMaxOpsBeforeYield) ? fiber.getFiberRef(_coreJs.currentSchedulingPriority) : false;
    }
    /**
   * @since 2.0.0
   */ flush() {
        while(this.tasks.buckets.length > 0){
            const tasks = this.tasks.buckets;
            this.tasks.buckets = [];
            for (const [_, toRun] of tasks)for(let i = 0; i < toRun.length; i++)toRun[i]();
        }
        this.deferred = true;
    }
}
class ControlledScheduler {
    /**
   * @since 2.0.0
   */ tasks = /*#__PURE__*/ new PriorityBuckets();
    /**
   * @since 2.0.0
   */ deferred = false;
    /**
   * @since 2.0.0
   */ scheduleTask(task, priority) {
        if (this.deferred) defaultScheduler.scheduleTask(task, priority);
        else this.tasks.scheduleTask(task, priority);
    }
    /**
   * @since 2.0.0
   */ shouldYield(fiber) {
        return fiber.currentOpCount > fiber.getFiberRef(_coreJs.currentMaxOpsBeforeYield) ? fiber.getFiberRef(_coreJs.currentSchedulingPriority) : false;
    }
    /**
   * @since 2.0.0
   */ step() {
        const tasks = this.tasks.buckets;
        this.tasks.buckets = [];
        for (const [_, toRun] of tasks)for(let i = 0; i < toRun.length; i++)toRun[i]();
    }
}
const makeMatrix = (...record)=>{
    const index = record.sort(([p0], [p1])=>p0 < p1 ? -1 : p0 > p1 ? 1 : 0);
    return {
        shouldYield (fiber) {
            for (const scheduler of record){
                const priority = scheduler[1].shouldYield(fiber);
                if (priority !== false) return priority;
            }
            return false;
        },
        scheduleTask (task, priority) {
            let scheduler = undefined;
            for (const i of index){
                if (priority >= i[0]) scheduler = i[1];
                else return (scheduler ?? defaultScheduler).scheduleTask(task, priority);
            }
            return (scheduler ?? defaultScheduler).scheduleTask(task, priority);
        }
    };
};
const defaultShouldYield = (fiber)=>{
    return fiber.currentOpCount > fiber.getFiberRef(_coreJs.currentMaxOpsBeforeYield) ? fiber.getFiberRef(_coreJs.currentSchedulingPriority) : false;
};
const make = (scheduleTask, shouldYield = defaultShouldYield)=>({
        scheduleTask,
        shouldYield
    });
const makeBatched = (callback, shouldYield = defaultShouldYield)=>{
    let running = false;
    const tasks = new PriorityBuckets();
    const starveInternal = ()=>{
        const tasksToRun = tasks.buckets;
        tasks.buckets = [];
        for (const [_, toRun] of tasksToRun)for(let i = 0; i < toRun.length; i++)toRun[i]();
        if (tasks.buckets.length === 0) running = false;
        else starve();
    };
    const starve = ()=>callback(starveInternal);
    return make((task, priority)=>{
        tasks.scheduleTask(task, priority);
        if (!running) {
            running = true;
            starve();
        }
    }, shouldYield);
};
const timer = (ms, shouldYield = defaultShouldYield)=>make((task)=>setTimeout(task, ms), shouldYield);
const timerBatched = (ms, shouldYield = defaultShouldYield)=>makeBatched((task)=>setTimeout(task, ms), shouldYield);
const currentScheduler = /*#__PURE__*/ (0, _globalValueJs.globalValue)(/*#__PURE__*/ Symbol.for("effect/FiberRef/currentScheduler"), ()=>_coreJs.fiberRefUnsafeMake(defaultScheduler));
const withScheduler = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, scheduler)=>_coreJs.fiberRefLocally(self, currentScheduler, scheduler));

},{"./Function.js":"21gOL","./GlobalValue.js":"5w3Hn","./internal/core.js":"cr3YV","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"dFrk6":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "currentRequestMap", ()=>currentRequestMap);
var _globalValueJs = require("../GlobalValue.js");
var _coreJs = require("./core.js");
const currentRequestMap = /*#__PURE__*/ (0, _globalValueJs.globalValue)(/*#__PURE__*/ Symbol.for("effect/FiberRef/currentRequestMap"), ()=>(0, _coreJs.fiberRefUnsafeMake)(new Map()));

},{"../GlobalValue.js":"5w3Hn","./core.js":"cr3YV","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"TC4N9":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "match", ()=>match);
parcelHelpers.export(exports, "matchSimple", ()=>matchSimple);
var _coreJs = require("./core.js");
const match = (concurrency, sequential, unbounded, bounded)=>{
    switch(concurrency){
        case undefined:
            return sequential();
        case "unbounded":
            return unbounded();
        case "inherit":
            return _coreJs.fiberRefGetWith(_coreJs.currentConcurrency, (concurrency)=>concurrency === "unbounded" ? unbounded() : concurrency > 1 ? bounded(concurrency) : sequential());
        default:
            return concurrency > 1 ? bounded(concurrency) : sequential();
    }
};
const matchSimple = (concurrency, sequential, concurrent)=>{
    switch(concurrency){
        case undefined:
            return sequential();
        case "unbounded":
            return concurrent();
        case "inherit":
            return _coreJs.fiberRefGetWith(_coreJs.currentConcurrency, (concurrency)=>concurrency === "unbounded" || concurrency > 1 ? concurrent() : sequential());
        default:
            return concurrency > 1 ? concurrent() : sequential();
    }
};

},{"./core.js":"cr3YV","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"65P25":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FiberTypeId", ()=>FiberTypeId);
parcelHelpers.export(exports, "fiberVariance", ()=>fiberVariance);
parcelHelpers.export(exports, "RuntimeFiberTypeId", ()=>RuntimeFiberTypeId);
parcelHelpers.export(exports, "Order", ()=>Order);
parcelHelpers.export(exports, "isFiber", ()=>isFiber);
parcelHelpers.export(exports, "isRuntimeFiber", ()=>isRuntimeFiber);
parcelHelpers.export(exports, "_await", ()=>_await);
parcelHelpers.export(exports, "children", ()=>children);
parcelHelpers.export(exports, "done", ()=>done);
parcelHelpers.export(exports, "dump", ()=>dump);
parcelHelpers.export(exports, "dumpAll", ()=>dumpAll);
parcelHelpers.export(exports, "fail", ()=>fail);
parcelHelpers.export(exports, "failCause", ()=>failCause);
parcelHelpers.export(exports, "fromEffect", ()=>fromEffect);
parcelHelpers.export(exports, "id", ()=>id);
parcelHelpers.export(exports, "inheritAll", ()=>inheritAll);
parcelHelpers.export(exports, "interrupted", ()=>interrupted);
parcelHelpers.export(exports, "interruptAll", ()=>interruptAll);
parcelHelpers.export(exports, "interruptAllAs", ()=>interruptAllAs);
parcelHelpers.export(exports, "interruptAsFork", ()=>interruptAsFork);
parcelHelpers.export(exports, "join", ()=>join);
parcelHelpers.export(exports, "map", ()=>map);
parcelHelpers.export(exports, "mapEffect", ()=>mapEffect);
parcelHelpers.export(exports, "mapFiber", ()=>mapFiber);
parcelHelpers.export(exports, "match", ()=>match);
parcelHelpers.export(exports, "never", ()=>never);
parcelHelpers.export(exports, "orElse", ()=>orElse);
parcelHelpers.export(exports, "orElseEither", ()=>orElseEither);
parcelHelpers.export(exports, "poll", ()=>poll);
parcelHelpers.export(exports, "pretty", ()=>pretty);
parcelHelpers.export(exports, "unsafeRoots", ()=>unsafeRoots);
parcelHelpers.export(exports, "roots", ()=>roots);
parcelHelpers.export(exports, "status", ()=>status);
parcelHelpers.export(exports, "succeed", ()=>succeed);
parcelHelpers.export(exports, "void", ()=>void_);
parcelHelpers.export(exports, "currentFiberURI", ()=>currentFiberURI);
parcelHelpers.export(exports, "getCurrentFiber", ()=>getCurrentFiber);
var _clockJs = require("../Clock.js");
var _eitherJs = require("../Either.js");
var _exitJs = require("../Exit.js");
var _fiberIdJs = require("../FiberId.js");
var _fiberStatusJs = require("../FiberStatus.js");
var _functionJs = require("../Function.js");
var _hashSetJs = require("../HashSet.js");
var _numberJs = require("../Number.js");
var _optionJs = require("../Option.js");
var _orderJs = require("../Order.js");
var _pipeableJs = require("../Pipeable.js");
var _predicateJs = require("../Predicate.js");
var _coreJs = require("./core.js");
var _effectableJs = require("./effectable.js");
var _fiberScopeJs = require("./fiberScope.js");
var _runtimeFlagsJs = require("./runtimeFlags.js");
/** @internal */ const FiberSymbolKey = "effect/Fiber";
const FiberTypeId = /*#__PURE__*/ Symbol.for(FiberSymbolKey);
const fiberVariance = {
    /* c8 ignore next */ _E: (_)=>_,
    /* c8 ignore next */ _A: (_)=>_
};
/** @internal */ const fiberProto = {
    [FiberTypeId]: fiberVariance,
    pipe () {
        return (0, _pipeableJs.pipeArguments)(this, arguments);
    }
};
/** @internal */ const RuntimeFiberSymbolKey = "effect/Fiber";
const RuntimeFiberTypeId = /*#__PURE__*/ Symbol.for(RuntimeFiberSymbolKey);
const Order = /*#__PURE__*/ (0, _functionJs.pipe)(/*#__PURE__*/ _orderJs.tuple(_numberJs.Order, _numberJs.Order), /*#__PURE__*/ _orderJs.mapInput((fiber)=>[
        fiber.id().startTimeMillis,
        fiber.id().id
    ]));
const isFiber = (u)=>(0, _predicateJs.hasProperty)(u, FiberTypeId);
const isRuntimeFiber = (self)=>RuntimeFiberTypeId in self;
const _await = (self)=>self.await;
const children = (self)=>self.children;
const done = (exit)=>{
    const _fiber = {
        ..._effectableJs.CommitPrototype,
        commit () {
            return join(this);
        },
        ...fiberProto,
        id: ()=>_fiberIdJs.none,
        await: _coreJs.succeed(exit),
        children: _coreJs.succeed([]),
        inheritAll: _coreJs.void,
        poll: _coreJs.succeed(_optionJs.some(exit)),
        interruptAsFork: ()=>_coreJs.void
    };
    return _fiber;
};
const dump = (self)=>_coreJs.map(self.status, (status)=>({
            id: self.id(),
            status
        }));
const dumpAll = (fibers)=>_coreJs.forEachSequential(fibers, dump);
const fail = (error)=>done(_exitJs.fail(error));
const failCause = (cause)=>done(_exitJs.failCause(cause));
const fromEffect = (effect)=>_coreJs.map(_coreJs.exit(effect), done);
const id = (self)=>self.id();
const inheritAll = (self)=>self.inheritAll;
const interrupted = (fiberId)=>done(_exitJs.interrupt(fiberId));
const interruptAll = (fibers)=>_coreJs.flatMap(_coreJs.fiberId, (fiberId)=>(0, _functionJs.pipe)(fibers, interruptAllAs(fiberId)));
const interruptAllAs = /*#__PURE__*/ (0, _functionJs.dual)(2, (fibers, fiberId)=>(0, _functionJs.pipe)(_coreJs.forEachSequentialDiscard(fibers, interruptAsFork(fiberId)), _coreJs.zipRight((0, _functionJs.pipe)(fibers, _coreJs.forEachSequentialDiscard(_await)))));
const interruptAsFork = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, fiberId)=>self.interruptAsFork(fiberId));
const join = (self)=>_coreJs.zipLeft(_coreJs.flatten(self.await), self.inheritAll);
const map = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>mapEffect(self, (a)=>_coreJs.sync(()=>f(a))));
const mapEffect = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>{
    const _fiber = {
        ..._effectableJs.CommitPrototype,
        commit () {
            return join(this);
        },
        ...fiberProto,
        id: ()=>self.id(),
        await: _coreJs.flatMap(self.await, _exitJs.forEachEffect(f)),
        children: self.children,
        inheritAll: self.inheritAll,
        poll: _coreJs.flatMap(self.poll, (result)=>{
            switch(result._tag){
                case "None":
                    return _coreJs.succeed(_optionJs.none());
                case "Some":
                    return (0, _functionJs.pipe)(_exitJs.forEachEffect(result.value, f), _coreJs.map(_optionJs.some));
            }
        }),
        interruptAsFork: (id)=>self.interruptAsFork(id)
    };
    return _fiber;
});
const mapFiber = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>_coreJs.map(self.await, _exitJs.match({
        onFailure: (cause)=>failCause(cause),
        onSuccess: (a)=>f(a)
    })));
const match = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, { onFiber, onRuntimeFiber })=>{
    if (isRuntimeFiber(self)) return onRuntimeFiber(self);
    return onFiber(self);
});
/** @internal */ const _never = {
    ..._effectableJs.CommitPrototype,
    commit () {
        return join(this);
    },
    ...fiberProto,
    id: ()=>_fiberIdJs.none,
    await: _coreJs.never,
    children: /*#__PURE__*/ _coreJs.succeed([]),
    inheritAll: _coreJs.never,
    poll: /*#__PURE__*/ _coreJs.succeed(/*#__PURE__*/ _optionJs.none()),
    interruptAsFork: ()=>_coreJs.never
};
const never = _never;
const orElse = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>({
        ..._effectableJs.CommitPrototype,
        commit () {
            return join(this);
        },
        ...fiberProto,
        id: ()=>_fiberIdJs.getOrElse(self.id(), that.id()),
        await: _coreJs.zipWith(self.await, that.await, (exit1, exit2)=>_exitJs.isSuccess(exit1) ? exit1 : exit2),
        children: self.children,
        inheritAll: _coreJs.zipRight(that.inheritAll, self.inheritAll),
        poll: _coreJs.zipWith(self.poll, that.poll, (option1, option2)=>{
            switch(option1._tag){
                case "None":
                    return _optionJs.none();
                case "Some":
                    return _exitJs.isSuccess(option1.value) ? option1 : option2;
            }
        }),
        interruptAsFork: (id)=>(0, _functionJs.pipe)(_coreJs.interruptAsFiber(self, id), _coreJs.zipRight((0, _functionJs.pipe)(that, _coreJs.interruptAsFiber(id))), _coreJs.asVoid)
    }));
const orElseEither = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>orElse(map(self, _eitherJs.left), map(that, _eitherJs.right)));
const poll = (self)=>self.poll;
// forked from https://github.com/sindresorhus/parse-ms/blob/4da2ffbdba02c6e288c08236695bdece0adca173/index.js
// MIT License
// Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)
/** @internal */ const parseMs = (milliseconds)=>{
    const roundTowardsZero = milliseconds > 0 ? Math.floor : Math.ceil;
    return {
        days: roundTowardsZero(milliseconds / 86400000),
        hours: roundTowardsZero(milliseconds / 3600000) % 24,
        minutes: roundTowardsZero(milliseconds / 60000) % 60,
        seconds: roundTowardsZero(milliseconds / 1000) % 60,
        milliseconds: roundTowardsZero(milliseconds) % 1000,
        microseconds: roundTowardsZero(milliseconds * 1000) % 1000,
        nanoseconds: roundTowardsZero(milliseconds * 1e6) % 1000
    };
};
/** @internal */ const renderStatus = (status)=>{
    if (_fiberStatusJs.isDone(status)) return "Done";
    if (_fiberStatusJs.isRunning(status)) return "Running";
    const isInterruptible = _runtimeFlagsJs.interruptible(status.runtimeFlags) ? "interruptible" : "uninterruptible";
    return `Suspended(${isInterruptible})`;
};
const pretty = (self)=>_coreJs.flatMap(_clockJs.currentTimeMillis, (now)=>_coreJs.map(dump(self), (dump)=>{
            const time = now - dump.id.startTimeMillis;
            const { days, hours, milliseconds, minutes, seconds } = parseMs(time);
            const lifeMsg = (days === 0 ? "" : `${days}d`) + (days === 0 && hours === 0 ? "" : `${hours}h`) + (days === 0 && hours === 0 && minutes === 0 ? "" : `${minutes}m`) + (days === 0 && hours === 0 && minutes === 0 && seconds === 0 ? "" : `${seconds}s`) + `${milliseconds}ms`;
            const waitMsg = _fiberStatusJs.isSuspended(dump.status) ? (()=>{
                const ids = _fiberIdJs.ids(dump.status.blockingOn);
                return _hashSetJs.size(ids) > 0 ? `waiting on ` + Array.from(ids).map((id)=>`${id}`).join(", ") : "";
            })() : "";
            const statusMsg = renderStatus(dump.status);
            return `[Fiber](#${dump.id.id}) (${lifeMsg}) ${waitMsg}\n   Status: ${statusMsg}`;
        }));
const unsafeRoots = ()=>Array.from(_fiberScopeJs.globalScope.roots);
const roots = /*#__PURE__*/ _coreJs.sync(unsafeRoots);
const status = (self)=>self.status;
const succeed = (value)=>done(_exitJs.succeed(value));
const void_ = /*#__PURE__*/ succeed(void 0);
const currentFiberURI = "effect/FiberCurrent";
const getCurrentFiber = ()=>_optionJs.fromNullable(globalThis[currentFiberURI]);

},{"../Clock.js":"2Ndj4","../Either.js":"4amnT","../Exit.js":"eUJDu","../FiberId.js":"4K4GG","../FiberStatus.js":"9ksVG","../Function.js":"21gOL","../HashSet.js":"aKFFV","../Number.js":"al4Y3","../Option.js":"6sHA7","../Order.js":"lQMwD","../Pipeable.js":"b5RU2","../Predicate.js":"gW5pd","./core.js":"cr3YV","./effectable.js":"8EvvU","./fiberScope.js":"f4YSV","./runtimeFlags.js":"9rFhC","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"eUJDu":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isExit", ()=>isExit);
parcelHelpers.export(exports, "isFailure", ()=>isFailure);
parcelHelpers.export(exports, "isSuccess", ()=>isSuccess);
parcelHelpers.export(exports, "isInterrupted", ()=>isInterrupted);
parcelHelpers.export(exports, "as", ()=>as);
parcelHelpers.export(exports, "asVoid", ()=>asVoid);
parcelHelpers.export(exports, "causeOption", ()=>causeOption);
parcelHelpers.export(exports, "all", ()=>all);
parcelHelpers.export(exports, "die", ()=>die);
parcelHelpers.export(exports, "exists", ()=>exists);
parcelHelpers.export(exports, "fail", ()=>fail);
parcelHelpers.export(exports, "failCause", ()=>failCause);
parcelHelpers.export(exports, "flatMap", ()=>flatMap);
parcelHelpers.export(exports, "flatMapEffect", ()=>flatMapEffect);
parcelHelpers.export(exports, "flatten", ()=>flatten);
parcelHelpers.export(exports, "forEachEffect", ()=>forEachEffect);
parcelHelpers.export(exports, "fromEither", ()=>fromEither);
parcelHelpers.export(exports, "fromOption", ()=>fromOption);
parcelHelpers.export(exports, "getOrElse", ()=>getOrElse);
parcelHelpers.export(exports, "interrupt", ()=>interrupt);
parcelHelpers.export(exports, "map", ()=>map);
parcelHelpers.export(exports, "mapBoth", ()=>mapBoth);
parcelHelpers.export(exports, "mapError", ()=>mapError);
parcelHelpers.export(exports, "mapErrorCause", ()=>mapErrorCause);
parcelHelpers.export(exports, "match", ()=>match);
parcelHelpers.export(exports, "matchEffect", ()=>matchEffect);
parcelHelpers.export(exports, "succeed", ()=>succeed);
parcelHelpers.export(exports, "void", ()=>/**
 * Represents an `Exit` which succeeds with `undefined`.
 *
 * @since 2.0.0
 * @category constructors
 */ void_);
parcelHelpers.export(exports, "zip", ()=>zip);
parcelHelpers.export(exports, "zipLeft", ()=>zipLeft);
parcelHelpers.export(exports, "zipRight", ()=>zipRight);
parcelHelpers.export(exports, "zipPar", ()=>zipPar);
parcelHelpers.export(exports, "zipParLeft", ()=>zipParLeft);
parcelHelpers.export(exports, "zipParRight", ()=>zipParRight);
parcelHelpers.export(exports, "zipWith", ()=>zipWith);
var _coreJs = require("./internal/core.js");
const isExit = _coreJs.exitIsExit;
const isFailure = _coreJs.exitIsFailure;
const isSuccess = _coreJs.exitIsSuccess;
const isInterrupted = _coreJs.exitIsInterrupted;
const as = _coreJs.exitAs;
const asVoid = _coreJs.exitAsVoid;
const causeOption = _coreJs.exitCauseOption;
const all = _coreJs.exitCollectAll;
const die = _coreJs.exitDie;
const exists = _coreJs.exitExists;
const fail = _coreJs.exitFail;
const failCause = _coreJs.exitFailCause;
const flatMap = _coreJs.exitFlatMap;
const flatMapEffect = _coreJs.exitFlatMapEffect;
const flatten = _coreJs.exitFlatten;
const forEachEffect = _coreJs.exitForEachEffect;
const fromEither = _coreJs.exitFromEither;
const fromOption = _coreJs.exitFromOption;
const getOrElse = _coreJs.exitGetOrElse;
const interrupt = _coreJs.exitInterrupt;
const map = _coreJs.exitMap;
const mapBoth = _coreJs.exitMapBoth;
const mapError = _coreJs.exitMapError;
const mapErrorCause = _coreJs.exitMapErrorCause;
const match = _coreJs.exitMatch;
const matchEffect = _coreJs.exitMatchEffect;
const succeed = _coreJs.exitSucceed;
const void_ = _coreJs.exitVoid;
const zip = _coreJs.exitZip;
const zipLeft = _coreJs.exitZipLeft;
const zipRight = _coreJs.exitZipRight;
const zipPar = _coreJs.exitZipPar;
const zipParLeft = _coreJs.exitZipParLeft;
const zipParRight = _coreJs.exitZipParRight;
const zipWith = _coreJs.exitZipWith;

},{"./internal/core.js":"cr3YV","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"f4YSV":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FiberScopeTypeId", ()=>FiberScopeTypeId);
parcelHelpers.export(exports, "unsafeMake", ()=>unsafeMake);
parcelHelpers.export(exports, "globalScope", ()=>globalScope);
var _fiberIdJs = require("../FiberId.js");
var _globalValueJs = require("../GlobalValue.js");
var _fiberMessageJs = require("./fiberMessage.js");
/** @internal */ const FiberScopeSymbolKey = "effect/FiberScope";
const FiberScopeTypeId = /*#__PURE__*/ Symbol.for(FiberScopeSymbolKey);
/** @internal */ class Global {
    [FiberScopeTypeId] = FiberScopeTypeId;
    fiberId = _fiberIdJs.none;
    roots = /*#__PURE__*/ new Set();
    add(_runtimeFlags, child) {
        this.roots.add(child);
        child.addObserver(()=>{
            this.roots.delete(child);
        });
    }
}
/** @internal */ class Local {
    fiberId;
    parent;
    [FiberScopeTypeId] = FiberScopeTypeId;
    constructor(fiberId, parent){
        this.fiberId = fiberId;
        this.parent = parent;
    }
    add(_runtimeFlags, child) {
        this.parent.tell(_fiberMessageJs.stateful((parentFiber)=>{
            parentFiber.addChild(child);
            child.addObserver(()=>{
                parentFiber.removeChild(child);
            });
        }));
    }
}
const unsafeMake = (fiber)=>{
    return new Local(fiber.id(), fiber);
};
const globalScope = /*#__PURE__*/ (0, _globalValueJs.globalValue)(/*#__PURE__*/ Symbol.for("effect/FiberScope/Global"), ()=>new Global());

},{"../FiberId.js":"4K4GG","../GlobalValue.js":"5w3Hn","./fiberMessage.js":"j6Tm3","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"j6Tm3":[function(require,module,exports,__globalThis) {
/** @internal */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "OP_INTERRUPT_SIGNAL", ()=>OP_INTERRUPT_SIGNAL);
parcelHelpers.export(exports, "OP_STATEFUL", ()=>OP_STATEFUL);
parcelHelpers.export(exports, "OP_RESUME", ()=>OP_RESUME);
parcelHelpers.export(exports, "OP_YIELD_NOW", ()=>OP_YIELD_NOW);
parcelHelpers.export(exports, "interruptSignal", ()=>interruptSignal);
parcelHelpers.export(exports, "stateful", ()=>stateful);
parcelHelpers.export(exports, "resume", ()=>resume);
parcelHelpers.export(exports, "yieldNow", ()=>yieldNow);
const OP_INTERRUPT_SIGNAL = "InterruptSignal";
const OP_STATEFUL = "Stateful";
const OP_RESUME = "Resume";
const OP_YIELD_NOW = "YieldNow";
const interruptSignal = (cause)=>({
        _tag: OP_INTERRUPT_SIGNAL,
        cause
    });
const stateful = (onFiber)=>({
        _tag: OP_STATEFUL,
        onFiber
    });
const resume = (effect)=>({
        _tag: OP_RESUME,
        effect
    });
const yieldNow = ()=>({
        _tag: OP_YIELD_NOW
    });

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"11rih":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "LoggerTypeId", ()=>LoggerTypeId);
parcelHelpers.export(exports, "makeLogger", ()=>makeLogger);
parcelHelpers.export(exports, "mapInput", ()=>mapInput);
parcelHelpers.export(exports, "mapInputOptions", ()=>mapInputOptions);
parcelHelpers.export(exports, "filterLogLevel", ()=>filterLogLevel);
parcelHelpers.export(exports, "map", ()=>map);
parcelHelpers.export(exports, "none", ()=>none);
parcelHelpers.export(exports, "simple", ()=>simple);
parcelHelpers.export(exports, "succeed", ()=>succeed);
parcelHelpers.export(exports, "sync", ()=>sync);
parcelHelpers.export(exports, "zip", ()=>zip);
parcelHelpers.export(exports, "zipLeft", ()=>zipLeft);
parcelHelpers.export(exports, "zipRight", ()=>zipRight);
parcelHelpers.export(exports, "stringLogger", ()=>stringLogger);
parcelHelpers.export(exports, "logfmtLogger", ()=>logfmtLogger);
parcelHelpers.export(exports, "structuredLogger", ()=>structuredLogger);
parcelHelpers.export(exports, "structuredMessage", ()=>structuredMessage);
parcelHelpers.export(exports, "jsonLogger", ()=>jsonLogger);
parcelHelpers.export(exports, "isLogger", ()=>isLogger);
parcelHelpers.export(exports, "prettyLogger", ()=>prettyLogger);
parcelHelpers.export(exports, "prettyLoggerDefault", ()=>prettyLoggerDefault);
var _arrayJs = require("../Array.js");
var _contextJs = require("../Context.js");
var _fiberRefsJs = require("../FiberRefs.js");
var _functionJs = require("../Function.js");
var _globalValueJs = require("../GlobalValue.js");
var _hashMapJs = require("../HashMap.js");
var _inspectableJs = require("../Inspectable.js");
var _listJs = require("../List.js");
var _optionJs = require("../Option.js");
var _pipeableJs = require("../Pipeable.js");
var _causeJs = require("./cause.js");
var _defaultServicesJs = require("./defaultServices.js");
var _consoleJs = require("./defaultServices/console.js");
var _fiberIdJs = require("./fiberId.js");
var _logSpanJs = require("./logSpan.js");
var process = require("44fffd851e2e3396");
/** @internal */ const LoggerSymbolKey = "effect/Logger";
const LoggerTypeId = /*#__PURE__*/ Symbol.for(LoggerSymbolKey);
const loggerVariance = {
    /* c8 ignore next */ _Message: (_)=>_,
    /* c8 ignore next */ _Output: (_)=>_
};
const makeLogger = (log)=>({
        [LoggerTypeId]: loggerVariance,
        log,
        pipe () {
            return (0, _pipeableJs.pipeArguments)(this, arguments);
        }
    });
const mapInput = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>makeLogger((options)=>self.log({
            ...options,
            message: f(options.message)
        })));
const mapInputOptions = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>makeLogger((options)=>self.log(f(options))));
const filterLogLevel = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>makeLogger((options)=>f(options.logLevel) ? _optionJs.some(self.log(options)) : _optionJs.none()));
const map = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>makeLogger((options)=>f(self.log(options))));
const none = {
    [LoggerTypeId]: loggerVariance,
    log: (0, _functionJs.constVoid),
    pipe () {
        return (0, _pipeableJs.pipeArguments)(this, arguments);
    }
};
const simple = (log)=>({
        [LoggerTypeId]: loggerVariance,
        log: ({ message })=>log(message),
        pipe () {
            return (0, _pipeableJs.pipeArguments)(this, arguments);
        }
    });
const succeed = (value)=>{
    return simple(()=>value);
};
const sync = (evaluate)=>{
    return simple(evaluate);
};
const zip = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>makeLogger((options)=>[
            self.log(options),
            that.log(options)
        ]));
const zipLeft = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>map(zip(self, that), (tuple)=>tuple[0]));
const zipRight = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>map(zip(self, that), (tuple)=>tuple[1]));
/**
 * Match strings that do not contain any whitespace characters, double quotes,
 * or equal signs.
 *
 * @internal
 */ const textOnly = /^[^\s"=]*$/;
/**
 * Used by both {@link stringLogger} and {@link logfmtLogger} to render a log
 * message.
 *
 * @internal
 */ const format = (quoteValue, whitespace)=>({ annotations, cause, date, fiberId, logLevel, message, spans })=>{
        const formatValue = (value)=>value.match(textOnly) ? value : quoteValue(value);
        const format = (label, value)=>`${_logSpanJs.formatLabel(label)}=${formatValue(value)}`;
        const append = (label, value)=>" " + format(label, value);
        let out = format("timestamp", date.toISOString());
        out += append("level", logLevel.label);
        out += append("fiber", _fiberIdJs.threadName(fiberId));
        const messages = _arrayJs.ensure(message);
        for(let i = 0; i < messages.length; i++)out += append("message", _inspectableJs.toStringUnknown(messages[i], whitespace));
        if (!_causeJs.isEmptyType(cause)) out += append("cause", _causeJs.pretty(cause, {
            renderErrorCause: true
        }));
        for (const span of spans)out += " " + _logSpanJs.render(date.getTime())(span);
        for (const [label, value] of annotations)out += append(label, _inspectableJs.toStringUnknown(value, whitespace));
        return out;
    };
/** @internal */ const escapeDoubleQuotes = (s)=>`"${s.replace(/\\([\s\S])|(")/g, "\\$1$2")}"`;
const stringLogger = /*#__PURE__*/ makeLogger(/*#__PURE__*/ format(escapeDoubleQuotes));
const logfmtLogger = /*#__PURE__*/ makeLogger(/*#__PURE__*/ format(JSON.stringify, 0));
const structuredLogger = /*#__PURE__*/ makeLogger(({ annotations, cause, date, fiberId, logLevel, message, spans })=>{
    const now = date.getTime();
    const annotationsObj = {};
    const spansObj = {};
    if (_hashMapJs.size(annotations) > 0) for (const [k, v] of annotations)annotationsObj[k] = structuredMessage(v);
    if (_listJs.isCons(spans)) for (const span of spans)spansObj[span.label] = now - span.startTime;
    const messageArr = _arrayJs.ensure(message);
    return {
        message: messageArr.length === 1 ? structuredMessage(messageArr[0]) : messageArr.map(structuredMessage),
        logLevel: logLevel.label,
        timestamp: date.toISOString(),
        cause: _causeJs.isEmpty(cause) ? undefined : _causeJs.pretty(cause, {
            renderErrorCause: true
        }),
        annotations: annotationsObj,
        spans: spansObj,
        fiberId: _fiberIdJs.threadName(fiberId)
    };
});
const structuredMessage = (u)=>{
    switch(typeof u){
        case "bigint":
        case "function":
        case "symbol":
            return String(u);
        default:
            return _inspectableJs.toJSON(u);
    }
};
const jsonLogger = /*#__PURE__*/ map(structuredLogger, _inspectableJs.stringifyCircular);
const isLogger = (u)=>{
    return typeof u === "object" && u != null && LoggerTypeId in u;
};
const withColor = (text, ...colors)=>{
    let out = "";
    for(let i = 0; i < colors.length; i++)out += `\x1b[${colors[i]}m`;
    return out + text + "\x1b[0m";
};
const withColorNoop = (text, ..._colors)=>text;
const colors = {
    bold: "1",
    red: "31",
    green: "32",
    yellow: "33",
    blue: "34",
    cyan: "36",
    white: "37",
    gray: "90",
    black: "30",
    bgBrightRed: "101"
};
const logLevelColors = {
    None: [],
    All: [],
    Trace: [
        colors.gray
    ],
    Debug: [
        colors.blue
    ],
    Info: [
        colors.green
    ],
    Warning: [
        colors.yellow
    ],
    Error: [
        colors.red
    ],
    Fatal: [
        colors.bgBrightRed,
        colors.black
    ]
};
const logLevelStyle = {
    None: "",
    All: "",
    Trace: "color:gray",
    Debug: "color:blue",
    Info: "color:green",
    Warning: "color:orange",
    Error: "color:red",
    Fatal: "background-color:red;color:white"
};
const defaultDateFormat = (date)=>`${date.getHours().toString().padStart(2, "0")}:${date.getMinutes().toString().padStart(2, "0")}:${date.getSeconds().toString().padStart(2, "0")}.${date.getMilliseconds().toString().padStart(3, "0")}`;
const hasProcessStdout = false;
const processStdoutIsTTY = hasProcessStdout && process.stdout.isTTY === true;
const hasProcessStdoutOrDeno = hasProcessStdout || "Deno" in globalThis;
const prettyLogger = (options)=>{
    const mode_ = options?.mode ?? "auto";
    const mode = mode_ === "auto" ? hasProcessStdoutOrDeno ? "tty" : "browser" : mode_;
    const isBrowser = mode === "browser";
    const showColors = typeof options?.colors === "boolean" ? options.colors : processStdoutIsTTY || isBrowser;
    const formatDate = options?.formatDate ?? defaultDateFormat;
    return isBrowser ? prettyLoggerBrowser({
        colors: showColors,
        formatDate
    }) : prettyLoggerTty({
        colors: showColors,
        formatDate,
        stderr: options?.stderr === true
    });
};
const prettyLoggerTty = (options)=>{
    const processIsBun = false;
    const color = options.colors ? withColor : withColorNoop;
    return makeLogger(({ annotations, cause, context, date, fiberId, logLevel, message: message_, spans })=>{
        const services = _fiberRefsJs.getOrDefault(context, _defaultServicesJs.currentServices);
        const console = _contextJs.get(services, (0, _consoleJs.consoleTag)).unsafe;
        const log = options.stderr === true ? console.error : console.log;
        const message = _arrayJs.ensure(message_);
        let firstLine = color(`[${options.formatDate(date)}]`, colors.white) + ` ${color(logLevel.label, ...logLevelColors[logLevel._tag])}` + ` (${_fiberIdJs.threadName(fiberId)})`;
        if (_listJs.isCons(spans)) {
            const now = date.getTime();
            const render = _logSpanJs.render(now);
            for (const span of spans)firstLine += " " + render(span);
        }
        firstLine += ":";
        let messageIndex = 0;
        if (message.length > 0) {
            const firstMaybeString = structuredMessage(message[0]);
            if (typeof firstMaybeString === "string") {
                firstLine += " " + color(firstMaybeString, colors.bold, colors.cyan);
                messageIndex++;
            }
        }
        log(firstLine);
        if (!processIsBun) console.group();
        if (!_causeJs.isEmpty(cause)) log(_causeJs.pretty(cause, {
            renderErrorCause: true
        }));
        if (messageIndex < message.length) for(; messageIndex < message.length; messageIndex++)log(_inspectableJs.redact(message[messageIndex]));
        if (_hashMapJs.size(annotations) > 0) for (const [key, value] of annotations)log(color(`${key}:`, colors.bold, colors.white), _inspectableJs.redact(value));
        if (!processIsBun) console.groupEnd();
    });
};
const prettyLoggerBrowser = (options)=>{
    const color = options.colors ? "%c" : "";
    return makeLogger(({ annotations, cause, context, date, fiberId, logLevel, message: message_, spans })=>{
        const services = _fiberRefsJs.getOrDefault(context, _defaultServicesJs.currentServices);
        const console = _contextJs.get(services, (0, _consoleJs.consoleTag)).unsafe;
        const message = _arrayJs.ensure(message_);
        let firstLine = `${color}[${options.formatDate(date)}]`;
        const firstParams = [];
        if (options.colors) firstParams.push("color:gray");
        firstLine += ` ${color}${logLevel.label}${color} (${_fiberIdJs.threadName(fiberId)})`;
        if (options.colors) firstParams.push(logLevelStyle[logLevel._tag], "");
        if (_listJs.isCons(spans)) {
            const now = date.getTime();
            const render = _logSpanJs.render(now);
            for (const span of spans)firstLine += " " + render(span);
        }
        firstLine += ":";
        let messageIndex = 0;
        if (message.length > 0) {
            const firstMaybeString = structuredMessage(message[0]);
            if (typeof firstMaybeString === "string") {
                firstLine += ` ${color}${firstMaybeString}`;
                if (options.colors) firstParams.push("color:deepskyblue");
                messageIndex++;
            }
        }
        console.groupCollapsed(firstLine, ...firstParams);
        if (!_causeJs.isEmpty(cause)) console.error(_causeJs.pretty(cause, {
            renderErrorCause: true
        }));
        if (messageIndex < message.length) for(; messageIndex < message.length; messageIndex++)console.log(_inspectableJs.redact(message[messageIndex]));
        if (_hashMapJs.size(annotations) > 0) for (const [key, value] of annotations){
            const redacted = _inspectableJs.redact(value);
            if (options.colors) console.log(`%c${key}:`, "color:gray", redacted);
            else console.log(`${key}:`, redacted);
        }
        console.groupEnd();
    });
};
const prettyLoggerDefault = /*#__PURE__*/ (0, _globalValueJs.globalValue)("effect/Logger/prettyLoggerDefault", ()=>prettyLogger());

},{"44fffd851e2e3396":"cnJLZ","../Array.js":"8L2Gk","../Context.js":"c2abN","../FiberRefs.js":"lIa2I","../Function.js":"21gOL","../GlobalValue.js":"5w3Hn","../HashMap.js":"aG8zS","../Inspectable.js":"1Ur70","../List.js":"a341T","../Option.js":"6sHA7","../Pipeable.js":"b5RU2","./cause.js":"l3ev0","./defaultServices.js":"aF4q8","./defaultServices/console.js":"lcu1k","./fiberId.js":"azUa1","./logSpan.js":"3TBwR","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"cnJLZ":[function(require,module,exports,__globalThis) {
// shim for using process in browser
var process = module.exports = {};
// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.
var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function() {
    try {
        if (typeof setTimeout === 'function') cachedSetTimeout = setTimeout;
        else cachedSetTimeout = defaultSetTimout;
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') cachedClearTimeout = clearTimeout;
        else cachedClearTimeout = defaultClearTimeout;
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) //normal enviroments in sane situations
    return setTimeout(fun, 0);
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) //normal enviroments in sane situations
    return clearTimeout(marker);
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
    if (!draining || !currentQueue) return;
    draining = false;
    if (currentQueue.length) queue = currentQueue.concat(queue);
    else queueIndex = -1;
    if (queue.length) drainQueue();
}
function drainQueue() {
    if (draining) return;
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while(len){
        currentQueue = queue;
        queue = [];
        while(++queueIndex < len)if (currentQueue) currentQueue[queueIndex].run();
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}
process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) for(var i = 1; i < arguments.length; i++)args[i - 1] = arguments[i];
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) runTimeout(drainQueue);
};
// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function() {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};
function noop() {}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function(name) {
    return [];
};
process.binding = function(name) {
    throw new Error('process.binding is not supported');
};
process.cwd = function() {
    return '/';
};
process.chdir = function(dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() {
    return 0;
};

},{}],"6Hb5Q":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MetricTypeId", ()=>MetricTypeId);
parcelHelpers.export(exports, "globalMetricRegistry", ()=>globalMetricRegistry);
parcelHelpers.export(exports, "make", ()=>make);
parcelHelpers.export(exports, "mapInput", ()=>mapInput);
parcelHelpers.export(exports, "counter", ()=>counter);
parcelHelpers.export(exports, "frequency", ()=>frequency);
parcelHelpers.export(exports, "withConstantInput", ()=>withConstantInput);
parcelHelpers.export(exports, "fromMetricKey", ()=>fromMetricKey);
parcelHelpers.export(exports, "gauge", ()=>gauge);
parcelHelpers.export(exports, "histogram", ()=>histogram);
parcelHelpers.export(exports, "increment", ()=>increment);
parcelHelpers.export(exports, "incrementBy", ()=>incrementBy);
parcelHelpers.export(exports, "map", ()=>map);
parcelHelpers.export(exports, "mapType", ()=>mapType);
parcelHelpers.export(exports, "modify", ()=>modify);
parcelHelpers.export(exports, "set", ()=>set);
parcelHelpers.export(exports, "succeed", ()=>succeed);
parcelHelpers.export(exports, "sync", ()=>sync);
parcelHelpers.export(exports, "summary", ()=>summary);
parcelHelpers.export(exports, "summaryTimestamp", ()=>summaryTimestamp);
parcelHelpers.export(exports, "tagged", ()=>tagged);
parcelHelpers.export(exports, "taggedWithLabelsInput", ()=>taggedWithLabelsInput);
parcelHelpers.export(exports, "taggedWithLabels", ()=>taggedWithLabels);
parcelHelpers.export(exports, "timer", ()=>timer);
parcelHelpers.export(exports, "timerWithBoundaries", ()=>timerWithBoundaries);
parcelHelpers.export(exports, "trackAll", ()=>trackAll);
parcelHelpers.export(exports, "trackDefect", ()=>trackDefect);
parcelHelpers.export(exports, "trackDefectWith", ()=>trackDefectWith);
parcelHelpers.export(exports, "trackDuration", ()=>trackDuration);
parcelHelpers.export(exports, "trackDurationWith", ()=>trackDurationWith);
parcelHelpers.export(exports, "trackError", ()=>trackError);
parcelHelpers.export(exports, "trackErrorWith", ()=>trackErrorWith);
parcelHelpers.export(exports, "trackSuccess", ()=>trackSuccess);
parcelHelpers.export(exports, "trackSuccessWith", ()=>trackSuccessWith);
parcelHelpers.export(exports, "update", ()=>update);
parcelHelpers.export(exports, "value", ()=>value);
parcelHelpers.export(exports, "withNow", ()=>withNow);
parcelHelpers.export(exports, "zip", ()=>zip);
parcelHelpers.export(exports, "unsafeSnapshot", ()=>unsafeSnapshot);
parcelHelpers.export(exports, "snapshot", ()=>snapshot);
var _arrayJs = require("../Array.js");
var _clockJs = require("../Clock.js");
var _durationJs = require("../Duration.js");
var _functionJs = require("../Function.js");
var _globalValueJs = require("../GlobalValue.js");
var _pipeableJs = require("../Pipeable.js");
var _causeJs = require("./cause.js");
var _coreEffectJs = require("./core-effect.js");
var _coreJs = require("./core.js");
var _boundariesJs = require("./metric/boundaries.js");
var _keyJs = require("./metric/key.js");
var _keyTypeJs = require("./metric/keyType.js");
var _labelJs = require("./metric/label.js");
var _registryJs = require("./metric/registry.js");
/** @internal */ const MetricSymbolKey = "effect/Metric";
const MetricTypeId = /*#__PURE__*/ Symbol.for(MetricSymbolKey);
const metricVariance = {
    /* c8 ignore next */ _Type: (_)=>_,
    /* c8 ignore next */ _In: (_)=>_,
    /* c8 ignore next */ _Out: (_)=>_
};
const globalMetricRegistry = /*#__PURE__*/ (0, _globalValueJs.globalValue)(/*#__PURE__*/ Symbol.for("effect/Metric/globalMetricRegistry"), ()=>_registryJs.make());
const make = function(keyType, unsafeUpdate, unsafeValue, unsafeModify) {
    const metric = Object.assign((effect)=>_coreJs.tap(effect, (a)=>update(metric, a)), {
        [MetricTypeId]: metricVariance,
        keyType,
        unsafeUpdate,
        unsafeValue,
        unsafeModify,
        register () {
            this.unsafeValue([]);
            return this;
        },
        pipe () {
            return (0, _pipeableJs.pipeArguments)(this, arguments);
        }
    });
    return metric;
};
const mapInput = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>make(self.keyType, (input, extraTags)=>self.unsafeUpdate(f(input), extraTags), self.unsafeValue, (input, extraTags)=>self.unsafeModify(f(input), extraTags)));
const counter = (name, options)=>fromMetricKey(_keyJs.counter(name, options));
const frequency = (name, options)=>fromMetricKey(_keyJs.frequency(name, options));
const withConstantInput = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, input)=>mapInput(self, ()=>input));
const fromMetricKey = (key)=>{
    let untaggedHook;
    const hookCache = new WeakMap();
    const hook = (extraTags)=>{
        if (extraTags.length === 0) {
            if (untaggedHook !== undefined) return untaggedHook;
            untaggedHook = globalMetricRegistry.get(key);
            return untaggedHook;
        }
        let hook = hookCache.get(extraTags);
        if (hook !== undefined) return hook;
        hook = globalMetricRegistry.get(_keyJs.taggedWithLabels(key, extraTags));
        hookCache.set(extraTags, hook);
        return hook;
    };
    return make(key.keyType, (input, extraTags)=>hook(extraTags).update(input), (extraTags)=>hook(extraTags).get(), (input, extraTags)=>hook(extraTags).modify(input));
};
const gauge = (name, options)=>fromMetricKey(_keyJs.gauge(name, options));
const histogram = (name, boundaries, description)=>fromMetricKey(_keyJs.histogram(name, boundaries, description));
const increment = (self)=>_keyTypeJs.isCounterKey(self.keyType) ? update(self, self.keyType.bigint ? BigInt(1) : 1) : modify(self, self.keyType.bigint ? BigInt(1) : 1);
const incrementBy = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, amount)=>_keyTypeJs.isCounterKey(self.keyType) ? update(self, amount) : modify(self, amount));
const map = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>make(self.keyType, self.unsafeUpdate, (extraTags)=>f(self.unsafeValue(extraTags)), self.unsafeModify));
const mapType = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>make(f(self.keyType), self.unsafeUpdate, self.unsafeValue, self.unsafeModify));
const modify = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, input)=>_coreJs.fiberRefGetWith(_coreJs.currentMetricLabels, (tags)=>_coreJs.sync(()=>self.unsafeModify(input, tags))));
const set = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, value)=>update(self, value));
const succeed = (out)=>make(void 0, (0, _functionJs.constVoid), ()=>out, (0, _functionJs.constVoid));
const sync = (evaluate)=>make(void 0, (0, _functionJs.constVoid), evaluate, (0, _functionJs.constVoid));
const summary = (options)=>withNow(summaryTimestamp(options));
const summaryTimestamp = (options)=>fromMetricKey(_keyJs.summary(options));
const tagged = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, key, value)=>taggedWithLabels(self, [
        _labelJs.make(key, value)
    ]));
const taggedWithLabelsInput = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>map(make(self.keyType, (input, extraTags)=>self.unsafeUpdate(input, _arrayJs.union(f(input), extraTags)), self.unsafeValue, (input, extraTags)=>self.unsafeModify(input, _arrayJs.union(f(input), extraTags))), (0, _functionJs.constVoid)));
const taggedWithLabels = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, extraTags)=>{
    return make(self.keyType, (input, extraTags1)=>self.unsafeUpdate(input, _arrayJs.union(extraTags, extraTags1)), (extraTags1)=>self.unsafeValue(_arrayJs.union(extraTags, extraTags1)), (input, extraTags1)=>self.unsafeModify(input, _arrayJs.union(extraTags, extraTags1)));
});
const timer = (name, description)=>{
    const boundaries = _boundariesJs.exponential({
        start: 0.5,
        factor: 2,
        count: 35
    });
    const base = (0, _functionJs.pipe)(histogram(name, boundaries, description), tagged("time_unit", "milliseconds"));
    return mapInput(base, _durationJs.toMillis);
};
const timerWithBoundaries = (name, boundaries, description)=>{
    const base = (0, _functionJs.pipe)(histogram(name, _boundariesJs.fromIterable(boundaries), description), tagged("time_unit", "milliseconds"));
    return mapInput(base, _durationJs.toMillis);
};
const trackAll = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, input)=>(effect)=>_coreJs.matchCauseEffect(effect, {
            onFailure: (cause)=>_coreJs.zipRight(update(self, input), _coreJs.failCause(cause)),
            onSuccess: (value)=>_coreJs.zipRight(update(self, input), _coreJs.succeed(value))
        }));
const trackDefect = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, metric)=>trackDefectWith(self, metric, (0, _functionJs.identity)));
const trackDefectWith = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, metric, f)=>{
    const updater = (defect)=>update(metric, f(defect));
    return _coreEffectJs.tapDefect(self, (cause)=>_coreJs.forEachSequentialDiscard(_causeJs.defects(cause), updater));
});
const trackDuration = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, metric)=>trackDurationWith(self, metric, (0, _functionJs.identity)));
const trackDurationWith = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, metric, f)=>_clockJs.clockWith((clock)=>{
        const startTime = clock.unsafeCurrentTimeNanos();
        return _coreJs.tap(self, (_)=>{
            const endTime = clock.unsafeCurrentTimeNanos();
            const duration = _durationJs.nanos(endTime - startTime);
            return update(metric, f(duration));
        });
    }));
const trackError = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, metric)=>trackErrorWith(self, metric, (a)=>a));
const trackErrorWith = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, metric, f)=>{
    const updater = (error)=>update(metric, f(error));
    return _coreEffectJs.tapError(self, updater);
});
const trackSuccess = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, metric)=>trackSuccessWith(self, metric, (a)=>a));
const trackSuccessWith = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, metric, f)=>{
    const updater = (value)=>update(metric, f(value));
    return _coreJs.tap(self, updater);
});
const update = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, input)=>_coreJs.fiberRefGetWith(_coreJs.currentMetricLabels, (tags)=>_coreJs.sync(()=>self.unsafeUpdate(input, tags))));
const value = (self)=>_coreJs.fiberRefGetWith(_coreJs.currentMetricLabels, (tags)=>_coreJs.sync(()=>self.unsafeValue(tags)));
const withNow = (self)=>mapInput(self, (input)=>[
            input,
            Date.now()
        ]);
const zip = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>make([
        self.keyType,
        that.keyType
    ], (input, extraTags)=>{
        const [l, r] = input;
        self.unsafeUpdate(l, extraTags);
        that.unsafeUpdate(r, extraTags);
    }, (extraTags)=>[
            self.unsafeValue(extraTags),
            that.unsafeValue(extraTags)
        ], (input, extraTags)=>{
        const [l, r] = input;
        self.unsafeModify(l, extraTags);
        that.unsafeModify(r, extraTags);
    }));
const unsafeSnapshot = ()=>globalMetricRegistry.snapshot();
const snapshot = /*#__PURE__*/ _coreJs.sync(unsafeSnapshot);

},{"../Array.js":"8L2Gk","../Clock.js":"2Ndj4","../Duration.js":"czLLe","../Function.js":"21gOL","../GlobalValue.js":"5w3Hn","../Pipeable.js":"b5RU2","./cause.js":"l3ev0","./core-effect.js":"k8F3C","./core.js":"cr3YV","./metric/boundaries.js":"dvuqu","./metric/key.js":"a3IDD","./metric/keyType.js":"57Nou","./metric/label.js":"hcYDB","./metric/registry.js":"hbbxL","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"dvuqu":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MetricBoundariesTypeId", ()=>MetricBoundariesTypeId);
parcelHelpers.export(exports, "isMetricBoundaries", ()=>isMetricBoundaries);
parcelHelpers.export(exports, "fromIterable", ()=>fromIterable);
parcelHelpers.export(exports, "linear", ()=>linear);
parcelHelpers.export(exports, "exponential", ()=>exponential);
var _arrayJs = require("../../Array.js");
var _chunkJs = require("../../Chunk.js");
var _equalJs = require("../../Equal.js");
var _functionJs = require("../../Function.js");
var _hashJs = require("../../Hash.js");
var _pipeableJs = require("../../Pipeable.js");
var _predicateJs = require("../../Predicate.js");
/** @internal */ const MetricBoundariesSymbolKey = "effect/MetricBoundaries";
const MetricBoundariesTypeId = /*#__PURE__*/ Symbol.for(MetricBoundariesSymbolKey);
/** @internal */ class MetricBoundariesImpl {
    values;
    [MetricBoundariesTypeId] = MetricBoundariesTypeId;
    constructor(values){
        this.values = values;
        this._hash = (0, _functionJs.pipe)(_hashJs.string(MetricBoundariesSymbolKey), _hashJs.combine(_hashJs.array(this.values)));
    }
    _hash;
    [_hashJs.symbol]() {
        return this._hash;
    }
    [_equalJs.symbol](u) {
        return isMetricBoundaries(u) && _equalJs.equals(this.values, u.values);
    }
    pipe() {
        return (0, _pipeableJs.pipeArguments)(this, arguments);
    }
}
const isMetricBoundaries = (u)=>(0, _predicateJs.hasProperty)(u, MetricBoundariesTypeId);
const fromIterable = (iterable)=>{
    const values = (0, _functionJs.pipe)(iterable, _arrayJs.appendAll(_chunkJs.of(Number.POSITIVE_INFINITY)), _arrayJs.dedupe);
    return new MetricBoundariesImpl(values);
};
const linear = (options)=>(0, _functionJs.pipe)(_arrayJs.makeBy(options.count - 1, (i)=>options.start + i * options.width), _chunkJs.unsafeFromArray, fromIterable);
const exponential = (options)=>(0, _functionJs.pipe)(_arrayJs.makeBy(options.count - 1, (i)=>options.start * Math.pow(options.factor, i)), _chunkJs.unsafeFromArray, fromIterable);

},{"../../Array.js":"8L2Gk","../../Chunk.js":"dL1OO","../../Equal.js":"gA0qD","../../Function.js":"21gOL","../../Hash.js":"gFMwE","../../Pipeable.js":"b5RU2","../../Predicate.js":"gW5pd","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"a3IDD":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MetricKeyTypeId", ()=>MetricKeyTypeId);
parcelHelpers.export(exports, "isMetricKey", ()=>isMetricKey);
parcelHelpers.export(exports, "counter", ()=>counter);
parcelHelpers.export(exports, "frequency", ()=>frequency);
parcelHelpers.export(exports, "gauge", ()=>gauge);
parcelHelpers.export(exports, "histogram", ()=>histogram);
parcelHelpers.export(exports, "summary", ()=>summary);
parcelHelpers.export(exports, "tagged", ()=>tagged);
parcelHelpers.export(exports, "taggedWithLabels", ()=>taggedWithLabels);
var _arrayJs = require("../../Array.js");
var _equalJs = require("../../Equal.js");
var _functionJs = require("../../Function.js");
var _hashJs = require("../../Hash.js");
var _optionJs = require("../../Option.js");
var _pipeableJs = require("../../Pipeable.js");
var _predicateJs = require("../../Predicate.js");
var _keyTypeJs = require("./keyType.js");
var _labelJs = require("./label.js");
/** @internal */ const MetricKeySymbolKey = "effect/MetricKey";
const MetricKeyTypeId = /*#__PURE__*/ Symbol.for(MetricKeySymbolKey);
const metricKeyVariance = {
    /* c8 ignore next */ _Type: (_)=>_
};
const arrayEquivilence = /*#__PURE__*/ _arrayJs.getEquivalence(_equalJs.equals);
/** @internal */ class MetricKeyImpl {
    name;
    keyType;
    description;
    tags;
    [MetricKeyTypeId] = metricKeyVariance;
    constructor(name, keyType, description, tags = []){
        this.name = name;
        this.keyType = keyType;
        this.description = description;
        this.tags = tags;
        this._hash = (0, _functionJs.pipe)(_hashJs.string(this.name + this.description), _hashJs.combine(_hashJs.hash(this.keyType)), _hashJs.combine(_hashJs.array(this.tags)));
    }
    _hash;
    [_hashJs.symbol]() {
        return this._hash;
    }
    [_equalJs.symbol](u) {
        return isMetricKey(u) && this.name === u.name && _equalJs.equals(this.keyType, u.keyType) && _equalJs.equals(this.description, u.description) && arrayEquivilence(this.tags, u.tags);
    }
    pipe() {
        return (0, _pipeableJs.pipeArguments)(this, arguments);
    }
}
const isMetricKey = (u)=>(0, _predicateJs.hasProperty)(u, MetricKeyTypeId);
const counter = (name, options)=>new MetricKeyImpl(name, _keyTypeJs.counter(options), _optionJs.fromNullable(options?.description));
const frequency = (name, options)=>new MetricKeyImpl(name, _keyTypeJs.frequency(options), _optionJs.fromNullable(options?.description));
const gauge = (name, options)=>new MetricKeyImpl(name, _keyTypeJs.gauge(options), _optionJs.fromNullable(options?.description));
const histogram = (name, boundaries, description)=>new MetricKeyImpl(name, _keyTypeJs.histogram(boundaries), _optionJs.fromNullable(description));
const summary = (options)=>new MetricKeyImpl(options.name, _keyTypeJs.summary(options), _optionJs.fromNullable(options.description));
const tagged = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, key, value)=>taggedWithLabels(self, [
        _labelJs.make(key, value)
    ]));
const taggedWithLabels = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, extraTags)=>extraTags.length === 0 ? self : new MetricKeyImpl(self.name, self.keyType, self.description, _arrayJs.union(self.tags, extraTags)));

},{"../../Array.js":"8L2Gk","../../Equal.js":"gA0qD","../../Function.js":"21gOL","../../Hash.js":"gFMwE","../../Option.js":"6sHA7","../../Pipeable.js":"b5RU2","../../Predicate.js":"gW5pd","./keyType.js":"57Nou","./label.js":"hcYDB","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"57Nou":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MetricKeyTypeTypeId", ()=>MetricKeyTypeTypeId);
parcelHelpers.export(exports, "CounterKeyTypeTypeId", ()=>CounterKeyTypeTypeId);
parcelHelpers.export(exports, "FrequencyKeyTypeTypeId", ()=>FrequencyKeyTypeTypeId);
parcelHelpers.export(exports, "GaugeKeyTypeTypeId", ()=>GaugeKeyTypeTypeId);
parcelHelpers.export(exports, "HistogramKeyTypeTypeId", ()=>HistogramKeyTypeTypeId);
parcelHelpers.export(exports, "SummaryKeyTypeTypeId", ()=>SummaryKeyTypeTypeId);
/** @internal */ parcelHelpers.export(exports, "HistogramKeyType", ()=>HistogramKeyType);
parcelHelpers.export(exports, "counter", ()=>counter);
parcelHelpers.export(exports, "frequency", ()=>frequency);
parcelHelpers.export(exports, "gauge", ()=>gauge);
parcelHelpers.export(exports, "histogram", ()=>histogram);
parcelHelpers.export(exports, "summary", ()=>summary);
parcelHelpers.export(exports, "isMetricKeyType", ()=>isMetricKeyType);
parcelHelpers.export(exports, "isCounterKey", ()=>isCounterKey);
parcelHelpers.export(exports, "isFrequencyKey", ()=>isFrequencyKey);
parcelHelpers.export(exports, "isGaugeKey", ()=>isGaugeKey);
parcelHelpers.export(exports, "isHistogramKey", ()=>isHistogramKey);
parcelHelpers.export(exports, "isSummaryKey", ()=>isSummaryKey);
var _durationJs = require("../../Duration.js");
var _equalJs = require("../../Equal.js");
var _functionJs = require("../../Function.js");
var _hashJs = require("../../Hash.js");
var _pipeableJs = require("../../Pipeable.js");
var _predicateJs = require("../../Predicate.js");
/** @internal */ const MetricKeyTypeSymbolKey = "effect/MetricKeyType";
const MetricKeyTypeTypeId = /*#__PURE__*/ Symbol.for(MetricKeyTypeSymbolKey);
/** @internal */ const CounterKeyTypeSymbolKey = "effect/MetricKeyType/Counter";
const CounterKeyTypeTypeId = /*#__PURE__*/ Symbol.for(CounterKeyTypeSymbolKey);
/** @internal */ const FrequencyKeyTypeSymbolKey = "effect/MetricKeyType/Frequency";
const FrequencyKeyTypeTypeId = /*#__PURE__*/ Symbol.for(FrequencyKeyTypeSymbolKey);
/** @internal */ const GaugeKeyTypeSymbolKey = "effect/MetricKeyType/Gauge";
const GaugeKeyTypeTypeId = /*#__PURE__*/ Symbol.for(GaugeKeyTypeSymbolKey);
/** @internal */ const HistogramKeyTypeSymbolKey = "effect/MetricKeyType/Histogram";
const HistogramKeyTypeTypeId = /*#__PURE__*/ Symbol.for(HistogramKeyTypeSymbolKey);
/** @internal */ const SummaryKeyTypeSymbolKey = "effect/MetricKeyType/Summary";
const SummaryKeyTypeTypeId = /*#__PURE__*/ Symbol.for(SummaryKeyTypeSymbolKey);
const metricKeyTypeVariance = {
    /* c8 ignore next */ _In: (_)=>_,
    /* c8 ignore next */ _Out: (_)=>_
};
/** @internal */ class CounterKeyType {
    incremental;
    bigint;
    [MetricKeyTypeTypeId] = metricKeyTypeVariance;
    [CounterKeyTypeTypeId] = CounterKeyTypeTypeId;
    constructor(incremental, bigint){
        this.incremental = incremental;
        this.bigint = bigint;
        this._hash = _hashJs.string(CounterKeyTypeSymbolKey);
    }
    _hash;
    [_hashJs.symbol]() {
        return this._hash;
    }
    [_equalJs.symbol](that) {
        return isCounterKey(that);
    }
    pipe() {
        return (0, _pipeableJs.pipeArguments)(this, arguments);
    }
}
const FrequencyKeyTypeHash = /*#__PURE__*/ _hashJs.string(FrequencyKeyTypeSymbolKey);
/** @internal */ class FrequencyKeyType {
    preregisteredWords;
    [MetricKeyTypeTypeId] = metricKeyTypeVariance;
    [FrequencyKeyTypeTypeId] = FrequencyKeyTypeTypeId;
    constructor(preregisteredWords){
        this.preregisteredWords = preregisteredWords;
    }
    [_hashJs.symbol]() {
        return FrequencyKeyTypeHash;
    }
    [_equalJs.symbol](that) {
        return isFrequencyKey(that);
    }
    pipe() {
        return (0, _pipeableJs.pipeArguments)(this, arguments);
    }
}
const GaugeKeyTypeHash = /*#__PURE__*/ _hashJs.string(GaugeKeyTypeSymbolKey);
/** @internal */ class GaugeKeyType {
    bigint;
    [MetricKeyTypeTypeId] = metricKeyTypeVariance;
    [GaugeKeyTypeTypeId] = GaugeKeyTypeTypeId;
    constructor(bigint){
        this.bigint = bigint;
    }
    [_hashJs.symbol]() {
        return GaugeKeyTypeHash;
    }
    [_equalJs.symbol](that) {
        return isGaugeKey(that);
    }
    pipe() {
        return (0, _pipeableJs.pipeArguments)(this, arguments);
    }
}
class HistogramKeyType {
    boundaries;
    [MetricKeyTypeTypeId] = metricKeyTypeVariance;
    [HistogramKeyTypeTypeId] = HistogramKeyTypeTypeId;
    constructor(boundaries){
        this.boundaries = boundaries;
        this._hash = (0, _functionJs.pipe)(_hashJs.string(HistogramKeyTypeSymbolKey), _hashJs.combine(_hashJs.hash(this.boundaries)));
    }
    _hash;
    [_hashJs.symbol]() {
        return this._hash;
    }
    [_equalJs.symbol](that) {
        return isHistogramKey(that) && _equalJs.equals(this.boundaries, that.boundaries);
    }
    pipe() {
        return (0, _pipeableJs.pipeArguments)(this, arguments);
    }
}
/** @internal */ class SummaryKeyType {
    maxAge;
    maxSize;
    error;
    quantiles;
    [MetricKeyTypeTypeId] = metricKeyTypeVariance;
    [SummaryKeyTypeTypeId] = SummaryKeyTypeTypeId;
    constructor(maxAge, maxSize, error, quantiles){
        this.maxAge = maxAge;
        this.maxSize = maxSize;
        this.error = error;
        this.quantiles = quantiles;
        this._hash = (0, _functionJs.pipe)(_hashJs.string(SummaryKeyTypeSymbolKey), _hashJs.combine(_hashJs.hash(this.maxAge)), _hashJs.combine(_hashJs.hash(this.maxSize)), _hashJs.combine(_hashJs.hash(this.error)), _hashJs.combine(_hashJs.array(this.quantiles)));
    }
    _hash;
    [_hashJs.symbol]() {
        return this._hash;
    }
    [_equalJs.symbol](that) {
        return isSummaryKey(that) && _equalJs.equals(this.maxAge, that.maxAge) && this.maxSize === that.maxSize && this.error === that.error && _equalJs.equals(this.quantiles, that.quantiles);
    }
    pipe() {
        return (0, _pipeableJs.pipeArguments)(this, arguments);
    }
}
const counter = (options)=>new CounterKeyType(options?.incremental ?? false, options?.bigint ?? false);
const frequency = (options)=>new FrequencyKeyType(options?.preregisteredWords ?? []);
const gauge = (options)=>new GaugeKeyType(options?.bigint ?? false);
const histogram = (boundaries)=>{
    return new HistogramKeyType(boundaries);
};
const summary = (options)=>{
    return new SummaryKeyType(_durationJs.decode(options.maxAge), options.maxSize, options.error, options.quantiles);
};
const isMetricKeyType = (u)=>(0, _predicateJs.hasProperty)(u, MetricKeyTypeTypeId);
const isCounterKey = (u)=>(0, _predicateJs.hasProperty)(u, CounterKeyTypeTypeId);
const isFrequencyKey = (u)=>(0, _predicateJs.hasProperty)(u, FrequencyKeyTypeTypeId);
const isGaugeKey = (u)=>(0, _predicateJs.hasProperty)(u, GaugeKeyTypeTypeId);
const isHistogramKey = (u)=>(0, _predicateJs.hasProperty)(u, HistogramKeyTypeTypeId);
const isSummaryKey = (u)=>(0, _predicateJs.hasProperty)(u, SummaryKeyTypeTypeId);

},{"../../Duration.js":"czLLe","../../Equal.js":"gA0qD","../../Function.js":"21gOL","../../Hash.js":"gFMwE","../../Pipeable.js":"b5RU2","../../Predicate.js":"gW5pd","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"hbbxL":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MetricRegistryTypeId", ()=>MetricRegistryTypeId);
parcelHelpers.export(exports, "make", ()=>make);
var _functionJs = require("../../Function.js");
var _mutableHashMapJs = require("../../MutableHashMap.js");
var _optionJs = require("../../Option.js");
var _hookJs = require("./hook.js");
var _keyTypeJs = require("./keyType.js");
var _pairJs = require("./pair.js");
/** @internal */ const MetricRegistrySymbolKey = "effect/MetricRegistry";
const MetricRegistryTypeId = /*#__PURE__*/ Symbol.for(MetricRegistrySymbolKey);
/** @internal */ class MetricRegistryImpl {
    [MetricRegistryTypeId] = MetricRegistryTypeId;
    map = /*#__PURE__*/ _mutableHashMapJs.empty();
    snapshot() {
        const result = [];
        for (const [key, hook] of this.map)result.push(_pairJs.unsafeMake(key, hook.get()));
        return result;
    }
    get(key) {
        const hook = (0, _functionJs.pipe)(this.map, _mutableHashMapJs.get(key), _optionJs.getOrUndefined);
        if (hook == null) {
            if (_keyTypeJs.isCounterKey(key.keyType)) return this.getCounter(key);
            if (_keyTypeJs.isGaugeKey(key.keyType)) return this.getGauge(key);
            if (_keyTypeJs.isFrequencyKey(key.keyType)) return this.getFrequency(key);
            if (_keyTypeJs.isHistogramKey(key.keyType)) return this.getHistogram(key);
            if (_keyTypeJs.isSummaryKey(key.keyType)) return this.getSummary(key);
            throw new Error("BUG: MetricRegistry.get - unknown MetricKeyType - please report an issue at https://github.com/Effect-TS/effect/issues");
        } else return hook;
    }
    getCounter(key) {
        let value = (0, _functionJs.pipe)(this.map, _mutableHashMapJs.get(key), _optionJs.getOrUndefined);
        if (value == null) {
            const counter = _hookJs.counter(key);
            if (!(0, _functionJs.pipe)(this.map, _mutableHashMapJs.has(key))) (0, _functionJs.pipe)(this.map, _mutableHashMapJs.set(key, counter));
            value = counter;
        }
        return value;
    }
    getFrequency(key) {
        let value = (0, _functionJs.pipe)(this.map, _mutableHashMapJs.get(key), _optionJs.getOrUndefined);
        if (value == null) {
            const frequency = _hookJs.frequency(key);
            if (!(0, _functionJs.pipe)(this.map, _mutableHashMapJs.has(key))) (0, _functionJs.pipe)(this.map, _mutableHashMapJs.set(key, frequency));
            value = frequency;
        }
        return value;
    }
    getGauge(key) {
        let value = (0, _functionJs.pipe)(this.map, _mutableHashMapJs.get(key), _optionJs.getOrUndefined);
        if (value == null) {
            const gauge = _hookJs.gauge(key, key.keyType.bigint ? BigInt(0) : 0);
            if (!(0, _functionJs.pipe)(this.map, _mutableHashMapJs.has(key))) (0, _functionJs.pipe)(this.map, _mutableHashMapJs.set(key, gauge));
            value = gauge;
        }
        return value;
    }
    getHistogram(key) {
        let value = (0, _functionJs.pipe)(this.map, _mutableHashMapJs.get(key), _optionJs.getOrUndefined);
        if (value == null) {
            const histogram = _hookJs.histogram(key);
            if (!(0, _functionJs.pipe)(this.map, _mutableHashMapJs.has(key))) (0, _functionJs.pipe)(this.map, _mutableHashMapJs.set(key, histogram));
            value = histogram;
        }
        return value;
    }
    getSummary(key) {
        let value = (0, _functionJs.pipe)(this.map, _mutableHashMapJs.get(key), _optionJs.getOrUndefined);
        if (value == null) {
            const summary = _hookJs.summary(key);
            if (!(0, _functionJs.pipe)(this.map, _mutableHashMapJs.has(key))) (0, _functionJs.pipe)(this.map, _mutableHashMapJs.set(key, summary));
            value = summary;
        }
        return value;
    }
}
const make = ()=>{
    return new MetricRegistryImpl();
};

},{"../../Function.js":"21gOL","../../MutableHashMap.js":"1goeS","../../Option.js":"6sHA7","./hook.js":"7eo6L","./keyType.js":"57Nou","./pair.js":"2ngrr","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"1goeS":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "empty", ()=>empty);
parcelHelpers.export(exports, "make", ()=>make);
parcelHelpers.export(exports, "fromIterable", ()=>fromIterable);
parcelHelpers.export(exports, "get", ()=>get);
parcelHelpers.export(exports, "keys", ()=>keys);
parcelHelpers.export(exports, "values", ()=>values);
parcelHelpers.export(exports, "has", ()=>has);
parcelHelpers.export(exports, "set", ()=>set);
parcelHelpers.export(exports, "modify", ()=>modify);
parcelHelpers.export(exports, "modifyAt", ()=>modifyAt);
parcelHelpers.export(exports, "remove", ()=>remove);
parcelHelpers.export(exports, "clear", ()=>clear);
parcelHelpers.export(exports, "size", ()=>size);
parcelHelpers.export(exports, "isEmpty", ()=>isEmpty);
parcelHelpers.export(exports, "forEach", ()=>forEach);
var _equalJs = require("./Equal.js");
var _functionJs = require("./Function.js");
var _hashJs = require("./Hash.js");
var _inspectableJs = require("./Inspectable.js");
var _optionJs = require("./Option.js");
var _pipeableJs = require("./Pipeable.js");
const TypeId = /*#__PURE__*/ Symbol.for("effect/MutableHashMap");
const MutableHashMapProto = {
    [TypeId]: TypeId,
    [Symbol.iterator] () {
        return new MutableHashMapIterator(this);
    },
    toString () {
        return (0, _inspectableJs.format)(this.toJSON());
    },
    toJSON () {
        return {
            _id: "MutableHashMap",
            values: Array.from(this).map((0, _inspectableJs.toJSON))
        };
    },
    [(0, _inspectableJs.NodeInspectSymbol)] () {
        return this.toJSON();
    },
    pipe () {
        return (0, _pipeableJs.pipeArguments)(this, arguments);
    }
};
class MutableHashMapIterator {
    self;
    referentialIterator;
    bucketIterator;
    constructor(self){
        this.self = self;
        this.referentialIterator = self.referential[Symbol.iterator]();
    }
    next() {
        if (this.bucketIterator !== undefined) return this.bucketIterator.next();
        const result = this.referentialIterator.next();
        if (result.done) {
            this.bucketIterator = new BucketIterator(this.self.buckets.values());
            return this.next();
        }
        return result;
    }
    [Symbol.iterator]() {
        return new MutableHashMapIterator(this.self);
    }
}
class BucketIterator {
    backing;
    constructor(backing){
        this.backing = backing;
    }
    currentBucket;
    next() {
        if (this.currentBucket === undefined) {
            const result = this.backing.next();
            if (result.done) return result;
            this.currentBucket = result.value[Symbol.iterator]();
        }
        const result = this.currentBucket.next();
        if (result.done) {
            this.currentBucket = undefined;
            return this.next();
        }
        return result;
    }
}
const empty = ()=>{
    const self = Object.create(MutableHashMapProto);
    self.referential = new Map();
    self.buckets = new Map();
    self.bucketsSize = 0;
    return self;
};
const make = (...entries)=>fromIterable(entries);
const fromIterable = (entries)=>{
    const self = empty();
    for (const [key, value] of entries)set(self, key, value);
    return self;
};
const get = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, key)=>{
    if (_equalJs.isEqual(key) === false) return self.referential.has(key) ? _optionJs.some(self.referential.get(key)) : _optionJs.none();
    const hash = key[_hashJs.symbol]();
    const bucket = self.buckets.get(hash);
    if (bucket === undefined) return _optionJs.none();
    return getFromBucket(self, bucket, key);
});
const keys = (self)=>{
    const keys = Array.from(self.referential.keys());
    for (const bucket of self.buckets.values())for(let i = 0, len = bucket.length; i < len; i++)keys.push(bucket[i][0]);
    return keys;
};
const values = (self)=>{
    const values = Array.from(self.referential.values());
    for (const bucket of self.buckets.values())for(let i = 0, len = bucket.length; i < len; i++)values.push(bucket[i][1]);
    return values;
};
const getFromBucket = (self, bucket, key, remove = false)=>{
    for(let i = 0, len = bucket.length; i < len; i++)if (key[_equalJs.symbol](bucket[i][0])) {
        const value = bucket[i][1];
        if (remove) {
            bucket.splice(i, 1);
            self.bucketsSize--;
        }
        return _optionJs.some(value);
    }
    return _optionJs.none();
};
const has = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, key)=>_optionJs.isSome(get(self, key)));
const set = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, key, value)=>{
    if (_equalJs.isEqual(key) === false) {
        self.referential.set(key, value);
        return self;
    }
    const hash = key[_hashJs.symbol]();
    const bucket = self.buckets.get(hash);
    if (bucket === undefined) {
        self.buckets.set(hash, [
            [
                key,
                value
            ]
        ]);
        self.bucketsSize++;
        return self;
    }
    removeFromBucket(self, bucket, key);
    bucket.push([
        key,
        value
    ]);
    self.bucketsSize++;
    return self;
});
const removeFromBucket = (self, bucket, key)=>{
    for(let i = 0, len = bucket.length; i < len; i++)if (key[_equalJs.symbol](bucket[i][0])) {
        bucket.splice(i, 1);
        self.bucketsSize--;
        return;
    }
};
const modify = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, key, f)=>{
    if (_equalJs.isEqual(key) === false) {
        if (self.referential.has(key)) self.referential.set(key, f(self.referential.get(key)));
        return self;
    }
    const hash = key[_hashJs.symbol]();
    const bucket = self.buckets.get(hash);
    if (bucket === undefined) return self;
    const value = getFromBucket(self, bucket, key, true);
    if (_optionJs.isNone(value)) return self;
    bucket.push([
        key,
        f(value.value)
    ]);
    self.bucketsSize++;
    return self;
});
const modifyAt = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, key, f)=>{
    if (_equalJs.isEqual(key) === false) {
        const result = f(get(self, key));
        if (_optionJs.isSome(result)) set(self, key, result.value);
        else remove(self, key);
        return self;
    }
    const hash = key[_hashJs.symbol]();
    const bucket = self.buckets.get(hash);
    if (bucket === undefined) {
        const result = f(_optionJs.none());
        return _optionJs.isSome(result) ? set(self, key, result.value) : self;
    }
    const result = f(getFromBucket(self, bucket, key, true));
    if (_optionJs.isNone(result)) {
        if (bucket.length === 0) self.buckets.delete(hash);
        return self;
    }
    bucket.push([
        key,
        result.value
    ]);
    self.bucketsSize++;
    return self;
});
const remove = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, key)=>{
    if (_equalJs.isEqual(key) === false) {
        self.referential.delete(key);
        return self;
    }
    const hash = key[_hashJs.symbol]();
    const bucket = self.buckets.get(hash);
    if (bucket === undefined) return self;
    removeFromBucket(self, bucket, key);
    if (bucket.length === 0) self.buckets.delete(hash);
    return self;
});
const clear = (self)=>{
    self.referential.clear();
    self.buckets.clear();
    self.bucketsSize = 0;
    return self;
};
const size = (self)=>{
    return self.referential.size + self.bucketsSize;
};
const isEmpty = (self)=>size(self) === 0;
const forEach = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>{
    self.referential.forEach(f);
    for (const bucket of self.buckets.values())for (const [key, value] of bucket)f(value, key);
});

},{"./Equal.js":"gA0qD","./Function.js":"21gOL","./Hash.js":"gFMwE","./Inspectable.js":"1Ur70","./Option.js":"6sHA7","./Pipeable.js":"b5RU2","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"7eo6L":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MetricHookTypeId", ()=>MetricHookTypeId);
parcelHelpers.export(exports, "make", ()=>make);
parcelHelpers.export(exports, "onModify", ()=>onModify);
parcelHelpers.export(exports, "onUpdate", ()=>onUpdate);
parcelHelpers.export(exports, "counter", ()=>counter);
parcelHelpers.export(exports, "frequency", ()=>frequency);
parcelHelpers.export(exports, "gauge", ()=>gauge);
parcelHelpers.export(exports, "histogram", ()=>histogram);
parcelHelpers.export(exports, "summary", ()=>summary);
var _arrayJs = require("../../Array.js");
var _durationJs = require("../../Duration.js");
var _functionJs = require("../../Function.js");
var _numberJs = require("../../Number.js");
var _optionJs = require("../../Option.js");
var _pipeableJs = require("../../Pipeable.js");
var _stateJs = require("./state.js");
/** @internal */ const MetricHookSymbolKey = "effect/MetricHook";
const MetricHookTypeId = /*#__PURE__*/ Symbol.for(MetricHookSymbolKey);
const metricHookVariance = {
    /* c8 ignore next */ _In: (_)=>_,
    /* c8 ignore next */ _Out: (_)=>_
};
const make = (options)=>({
        [MetricHookTypeId]: metricHookVariance,
        pipe () {
            return (0, _pipeableJs.pipeArguments)(this, arguments);
        },
        ...options
    });
const onModify = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>({
        [MetricHookTypeId]: metricHookVariance,
        pipe () {
            return (0, _pipeableJs.pipeArguments)(this, arguments);
        },
        get: self.get,
        update: self.update,
        modify: (input)=>{
            self.modify(input);
            return f(input);
        }
    }));
const onUpdate = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>({
        [MetricHookTypeId]: metricHookVariance,
        pipe () {
            return (0, _pipeableJs.pipeArguments)(this, arguments);
        },
        get: self.get,
        update: (input)=>{
            self.update(input);
            return f(input);
        },
        modify: self.modify
    }));
const bigint0 = /*#__PURE__*/ BigInt(0);
const counter = (key)=>{
    let sum = key.keyType.bigint ? bigint0 : 0;
    const canUpdate = key.keyType.incremental ? key.keyType.bigint ? (value)=>value >= bigint0 : (value)=>value >= 0 : (_value)=>true;
    const update = (value)=>{
        if (canUpdate(value)) sum = sum + value;
    };
    return make({
        get: ()=>_stateJs.counter(sum),
        update,
        modify: update
    });
};
const frequency = (key)=>{
    const values = new Map();
    for (const word of key.keyType.preregisteredWords)values.set(word, 0);
    const update = (word)=>{
        const slotCount = values.get(word) ?? 0;
        values.set(word, slotCount + 1);
    };
    return make({
        get: ()=>_stateJs.frequency(values),
        update,
        modify: update
    });
};
const gauge = (_key, startAt)=>{
    let value = startAt;
    return make({
        get: ()=>_stateJs.gauge(value),
        update: (v)=>{
            value = v;
        },
        modify: (v)=>{
            value = value + v;
        }
    });
};
const histogram = (key)=>{
    const bounds = key.keyType.boundaries.values;
    const size = bounds.length;
    const values = new Uint32Array(size + 1);
    const boundaries = new Float32Array(size);
    let count = 0;
    let sum = 0;
    let min = Number.MAX_VALUE;
    let max = Number.MIN_VALUE;
    (0, _functionJs.pipe)(bounds, _arrayJs.sort(_numberJs.Order), _arrayJs.map((n, i)=>{
        boundaries[i] = n;
    }));
    // Insert the value into the right bucket with a binary search
    const update = (value)=>{
        let from = 0;
        let to = size;
        while(from !== to){
            const mid = Math.floor(from + (to - from) / 2);
            const boundary = boundaries[mid];
            if (value <= boundary) to = mid;
            else from = mid;
            // The special case when to / from have a distance of one
            if (to === from + 1) {
                if (value <= boundaries[from]) to = from;
                else from = to;
            }
        }
        values[from] = values[from] + 1;
        count = count + 1;
        sum = sum + value;
        if (value < min) min = value;
        if (value > max) max = value;
    };
    const getBuckets = ()=>{
        const builder = _arrayJs.allocate(size);
        let cumulated = 0;
        for(let i = 0; i < size; i++){
            const boundary = boundaries[i];
            const value = values[i];
            cumulated = cumulated + value;
            builder[i] = [
                boundary,
                cumulated
            ];
        }
        return builder;
    };
    return make({
        get: ()=>_stateJs.histogram({
                buckets: getBuckets(),
                count,
                min,
                max,
                sum
            }),
        update,
        modify: update
    });
};
const summary = (key)=>{
    const { error, maxAge, maxSize, quantiles } = key.keyType;
    const sortedQuantiles = (0, _functionJs.pipe)(quantiles, _arrayJs.sort(_numberJs.Order));
    const values = _arrayJs.allocate(maxSize);
    let head = 0;
    let count = 0;
    let sum = 0;
    let min = Number.MAX_VALUE;
    let max = Number.MIN_VALUE;
    // Just before the snapshot we filter out all values older than maxAge
    const snapshot = (now)=>{
        const builder = [];
        // If the buffer is not full yet it contains valid items at the 0..last
        // indices and null values at the rest of the positions.
        //
        // If the buffer is already full then all elements contains a valid
        // measurement with timestamp.
        //
        // At any given point in time we can enumerate all the non-null elements in
        // the buffer and filter them by timestamp to get a valid view of a time
        // window.
        //
        // The order does not matter because it gets sorted before passing to
        // `calculateQuantiles`.
        let i = 0;
        while(i !== maxSize - 1){
            const item = values[i];
            if (item != null) {
                const [t, v] = item;
                const age = _durationJs.millis(now - t);
                if (_durationJs.greaterThanOrEqualTo(age, _durationJs.zero) && _durationJs.lessThanOrEqualTo(age, maxAge)) builder.push(v);
            }
            i = i + 1;
        }
        return calculateQuantiles(error, sortedQuantiles, _arrayJs.sort(builder, _numberJs.Order));
    };
    const observe = (value, timestamp)=>{
        if (maxSize > 0) {
            head = head + 1;
            const target = head % maxSize;
            values[target] = [
                timestamp,
                value
            ];
        }
        count = count + 1;
        sum = sum + value;
        if (value < min) min = value;
        if (value > max) max = value;
    };
    return make({
        get: ()=>_stateJs.summary({
                error,
                quantiles: snapshot(Date.now()),
                count,
                min,
                max,
                sum
            }),
        update: ([value, timestamp])=>observe(value, timestamp),
        modify: ([value, timestamp])=>observe(value, timestamp)
    });
};
/** @internal */ const calculateQuantiles = (error, sortedQuantiles, sortedSamples)=>{
    // The number of samples examined
    const sampleCount = sortedSamples.length;
    if (!_arrayJs.isNonEmptyReadonlyArray(sortedQuantiles)) return _arrayJs.empty();
    const head = sortedQuantiles[0];
    const tail = sortedQuantiles.slice(1);
    const resolvedHead = resolveQuantile(error, sampleCount, _optionJs.none(), 0, head, sortedSamples);
    const resolved = _arrayJs.of(resolvedHead);
    tail.forEach((quantile)=>{
        resolved.push(resolveQuantile(error, sampleCount, resolvedHead.value, resolvedHead.consumed, quantile, resolvedHead.rest));
    });
    return _arrayJs.map(resolved, (rq)=>[
            rq.quantile,
            rq.value
        ]);
};
/** @internal */ const resolveQuantile = (error, sampleCount, current, consumed, quantile, rest)=>{
    let error_1 = error;
    let sampleCount_1 = sampleCount;
    let current_1 = current;
    let consumed_1 = consumed;
    let quantile_1 = quantile;
    let rest_1 = rest;
    let error_2 = error;
    let sampleCount_2 = sampleCount;
    let current_2 = current;
    let consumed_2 = consumed;
    let quantile_2 = quantile;
    let rest_2 = rest;
    // eslint-disable-next-line no-constant-condition
    while(true){
        // If the remaining list of samples is empty, there is nothing more to resolve
        if (!_arrayJs.isNonEmptyReadonlyArray(rest_1)) return {
            quantile: quantile_1,
            value: _optionJs.none(),
            consumed: consumed_1,
            rest: []
        };
        // If the quantile is the 100% quantile, we can take the maximum of all the
        // remaining values as the result
        if (quantile_1 === 1) return {
            quantile: quantile_1,
            value: _optionJs.some(_arrayJs.lastNonEmpty(rest_1)),
            consumed: consumed_1 + rest_1.length,
            rest: []
        };
        // Split into two chunks - the first chunk contains all elements of the same
        // value as the chunk head
        const headValue = _arrayJs.headNonEmpty(rest_1); // Get head value since rest_1 is non-empty
        const sameHead = _arrayJs.span(rest_1, (n)=>n === headValue);
        // How many elements do we want to accept for this quantile
        const desired = quantile_1 * sampleCount_1;
        // The error margin
        const allowedError = error_1 / 2 * desired;
        // Taking into account the elements consumed from the samples so far and the
        // number of same elements at the beginning of the chunk, calculate the number
        // of elements we would have if we selected the current head as result
        const candConsumed = consumed_1 + sameHead[0].length;
        const candError = Math.abs(candConsumed - desired);
        // If we haven't got enough elements yet, recurse
        if (candConsumed < desired - allowedError) {
            error_2 = error_1;
            sampleCount_2 = sampleCount_1;
            current_2 = _arrayJs.head(rest_1);
            consumed_2 = candConsumed;
            quantile_2 = quantile_1;
            rest_2 = sameHead[1];
            error_1 = error_2;
            sampleCount_1 = sampleCount_2;
            current_1 = current_2;
            consumed_1 = consumed_2;
            quantile_1 = quantile_2;
            rest_1 = rest_2;
            continue;
        }
        // If consuming this chunk leads to too many elements (rank is too high)
        if (candConsumed > desired + allowedError) {
            const valueToReturn = _optionJs.isNone(current_1) ? _optionJs.some(headValue) : current_1;
            return {
                quantile: quantile_1,
                value: valueToReturn,
                consumed: consumed_1,
                rest: rest_1
            };
        }
        // If we are in the target interval, select the current head and hand back the leftover after dropping all elements
        // from the sample chunk that are equal to the current head
        switch(current_1._tag){
            case "None":
                error_2 = error_1;
                sampleCount_2 = sampleCount_1;
                current_2 = _arrayJs.head(rest_1);
                consumed_2 = candConsumed;
                quantile_2 = quantile_1;
                rest_2 = sameHead[1];
                error_1 = error_2;
                sampleCount_1 = sampleCount_2;
                current_1 = current_2;
                consumed_1 = consumed_2;
                quantile_1 = quantile_2;
                rest_1 = rest_2;
                continue;
            case "Some":
                {
                    const prevError = Math.abs(desired - current_1.value);
                    if (candError < prevError) {
                        error_2 = error_1;
                        sampleCount_2 = sampleCount_1;
                        current_2 = _arrayJs.head(rest_1);
                        consumed_2 = candConsumed;
                        quantile_2 = quantile_1;
                        rest_2 = sameHead[1];
                        error_1 = error_2;
                        sampleCount_1 = sampleCount_2;
                        current_1 = current_2;
                        consumed_1 = consumed_2;
                        quantile_1 = quantile_2;
                        rest_1 = rest_2;
                        continue;
                    }
                    return {
                        quantile: quantile_1,
                        value: _optionJs.some(current_1.value),
                        consumed: consumed_1,
                        rest: rest_1
                    };
                }
        }
    }
    throw new Error("BUG: MetricHook.resolveQuantiles - please report an issue at https://github.com/Effect-TS/effect/issues");
};

},{"../../Array.js":"8L2Gk","../../Duration.js":"czLLe","../../Function.js":"21gOL","../../Number.js":"al4Y3","../../Option.js":"6sHA7","../../Pipeable.js":"b5RU2","./state.js":"7SyxM","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"7SyxM":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MetricStateTypeId", ()=>MetricStateTypeId);
parcelHelpers.export(exports, "CounterStateTypeId", ()=>CounterStateTypeId);
parcelHelpers.export(exports, "FrequencyStateTypeId", ()=>FrequencyStateTypeId);
parcelHelpers.export(exports, "GaugeStateTypeId", ()=>GaugeStateTypeId);
parcelHelpers.export(exports, "HistogramStateTypeId", ()=>HistogramStateTypeId);
parcelHelpers.export(exports, "SummaryStateTypeId", ()=>SummaryStateTypeId);
/** @internal */ parcelHelpers.export(exports, "HistogramState", ()=>HistogramState);
/** @internal */ parcelHelpers.export(exports, "SummaryState", ()=>SummaryState);
parcelHelpers.export(exports, "counter", ()=>counter);
parcelHelpers.export(exports, "frequency", ()=>frequency);
parcelHelpers.export(exports, "gauge", ()=>gauge);
parcelHelpers.export(exports, "histogram", ()=>histogram);
parcelHelpers.export(exports, "summary", ()=>summary);
parcelHelpers.export(exports, "isMetricState", ()=>isMetricState);
parcelHelpers.export(exports, "isCounterState", ()=>isCounterState);
parcelHelpers.export(exports, "isFrequencyState", ()=>isFrequencyState);
parcelHelpers.export(exports, "isGaugeState", ()=>isGaugeState);
parcelHelpers.export(exports, "isHistogramState", ()=>isHistogramState);
parcelHelpers.export(exports, "isSummaryState", ()=>isSummaryState);
var _arrayJs = require("../../Array.js");
var _equalJs = require("../../Equal.js");
var _functionJs = require("../../Function.js");
var _hashJs = require("../../Hash.js");
var _pipeableJs = require("../../Pipeable.js");
var _predicateJs = require("../../Predicate.js");
/** @internal */ const MetricStateSymbolKey = "effect/MetricState";
const MetricStateTypeId = /*#__PURE__*/ Symbol.for(MetricStateSymbolKey);
/** @internal */ const CounterStateSymbolKey = "effect/MetricState/Counter";
const CounterStateTypeId = /*#__PURE__*/ Symbol.for(CounterStateSymbolKey);
/** @internal */ const FrequencyStateSymbolKey = "effect/MetricState/Frequency";
const FrequencyStateTypeId = /*#__PURE__*/ Symbol.for(FrequencyStateSymbolKey);
/** @internal */ const GaugeStateSymbolKey = "effect/MetricState/Gauge";
const GaugeStateTypeId = /*#__PURE__*/ Symbol.for(GaugeStateSymbolKey);
/** @internal */ const HistogramStateSymbolKey = "effect/MetricState/Histogram";
const HistogramStateTypeId = /*#__PURE__*/ Symbol.for(HistogramStateSymbolKey);
/** @internal */ const SummaryStateSymbolKey = "effect/MetricState/Summary";
const SummaryStateTypeId = /*#__PURE__*/ Symbol.for(SummaryStateSymbolKey);
const metricStateVariance = {
    /* c8 ignore next */ _A: (_)=>_
};
/** @internal */ class CounterState {
    count;
    [MetricStateTypeId] = metricStateVariance;
    [CounterStateTypeId] = CounterStateTypeId;
    constructor(count){
        this.count = count;
    }
    [_hashJs.symbol]() {
        return (0, _functionJs.pipe)(_hashJs.hash(CounterStateSymbolKey), _hashJs.combine(_hashJs.hash(this.count)), _hashJs.cached(this));
    }
    [_equalJs.symbol](that) {
        return isCounterState(that) && this.count === that.count;
    }
    pipe() {
        return (0, _pipeableJs.pipeArguments)(this, arguments);
    }
}
const arrayEquals = /*#__PURE__*/ _arrayJs.getEquivalence(_equalJs.equals);
/** @internal */ class FrequencyState {
    occurrences;
    [MetricStateTypeId] = metricStateVariance;
    [FrequencyStateTypeId] = FrequencyStateTypeId;
    constructor(occurrences){
        this.occurrences = occurrences;
    }
    _hash;
    [_hashJs.symbol]() {
        return (0, _functionJs.pipe)(_hashJs.string(FrequencyStateSymbolKey), _hashJs.combine(_hashJs.array(_arrayJs.fromIterable(this.occurrences.entries()))), _hashJs.cached(this));
    }
    [_equalJs.symbol](that) {
        return isFrequencyState(that) && arrayEquals(_arrayJs.fromIterable(this.occurrences.entries()), _arrayJs.fromIterable(that.occurrences.entries()));
    }
    pipe() {
        return (0, _pipeableJs.pipeArguments)(this, arguments);
    }
}
/** @internal */ class GaugeState {
    value;
    [MetricStateTypeId] = metricStateVariance;
    [GaugeStateTypeId] = GaugeStateTypeId;
    constructor(value){
        this.value = value;
    }
    [_hashJs.symbol]() {
        return (0, _functionJs.pipe)(_hashJs.hash(GaugeStateSymbolKey), _hashJs.combine(_hashJs.hash(this.value)), _hashJs.cached(this));
    }
    [_equalJs.symbol](u) {
        return isGaugeState(u) && this.value === u.value;
    }
    pipe() {
        return (0, _pipeableJs.pipeArguments)(this, arguments);
    }
}
class HistogramState {
    buckets;
    count;
    min;
    max;
    sum;
    [MetricStateTypeId] = metricStateVariance;
    [HistogramStateTypeId] = HistogramStateTypeId;
    constructor(buckets, count, min, max, sum){
        this.buckets = buckets;
        this.count = count;
        this.min = min;
        this.max = max;
        this.sum = sum;
    }
    [_hashJs.symbol]() {
        return (0, _functionJs.pipe)(_hashJs.hash(HistogramStateSymbolKey), _hashJs.combine(_hashJs.hash(this.buckets)), _hashJs.combine(_hashJs.hash(this.count)), _hashJs.combine(_hashJs.hash(this.min)), _hashJs.combine(_hashJs.hash(this.max)), _hashJs.combine(_hashJs.hash(this.sum)), _hashJs.cached(this));
    }
    [_equalJs.symbol](that) {
        return isHistogramState(that) && _equalJs.equals(this.buckets, that.buckets) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;
    }
    pipe() {
        return (0, _pipeableJs.pipeArguments)(this, arguments);
    }
}
class SummaryState {
    error;
    quantiles;
    count;
    min;
    max;
    sum;
    [MetricStateTypeId] = metricStateVariance;
    [SummaryStateTypeId] = SummaryStateTypeId;
    constructor(error, quantiles, count, min, max, sum){
        this.error = error;
        this.quantiles = quantiles;
        this.count = count;
        this.min = min;
        this.max = max;
        this.sum = sum;
    }
    [_hashJs.symbol]() {
        return (0, _functionJs.pipe)(_hashJs.hash(SummaryStateSymbolKey), _hashJs.combine(_hashJs.hash(this.error)), _hashJs.combine(_hashJs.hash(this.quantiles)), _hashJs.combine(_hashJs.hash(this.count)), _hashJs.combine(_hashJs.hash(this.min)), _hashJs.combine(_hashJs.hash(this.max)), _hashJs.combine(_hashJs.hash(this.sum)), _hashJs.cached(this));
    }
    [_equalJs.symbol](that) {
        return isSummaryState(that) && this.error === that.error && _equalJs.equals(this.quantiles, that.quantiles) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;
    }
    pipe() {
        return (0, _pipeableJs.pipeArguments)(this, arguments);
    }
}
const counter = (count)=>new CounterState(count);
const frequency = (occurrences)=>{
    return new FrequencyState(occurrences);
};
const gauge = (count)=>new GaugeState(count);
const histogram = (options)=>new HistogramState(options.buckets, options.count, options.min, options.max, options.sum);
const summary = (options)=>new SummaryState(options.error, options.quantiles, options.count, options.min, options.max, options.sum);
const isMetricState = (u)=>(0, _predicateJs.hasProperty)(u, MetricStateTypeId);
const isCounterState = (u)=>(0, _predicateJs.hasProperty)(u, CounterStateTypeId);
const isFrequencyState = (u)=>(0, _predicateJs.hasProperty)(u, FrequencyStateTypeId);
const isGaugeState = (u)=>(0, _predicateJs.hasProperty)(u, GaugeStateTypeId);
const isHistogramState = (u)=>(0, _predicateJs.hasProperty)(u, HistogramStateTypeId);
const isSummaryState = (u)=>(0, _predicateJs.hasProperty)(u, SummaryStateTypeId);

},{"../../Array.js":"8L2Gk","../../Equal.js":"gA0qD","../../Function.js":"21gOL","../../Hash.js":"gFMwE","../../Pipeable.js":"b5RU2","../../Predicate.js":"gW5pd","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"2ngrr":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MetricPairTypeId", ()=>MetricPairTypeId);
parcelHelpers.export(exports, "make", ()=>make);
parcelHelpers.export(exports, "unsafeMake", ()=>unsafeMake);
var _pipeableJs = require("../../Pipeable.js");
/** @internal */ const MetricPairSymbolKey = "effect/MetricPair";
const MetricPairTypeId = /*#__PURE__*/ Symbol.for(MetricPairSymbolKey);
const metricPairVariance = {
    /* c8 ignore next */ _Type: (_)=>_
};
const make = (metricKey, metricState)=>{
    return {
        [MetricPairTypeId]: metricPairVariance,
        metricKey,
        metricState,
        pipe () {
            return (0, _pipeableJs.pipeArguments)(this, arguments);
        }
    };
};
const unsafeMake = (metricKey, metricState)=>{
    return {
        [MetricPairTypeId]: metricPairVariance,
        metricKey,
        metricState,
        pipe () {
            return (0, _pipeableJs.pipeArguments)(this, arguments);
        }
    };
};

},{"../../Pipeable.js":"b5RU2","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"j7pmc":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RequestTypeId", ()=>RequestTypeId);
parcelHelpers.export(exports, "isRequest", ()=>isRequest);
parcelHelpers.export(exports, "of", ()=>of);
parcelHelpers.export(exports, "tagged", ()=>tagged);
parcelHelpers.export(exports, "Class", ()=>Class);
parcelHelpers.export(exports, "TaggedClass", ()=>TaggedClass);
parcelHelpers.export(exports, "complete", ()=>complete);
parcelHelpers.export(exports, "completeEffect", ()=>completeEffect);
parcelHelpers.export(exports, "fail", ()=>fail);
parcelHelpers.export(exports, "failCause", ()=>failCause);
parcelHelpers.export(exports, "succeed", ()=>succeed);
/** @internal */ parcelHelpers.export(exports, "Listeners", ()=>Listeners);
parcelHelpers.export(exports, "filterOutCompleted", ()=>filterOutCompleted);
var _functionJs = require("../Function.js");
var _predicateJs = require("../Predicate.js");
var _completedRequestMapJs = require("./completedRequestMap.js");
var _coreJs = require("./core.js");
var _effectableJs = require("./effectable.js");
/** @internal */ const RequestSymbolKey = "effect/Request";
const RequestTypeId = /*#__PURE__*/ Symbol.for(RequestSymbolKey);
const requestVariance = {
    /* c8 ignore next */ _E: (_)=>_,
    /* c8 ignore next */ _A: (_)=>_
};
const RequestPrototype = {
    ...(0, _effectableJs.StructuralPrototype),
    [RequestTypeId]: requestVariance
};
const isRequest = (u)=>(0, _predicateJs.hasProperty)(u, RequestTypeId);
const of = ()=>(args)=>Object.assign(Object.create(RequestPrototype), args);
const tagged = (tag)=>(args)=>{
        const request = Object.assign(Object.create(RequestPrototype), args);
        request._tag = tag;
        return request;
    };
const Class = /*#__PURE__*/ function() {
    function Class(args) {
        if (args) Object.assign(this, args);
    }
    Class.prototype = RequestPrototype;
    return Class;
}();
const TaggedClass = (tag)=>{
    return class TaggedClass extends Class {
        _tag = tag;
    };
};
const complete = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, result)=>_coreJs.fiberRefGetWith(_completedRequestMapJs.currentRequestMap, (map)=>_coreJs.sync(()=>{
            if (map.has(self)) {
                const entry = map.get(self);
                if (!entry.state.completed) {
                    entry.state.completed = true;
                    _coreJs.deferredUnsafeDone(entry.result, result);
                }
            }
        })));
const completeEffect = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, effect)=>_coreJs.matchEffect(effect, {
        onFailure: (error)=>complete(self, _coreJs.exitFail(error)),
        onSuccess: (value)=>complete(self, _coreJs.exitSucceed(value))
    }));
const fail = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, error)=>complete(self, _coreJs.exitFail(error)));
const failCause = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, cause)=>complete(self, _coreJs.exitFailCause(cause)));
const succeed = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, value)=>complete(self, _coreJs.exitSucceed(value)));
class Listeners {
    count = 0;
    observers = /*#__PURE__*/ new Set();
    interrupted = false;
    addObserver(f) {
        this.observers.add(f);
    }
    removeObserver(f) {
        this.observers.delete(f);
    }
    increment() {
        this.count++;
        this.observers.forEach((f)=>f(this.count));
    }
    decrement() {
        this.count--;
        this.observers.forEach((f)=>f(this.count));
    }
}
const filterOutCompleted = (requests)=>_coreJs.fiberRefGetWith(_completedRequestMapJs.currentRequestMap, (map)=>_coreJs.succeed(requests.filter((request)=>!(map.get(request)?.state.completed === true))));

},{"../Function.js":"21gOL","../Predicate.js":"gW5pd","./completedRequestMap.js":"dFrk6","./core.js":"cr3YV","./effectable.js":"8EvvU","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"bryLt":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SupervisorTypeId", ()=>SupervisorTypeId);
parcelHelpers.export(exports, "supervisorVariance", ()=>supervisorVariance);
/** @internal */ parcelHelpers.export(exports, "ProxySupervisor", ()=>ProxySupervisor);
/** @internal */ parcelHelpers.export(exports, "Zip", ()=>Zip);
parcelHelpers.export(exports, "isZip", ()=>isZip);
/** @internal */ parcelHelpers.export(exports, "Track", ()=>Track);
/** @internal */ parcelHelpers.export(exports, "Const", ()=>Const);
parcelHelpers.export(exports, "unsafeTrack", ()=>unsafeTrack);
parcelHelpers.export(exports, "track", ()=>track);
parcelHelpers.export(exports, "fromEffect", ()=>fromEffect);
parcelHelpers.export(exports, "none", ()=>none);
parcelHelpers.export(exports, "fibersIn", ()=>fibersIn);
var _functionJs = require("../Function.js");
var _globalValueJs = require("../GlobalValue.js");
var _mutableRefJs = require("../MutableRef.js");
var _predicateJs = require("../Predicate.js");
var _sortedSetJs = require("../SortedSet.js");
var _coreJs = require("./core.js");
/** @internal */ const SupervisorSymbolKey = "effect/Supervisor";
const SupervisorTypeId = /*#__PURE__*/ Symbol.for(SupervisorSymbolKey);
const supervisorVariance = {
    /* c8 ignore next */ _T: (_)=>_
};
class ProxySupervisor {
    underlying;
    value0;
    [SupervisorTypeId] = supervisorVariance;
    constructor(underlying, value0){
        this.underlying = underlying;
        this.value0 = value0;
    }
    get value() {
        return this.value0;
    }
    onStart(context, effect, parent, fiber) {
        this.underlying.onStart(context, effect, parent, fiber);
    }
    onEnd(value, fiber) {
        this.underlying.onEnd(value, fiber);
    }
    onEffect(fiber, effect) {
        this.underlying.onEffect(fiber, effect);
    }
    onSuspend(fiber) {
        this.underlying.onSuspend(fiber);
    }
    onResume(fiber) {
        this.underlying.onResume(fiber);
    }
    map(f) {
        return new ProxySupervisor(this, (0, _functionJs.pipe)(this.value, _coreJs.map(f)));
    }
    zip(right) {
        return new Zip(this, right);
    }
}
class Zip {
    left;
    right;
    _tag = "Zip";
    [SupervisorTypeId] = supervisorVariance;
    constructor(left, right){
        this.left = left;
        this.right = right;
    }
    get value() {
        return _coreJs.zip(this.left.value, this.right.value);
    }
    onStart(context, effect, parent, fiber) {
        this.left.onStart(context, effect, parent, fiber);
        this.right.onStart(context, effect, parent, fiber);
    }
    onEnd(value, fiber) {
        this.left.onEnd(value, fiber);
        this.right.onEnd(value, fiber);
    }
    onEffect(fiber, effect) {
        this.left.onEffect(fiber, effect);
        this.right.onEffect(fiber, effect);
    }
    onSuspend(fiber) {
        this.left.onSuspend(fiber);
        this.right.onSuspend(fiber);
    }
    onResume(fiber) {
        this.left.onResume(fiber);
        this.right.onResume(fiber);
    }
    map(f) {
        return new ProxySupervisor(this, (0, _functionJs.pipe)(this.value, _coreJs.map(f)));
    }
    zip(right) {
        return new Zip(this, right);
    }
}
const isZip = (self)=>(0, _predicateJs.hasProperty)(self, SupervisorTypeId) && (0, _predicateJs.isTagged)(self, "Zip");
class Track {
    [SupervisorTypeId] = supervisorVariance;
    fibers = /*#__PURE__*/ new Set();
    get value() {
        return _coreJs.sync(()=>Array.from(this.fibers));
    }
    onStart(_context, _effect, _parent, fiber) {
        this.fibers.add(fiber);
    }
    onEnd(_value, fiber) {
        this.fibers.delete(fiber);
    }
    onEffect(_fiber, _effect) {
    //
    }
    onSuspend(_fiber) {
    //
    }
    onResume(_fiber) {
    //
    }
    map(f) {
        return new ProxySupervisor(this, (0, _functionJs.pipe)(this.value, _coreJs.map(f)));
    }
    zip(right) {
        return new Zip(this, right);
    }
    onRun(execution, _fiber) {
        return execution();
    }
}
class Const {
    effect;
    [SupervisorTypeId] = supervisorVariance;
    constructor(effect){
        this.effect = effect;
    }
    get value() {
        return this.effect;
    }
    onStart(_context, _effect, _parent, _fiber) {
    //
    }
    onEnd(_value, _fiber) {
    //
    }
    onEffect(_fiber, _effect) {
    //
    }
    onSuspend(_fiber) {
    //
    }
    onResume(_fiber) {
    //
    }
    map(f) {
        return new ProxySupervisor(this, (0, _functionJs.pipe)(this.value, _coreJs.map(f)));
    }
    zip(right) {
        return new Zip(this, right);
    }
    onRun(execution, _fiber) {
        return execution();
    }
}
class FibersIn {
    ref;
    [SupervisorTypeId] = supervisorVariance;
    constructor(ref){
        this.ref = ref;
    }
    get value() {
        return _coreJs.sync(()=>_mutableRefJs.get(this.ref));
    }
    onStart(_context, _effect, _parent, fiber) {
        (0, _functionJs.pipe)(this.ref, _mutableRefJs.set((0, _functionJs.pipe)(_mutableRefJs.get(this.ref), _sortedSetJs.add(fiber))));
    }
    onEnd(_value, fiber) {
        (0, _functionJs.pipe)(this.ref, _mutableRefJs.set((0, _functionJs.pipe)(_mutableRefJs.get(this.ref), _sortedSetJs.remove(fiber))));
    }
    onEffect(_fiber, _effect) {
    //
    }
    onSuspend(_fiber) {
    //
    }
    onResume(_fiber) {
    //
    }
    map(f) {
        return new ProxySupervisor(this, (0, _functionJs.pipe)(this.value, _coreJs.map(f)));
    }
    zip(right) {
        return new Zip(this, right);
    }
    onRun(execution, _fiber) {
        return execution();
    }
}
const unsafeTrack = ()=>{
    return new Track();
};
const track = /*#__PURE__*/ _coreJs.sync(unsafeTrack);
const fromEffect = (effect)=>{
    return new Const(effect);
};
const none = /*#__PURE__*/ (0, _globalValueJs.globalValue)("effect/Supervisor/none", ()=>fromEffect(_coreJs.void));
const fibersIn = (ref)=>_coreJs.sync(()=>new FibersIn(ref));

},{"../Function.js":"21gOL","../GlobalValue.js":"5w3Hn","../MutableRef.js":"aCyaL","../Predicate.js":"gW5pd","../SortedSet.js":"c0PkG","./core.js":"cr3YV","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"c0PkG":[function(require,module,exports,__globalThis) {
/**
 * @since 2.0.0
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isSortedSet", ()=>isSortedSet);
parcelHelpers.export(exports, "empty", ()=>empty);
parcelHelpers.export(exports, "fromIterable", ()=>fromIterable);
parcelHelpers.export(exports, "make", ()=>make);
parcelHelpers.export(exports, "add", ()=>add);
parcelHelpers.export(exports, "difference", ()=>difference);
parcelHelpers.export(exports, "every", ()=>every);
parcelHelpers.export(exports, "filter", ()=>filter);
parcelHelpers.export(exports, "flatMap", ()=>flatMap);
parcelHelpers.export(exports, "forEach", ()=>forEach);
parcelHelpers.export(exports, "has", ()=>has);
parcelHelpers.export(exports, "intersection", ()=>intersection);
parcelHelpers.export(exports, "isSubset", ()=>isSubset);
parcelHelpers.export(exports, "map", ()=>map);
parcelHelpers.export(exports, "partition", ()=>partition);
parcelHelpers.export(exports, "remove", ()=>remove);
parcelHelpers.export(exports, "size", ()=>size);
parcelHelpers.export(exports, "some", ()=>some);
parcelHelpers.export(exports, "toggle", ()=>toggle);
parcelHelpers.export(exports, "union", ()=>union);
parcelHelpers.export(exports, "values", ()=>values);
parcelHelpers.export(exports, "getEquivalence", ()=>getEquivalence);
var _equalJs = require("./Equal.js");
var _functionJs = require("./Function.js");
var _hashJs = require("./Hash.js");
var _inspectableJs = require("./Inspectable.js");
var _pipeableJs = require("./Pipeable.js");
var _predicateJs = require("./Predicate.js");
var _redBlackTreeJs = require("./RedBlackTree.js");
const TypeId = /*#__PURE__*/ Symbol.for("effect/SortedSet");
const SortedSetProto = {
    [TypeId]: {
        _A: (_)=>_
    },
    [_hashJs.symbol] () {
        return (0, _functionJs.pipe)(_hashJs.hash(this.keyTree), _hashJs.combine(_hashJs.hash(TypeId)), _hashJs.cached(this));
    },
    [_equalJs.symbol] (that) {
        return isSortedSet(that) && _equalJs.equals(this.keyTree, that.keyTree);
    },
    [Symbol.iterator] () {
        return _redBlackTreeJs.keys(this.keyTree);
    },
    toString () {
        return (0, _inspectableJs.format)(this.toJSON());
    },
    toJSON () {
        return {
            _id: "SortedSet",
            values: Array.from(this).map((0, _inspectableJs.toJSON))
        };
    },
    [(0, _inspectableJs.NodeInspectSymbol)] () {
        return this.toJSON();
    },
    pipe () {
        return (0, _pipeableJs.pipeArguments)(this, arguments);
    }
};
const fromTree = (keyTree)=>{
    const a = Object.create(SortedSetProto);
    a.keyTree = keyTree;
    return a;
};
const isSortedSet = (u)=>(0, _predicateJs.hasProperty)(u, TypeId);
const empty = (O)=>fromTree(_redBlackTreeJs.empty(O));
const fromIterable = /*#__PURE__*/ _functionJs.dual(2, (iterable, ord)=>fromTree(_redBlackTreeJs.fromIterable(Array.from(iterable).map((k)=>[
            k,
            true
        ]), ord)));
const make = (ord)=>(...entries)=>fromIterable(entries, ord);
const add = /*#__PURE__*/ _functionJs.dual(2, (self, value)=>_redBlackTreeJs.has(self.keyTree, value) ? self : fromTree(_redBlackTreeJs.insert(self.keyTree, value, true)));
const difference = /*#__PURE__*/ _functionJs.dual(2, (self, that)=>{
    let out = self;
    for (const value of that)out = remove(out, value);
    return out;
});
const every = /*#__PURE__*/ _functionJs.dual(2, (self, predicate)=>{
    for (const value of self){
        if (!predicate(value)) return false;
    }
    return true;
});
const filter = /*#__PURE__*/ _functionJs.dual(2, (self, predicate)=>{
    const ord = _redBlackTreeJs.getOrder(self.keyTree);
    let out = empty(ord);
    for (const value of self)if (predicate(value)) out = add(out, value);
    return out;
});
const flatMap = /*#__PURE__*/ _functionJs.dual(3, (self, O, f)=>{
    let out = empty(O);
    forEach(self, (a)=>{
        for (const b of f(a))out = add(out, b);
    });
    return out;
});
const forEach = /*#__PURE__*/ _functionJs.dual(2, (self, f)=>_redBlackTreeJs.forEach(self.keyTree, f));
const has = /*#__PURE__*/ _functionJs.dual(2, (self, value)=>_redBlackTreeJs.has(self.keyTree, value));
const intersection = /*#__PURE__*/ _functionJs.dual(2, (self, that)=>{
    const ord = _redBlackTreeJs.getOrder(self.keyTree);
    let out = empty(ord);
    for (const value of that)if (has(self, value)) out = add(out, value);
    return out;
});
const isSubset = /*#__PURE__*/ _functionJs.dual(2, (self, that)=>every(self, (a)=>has(that, a)));
const map = /*#__PURE__*/ _functionJs.dual(3, (self, O, f)=>{
    let out = empty(O);
    forEach(self, (a)=>{
        const b = f(a);
        if (!has(out, b)) out = add(out, b);
    });
    return out;
});
const partition = /*#__PURE__*/ _functionJs.dual(2, (self, predicate)=>{
    const ord = _redBlackTreeJs.getOrder(self.keyTree);
    let right = empty(ord);
    let left = empty(ord);
    for (const value of self)if (predicate(value)) right = add(right, value);
    else left = add(left, value);
    return [
        left,
        right
    ];
});
const remove = /*#__PURE__*/ _functionJs.dual(2, (self, value)=>fromTree(_redBlackTreeJs.removeFirst(self.keyTree, value)));
const size = (self)=>_redBlackTreeJs.size(self.keyTree);
const some = /*#__PURE__*/ _functionJs.dual(2, (self, predicate)=>{
    for (const value of self){
        if (predicate(value)) return true;
    }
    return false;
});
const toggle = /*#__PURE__*/ _functionJs.dual(2, (self, value)=>has(self, value) ? remove(self, value) : add(self, value));
const union = /*#__PURE__*/ _functionJs.dual(2, (self, that)=>{
    const ord = _redBlackTreeJs.getOrder(self.keyTree);
    let out = empty(ord);
    for (const value of self)out = add(value)(out);
    for (const value of that)out = add(value)(out);
    return out;
});
const values = (self)=>_redBlackTreeJs.keys(self.keyTree);
const getEquivalence = ()=>(a, b)=>isSubset(a, b) && isSubset(b, a);

},{"./Equal.js":"gA0qD","./Function.js":"21gOL","./Hash.js":"gFMwE","./Inspectable.js":"1Ur70","./Pipeable.js":"b5RU2","./Predicate.js":"gW5pd","./RedBlackTree.js":"6Lbzj","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"6Lbzj":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Direction", ()=>Direction);
parcelHelpers.export(exports, "isRedBlackTree", ()=>isRedBlackTree);
parcelHelpers.export(exports, "empty", ()=>empty);
parcelHelpers.export(exports, "fromIterable", ()=>fromIterable);
parcelHelpers.export(exports, "make", ()=>make);
parcelHelpers.export(exports, "at", ()=>at);
parcelHelpers.export(exports, "atReversed", ()=>atReversed);
parcelHelpers.export(exports, "findAll", ()=>findAll);
parcelHelpers.export(exports, "findFirst", ()=>findFirst);
parcelHelpers.export(exports, "first", ()=>first);
parcelHelpers.export(exports, "getAt", ()=>getAt);
parcelHelpers.export(exports, "getOrder", ()=>getOrder);
parcelHelpers.export(exports, "greaterThan", ()=>greaterThan);
parcelHelpers.export(exports, "greaterThanReversed", ()=>greaterThanReversed);
parcelHelpers.export(exports, "greaterThanEqual", ()=>greaterThanEqual);
parcelHelpers.export(exports, "greaterThanEqualReversed", ()=>greaterThanEqualReversed);
parcelHelpers.export(exports, "has", ()=>has);
parcelHelpers.export(exports, "insert", ()=>insert);
parcelHelpers.export(exports, "keys", ()=>keys);
parcelHelpers.export(exports, "keysReversed", ()=>keysReversed);
parcelHelpers.export(exports, "last", ()=>last);
parcelHelpers.export(exports, "lessThan", ()=>lessThan);
parcelHelpers.export(exports, "lessThanReversed", ()=>lessThanReversed);
parcelHelpers.export(exports, "lessThanEqual", ()=>lessThanEqual);
parcelHelpers.export(exports, "lessThanEqualReversed", ()=>lessThanEqualReversed);
parcelHelpers.export(exports, "forEach", ()=>forEach);
parcelHelpers.export(exports, "forEachGreaterThanEqual", ()=>forEachGreaterThanEqual);
parcelHelpers.export(exports, "forEachLessThan", ()=>forEachLessThan);
parcelHelpers.export(exports, "forEachBetween", ()=>forEachBetween);
parcelHelpers.export(exports, "reduce", ()=>reduce);
parcelHelpers.export(exports, "removeFirst", ()=>removeFirst);
parcelHelpers.export(exports, "reversed", ()=>reversed);
parcelHelpers.export(exports, "size", ()=>size);
parcelHelpers.export(exports, "values", ()=>values);
parcelHelpers.export(exports, "valuesReversed", ()=>valuesReversed);
var _redBlackTreeJs = require("./internal/redBlackTree.js");
var _iteratorJs = require("./internal/redBlackTree/iterator.js");
const TypeId = _redBlackTreeJs.RedBlackTreeTypeId;
const Direction = _iteratorJs.Direction;
const isRedBlackTree = _redBlackTreeJs.isRedBlackTree;
const empty = _redBlackTreeJs.empty;
const fromIterable = _redBlackTreeJs.fromIterable;
const make = _redBlackTreeJs.make;
const at = _redBlackTreeJs.atForwards;
const atReversed = _redBlackTreeJs.atBackwards;
const findAll = _redBlackTreeJs.findAll;
const findFirst = _redBlackTreeJs.findFirst;
const first = _redBlackTreeJs.first;
const getAt = _redBlackTreeJs.getAt;
const getOrder = _redBlackTreeJs.getOrder;
const greaterThan = _redBlackTreeJs.greaterThanForwards;
const greaterThanReversed = _redBlackTreeJs.greaterThanBackwards;
const greaterThanEqual = _redBlackTreeJs.greaterThanEqualForwards;
const greaterThanEqualReversed = _redBlackTreeJs.greaterThanEqualBackwards;
const has = _redBlackTreeJs.has;
const insert = _redBlackTreeJs.insert;
const keys = _redBlackTreeJs.keysForward;
const keysReversed = _redBlackTreeJs.keysBackward;
const last = _redBlackTreeJs.last;
const lessThan = _redBlackTreeJs.lessThanForwards;
const lessThanReversed = _redBlackTreeJs.lessThanBackwards;
const lessThanEqual = _redBlackTreeJs.lessThanEqualForwards;
const lessThanEqualReversed = _redBlackTreeJs.lessThanEqualBackwards;
const forEach = _redBlackTreeJs.forEach;
const forEachGreaterThanEqual = _redBlackTreeJs.forEachGreaterThanEqual;
const forEachLessThan = _redBlackTreeJs.forEachLessThan;
const forEachBetween = _redBlackTreeJs.forEachBetween;
const reduce = _redBlackTreeJs.reduce;
const removeFirst = _redBlackTreeJs.removeFirst;
const reversed = _redBlackTreeJs.reversed;
const size = _redBlackTreeJs.size;
const values = _redBlackTreeJs.valuesForward;
const valuesReversed = _redBlackTreeJs.valuesBackward;

},{"./internal/redBlackTree.js":"l2lDN","./internal/redBlackTree/iterator.js":"fWfKz","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"l2lDN":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RedBlackTreeTypeId", ()=>RedBlackTreeTypeId);
parcelHelpers.export(exports, "isRedBlackTree", ()=>isRedBlackTree);
parcelHelpers.export(exports, "empty", ()=>empty);
parcelHelpers.export(exports, "fromIterable", ()=>fromIterable);
parcelHelpers.export(exports, "make", ()=>make);
parcelHelpers.export(exports, "atBackwards", ()=>atBackwards);
parcelHelpers.export(exports, "atForwards", ()=>atForwards);
parcelHelpers.export(exports, "findAll", ()=>findAll);
parcelHelpers.export(exports, "findFirst", ()=>findFirst);
parcelHelpers.export(exports, "first", ()=>first);
parcelHelpers.export(exports, "getAt", ()=>getAt);
parcelHelpers.export(exports, "getOrder", ()=>getOrder);
parcelHelpers.export(exports, "has", ()=>has);
parcelHelpers.export(exports, "insert", ()=>insert);
parcelHelpers.export(exports, "keysForward", ()=>keysForward);
parcelHelpers.export(exports, "keysBackward", ()=>keysBackward);
parcelHelpers.export(exports, "last", ()=>last);
parcelHelpers.export(exports, "reversed", ()=>reversed);
parcelHelpers.export(exports, "greaterThanBackwards", ()=>greaterThanBackwards);
parcelHelpers.export(exports, "greaterThanForwards", ()=>greaterThanForwards);
parcelHelpers.export(exports, "greaterThanEqualBackwards", ()=>greaterThanEqualBackwards);
parcelHelpers.export(exports, "greaterThanEqualForwards", ()=>greaterThanEqualForwards);
parcelHelpers.export(exports, "lessThanBackwards", ()=>lessThanBackwards);
parcelHelpers.export(exports, "lessThanForwards", ()=>lessThanForwards);
parcelHelpers.export(exports, "lessThanEqualBackwards", ()=>lessThanEqualBackwards);
parcelHelpers.export(exports, "lessThanEqualForwards", ()=>lessThanEqualForwards);
parcelHelpers.export(exports, "forEach", ()=>forEach);
parcelHelpers.export(exports, "forEachGreaterThanEqual", ()=>forEachGreaterThanEqual);
parcelHelpers.export(exports, "forEachLessThan", ()=>forEachLessThan);
parcelHelpers.export(exports, "forEachBetween", ()=>forEachBetween);
parcelHelpers.export(exports, "reduce", ()=>reduce);
parcelHelpers.export(exports, "removeFirst", ()=>removeFirst);
parcelHelpers.export(exports, "size", ()=>size);
parcelHelpers.export(exports, "valuesForward", ()=>valuesForward);
parcelHelpers.export(exports, "valuesBackward", ()=>valuesBackward);
var _chunkJs = require("../Chunk.js");
var _equalJs = require("../Equal.js");
var _functionJs = require("../Function.js");
var _hashJs = require("../Hash.js");
var _inspectableJs = require("../Inspectable.js");
var _optionJs = require("../Option.js");
var _pipeableJs = require("../Pipeable.js");
var _predicateJs = require("../Predicate.js");
var _iteratorJs = require("./redBlackTree/iterator.js");
var _nodeJs = require("./redBlackTree/node.js");
var _stackJs = require("./stack.js");
const RedBlackTreeSymbolKey = "effect/RedBlackTree";
const RedBlackTreeTypeId = /*#__PURE__*/ Symbol.for(RedBlackTreeSymbolKey);
const redBlackTreeVariance = {
    /* c8 ignore next */ _Key: (_)=>_,
    /* c8 ignore next */ _Value: (_)=>_
};
const RedBlackTreeProto = {
    [RedBlackTreeTypeId]: redBlackTreeVariance,
    [_hashJs.symbol] () {
        let hash = _hashJs.hash(RedBlackTreeSymbolKey);
        for (const item of this)hash ^= (0, _functionJs.pipe)(_hashJs.hash(item[0]), _hashJs.combine(_hashJs.hash(item[1])));
        return _hashJs.cached(this, hash);
    },
    [_equalJs.symbol] (that) {
        if (isRedBlackTree(that)) {
            if ((this._root?.count ?? 0) !== (that._root?.count ?? 0)) return false;
            const entries = Array.from(that);
            return Array.from(this).every((itemSelf, i)=>{
                const itemThat = entries[i];
                return _equalJs.equals(itemSelf[0], itemThat[0]) && _equalJs.equals(itemSelf[1], itemThat[1]);
            });
        }
        return false;
    },
    [Symbol.iterator] () {
        const stack = [];
        let n = this._root;
        while(n != null){
            stack.push(n);
            n = n.left;
        }
        return new (0, _iteratorJs.RedBlackTreeIterator)(this, stack, (0, _iteratorJs.Direction).Forward);
    },
    toString () {
        return (0, _inspectableJs.format)(this.toJSON());
    },
    toJSON () {
        return {
            _id: "RedBlackTree",
            values: Array.from(this).map((0, _inspectableJs.toJSON))
        };
    },
    [(0, _inspectableJs.NodeInspectSymbol)] () {
        return this.toJSON();
    },
    pipe () {
        return (0, _pipeableJs.pipeArguments)(this, arguments);
    }
};
const makeImpl = (ord, root)=>{
    const tree = Object.create(RedBlackTreeProto);
    tree._ord = ord;
    tree._root = root;
    return tree;
};
const isRedBlackTree = (u)=>(0, _predicateJs.hasProperty)(u, RedBlackTreeTypeId);
const empty = (ord)=>makeImpl(ord, undefined);
const fromIterable = /*#__PURE__*/ (0, _functionJs.dual)(2, (entries, ord)=>{
    let tree = empty(ord);
    for (const [key, value] of entries)tree = insert(tree, key, value);
    return tree;
});
const make = (ord)=>(...entries)=>{
        return fromIterable(entries, ord);
    };
const atBackwards = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, index)=>at(self, index, (0, _iteratorJs.Direction).Backward));
const atForwards = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, index)=>at(self, index, (0, _iteratorJs.Direction).Forward));
const at = (self, index, direction)=>{
    return {
        [Symbol.iterator]: ()=>{
            if (index < 0) return new (0, _iteratorJs.RedBlackTreeIterator)(self, [], direction);
            let node = self._root;
            const stack = [];
            while(node !== undefined){
                stack.push(node);
                if (node.left !== undefined) {
                    if (index < node.left.count) {
                        node = node.left;
                        continue;
                    }
                    index -= node.left.count;
                }
                if (!index) return new (0, _iteratorJs.RedBlackTreeIterator)(self, stack, direction);
                index -= 1;
                if (node.right !== undefined) {
                    if (index >= node.right.count) break;
                    node = node.right;
                } else break;
            }
            return new (0, _iteratorJs.RedBlackTreeIterator)(self, [], direction);
        }
    };
};
const findAll = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, key)=>{
    const stack = [];
    let node = self._root;
    let result = _chunkJs.empty();
    while(node !== undefined || stack.length > 0)if (node) {
        stack.push(node);
        node = node.left;
    } else {
        const current = stack.pop();
        if (_equalJs.equals(key, current.key)) result = _chunkJs.prepend(current.value)(result);
        node = current.right;
    }
    return result;
});
const findFirst = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, key)=>{
    const cmp = self._ord;
    let node = self._root;
    while(node !== undefined){
        const d = cmp(key, node.key);
        if (_equalJs.equals(key, node.key)) return _optionJs.some(node.value);
        if (d <= 0) node = node.left;
        else node = node.right;
    }
    return _optionJs.none();
});
const first = (self)=>{
    let node = self._root;
    let current = self._root;
    while(node !== undefined){
        current = node;
        node = node.left;
    }
    return current ? _optionJs.some([
        current.key,
        current.value
    ]) : _optionJs.none();
};
const getAt = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, index)=>{
    if (index < 0) return _optionJs.none();
    let root = self._root;
    let node = undefined;
    while(root !== undefined){
        node = root;
        if (root.left) {
            if (index < root.left.count) {
                root = root.left;
                continue;
            }
            index -= root.left.count;
        }
        if (!index) return _optionJs.some([
            node.key,
            node.value
        ]);
        index -= 1;
        if (root.right) {
            if (index >= root.right.count) break;
            root = root.right;
        } else break;
    }
    return _optionJs.none();
});
const getOrder = (tree)=>tree._ord;
const has = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, key)=>_optionJs.isSome(findFirst(self, key)));
const insert = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, key, value)=>{
    const cmp = self._ord;
    // Find point to insert new node at
    let n = self._root;
    const n_stack = [];
    const d_stack = [];
    while(n != null){
        const d = cmp(key, n.key);
        n_stack.push(n);
        d_stack.push(d);
        if (d <= 0) n = n.left;
        else n = n.right;
    }
    // Rebuild path to leaf node
    n_stack.push({
        color: _nodeJs.Color.Red,
        key,
        value,
        left: undefined,
        right: undefined,
        count: 1
    });
    for(let s = n_stack.length - 2; s >= 0; --s){
        const n2 = n_stack[s];
        if (d_stack[s] <= 0) n_stack[s] = {
            color: n2.color,
            key: n2.key,
            value: n2.value,
            left: n_stack[s + 1],
            right: n2.right,
            count: n2.count + 1
        };
        else n_stack[s] = {
            color: n2.color,
            key: n2.key,
            value: n2.value,
            left: n2.left,
            right: n_stack[s + 1],
            count: n2.count + 1
        };
    }
    // Rebalance tree using rotations
    for(let s = n_stack.length - 1; s > 1; --s){
        const p = n_stack[s - 1];
        const n3 = n_stack[s];
        if (p.color === _nodeJs.Color.Black || n3.color === _nodeJs.Color.Black) break;
        const pp = n_stack[s - 2];
        if (pp.left === p) {
            if (p.left === n3) {
                const y = pp.right;
                if (y && y.color === _nodeJs.Color.Red) {
                    p.color = _nodeJs.Color.Black;
                    pp.right = _nodeJs.repaint(y, _nodeJs.Color.Black);
                    pp.color = _nodeJs.Color.Red;
                    s -= 1;
                } else {
                    pp.color = _nodeJs.Color.Red;
                    pp.left = p.right;
                    p.color = _nodeJs.Color.Black;
                    p.right = pp;
                    n_stack[s - 2] = p;
                    n_stack[s - 1] = n3;
                    _nodeJs.recount(pp);
                    _nodeJs.recount(p);
                    if (s >= 3) {
                        const ppp = n_stack[s - 3];
                        if (ppp.left === pp) ppp.left = p;
                        else ppp.right = p;
                    }
                    break;
                }
            } else {
                const y = pp.right;
                if (y && y.color === _nodeJs.Color.Red) {
                    p.color = _nodeJs.Color.Black;
                    pp.right = _nodeJs.repaint(y, _nodeJs.Color.Black);
                    pp.color = _nodeJs.Color.Red;
                    s -= 1;
                } else {
                    p.right = n3.left;
                    pp.color = _nodeJs.Color.Red;
                    pp.left = n3.right;
                    n3.color = _nodeJs.Color.Black;
                    n3.left = p;
                    n3.right = pp;
                    n_stack[s - 2] = n3;
                    n_stack[s - 1] = p;
                    _nodeJs.recount(pp);
                    _nodeJs.recount(p);
                    _nodeJs.recount(n3);
                    if (s >= 3) {
                        const ppp = n_stack[s - 3];
                        if (ppp.left === pp) ppp.left = n3;
                        else ppp.right = n3;
                    }
                    break;
                }
            }
        } else if (p.right === n3) {
            const y = pp.left;
            if (y && y.color === _nodeJs.Color.Red) {
                p.color = _nodeJs.Color.Black;
                pp.left = _nodeJs.repaint(y, _nodeJs.Color.Black);
                pp.color = _nodeJs.Color.Red;
                s -= 1;
            } else {
                pp.color = _nodeJs.Color.Red;
                pp.right = p.left;
                p.color = _nodeJs.Color.Black;
                p.left = pp;
                n_stack[s - 2] = p;
                n_stack[s - 1] = n3;
                _nodeJs.recount(pp);
                _nodeJs.recount(p);
                if (s >= 3) {
                    const ppp = n_stack[s - 3];
                    if (ppp.right === pp) ppp.right = p;
                    else ppp.left = p;
                }
                break;
            }
        } else {
            const y = pp.left;
            if (y && y.color === _nodeJs.Color.Red) {
                p.color = _nodeJs.Color.Black;
                pp.left = _nodeJs.repaint(y, _nodeJs.Color.Black);
                pp.color = _nodeJs.Color.Red;
                s -= 1;
            } else {
                p.left = n3.right;
                pp.color = _nodeJs.Color.Red;
                pp.right = n3.left;
                n3.color = _nodeJs.Color.Black;
                n3.right = p;
                n3.left = pp;
                n_stack[s - 2] = n3;
                n_stack[s - 1] = p;
                _nodeJs.recount(pp);
                _nodeJs.recount(p);
                _nodeJs.recount(n3);
                if (s >= 3) {
                    const ppp = n_stack[s - 3];
                    if (ppp.right === pp) ppp.right = n3;
                    else ppp.left = n3;
                }
                break;
            }
        }
    }
    // Return new tree
    n_stack[0].color = _nodeJs.Color.Black;
    return makeImpl(self._ord, n_stack[0]);
});
const keysForward = (self)=>keys(self, (0, _iteratorJs.Direction).Forward);
const keysBackward = (self)=>keys(self, (0, _iteratorJs.Direction).Backward);
const keys = (self, direction)=>{
    const begin = self[Symbol.iterator]();
    let count = 0;
    return {
        [Symbol.iterator]: ()=>keys(self, direction),
        next: ()=>{
            count++;
            const entry = begin.key;
            if (direction === (0, _iteratorJs.Direction).Forward) begin.moveNext();
            else begin.movePrev();
            switch(entry._tag){
                case "None":
                    return {
                        done: true,
                        value: count
                    };
                case "Some":
                    return {
                        done: false,
                        value: entry.value
                    };
            }
        }
    };
};
const last = (self)=>{
    let node = self._root;
    let current = self._root;
    while(node !== undefined){
        current = node;
        node = node.right;
    }
    return current ? _optionJs.some([
        current.key,
        current.value
    ]) : _optionJs.none();
};
const reversed = (self)=>{
    return {
        [Symbol.iterator]: ()=>{
            const stack = [];
            let node = self._root;
            while(node !== undefined){
                stack.push(node);
                node = node.right;
            }
            return new (0, _iteratorJs.RedBlackTreeIterator)(self, stack, (0, _iteratorJs.Direction).Backward);
        }
    };
};
const greaterThanBackwards = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, key)=>greaterThan(self, key, (0, _iteratorJs.Direction).Backward));
const greaterThanForwards = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, key)=>greaterThan(self, key, (0, _iteratorJs.Direction).Forward));
const greaterThan = (self, key, direction)=>{
    return {
        [Symbol.iterator]: ()=>{
            const cmp = self._ord;
            let node = self._root;
            const stack = [];
            let last_ptr = 0;
            while(node !== undefined){
                const d = cmp(key, node.key);
                stack.push(node);
                if (d < 0) last_ptr = stack.length;
                if (d < 0) node = node.left;
                else node = node.right;
            }
            stack.length = last_ptr;
            return new (0, _iteratorJs.RedBlackTreeIterator)(self, stack, direction);
        }
    };
};
const greaterThanEqualBackwards = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, key)=>greaterThanEqual(self, key, (0, _iteratorJs.Direction).Backward));
const greaterThanEqualForwards = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, key)=>greaterThanEqual(self, key, (0, _iteratorJs.Direction).Forward));
const greaterThanEqual = (self, key, direction = (0, _iteratorJs.Direction).Forward)=>{
    return {
        [Symbol.iterator]: ()=>{
            const cmp = self._ord;
            let node = self._root;
            const stack = [];
            let last_ptr = 0;
            while(node !== undefined){
                const d = cmp(key, node.key);
                stack.push(node);
                if (d <= 0) last_ptr = stack.length;
                if (d <= 0) node = node.left;
                else node = node.right;
            }
            stack.length = last_ptr;
            return new (0, _iteratorJs.RedBlackTreeIterator)(self, stack, direction);
        }
    };
};
const lessThanBackwards = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, key)=>lessThan(self, key, (0, _iteratorJs.Direction).Backward));
const lessThanForwards = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, key)=>lessThan(self, key, (0, _iteratorJs.Direction).Forward));
const lessThan = (self, key, direction)=>{
    return {
        [Symbol.iterator]: ()=>{
            const cmp = self._ord;
            let node = self._root;
            const stack = [];
            let last_ptr = 0;
            while(node !== undefined){
                const d = cmp(key, node.key);
                stack.push(node);
                if (d > 0) last_ptr = stack.length;
                if (d <= 0) node = node.left;
                else node = node.right;
            }
            stack.length = last_ptr;
            return new (0, _iteratorJs.RedBlackTreeIterator)(self, stack, direction);
        }
    };
};
const lessThanEqualBackwards = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, key)=>lessThanEqual(self, key, (0, _iteratorJs.Direction).Backward));
const lessThanEqualForwards = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, key)=>lessThanEqual(self, key, (0, _iteratorJs.Direction).Forward));
const lessThanEqual = (self, key, direction)=>{
    return {
        [Symbol.iterator]: ()=>{
            const cmp = self._ord;
            let node = self._root;
            const stack = [];
            let last_ptr = 0;
            while(node !== undefined){
                const d = cmp(key, node.key);
                stack.push(node);
                if (d >= 0) last_ptr = stack.length;
                if (d < 0) node = node.left;
                else node = node.right;
            }
            stack.length = last_ptr;
            return new (0, _iteratorJs.RedBlackTreeIterator)(self, stack, direction);
        }
    };
};
const forEach = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>{
    const root = self._root;
    if (root !== undefined) visitFull(root, (key, value)=>{
        f(key, value);
        return _optionJs.none();
    });
});
const forEachGreaterThanEqual = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, min, f)=>{
    const root = self._root;
    const ord = self._ord;
    if (root !== undefined) visitGreaterThanEqual(root, min, ord, (key, value)=>{
        f(key, value);
        return _optionJs.none();
    });
});
const forEachLessThan = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, max, f)=>{
    const root = self._root;
    const ord = self._ord;
    if (root !== undefined) visitLessThan(root, max, ord, (key, value)=>{
        f(key, value);
        return _optionJs.none();
    });
});
const forEachBetween = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, { body, max, min })=>{
    const root = self._root;
    const ord = self._ord;
    if (root) visitBetween(root, min, max, ord, (key, value)=>{
        body(key, value);
        return _optionJs.none();
    });
});
const reduce = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, zero, f)=>{
    let accumulator = zero;
    for (const entry of self)accumulator = f(accumulator, entry[1], entry[0]);
    return accumulator;
});
const removeFirst = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, key)=>{
    if (!has(self, key)) return self;
    const ord = self._ord;
    const cmp = ord;
    let node = self._root;
    const stack = [];
    while(node !== undefined){
        const d = cmp(key, node.key);
        stack.push(node);
        if (_equalJs.equals(key, node.key)) node = undefined;
        else if (d <= 0) node = node.left;
        else node = node.right;
    }
    if (stack.length === 0) return self;
    const cstack = new Array(stack.length);
    let n = stack[stack.length - 1];
    cstack[cstack.length - 1] = {
        color: n.color,
        key: n.key,
        value: n.value,
        left: n.left,
        right: n.right,
        count: n.count
    };
    for(let i = stack.length - 2; i >= 0; --i){
        n = stack[i];
        if (n.left === stack[i + 1]) cstack[i] = {
            color: n.color,
            key: n.key,
            value: n.value,
            left: cstack[i + 1],
            right: n.right,
            count: n.count
        };
        else cstack[i] = {
            color: n.color,
            key: n.key,
            value: n.value,
            left: n.left,
            right: cstack[i + 1],
            count: n.count
        };
    }
    // Get node
    n = cstack[cstack.length - 1];
    // If not leaf, then swap with previous node
    if (n.left !== undefined && n.right !== undefined) {
        // First walk to previous leaf
        const split = cstack.length;
        n = n.left;
        while(n.right != null){
            cstack.push(n);
            n = n.right;
        }
        // Copy path to leaf
        const v = cstack[split - 1];
        cstack.push({
            color: n.color,
            key: v.key,
            value: v.value,
            left: n.left,
            right: n.right,
            count: n.count
        });
        cstack[split - 1].key = n.key;
        cstack[split - 1].value = n.value;
        // Fix up stack
        for(let i = cstack.length - 2; i >= split; --i){
            n = cstack[i];
            cstack[i] = {
                color: n.color,
                key: n.key,
                value: n.value,
                left: n.left,
                right: cstack[i + 1],
                count: n.count
            };
        }
        cstack[split - 1].left = cstack[split];
    }
    // Remove leaf node
    n = cstack[cstack.length - 1];
    if (n.color === _nodeJs.Color.Red) {
        // Easy case: removing red leaf
        const p = cstack[cstack.length - 2];
        if (p.left === n) p.left = undefined;
        else if (p.right === n) p.right = undefined;
        cstack.pop();
        for(let i = 0; i < cstack.length; ++i)cstack[i].count--;
        return makeImpl(ord, cstack[0]);
    } else {
        if (n.left !== undefined || n.right !== undefined) {
            // Second easy case:  Single child black parent
            if (n.left !== undefined) _nodeJs.swap(n, n.left);
            else if (n.right !== undefined) _nodeJs.swap(n, n.right);
            // Child must be red, so repaint it black to balance color
            n.color = _nodeJs.Color.Black;
            for(let i = 0; i < cstack.length - 1; ++i)cstack[i].count--;
            return makeImpl(ord, cstack[0]);
        } else if (cstack.length === 1) // Third easy case: root
        return makeImpl(ord, undefined);
        else {
            // Hard case: Repaint n, and then do some nasty stuff
            for(let i = 0; i < cstack.length; ++i)cstack[i].count--;
            const parent = cstack[cstack.length - 2];
            fixDoubleBlack(cstack);
            // Fix up links
            if (parent.left === n) parent.left = undefined;
            else parent.right = undefined;
        }
    }
    return makeImpl(ord, cstack[0]);
});
const size = (self)=>self._root?.count ?? 0;
const valuesForward = (self)=>values(self, (0, _iteratorJs.Direction).Forward);
const valuesBackward = (self)=>values(self, (0, _iteratorJs.Direction).Backward);
/** @internal */ const values = (self, direction)=>{
    const begin = self[Symbol.iterator]();
    let count = 0;
    return {
        [Symbol.iterator]: ()=>values(self, direction),
        next: ()=>{
            count++;
            const entry = begin.value;
            if (direction === (0, _iteratorJs.Direction).Forward) begin.moveNext();
            else begin.movePrev();
            switch(entry._tag){
                case "None":
                    return {
                        done: true,
                        value: count
                    };
                case "Some":
                    return {
                        done: false,
                        value: entry.value
                    };
            }
        }
    };
};
const visitFull = (node, visit)=>{
    let current = node;
    let stack = undefined;
    let done = false;
    while(!done){
        if (current != null) {
            stack = _stackJs.make(current, stack);
            current = current.left;
        } else if (stack != null) {
            const value = visit(stack.value.key, stack.value.value);
            if (_optionJs.isSome(value)) return value;
            current = stack.value.right;
            stack = stack.previous;
        } else done = true;
    }
    return _optionJs.none();
};
const visitGreaterThanEqual = (node, min, ord, visit)=>{
    let current = node;
    let stack = undefined;
    let done = false;
    while(!done){
        if (current !== undefined) {
            stack = _stackJs.make(current, stack);
            if (ord(min, current.key) <= 0) current = current.left;
            else current = undefined;
        } else if (stack !== undefined) {
            if (ord(min, stack.value.key) <= 0) {
                const value = visit(stack.value.key, stack.value.value);
                if (_optionJs.isSome(value)) return value;
            }
            current = stack.value.right;
            stack = stack.previous;
        } else done = true;
    }
    return _optionJs.none();
};
const visitLessThan = (node, max, ord, visit)=>{
    let current = node;
    let stack = undefined;
    let done = false;
    while(!done){
        if (current !== undefined) {
            stack = _stackJs.make(current, stack);
            current = current.left;
        } else if (stack !== undefined && ord(max, stack.value.key) > 0) {
            const value = visit(stack.value.key, stack.value.value);
            if (_optionJs.isSome(value)) return value;
            current = stack.value.right;
            stack = stack.previous;
        } else done = true;
    }
    return _optionJs.none();
};
const visitBetween = (node, min, max, ord, visit)=>{
    let current = node;
    let stack = undefined;
    let done = false;
    while(!done){
        if (current !== undefined) {
            stack = _stackJs.make(current, stack);
            if (ord(min, current.key) <= 0) current = current.left;
            else current = undefined;
        } else if (stack !== undefined && ord(max, stack.value.key) > 0) {
            if (ord(min, stack.value.key) <= 0) {
                const value = visit(stack.value.key, stack.value.value);
                if (_optionJs.isSome(value)) return value;
            }
            current = stack.value.right;
            stack = stack.previous;
        } else done = true;
    }
    return _optionJs.none();
};
/**
 * Fix up a double black node in a Red-Black Tree.
 */ const fixDoubleBlack = (stack)=>{
    let n, p, s, z;
    for(let i = stack.length - 1; i >= 0; --i){
        n = stack[i];
        if (i === 0) {
            n.color = _nodeJs.Color.Black;
            return;
        }
        p = stack[i - 1];
        if (p.left === n) {
            s = p.right;
            if (s !== undefined && s.right !== undefined && s.right.color === _nodeJs.Color.Red) {
                s = p.right = _nodeJs.clone(s);
                z = s.right = _nodeJs.clone(s.right);
                p.right = s.left;
                s.left = p;
                s.right = z;
                s.color = p.color;
                n.color = _nodeJs.Color.Black;
                p.color = _nodeJs.Color.Black;
                z.color = _nodeJs.Color.Black;
                _nodeJs.recount(p);
                _nodeJs.recount(s);
                if (i > 1) {
                    const pp = stack[i - 2];
                    if (pp.left === p) pp.left = s;
                    else pp.right = s;
                }
                stack[i - 1] = s;
                return;
            } else if (s !== undefined && s.left !== undefined && s.left.color === _nodeJs.Color.Red) {
                s = p.right = _nodeJs.clone(s);
                z = s.left = _nodeJs.clone(s.left);
                p.right = z.left;
                s.left = z.right;
                z.left = p;
                z.right = s;
                z.color = p.color;
                p.color = _nodeJs.Color.Black;
                s.color = _nodeJs.Color.Black;
                n.color = _nodeJs.Color.Black;
                _nodeJs.recount(p);
                _nodeJs.recount(s);
                _nodeJs.recount(z);
                if (i > 1) {
                    const pp = stack[i - 2];
                    if (pp.left === p) pp.left = z;
                    else pp.right = z;
                }
                stack[i - 1] = z;
                return;
            }
            if (s !== undefined && s.color === _nodeJs.Color.Black) {
                if (p.color === _nodeJs.Color.Red) {
                    p.color = _nodeJs.Color.Black;
                    p.right = _nodeJs.repaint(s, _nodeJs.Color.Red);
                    return;
                } else {
                    p.right = _nodeJs.repaint(s, _nodeJs.Color.Red);
                    continue;
                }
            } else if (s !== undefined) {
                s = _nodeJs.clone(s);
                p.right = s.left;
                s.left = p;
                s.color = p.color;
                p.color = _nodeJs.Color.Red;
                _nodeJs.recount(p);
                _nodeJs.recount(s);
                if (i > 1) {
                    const pp = stack[i - 2];
                    if (pp.left === p) pp.left = s;
                    else pp.right = s;
                }
                stack[i - 1] = s;
                stack[i] = p;
                if (i + 1 < stack.length) stack[i + 1] = n;
                else stack.push(n);
                i = i + 2;
            }
        } else {
            s = p.left;
            if (s !== undefined && s.left !== undefined && s.left.color === _nodeJs.Color.Red) {
                s = p.left = _nodeJs.clone(s);
                z = s.left = _nodeJs.clone(s.left);
                p.left = s.right;
                s.right = p;
                s.left = z;
                s.color = p.color;
                n.color = _nodeJs.Color.Black;
                p.color = _nodeJs.Color.Black;
                z.color = _nodeJs.Color.Black;
                _nodeJs.recount(p);
                _nodeJs.recount(s);
                if (i > 1) {
                    const pp = stack[i - 2];
                    if (pp.right === p) pp.right = s;
                    else pp.left = s;
                }
                stack[i - 1] = s;
                return;
            } else if (s !== undefined && s.right !== undefined && s.right.color === _nodeJs.Color.Red) {
                s = p.left = _nodeJs.clone(s);
                z = s.right = _nodeJs.clone(s.right);
                p.left = z.right;
                s.right = z.left;
                z.right = p;
                z.left = s;
                z.color = p.color;
                p.color = _nodeJs.Color.Black;
                s.color = _nodeJs.Color.Black;
                n.color = _nodeJs.Color.Black;
                _nodeJs.recount(p);
                _nodeJs.recount(s);
                _nodeJs.recount(z);
                if (i > 1) {
                    const pp = stack[i - 2];
                    if (pp.right === p) pp.right = z;
                    else pp.left = z;
                }
                stack[i - 1] = z;
                return;
            }
            if (s !== undefined && s.color === _nodeJs.Color.Black) {
                if (p.color === _nodeJs.Color.Red) {
                    p.color = _nodeJs.Color.Black;
                    p.left = _nodeJs.repaint(s, _nodeJs.Color.Red);
                    return;
                } else {
                    p.left = _nodeJs.repaint(s, _nodeJs.Color.Red);
                    continue;
                }
            } else if (s !== undefined) {
                s = _nodeJs.clone(s);
                p.left = s.right;
                s.right = p;
                s.color = p.color;
                p.color = _nodeJs.Color.Red;
                _nodeJs.recount(p);
                _nodeJs.recount(s);
                if (i > 1) {
                    const pp = stack[i - 2];
                    if (pp.right === p) pp.right = s;
                    else pp.left = s;
                }
                stack[i - 1] = s;
                stack[i] = p;
                if (i + 1 < stack.length) stack[i + 1] = n;
                else stack.push(n);
                i = i + 2;
            }
        }
    }
};

},{"../Chunk.js":"dL1OO","../Equal.js":"gA0qD","../Function.js":"21gOL","../Hash.js":"gFMwE","../Inspectable.js":"1Ur70","../Option.js":"6sHA7","../Pipeable.js":"b5RU2","../Predicate.js":"gW5pd","./redBlackTree/iterator.js":"fWfKz","./redBlackTree/node.js":"98mGN","./stack.js":"Pt170","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"fWfKz":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Direction", ()=>Direction);
/** @internal */ parcelHelpers.export(exports, "RedBlackTreeIterator", ()=>RedBlackTreeIterator);
var _arrayJs = require("../../Array.js");
var _optionJs = require("../../Option.js");
const Direction = {
    Forward: 0,
    Backward: 1
};
class RedBlackTreeIterator {
    self;
    stack;
    direction;
    count = 0;
    constructor(self, stack, direction){
        this.self = self;
        this.stack = stack;
        this.direction = direction;
    }
    /**
   * Clones the iterator
   */ clone() {
        return new RedBlackTreeIterator(this.self, this.stack.slice(), this.direction);
    }
    /**
   * Reverse the traversal direction
   */ reversed() {
        return new RedBlackTreeIterator(this.self, this.stack.slice(), this.direction === Direction.Forward ? Direction.Backward : Direction.Forward);
    }
    /**
   * Iterator next
   */ next() {
        const entry = this.entry;
        this.count++;
        if (this.direction === Direction.Forward) this.moveNext();
        else this.movePrev();
        switch(entry._tag){
            case "None":
                return {
                    done: true,
                    value: this.count
                };
            case "Some":
                return {
                    done: false,
                    value: entry.value
                };
        }
    }
    /**
   * Returns the key
   */ get key() {
        if (this.stack.length > 0) return _optionJs.some(this.stack[this.stack.length - 1].key);
        return _optionJs.none();
    }
    /**
   * Returns the value
   */ get value() {
        if (this.stack.length > 0) return _optionJs.some(this.stack[this.stack.length - 1].value);
        return _optionJs.none();
    }
    /**
   * Returns the key
   */ get entry() {
        return _optionJs.map(_arrayJs.last(this.stack), (node)=>[
                node.key,
                node.value
            ]);
    }
    /**
   * Returns the position of this iterator in the sorted list
   */ get index() {
        let idx = 0;
        const stack = this.stack;
        if (stack.length === 0) {
            const r = this.self._root;
            if (r != null) return r.count;
            return 0;
        } else if (stack[stack.length - 1].left != null) idx = stack[stack.length - 1].left.count;
        for(let s = stack.length - 2; s >= 0; --s)if (stack[s + 1] === stack[s].right) {
            ++idx;
            if (stack[s].left != null) idx += stack[s].left.count;
        }
        return idx;
    }
    /**
   * Advances iterator to next element in list
   */ moveNext() {
        const stack = this.stack;
        if (stack.length === 0) return;
        let n = stack[stack.length - 1];
        if (n.right != null) {
            n = n.right;
            while(n != null){
                stack.push(n);
                n = n.left;
            }
        } else {
            stack.pop();
            while(stack.length > 0 && stack[stack.length - 1].right === n){
                n = stack[stack.length - 1];
                stack.pop();
            }
        }
    }
    /**
   * Checks if there is a next element
   */ get hasNext() {
        const stack = this.stack;
        if (stack.length === 0) return false;
        if (stack[stack.length - 1].right != null) return true;
        for(let s = stack.length - 1; s > 0; --s){
            if (stack[s - 1].left === stack[s]) return true;
        }
        return false;
    }
    /**
   * Advances iterator to previous element in list
   */ movePrev() {
        const stack = this.stack;
        if (stack.length === 0) return;
        let n = stack[stack.length - 1];
        if (n != null && n.left != null) {
            n = n.left;
            while(n != null){
                stack.push(n);
                n = n.right;
            }
        } else {
            stack.pop();
            while(stack.length > 0 && stack[stack.length - 1].left === n){
                n = stack[stack.length - 1];
                stack.pop();
            }
        }
    }
    /**
   * Checks if there is a previous element
   */ get hasPrev() {
        const stack = this.stack;
        if (stack.length === 0) return false;
        if (stack[stack.length - 1].left != null) return true;
        for(let s = stack.length - 1; s > 0; --s){
            if (stack[s - 1].right === stack[s]) return true;
        }
        return false;
    }
}

},{"../../Array.js":"8L2Gk","../../Option.js":"6sHA7","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"98mGN":[function(require,module,exports,__globalThis) {
/** @internal */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Color", ()=>Color);
parcelHelpers.export(exports, "clone", ()=>clone);
/** @internal */ parcelHelpers.export(exports, "swap", ()=>swap);
parcelHelpers.export(exports, "repaint", ()=>repaint);
parcelHelpers.export(exports, "recount", ()=>recount);
const Color = {
    Red: 0,
    Black: 1
};
const clone = ({ color, count, key, left, right, value })=>({
        color,
        key,
        value,
        left,
        right,
        count
    });
function swap(n, v) {
    n.key = v.key;
    n.value = v.value;
    n.left = v.left;
    n.right = v.right;
    n.color = v.color;
    n.count = v.count;
}
const repaint = ({ count, key, left, right, value }, color)=>({
        color,
        key,
        value,
        left,
        right,
        count
    });
const recount = (node)=>{
    node.count = 1 + (node.left?.count ?? 0) + (node.right?.count ?? 0);
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"2Cdn0":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "OP_EMPTY", ()=>OP_EMPTY);
parcelHelpers.export(exports, "OP_ADD_SUPERVISOR", ()=>OP_ADD_SUPERVISOR);
parcelHelpers.export(exports, "OP_REMOVE_SUPERVISOR", ()=>OP_REMOVE_SUPERVISOR);
parcelHelpers.export(exports, "OP_AND_THEN", ()=>OP_AND_THEN);
parcelHelpers.export(exports, "empty", ()=>empty);
parcelHelpers.export(exports, "combine", ()=>combine);
parcelHelpers.export(exports, "patch", ()=>patch);
parcelHelpers.export(exports, "diff", ()=>diff);
parcelHelpers.export(exports, "differ", ()=>differ);
var _chunkJs = require("../../Chunk.js");
var _differJs = require("../../Differ.js");
var _equalJs = require("../../Equal.js");
var _functionJs = require("../../Function.js");
var _hashSetJs = require("../../HashSet.js");
var _supervisorJs = require("../supervisor.js");
const OP_EMPTY = "Empty";
const OP_ADD_SUPERVISOR = "AddSupervisor";
const OP_REMOVE_SUPERVISOR = "RemoveSupervisor";
const OP_AND_THEN = "AndThen";
const empty = {
    _tag: OP_EMPTY
};
const combine = (self, that)=>{
    return {
        _tag: OP_AND_THEN,
        first: self,
        second: that
    };
};
const patch = (self, supervisor)=>{
    return patchLoop(supervisor, _chunkJs.of(self));
};
/** @internal */ const patchLoop = (_supervisor, _patches)=>{
    let supervisor = _supervisor;
    let patches = _patches;
    while(_chunkJs.isNonEmpty(patches)){
        const head = _chunkJs.headNonEmpty(patches);
        switch(head._tag){
            case OP_EMPTY:
                patches = _chunkJs.tailNonEmpty(patches);
                break;
            case OP_ADD_SUPERVISOR:
                supervisor = supervisor.zip(head.supervisor);
                patches = _chunkJs.tailNonEmpty(patches);
                break;
            case OP_REMOVE_SUPERVISOR:
                supervisor = removeSupervisor(supervisor, head.supervisor);
                patches = _chunkJs.tailNonEmpty(patches);
                break;
            case OP_AND_THEN:
                patches = _chunkJs.prepend(head.first)(_chunkJs.prepend(head.second)(_chunkJs.tailNonEmpty(patches)));
                break;
        }
    }
    return supervisor;
};
/** @internal */ const removeSupervisor = (self, that)=>{
    if (_equalJs.equals(self, that)) return _supervisorJs.none;
    else {
        if (_supervisorJs.isZip(self)) return removeSupervisor(self.left, that).zip(removeSupervisor(self.right, that));
        else return self;
    }
};
/** @internal */ const toSet = (self)=>{
    if (_equalJs.equals(self, _supervisorJs.none)) return _hashSetJs.empty();
    else {
        if (_supervisorJs.isZip(self)) return (0, _functionJs.pipe)(toSet(self.left), _hashSetJs.union(toSet(self.right)));
        else return _hashSetJs.make(self);
    }
};
const diff = (oldValue, newValue)=>{
    if (_equalJs.equals(oldValue, newValue)) return empty;
    const oldSupervisors = toSet(oldValue);
    const newSupervisors = toSet(newValue);
    const added = (0, _functionJs.pipe)(newSupervisors, _hashSetJs.difference(oldSupervisors), _hashSetJs.reduce(empty, (patch, supervisor)=>combine(patch, {
            _tag: OP_ADD_SUPERVISOR,
            supervisor
        })));
    const removed = (0, _functionJs.pipe)(oldSupervisors, _hashSetJs.difference(newSupervisors), _hashSetJs.reduce(empty, (patch, supervisor)=>combine(patch, {
            _tag: OP_REMOVE_SUPERVISOR,
            supervisor
        })));
    return combine(added, removed);
};
const differ = /*#__PURE__*/ _differJs.make({
    empty,
    patch,
    combine,
    diff
});

},{"../../Chunk.js":"dL1OO","../../Differ.js":"lPymI","../../Equal.js":"gA0qD","../../Function.js":"21gOL","../../HashSet.js":"aKFFV","../supervisor.js":"bryLt","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"lPymI":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TypeId", ()=>TypeId);
parcelHelpers.export(exports, "empty", ()=>empty);
parcelHelpers.export(exports, "diff", ()=>diff);
parcelHelpers.export(exports, "combine", ()=>combine);
parcelHelpers.export(exports, "patch", ()=>patch);
parcelHelpers.export(exports, "make", ()=>make);
parcelHelpers.export(exports, "environment", ()=>environment);
parcelHelpers.export(exports, "chunk", ()=>chunk);
parcelHelpers.export(exports, "hashMap", ()=>hashMap);
parcelHelpers.export(exports, "hashSet", ()=>hashSet);
parcelHelpers.export(exports, "orElseEither", ()=>orElseEither);
parcelHelpers.export(exports, "readonlyArray", ()=>readonlyArray);
parcelHelpers.export(exports, "transform", ()=>transform);
parcelHelpers.export(exports, "update", ()=>update);
parcelHelpers.export(exports, "updateWith", ()=>updateWith);
parcelHelpers.export(exports, "zip", ()=>zip);
var _functionJs = require("./Function.js");
var _differJs = require("./internal/differ.js");
var _chunkPatchJs = require("./internal/differ/chunkPatch.js");
var _contextPatchJs = require("./internal/differ/contextPatch.js");
var _hashMapPatchJs = require("./internal/differ/hashMapPatch.js");
var _hashSetPatchJs = require("./internal/differ/hashSetPatch.js");
var _orPatchJs = require("./internal/differ/orPatch.js");
var _readonlyArrayPatchJs = require("./internal/differ/readonlyArrayPatch.js");
const TypeId = _differJs.DifferTypeId;
const ChunkPatchTypeId = _chunkPatchJs.ChunkPatchTypeId;
const ContextPatchTypeId = _contextPatchJs.ContextPatchTypeId;
const HashMapPatchTypeId = _hashMapPatchJs.HashMapPatchTypeId;
const HashSetPatchTypeId = _hashSetPatchJs.HashSetPatchTypeId;
const OrPatchTypeId = _orPatchJs.OrPatchTypeId;
const ReadonlyArrayPatchTypeId = _readonlyArrayPatchJs.ReadonlyArrayPatchTypeId;
const empty = (self)=>self.empty;
const diff = /*#__PURE__*/ _functionJs.dual(3, (self, oldValue, newValue)=>self.diff(oldValue, newValue));
const combine = /*#__PURE__*/ _functionJs.dual(3, (self, first, second)=>self.combine(first, second));
const patch = /*#__PURE__*/ _functionJs.dual(3, (self, patch, oldValue)=>self.patch(patch, oldValue));
const make = _differJs.make;
const environment = _differJs.environment;
const chunk = _differJs.chunk;
const hashMap = _differJs.hashMap;
const hashSet = _differJs.hashSet;
const orElseEither = _differJs.orElseEither;
const readonlyArray = _differJs.readonlyArray;
const transform = _differJs.transform;
const update = _differJs.update;
const updateWith = _differJs.updateWith;
const zip = _differJs.zip;

},{"./Function.js":"21gOL","./internal/differ.js":"jOq6n","./internal/differ/chunkPatch.js":"gqpP3","./internal/differ/contextPatch.js":"dOZM5","./internal/differ/hashMapPatch.js":"guP0Y","./internal/differ/hashSetPatch.js":"1i5Zt","./internal/differ/orPatch.js":"RGDmm","./internal/differ/readonlyArrayPatch.js":"uaIJN","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"aHmA5":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "LayerTypeId", ()=>LayerTypeId);
parcelHelpers.export(exports, "proto", ()=>proto);
parcelHelpers.export(exports, "MemoMapTypeId", ()=>MemoMapTypeId);
parcelHelpers.export(exports, "CurrentMemoMap", ()=>CurrentMemoMap);
parcelHelpers.export(exports, "isLayer", ()=>isLayer);
parcelHelpers.export(exports, "isFresh", ()=>isFresh);
parcelHelpers.export(exports, "makeMemoMap", ()=>makeMemoMap);
parcelHelpers.export(exports, "unsafeMakeMemoMap", ()=>unsafeMakeMemoMap);
parcelHelpers.export(exports, "build", ()=>build);
parcelHelpers.export(exports, "buildWithScope", ()=>buildWithScope);
parcelHelpers.export(exports, "buildWithMemoMap", ()=>buildWithMemoMap);
parcelHelpers.export(exports, "catchAll", ()=>catchAll);
parcelHelpers.export(exports, "catchAllCause", ()=>catchAllCause);
parcelHelpers.export(exports, "die", ()=>die);
parcelHelpers.export(exports, "dieSync", ()=>dieSync);
parcelHelpers.export(exports, "discard", ()=>discard);
parcelHelpers.export(exports, "context", ()=>context);
parcelHelpers.export(exports, "extendScope", ()=>extendScope);
parcelHelpers.export(exports, "fail", ()=>fail);
parcelHelpers.export(exports, "failSync", ()=>failSync);
parcelHelpers.export(exports, "failCause", ()=>failCause);
parcelHelpers.export(exports, "failCauseSync", ()=>failCauseSync);
parcelHelpers.export(exports, "flatMap", ()=>flatMap);
parcelHelpers.export(exports, "flatten", ()=>flatten);
parcelHelpers.export(exports, "fresh", ()=>fresh);
parcelHelpers.export(exports, "fromEffect", ()=>fromEffect);
parcelHelpers.export(exports, "fromEffectDiscard", ()=>fromEffectDiscard);
/** @internal */ parcelHelpers.export(exports, "fromEffectContext", ()=>fromEffectContext);
parcelHelpers.export(exports, "fiberRefLocally", ()=>fiberRefLocally);
parcelHelpers.export(exports, "locallyEffect", ()=>locallyEffect);
parcelHelpers.export(exports, "fiberRefLocallyWith", ()=>fiberRefLocallyWith);
parcelHelpers.export(exports, "fiberRefLocallyScoped", ()=>fiberRefLocallyScoped);
parcelHelpers.export(exports, "fiberRefLocallyScopedWith", ()=>fiberRefLocallyScopedWith);
parcelHelpers.export(exports, "fromFunction", ()=>fromFunction);
parcelHelpers.export(exports, "launch", ()=>launch);
parcelHelpers.export(exports, "map", ()=>map);
parcelHelpers.export(exports, "mapError", ()=>mapError);
parcelHelpers.export(exports, "matchCause", ()=>matchCause);
parcelHelpers.export(exports, "match", ()=>match);
parcelHelpers.export(exports, "memoize", ()=>memoize);
parcelHelpers.export(exports, "merge", ()=>merge);
parcelHelpers.export(exports, "mergeAll", ()=>mergeAll);
parcelHelpers.export(exports, "orDie", ()=>orDie);
parcelHelpers.export(exports, "orElse", ()=>orElse);
parcelHelpers.export(exports, "passthrough", ()=>passthrough);
parcelHelpers.export(exports, "project", ()=>project);
parcelHelpers.export(exports, "retry", ()=>retry);
parcelHelpers.export(exports, "scoped", ()=>scoped);
parcelHelpers.export(exports, "scopedDiscard", ()=>scopedDiscard);
parcelHelpers.export(exports, "scopedContext", ()=>scopedContext);
parcelHelpers.export(exports, "scope", ()=>scope);
parcelHelpers.export(exports, "service", ()=>service);
parcelHelpers.export(exports, "succeed", ()=>succeed);
parcelHelpers.export(exports, "succeedContext", ()=>succeedContext);
parcelHelpers.export(exports, "empty", ()=>empty);
parcelHelpers.export(exports, "suspend", ()=>suspend);
parcelHelpers.export(exports, "sync", ()=>sync);
parcelHelpers.export(exports, "syncContext", ()=>syncContext);
parcelHelpers.export(exports, "tap", ()=>tap);
parcelHelpers.export(exports, "tapError", ()=>tapError);
parcelHelpers.export(exports, "tapErrorCause", ()=>tapErrorCause);
parcelHelpers.export(exports, "toRuntime", ()=>toRuntime);
parcelHelpers.export(exports, "toRuntimeWithMemoMap", ()=>toRuntimeWithMemoMap);
parcelHelpers.export(exports, "provide", ()=>provide);
parcelHelpers.export(exports, "provideMerge", ()=>provideMerge);
parcelHelpers.export(exports, "zipWith", ()=>zipWith);
parcelHelpers.export(exports, "unwrapEffect", ()=>unwrapEffect);
parcelHelpers.export(exports, "unwrapScoped", ()=>unwrapScoped);
parcelHelpers.export(exports, "annotateLogs", ()=>annotateLogs);
parcelHelpers.export(exports, "annotateSpans", ()=>annotateSpans);
parcelHelpers.export(exports, "withSpan", ()=>withSpan);
parcelHelpers.export(exports, "withParentSpan", ()=>withParentSpan);
parcelHelpers.export(exports, "effect_provide", ()=>effect_provide);
var _causeJs = require("../Cause.js");
var _clockJs = require("../Clock.js");
var _contextJs = require("../Context.js");
var _durationJs = require("../Duration.js");
var _fiberRefsPatchJs = require("../FiberRefsPatch.js");
var _functionJs = require("../Function.js");
var _hashMapJs = require("../HashMap.js");
var _pipeableJs = require("../Pipeable.js");
var _predicateJs = require("../Predicate.js");
var _scheduleDecisionJs = require("../ScheduleDecision.js");
var _scheduleIntervalsJs = require("../ScheduleIntervals.js");
var _scopeJs = require("../Scope.js");
var _coreEffectJs = require("./core-effect.js");
var _coreJs = require("./core.js");
var _circularJs = require("./effect/circular.js");
var _fiberRuntimeJs = require("./fiberRuntime.js");
var _circularJs1 = require("./managedRuntime/circular.js");
var _effectJs = require("./opCodes/effect.js");
var _layerJs = require("./opCodes/layer.js");
var _refJs = require("./ref.js");
var _runtimeJs = require("./runtime.js");
var _runtimeFlagsJs = require("./runtimeFlags.js");
var _synchronizedRefJs = require("./synchronizedRef.js");
var _tracerJs = require("./tracer.js");
/** @internal */ const LayerSymbolKey = "effect/Layer";
const LayerTypeId = /*#__PURE__*/ Symbol.for(LayerSymbolKey);
const layerVariance = {
    /* c8 ignore next */ _RIn: (_)=>_,
    /* c8 ignore next */ _E: (_)=>_,
    /* c8 ignore next */ _ROut: (_)=>_
};
const proto = {
    [LayerTypeId]: layerVariance,
    pipe () {
        return (0, _pipeableJs.pipeArguments)(this, arguments);
    }
};
/** @internal */ const MemoMapTypeIdKey = "effect/Layer/MemoMap";
const MemoMapTypeId = /*#__PURE__*/ Symbol.for(MemoMapTypeIdKey);
const CurrentMemoMap = /*#__PURE__*/ _contextJs.Reference()("effect/Layer/CurrentMemoMap", {
    defaultValue: ()=>unsafeMakeMemoMap()
});
const isLayer = (u)=>(0, _predicateJs.hasProperty)(u, LayerTypeId);
const isFresh = (self)=>{
    return self._op_layer === _layerJs.OP_FRESH;
};
// -----------------------------------------------------------------------------
// MemoMap
// -----------------------------------------------------------------------------
/** @internal */ class MemoMapImpl {
    ref;
    [MemoMapTypeId];
    constructor(ref){
        this.ref = ref;
        this[MemoMapTypeId] = MemoMapTypeId;
    }
    /**
   * Checks the memo map to see if a layer exists. If it is, immediately
   * returns it. Otherwise, obtains the layer, stores it in the memo map,
   * and adds a finalizer to the `Scope`.
   */ getOrElseMemoize(layer, scope) {
        return (0, _functionJs.pipe)(_synchronizedRefJs.modifyEffect(this.ref, (map)=>{
            const inMap = map.get(layer);
            if (inMap !== undefined) {
                const [acquire, release] = inMap;
                const cached = (0, _functionJs.pipe)(acquire, _coreJs.flatMap(([patch, b])=>(0, _functionJs.pipe)(_coreEffectJs.patchFiberRefs(patch), _coreJs.as(b))), _coreJs.onExit(_coreJs.exitMatch({
                    onFailure: ()=>_coreJs.void,
                    onSuccess: ()=>_coreJs.scopeAddFinalizerExit(scope, release)
                })));
                return _coreJs.succeed([
                    cached,
                    map
                ]);
            }
            return (0, _functionJs.pipe)(_refJs.make(0), _coreJs.flatMap((observers)=>(0, _functionJs.pipe)(_coreJs.deferredMake(), _coreJs.flatMap((deferred)=>(0, _functionJs.pipe)(_refJs.make(()=>_coreJs.void), _coreJs.map((finalizerRef)=>{
                        const resource = _coreJs.uninterruptibleMask((restore)=>(0, _functionJs.pipe)(_fiberRuntimeJs.scopeMake(), _coreJs.flatMap((innerScope)=>(0, _functionJs.pipe)(restore(_coreJs.flatMap(makeBuilder(layer, innerScope, true), (f)=>_coreEffectJs.diffFiberRefs(f(this)))), _coreJs.exit, _coreJs.flatMap((exit)=>{
                                    switch(exit._tag){
                                        case _effectJs.OP_FAILURE:
                                            return (0, _functionJs.pipe)(_coreJs.deferredFailCause(deferred, exit.effect_instruction_i0), _coreJs.zipRight(_coreJs.scopeClose(innerScope, exit)), _coreJs.zipRight(_coreJs.failCause(exit.effect_instruction_i0)));
                                        case _effectJs.OP_SUCCESS:
                                            return (0, _functionJs.pipe)(_refJs.set(finalizerRef, (exit)=>(0, _functionJs.pipe)(_coreJs.scopeClose(innerScope, exit), _coreJs.whenEffect(_refJs.modify(observers, (n)=>[
                                                        n === 1,
                                                        n - 1
                                                    ])), _coreJs.asVoid)), _coreJs.zipRight(_refJs.update(observers, (n)=>n + 1)), _coreJs.zipRight(_coreJs.scopeAddFinalizerExit(scope, (exit)=>(0, _functionJs.pipe)(_coreJs.sync(()=>map.delete(layer)), _coreJs.zipRight(_refJs.get(finalizerRef)), _coreJs.flatMap((finalizer)=>finalizer(exit))))), _coreJs.zipRight(_coreJs.deferredSucceed(deferred, exit.effect_instruction_i0)), _coreJs.as(exit.effect_instruction_i0[1]));
                                    }
                                })))));
                        const memoized = [
                            (0, _functionJs.pipe)(_coreJs.deferredAwait(deferred), _coreJs.onExit(_coreJs.exitMatchEffect({
                                onFailure: ()=>_coreJs.void,
                                onSuccess: ()=>_refJs.update(observers, (n)=>n + 1)
                            }))),
                            (exit)=>(0, _functionJs.pipe)(_refJs.get(finalizerRef), _coreJs.flatMap((finalizer)=>finalizer(exit)))
                        ];
                        return [
                            resource,
                            isFresh(layer) ? map : map.set(layer, memoized)
                        ];
                    }))))));
        }), _coreJs.flatten);
    }
}
const makeMemoMap = /*#__PURE__*/ _coreJs.suspend(()=>_coreJs.map(_circularJs.makeSynchronized(new Map()), (ref)=>new MemoMapImpl(ref)));
const unsafeMakeMemoMap = ()=>new MemoMapImpl(_circularJs.unsafeMakeSynchronized(new Map()));
const build = (self)=>_fiberRuntimeJs.scopeWith((scope)=>buildWithScope(self, scope));
const buildWithScope = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, scope)=>_coreJs.flatMap(makeMemoMap, (memoMap)=>buildWithMemoMap(self, memoMap, scope)));
const buildWithMemoMap = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, memoMap, scope)=>_coreJs.flatMap(makeBuilder(self, scope), (run)=>_coreEffectJs.provideService(run(memoMap), CurrentMemoMap, memoMap)));
const makeBuilder = (self, scope, inMemoMap = false)=>{
    const op = self;
    switch(op._op_layer){
        case "Locally":
            return _coreJs.sync(()=>(memoMap)=>op.f(memoMap.getOrElseMemoize(op.self, scope)));
        case "ExtendScope":
            return _coreJs.sync(()=>(memoMap)=>_fiberRuntimeJs.scopeWith((scope)=>memoMap.getOrElseMemoize(op.layer, scope)));
        case "Fold":
            return _coreJs.sync(()=>(memoMap)=>(0, _functionJs.pipe)(memoMap.getOrElseMemoize(op.layer, scope), _coreJs.matchCauseEffect({
                        onFailure: (cause)=>memoMap.getOrElseMemoize(op.failureK(cause), scope),
                        onSuccess: (value)=>memoMap.getOrElseMemoize(op.successK(value), scope)
                    })));
        case "Fresh":
            return _coreJs.sync(()=>(_)=>(0, _functionJs.pipe)(op.layer, buildWithScope(scope)));
        case "FromEffect":
            return inMemoMap ? _coreJs.sync(()=>(_)=>op.effect) : _coreJs.sync(()=>(memoMap)=>memoMap.getOrElseMemoize(self, scope));
        case "Provide":
            return _coreJs.sync(()=>(memoMap)=>(0, _functionJs.pipe)(memoMap.getOrElseMemoize(op.first, scope), _coreJs.flatMap((env)=>(0, _functionJs.pipe)(memoMap.getOrElseMemoize(op.second, scope), _coreJs.provideContext(env)))));
        case "Scoped":
            return inMemoMap ? _coreJs.sync(()=>(_)=>_fiberRuntimeJs.scopeExtend(op.effect, scope)) : _coreJs.sync(()=>(memoMap)=>memoMap.getOrElseMemoize(self, scope));
        case "Suspend":
            return _coreJs.sync(()=>(memoMap)=>memoMap.getOrElseMemoize(op.evaluate(), scope));
        case "ProvideMerge":
            return _coreJs.sync(()=>(memoMap)=>(0, _functionJs.pipe)(memoMap.getOrElseMemoize(op.first, scope), _coreJs.zipWith(memoMap.getOrElseMemoize(op.second, scope), op.zipK)));
        case "ZipWith":
            return _coreJs.sync(()=>(memoMap)=>(0, _functionJs.pipe)(memoMap.getOrElseMemoize(op.first, scope), _fiberRuntimeJs.zipWithOptions(memoMap.getOrElseMemoize(op.second, scope), op.zipK, {
                        concurrent: true
                    })));
    }
};
const catchAll = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, onFailure)=>match(self, {
        onFailure,
        onSuccess: succeedContext
    }));
const catchAllCause = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, onFailure)=>matchCause(self, {
        onFailure,
        onSuccess: succeedContext
    }));
const die = (defect)=>failCause(_causeJs.die(defect));
const dieSync = (evaluate)=>failCauseSync(()=>_causeJs.die(evaluate()));
const discard = (self)=>map(self, ()=>_contextJs.empty());
const context = ()=>fromEffectContext(_coreJs.context());
const extendScope = (self)=>{
    const extendScope = Object.create(proto);
    extendScope._op_layer = _layerJs.OP_EXTEND_SCOPE;
    extendScope.layer = self;
    return extendScope;
};
const fail = (error)=>failCause(_causeJs.fail(error));
const failSync = (evaluate)=>failCauseSync(()=>_causeJs.fail(evaluate()));
const failCause = (cause)=>fromEffectContext(_coreJs.failCause(cause));
const failCauseSync = (evaluate)=>fromEffectContext(_coreJs.failCauseSync(evaluate));
const flatMap = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>match(self, {
        onFailure: fail,
        onSuccess: f
    }));
const flatten = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, tag)=>flatMap(self, _contextJs.get(tag)));
const fresh = (self)=>{
    const fresh = Object.create(proto);
    fresh._op_layer = _layerJs.OP_FRESH;
    fresh.layer = self;
    return fresh;
};
const fromEffect = /*#__PURE__*/ (0, _functionJs.dual)(2, (a, b)=>{
    const tagFirst = _contextJs.isTag(a);
    const tag = tagFirst ? a : b;
    const effect = tagFirst ? b : a;
    return fromEffectContext(_coreJs.map(effect, (service)=>_contextJs.make(tag, service)));
});
const fromEffectDiscard = (effect)=>fromEffectContext(_coreJs.map(effect, ()=>_contextJs.empty()));
function fromEffectContext(effect) {
    const fromEffect = Object.create(proto);
    fromEffect._op_layer = _layerJs.OP_FROM_EFFECT;
    fromEffect.effect = effect;
    return fromEffect;
}
const fiberRefLocally = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, ref, value)=>locallyEffect(self, _coreJs.fiberRefLocally(ref, value)));
const locallyEffect = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>{
    const locally = Object.create(proto);
    locally._op_layer = "Locally";
    locally.self = self;
    locally.f = f;
    return locally;
});
const fiberRefLocallyWith = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, ref, value)=>locallyEffect(self, _coreJs.fiberRefLocallyWith(ref, value)));
const fiberRefLocallyScoped = (self, value)=>scopedDiscard(_fiberRuntimeJs.fiberRefLocallyScoped(self, value));
const fiberRefLocallyScopedWith = (self, value)=>scopedDiscard(_fiberRuntimeJs.fiberRefLocallyScopedWith(self, value));
const fromFunction = (tagA, tagB, f)=>fromEffectContext(_coreJs.map(tagA, (a)=>_contextJs.make(tagB, f(a))));
const launch = (self)=>_fiberRuntimeJs.scopedEffect(_coreJs.zipRight(_fiberRuntimeJs.scopeWith((scope)=>(0, _functionJs.pipe)(self, buildWithScope(scope))), _coreJs.never));
const map = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>flatMap(self, (context)=>succeedContext(f(context))));
const mapError = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>catchAll(self, (error)=>failSync(()=>f(error))));
const matchCause = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, { onFailure, onSuccess })=>{
    const fold = Object.create(proto);
    fold._op_layer = _layerJs.OP_FOLD;
    fold.layer = self;
    fold.failureK = onFailure;
    fold.successK = onSuccess;
    return fold;
});
const match = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, { onFailure, onSuccess })=>matchCause(self, {
        onFailure: (cause)=>{
            const failureOrCause = _causeJs.failureOrCause(cause);
            switch(failureOrCause._tag){
                case "Left":
                    return onFailure(failureOrCause.left);
                case "Right":
                    return failCause(failureOrCause.right);
            }
        },
        onSuccess
    }));
const memoize = (self)=>_fiberRuntimeJs.scopeWith((scope)=>_coreJs.map(_coreEffectJs.memoize(buildWithScope(self, scope)), fromEffectContext));
const merge = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>zipWith(self, that, (a, b)=>_contextJs.merge(a, b)));
const mergeAll = (...layers)=>{
    let final = layers[0];
    for(let i = 1; i < layers.length; i++)final = merge(final, layers[i]);
    return final;
};
const orDie = (self)=>catchAll(self, (defect)=>die(defect));
const orElse = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>catchAll(self, that));
const passthrough = (self)=>merge(context(), self);
const project = /*#__PURE__*/ (0, _functionJs.dual)(4, (self, tagA, tagB, f)=>map(self, (context)=>_contextJs.make(tagB, f(_contextJs.unsafeGet(context, tagA)))));
const retry = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, schedule)=>suspend(()=>{
        const stateTag = _contextJs.GenericTag("effect/Layer/retry/{ state: unknown }");
        return (0, _functionJs.pipe)(succeed(stateTag, {
            state: schedule.initial
        }), flatMap((env)=>retryLoop(self, schedule, stateTag, (0, _functionJs.pipe)(env, _contextJs.get(stateTag)).state)));
    }));
const retryLoop = (self, schedule, stateTag, state)=>{
    return (0, _functionJs.pipe)(self, catchAll((error)=>(0, _functionJs.pipe)(retryUpdate(schedule, stateTag, error, state), flatMap((env)=>fresh(retryLoop(self, schedule, stateTag, (0, _functionJs.pipe)(env, _contextJs.get(stateTag)).state))))));
};
const retryUpdate = (schedule, stateTag, error, state)=>{
    return fromEffect(stateTag, (0, _functionJs.pipe)(_clockJs.currentTimeMillis, _coreJs.flatMap((now)=>(0, _functionJs.pipe)(schedule.step(now, error, state), _coreJs.flatMap(([state, _, decision])=>_scheduleDecisionJs.isDone(decision) ? _coreJs.fail(error) : (0, _functionJs.pipe)(_clockJs.sleep(_durationJs.millis(_scheduleIntervalsJs.start(decision.intervals) - now)), _coreJs.as({
                state
            })))))));
};
const scoped = /*#__PURE__*/ (0, _functionJs.dual)(2, (a, b)=>{
    const tagFirst = _contextJs.isTag(a);
    const tag = tagFirst ? a : b;
    const effect = tagFirst ? b : a;
    return scopedContext(_coreJs.map(effect, (service)=>_contextJs.make(tag, service)));
});
const scopedDiscard = (effect)=>scopedContext((0, _functionJs.pipe)(effect, _coreJs.as(_contextJs.empty())));
const scopedContext = (effect)=>{
    const scoped = Object.create(proto);
    scoped._op_layer = _layerJs.OP_SCOPED;
    scoped.effect = effect;
    return scoped;
};
const scope = /*#__PURE__*/ scopedContext(/*#__PURE__*/ _coreJs.map(/*#__PURE__*/ _fiberRuntimeJs.acquireRelease(/*#__PURE__*/ _fiberRuntimeJs.scopeMake(), (scope, exit)=>scope.close(exit)), (scope)=>_contextJs.make(_scopeJs.Scope, scope)));
const service = (tag)=>fromEffect(tag, tag);
const succeed = /*#__PURE__*/ (0, _functionJs.dual)(2, (a, b)=>{
    const tagFirst = _contextJs.isTag(a);
    const tag = tagFirst ? a : b;
    const resource = tagFirst ? b : a;
    return fromEffectContext(_coreJs.succeed(_contextJs.make(tag, resource)));
});
const succeedContext = (context)=>{
    return fromEffectContext(_coreJs.succeed(context));
};
const empty = /*#__PURE__*/ succeedContext(/*#__PURE__*/ _contextJs.empty());
const suspend = (evaluate)=>{
    const suspend = Object.create(proto);
    suspend._op_layer = _layerJs.OP_SUSPEND;
    suspend.evaluate = evaluate;
    return suspend;
};
const sync = /*#__PURE__*/ (0, _functionJs.dual)(2, (a, b)=>{
    const tagFirst = _contextJs.isTag(a);
    const tag = tagFirst ? a : b;
    const evaluate = tagFirst ? b : a;
    return fromEffectContext(_coreJs.sync(()=>_contextJs.make(tag, evaluate())));
});
const syncContext = (evaluate)=>{
    return fromEffectContext(_coreJs.sync(evaluate));
};
const tap = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>flatMap(self, (context)=>fromEffectContext(_coreJs.as(f(context), context))));
const tapError = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>catchAll(self, (e)=>fromEffectContext(_coreJs.flatMap(f(e), ()=>_coreJs.fail(e)))));
const tapErrorCause = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>catchAllCause(self, (cause)=>fromEffectContext(_coreJs.flatMap(f(cause), ()=>_coreJs.failCause(cause)))));
const toRuntime = (self)=>(0, _functionJs.pipe)(_fiberRuntimeJs.scopeWith((scope)=>buildWithScope(self, scope)), _coreJs.flatMap((context)=>(0, _functionJs.pipe)(_runtimeJs.runtime(), _coreJs.provideContext(context))));
const toRuntimeWithMemoMap = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, memoMap)=>_coreJs.flatMap(_fiberRuntimeJs.scopeWith((scope)=>buildWithMemoMap(self, memoMap, scope)), (context)=>(0, _functionJs.pipe)(_runtimeJs.runtime(), _coreJs.provideContext(context))));
const provide = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>suspend(()=>{
        const provideTo = Object.create(proto);
        provideTo._op_layer = _layerJs.OP_PROVIDE;
        provideTo.first = Object.create(proto, {
            _op_layer: {
                value: _layerJs.OP_PROVIDE_MERGE,
                enumerable: true
            },
            first: {
                value: context(),
                enumerable: true
            },
            second: {
                value: Array.isArray(that) ? mergeAll(...that) : that
            },
            zipK: {
                value: (a, b)=>(0, _functionJs.pipe)(a, _contextJs.merge(b))
            }
        });
        provideTo.second = self;
        return provideTo;
    }));
const provideMerge = /*#__PURE__*/ (0, _functionJs.dual)(2, (that, self)=>{
    const zipWith = Object.create(proto);
    zipWith._op_layer = _layerJs.OP_PROVIDE_MERGE;
    zipWith.first = self;
    zipWith.second = provide(that, self);
    zipWith.zipK = (a, b)=>{
        return (0, _functionJs.pipe)(a, _contextJs.merge(b));
    };
    return zipWith;
});
const zipWith = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, that, f)=>suspend(()=>{
        const zipWith = Object.create(proto);
        zipWith._op_layer = _layerJs.OP_ZIP_WITH;
        zipWith.first = self;
        zipWith.second = that;
        zipWith.zipK = f;
        return zipWith;
    }));
const unwrapEffect = (self)=>{
    const tag = _contextJs.GenericTag("effect/Layer/unwrapEffect/Layer.Layer<R1, E1, A>");
    return flatMap(fromEffect(tag, self), (context)=>_contextJs.get(context, tag));
};
const unwrapScoped = (self)=>{
    const tag = _contextJs.GenericTag("effect/Layer/unwrapScoped/Layer.Layer<R1, E1, A>");
    return flatMap(scoped(tag, self), (context)=>_contextJs.get(context, tag));
};
const annotateLogs = /*#__PURE__*/ (0, _functionJs.dual)((args)=>isLayer(args[0]), function() {
    const args = arguments;
    return fiberRefLocallyWith(args[0], _coreJs.currentLogAnnotations, typeof args[1] === "string" ? _hashMapJs.set(args[1], args[2]) : (annotations)=>Object.entries(args[1]).reduce((acc, [key, value])=>_hashMapJs.set(acc, key, value), annotations));
});
const annotateSpans = /*#__PURE__*/ (0, _functionJs.dual)((args)=>isLayer(args[0]), function() {
    const args = arguments;
    return fiberRefLocallyWith(args[0], _coreJs.currentTracerSpanAnnotations, typeof args[1] === "string" ? _hashMapJs.set(args[1], args[2]) : (annotations)=>Object.entries(args[1]).reduce((acc, [key, value])=>_hashMapJs.set(acc, key, value), annotations));
});
const withSpan = function() {
    const dataFirst = typeof arguments[0] !== "string";
    const name = dataFirst ? arguments[1] : arguments[0];
    const options = _tracerJs.addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
    if (dataFirst) {
        const self = arguments[0];
        return unwrapScoped(_coreJs.map(options?.onEnd ? _coreJs.tap(_fiberRuntimeJs.makeSpanScoped(name, options), (span)=>_fiberRuntimeJs.addFinalizer((exit)=>options.onEnd(span, exit))) : _fiberRuntimeJs.makeSpanScoped(name, options), (span)=>withParentSpan(self, span)));
    }
    return (self)=>unwrapScoped(_coreJs.map(options?.onEnd ? _coreJs.tap(_fiberRuntimeJs.makeSpanScoped(name, options), (span)=>_fiberRuntimeJs.addFinalizer((exit)=>options.onEnd(span, exit))) : _fiberRuntimeJs.makeSpanScoped(name, options), (span)=>withParentSpan(self, span)));
};
const withParentSpan = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, span)=>provide(self, succeedContext(_contextJs.make(_tracerJs.spanTag, span))));
// circular with Effect
const provideSomeLayer = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, layer)=>_fiberRuntimeJs.scopedWith((scope)=>_coreJs.flatMap(buildWithScope(layer, scope), (context)=>_coreJs.provideSomeContext(self, context))));
const provideSomeRuntime = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, rt)=>{
    const patchRefs = _fiberRefsPatchJs.diff(_runtimeJs.defaultRuntime.fiberRefs, rt.fiberRefs);
    const patchFlags = _runtimeFlagsJs.diff(_runtimeJs.defaultRuntime.runtimeFlags, rt.runtimeFlags);
    return _coreJs.uninterruptibleMask((restore)=>_coreJs.withFiberRuntime((fiber)=>{
            const oldContext = fiber.getFiberRef(_coreJs.currentContext);
            const oldRefs = fiber.getFiberRefs();
            const newRefs = _fiberRefsPatchJs.patch(fiber.id(), oldRefs)(patchRefs);
            const oldFlags = fiber.currentRuntimeFlags;
            const newFlags = _runtimeFlagsJs.patch(patchFlags)(oldFlags);
            const rollbackRefs = _fiberRefsPatchJs.diff(newRefs, oldRefs);
            const rollbackFlags = _runtimeFlagsJs.diff(newFlags, oldFlags);
            fiber.setFiberRefs(newRefs);
            fiber.currentRuntimeFlags = newFlags;
            return _fiberRuntimeJs.ensuring(_coreJs.provideSomeContext(restore(self), _contextJs.merge(oldContext, rt.context)), _coreJs.withFiberRuntime((fiber)=>{
                fiber.setFiberRefs(_fiberRefsPatchJs.patch(fiber.id(), fiber.getFiberRefs())(rollbackRefs));
                fiber.currentRuntimeFlags = _runtimeFlagsJs.patch(rollbackFlags)(fiber.currentRuntimeFlags);
                return _coreJs.void;
            }));
        }));
});
const effect_provide = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, source)=>{
    if (Array.isArray(source)) // @ts-expect-error
    return provideSomeLayer(self, mergeAll(...source));
    else if (isLayer(source)) return provideSomeLayer(self, source);
    else if (_contextJs.isContext(source)) return _coreJs.provideSomeContext(self, source);
    else if (_circularJs1.TypeId in source) return _coreJs.flatMap(source.runtimeEffect, (rt)=>provideSomeRuntime(self, rt));
    else return provideSomeRuntime(self, source);
});

},{"../Cause.js":"gQcQI","../Clock.js":"2Ndj4","../Context.js":"c2abN","../Duration.js":"czLLe","../FiberRefsPatch.js":"2QlCD","../Function.js":"21gOL","../HashMap.js":"aG8zS","../Pipeable.js":"b5RU2","../Predicate.js":"gW5pd","../ScheduleDecision.js":"23h1w","../ScheduleIntervals.js":"cBPei","../Scope.js":"kZhIw","./core-effect.js":"k8F3C","./core.js":"cr3YV","./effect/circular.js":"VvDt4","./fiberRuntime.js":"2spXK","./managedRuntime/circular.js":"hPPdd","./opCodes/effect.js":"9RoDl","./opCodes/layer.js":"5D59K","./ref.js":"90h4v","./runtime.js":"criei","./runtimeFlags.js":"9rFhC","./synchronizedRef.js":"cDm3c","./tracer.js":"aAsvB","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"23h1w":[function(require,module,exports,__globalThis) {
/**
 * @since 2.0.0
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "continue", ()=>/**
 * @since 2.0.0
 * @category constructors
 */ _continue);
parcelHelpers.export(exports, "continueWith", ()=>continueWith);
parcelHelpers.export(exports, "done", ()=>done);
parcelHelpers.export(exports, "isContinue", ()=>isContinue);
parcelHelpers.export(exports, "isDone", ()=>isDone);
var _decisionJs = require("./internal/schedule/decision.js");
const _continue = _decisionJs._continue;
const continueWith = _decisionJs.continueWith;
const done = _decisionJs.done;
const isContinue = _decisionJs.isContinue;
const isDone = _decisionJs.isDone;

},{"./internal/schedule/decision.js":"6UiJ3","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"6UiJ3":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "OP_CONTINUE", ()=>OP_CONTINUE);
parcelHelpers.export(exports, "OP_DONE", ()=>OP_DONE);
parcelHelpers.export(exports, "_continue", ()=>_continue);
parcelHelpers.export(exports, "continueWith", ()=>continueWith);
parcelHelpers.export(exports, "done", ()=>done);
parcelHelpers.export(exports, "isContinue", ()=>isContinue);
parcelHelpers.export(exports, "isDone", ()=>isDone);
var _chunkJs = require("../../Chunk.js");
var _scheduleIntervalsJs = require("../../ScheduleIntervals.js");
const OP_CONTINUE = "Continue";
const OP_DONE = "Done";
const _continue = (intervals)=>{
    return {
        _tag: OP_CONTINUE,
        intervals
    };
};
const continueWith = (interval)=>{
    return {
        _tag: OP_CONTINUE,
        intervals: _scheduleIntervalsJs.make(_chunkJs.of(interval))
    };
};
const done = {
    _tag: OP_DONE
};
const isContinue = (self)=>{
    return self._tag === OP_CONTINUE;
};
const isDone = (self)=>{
    return self._tag === OP_DONE;
};

},{"../../Chunk.js":"dL1OO","../../ScheduleIntervals.js":"cBPei","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"cBPei":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "IntervalsTypeId", ()=>IntervalsTypeId);
parcelHelpers.export(exports, "make", ()=>make);
parcelHelpers.export(exports, "empty", ()=>empty);
parcelHelpers.export(exports, "fromIterable", ()=>fromIterable);
parcelHelpers.export(exports, "union", ()=>union);
parcelHelpers.export(exports, "intersect", ()=>intersect);
parcelHelpers.export(exports, "start", ()=>start);
parcelHelpers.export(exports, "end", ()=>end);
parcelHelpers.export(exports, "lessThan", ()=>lessThan);
parcelHelpers.export(exports, "isNonEmpty", ()=>isNonEmpty);
parcelHelpers.export(exports, "max", ()=>max);
var _intervalsJs = require("./internal/schedule/intervals.js");
const IntervalsTypeId = _intervalsJs.IntervalsTypeId;
const make = _intervalsJs.make;
const empty = _intervalsJs.empty;
const fromIterable = _intervalsJs.fromIterable;
const union = _intervalsJs.union;
const intersect = _intervalsJs.intersect;
const start = _intervalsJs.start;
const end = _intervalsJs.end;
const lessThan = _intervalsJs.lessThan;
const isNonEmpty = _intervalsJs.isNonEmpty;
const max = _intervalsJs.max;

},{"./internal/schedule/intervals.js":"htmWw","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"htmWw":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "IntervalsTypeId", ()=>IntervalsTypeId);
parcelHelpers.export(exports, "make", ()=>make);
parcelHelpers.export(exports, "empty", ()=>empty);
parcelHelpers.export(exports, "fromIterable", ()=>fromIterable);
parcelHelpers.export(exports, "union", ()=>union);
parcelHelpers.export(exports, "intersect", ()=>intersect);
parcelHelpers.export(exports, "start", ()=>start);
parcelHelpers.export(exports, "end", ()=>end);
parcelHelpers.export(exports, "lessThan", ()=>lessThan);
parcelHelpers.export(exports, "isNonEmpty", ()=>isNonEmpty);
parcelHelpers.export(exports, "max", ()=>max);
var _chunkJs = require("../../Chunk.js");
var _functionJs = require("../../Function.js");
var _optionJs = require("../../Option.js");
var _scheduleIntervalJs = require("../../ScheduleInterval.js");
var _errorsJs = require("../errors.js");
/** @internal */ const IntervalsSymbolKey = "effect/ScheduleIntervals";
const IntervalsTypeId = /*#__PURE__*/ Symbol.for(IntervalsSymbolKey);
const make = (intervals)=>{
    return {
        [IntervalsTypeId]: IntervalsTypeId,
        intervals
    };
};
const empty = /*#__PURE__*/ make(/*#__PURE__*/ _chunkJs.empty());
const fromIterable = (intervals)=>Array.from(intervals).reduce((intervals, interval)=>(0, _functionJs.pipe)(intervals, union(make(_chunkJs.of(interval)))), empty);
const union = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>{
    if (!_chunkJs.isNonEmpty(that.intervals)) return self;
    if (!_chunkJs.isNonEmpty(self.intervals)) return that;
    if (_chunkJs.headNonEmpty(self.intervals).startMillis < _chunkJs.headNonEmpty(that.intervals).startMillis) return unionLoop(_chunkJs.tailNonEmpty(self.intervals), that.intervals, _chunkJs.headNonEmpty(self.intervals), _chunkJs.empty());
    return unionLoop(self.intervals, _chunkJs.tailNonEmpty(that.intervals), _chunkJs.headNonEmpty(that.intervals), _chunkJs.empty());
});
/** @internal */ const unionLoop = (_self, _that, _interval, _acc)=>{
    let self = _self;
    let that = _that;
    let interval = _interval;
    let acc = _acc;
    while(_chunkJs.isNonEmpty(self) || _chunkJs.isNonEmpty(that)){
        if (!_chunkJs.isNonEmpty(self) && _chunkJs.isNonEmpty(that)) {
            if (interval.endMillis < _chunkJs.headNonEmpty(that).startMillis) {
                acc = (0, _functionJs.pipe)(acc, _chunkJs.prepend(interval));
                interval = _chunkJs.headNonEmpty(that);
                that = _chunkJs.tailNonEmpty(that);
                self = _chunkJs.empty();
            } else {
                interval = _scheduleIntervalJs.make(interval.startMillis, _chunkJs.headNonEmpty(that).endMillis);
                that = _chunkJs.tailNonEmpty(that);
                self = _chunkJs.empty();
            }
        } else if (_chunkJs.isNonEmpty(self) && _chunkJs.isEmpty(that)) {
            if (interval.endMillis < _chunkJs.headNonEmpty(self).startMillis) {
                acc = (0, _functionJs.pipe)(acc, _chunkJs.prepend(interval));
                interval = _chunkJs.headNonEmpty(self);
                that = _chunkJs.empty();
                self = _chunkJs.tailNonEmpty(self);
            } else {
                interval = _scheduleIntervalJs.make(interval.startMillis, _chunkJs.headNonEmpty(self).endMillis);
                that = _chunkJs.empty();
                self = _chunkJs.tailNonEmpty(self);
            }
        } else if (_chunkJs.isNonEmpty(self) && _chunkJs.isNonEmpty(that)) {
            if (_chunkJs.headNonEmpty(self).startMillis < _chunkJs.headNonEmpty(that).startMillis) {
                if (interval.endMillis < _chunkJs.headNonEmpty(self).startMillis) {
                    acc = (0, _functionJs.pipe)(acc, _chunkJs.prepend(interval));
                    interval = _chunkJs.headNonEmpty(self);
                    self = _chunkJs.tailNonEmpty(self);
                } else {
                    interval = _scheduleIntervalJs.make(interval.startMillis, _chunkJs.headNonEmpty(self).endMillis);
                    self = _chunkJs.tailNonEmpty(self);
                }
            } else if (interval.endMillis < _chunkJs.headNonEmpty(that).startMillis) {
                acc = (0, _functionJs.pipe)(acc, _chunkJs.prepend(interval));
                interval = _chunkJs.headNonEmpty(that);
                that = _chunkJs.tailNonEmpty(that);
            } else {
                interval = _scheduleIntervalJs.make(interval.startMillis, _chunkJs.headNonEmpty(that).endMillis);
                that = _chunkJs.tailNonEmpty(that);
            }
        } else throw new Error((0, _errorsJs.getBugErrorMessage)("Intervals.unionLoop"));
    }
    return make((0, _functionJs.pipe)(acc, _chunkJs.prepend(interval), _chunkJs.reverse));
};
const intersect = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>intersectLoop(self.intervals, that.intervals, _chunkJs.empty()));
/** @internal */ const intersectLoop = (_left, _right, _acc)=>{
    let left = _left;
    let right = _right;
    let acc = _acc;
    while(_chunkJs.isNonEmpty(left) && _chunkJs.isNonEmpty(right)){
        const interval = (0, _functionJs.pipe)(_chunkJs.headNonEmpty(left), _scheduleIntervalJs.intersect(_chunkJs.headNonEmpty(right)));
        const intervals = _scheduleIntervalJs.isEmpty(interval) ? acc : (0, _functionJs.pipe)(acc, _chunkJs.prepend(interval));
        if ((0, _functionJs.pipe)(_chunkJs.headNonEmpty(left), _scheduleIntervalJs.lessThan(_chunkJs.headNonEmpty(right)))) left = _chunkJs.tailNonEmpty(left);
        else right = _chunkJs.tailNonEmpty(right);
        acc = intervals;
    }
    return make(_chunkJs.reverse(acc));
};
const start = (self)=>{
    return (0, _functionJs.pipe)(self.intervals, _chunkJs.head, _optionJs.getOrElse(()=>_scheduleIntervalJs.empty)).startMillis;
};
const end = (self)=>{
    return (0, _functionJs.pipe)(self.intervals, _chunkJs.head, _optionJs.getOrElse(()=>_scheduleIntervalJs.empty)).endMillis;
};
const lessThan = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>start(self) < start(that));
const isNonEmpty = (self)=>{
    return _chunkJs.isNonEmpty(self.intervals);
};
const max = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>lessThan(self, that) ? that : self);

},{"../../Chunk.js":"dL1OO","../../Function.js":"21gOL","../../Option.js":"6sHA7","../../ScheduleInterval.js":"MON0z","../errors.js":"2Q5er","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"MON0z":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "IntervalTypeId", ()=>IntervalTypeId);
parcelHelpers.export(exports, "make", ()=>make);
parcelHelpers.export(exports, "empty", ()=>empty);
parcelHelpers.export(exports, "lessThan", ()=>lessThan);
parcelHelpers.export(exports, "min", ()=>min);
parcelHelpers.export(exports, "max", ()=>max);
parcelHelpers.export(exports, "isEmpty", ()=>isEmpty);
parcelHelpers.export(exports, "isNonEmpty", ()=>isNonEmpty);
parcelHelpers.export(exports, "intersect", ()=>intersect);
parcelHelpers.export(exports, "size", ()=>size);
parcelHelpers.export(exports, "union", ()=>union);
parcelHelpers.export(exports, "after", ()=>after);
parcelHelpers.export(exports, "before", ()=>before);
var _intervalJs = require("./internal/schedule/interval.js");
const IntervalTypeId = _intervalJs.IntervalTypeId;
const make = _intervalJs.make;
const empty = _intervalJs.empty;
const lessThan = _intervalJs.lessThan;
const min = _intervalJs.min;
const max = _intervalJs.max;
const isEmpty = _intervalJs.isEmpty;
const isNonEmpty = _intervalJs.isNonEmpty;
const intersect = _intervalJs.intersect;
const size = _intervalJs.size;
const union = _intervalJs.union;
const after = _intervalJs.after;
const before = _intervalJs.before;

},{"./internal/schedule/interval.js":"59p75","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"59p75":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "IntervalTypeId", ()=>IntervalTypeId);
parcelHelpers.export(exports, "empty", ()=>empty);
parcelHelpers.export(exports, "make", ()=>make);
parcelHelpers.export(exports, "lessThan", ()=>lessThan);
parcelHelpers.export(exports, "min", ()=>min);
parcelHelpers.export(exports, "max", ()=>max);
parcelHelpers.export(exports, "isEmpty", ()=>isEmpty);
parcelHelpers.export(exports, "isNonEmpty", ()=>isNonEmpty);
parcelHelpers.export(exports, "intersect", ()=>intersect);
parcelHelpers.export(exports, "size", ()=>size);
parcelHelpers.export(exports, "union", ()=>union);
parcelHelpers.export(exports, "after", ()=>after);
parcelHelpers.export(exports, "before", ()=>before);
var _durationJs = require("../../Duration.js");
var _functionJs = require("../../Function.js");
var _optionJs = require("../../Option.js");
/** @internal */ const IntervalSymbolKey = "effect/ScheduleInterval";
const IntervalTypeId = /*#__PURE__*/ Symbol.for(IntervalSymbolKey);
const empty = {
    [IntervalTypeId]: IntervalTypeId,
    startMillis: 0,
    endMillis: 0
};
const make = (startMillis, endMillis)=>{
    if (startMillis > endMillis) return empty;
    return {
        [IntervalTypeId]: IntervalTypeId,
        startMillis,
        endMillis
    };
};
const lessThan = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>min(self, that) === self);
const min = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>{
    if (self.endMillis <= that.startMillis) return self;
    if (that.endMillis <= self.startMillis) return that;
    if (self.startMillis < that.startMillis) return self;
    if (that.startMillis < self.startMillis) return that;
    if (self.endMillis <= that.endMillis) return self;
    return that;
});
const max = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>min(self, that) === self ? that : self);
const isEmpty = (self)=>{
    return self.startMillis >= self.endMillis;
};
const isNonEmpty = (self)=>{
    return !isEmpty(self);
};
const intersect = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>{
    const start = Math.max(self.startMillis, that.startMillis);
    const end = Math.min(self.endMillis, that.endMillis);
    return make(start, end);
});
const size = (self)=>{
    return _durationJs.millis(self.endMillis - self.startMillis);
};
const union = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>{
    const start = Math.max(self.startMillis, that.startMillis);
    const end = Math.min(self.endMillis, that.endMillis);
    return start < end ? _optionJs.none() : _optionJs.some(make(start, end));
});
const after = (startMilliseconds)=>{
    return make(startMilliseconds, Number.POSITIVE_INFINITY);
};
const before = (endMilliseconds)=>{
    return make(Number.NEGATIVE_INFINITY, endMilliseconds);
};

},{"../../Duration.js":"czLLe","../../Function.js":"21gOL","../../Option.js":"6sHA7","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"kZhIw":[function(require,module,exports,__globalThis) {
/**
 * @since 2.0.0
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ScopeTypeId", ()=>ScopeTypeId);
parcelHelpers.export(exports, "CloseableScopeTypeId", ()=>CloseableScopeTypeId);
parcelHelpers.export(exports, "Scope", ()=>Scope);
parcelHelpers.export(exports, "addFinalizer", ()=>addFinalizer);
parcelHelpers.export(exports, "addFinalizerExit", ()=>addFinalizerExit);
parcelHelpers.export(exports, "close", ()=>close);
parcelHelpers.export(exports, "extend", ()=>extend);
parcelHelpers.export(exports, "fork", ()=>fork);
parcelHelpers.export(exports, "use", ()=>use);
parcelHelpers.export(exports, "make", ()=>make);
var _coreJs = require("./internal/core.js");
var _fiberRuntimeJs = require("./internal/fiberRuntime.js");
const ScopeTypeId = _coreJs.ScopeTypeId;
const CloseableScopeTypeId = _coreJs.CloseableScopeTypeId;
const Scope = _fiberRuntimeJs.scopeTag;
const addFinalizer = _coreJs.scopeAddFinalizer;
const addFinalizerExit = _coreJs.scopeAddFinalizerExit;
const close = _coreJs.scopeClose;
const extend = _fiberRuntimeJs.scopeExtend;
const fork = _coreJs.scopeFork;
const use = _fiberRuntimeJs.scopeUse;
const make = _fiberRuntimeJs.scopeMake;

},{"./internal/core.js":"cr3YV","./internal/fiberRuntime.js":"2spXK","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"VvDt4":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "unsafeMakeSemaphore", ()=>unsafeMakeSemaphore);
parcelHelpers.export(exports, "makeSemaphore", ()=>makeSemaphore);
parcelHelpers.export(exports, "unsafeMakeLatch", ()=>unsafeMakeLatch);
parcelHelpers.export(exports, "makeLatch", ()=>makeLatch);
parcelHelpers.export(exports, "awaitAllChildren", ()=>awaitAllChildren);
parcelHelpers.export(exports, "cached", ()=>cached);
parcelHelpers.export(exports, "cachedInvalidateWithTTL", ()=>cachedInvalidateWithTTL);
parcelHelpers.export(exports, "ensuringChild", ()=>ensuringChild);
parcelHelpers.export(exports, "ensuringChildren", ()=>ensuringChildren);
parcelHelpers.export(exports, "forkAll", ()=>forkAll);
parcelHelpers.export(exports, "forkIn", ()=>forkIn);
parcelHelpers.export(exports, "forkScoped", ()=>forkScoped);
parcelHelpers.export(exports, "fromFiber", ()=>fromFiber);
parcelHelpers.export(exports, "fromFiberEffect", ()=>fromFiberEffect);
parcelHelpers.export(exports, "cachedFunction", ()=>cachedFunction);
parcelHelpers.export(exports, "raceFirst", ()=>raceFirst);
parcelHelpers.export(exports, "scheduleForked", ()=>scheduleForked);
parcelHelpers.export(exports, "supervised", ()=>supervised);
parcelHelpers.export(exports, "timeout", ()=>timeout);
parcelHelpers.export(exports, "timeoutFail", ()=>timeoutFail);
parcelHelpers.export(exports, "timeoutFailCause", ()=>timeoutFailCause);
parcelHelpers.export(exports, "timeoutOption", ()=>timeoutOption);
parcelHelpers.export(exports, "timeoutTo", ()=>timeoutTo);
parcelHelpers.export(exports, "SynchronizedTypeId", ()=>SynchronizedTypeId);
parcelHelpers.export(exports, "synchronizedVariance", ()=>synchronizedVariance);
parcelHelpers.export(exports, "makeSynchronized", ()=>makeSynchronized);
parcelHelpers.export(exports, "unsafeMakeSynchronized", ()=>unsafeMakeSynchronized);
parcelHelpers.export(exports, "updateSomeAndGetEffectSynchronized", ()=>updateSomeAndGetEffectSynchronized);
parcelHelpers.export(exports, "zipFiber", ()=>zipFiber);
parcelHelpers.export(exports, "zipLeftFiber", ()=>zipLeftFiber);
parcelHelpers.export(exports, "zipRightFiber", ()=>zipRightFiber);
parcelHelpers.export(exports, "zipWithFiber", ()=>zipWithFiber);
parcelHelpers.export(exports, "bindAll", ()=>bindAll);
var _durationJs = require("../../Duration.js");
var _effectableJs = require("../../Effectable.js");
var _equalJs = require("../../Equal.js");
var _exitJs = require("../../Exit.js");
var _fiberIdJs = require("../../FiberId.js");
var _functionJs = require("../../Function.js");
var _hashJs = require("../../Hash.js");
var _mutableHashMapJs = require("../../MutableHashMap.js");
var _optionJs = require("../../Option.js");
var _pipeableJs = require("../../Pipeable.js");
var _predicateJs = require("../../Predicate.js");
var _readableJs = require("../../Readable.js");
var _schedulerJs = require("../../Scheduler.js");
var _causeJs = require("../cause.js");
var _coreEffectJs = require("../core-effect.js");
var _coreJs = require("../core.js");
var _fiberJs = require("../fiber.js");
var _fiberRuntimeJs = require("../fiberRuntime.js");
var _fiberScopeJs = require("../fiberScope.js");
var _refJs = require("../ref.js");
var _scheduleJs = require("../schedule.js");
var _supervisorJs = require("../supervisor.js");
/** @internal */ class Semaphore {
    permits;
    waiters = /*#__PURE__*/ new Set();
    taken = 0;
    constructor(permits){
        this.permits = permits;
    }
    get free() {
        return this.permits - this.taken;
    }
    take = (n)=>_coreJs.asyncInterrupt((resume)=>{
            if (this.free < n) {
                const observer = ()=>{
                    if (this.free < n) return;
                    this.waiters.delete(observer);
                    this.taken += n;
                    resume(_coreJs.succeed(n));
                };
                this.waiters.add(observer);
                return _coreJs.sync(()=>{
                    this.waiters.delete(observer);
                });
            }
            this.taken += n;
            return resume(_coreJs.succeed(n));
        });
    updateTaken = (f)=>_coreJs.withFiberRuntime((fiber)=>{
            this.taken = f(this.taken);
            if (this.waiters.size > 0) fiber.getFiberRef((0, _schedulerJs.currentScheduler)).scheduleTask(()=>{
                const iter = this.waiters.values();
                let item = iter.next();
                while(item.done === false && this.free > 0){
                    item.value();
                    item = iter.next();
                }
            }, fiber.getFiberRef(_coreJs.currentSchedulingPriority));
            return _coreJs.succeed(this.free);
        });
    release = (n)=>this.updateTaken((taken)=>taken - n);
    releaseAll = /*#__PURE__*/ this.updateTaken((_)=>0);
    withPermits = (n)=>(self)=>_coreJs.uninterruptibleMask((restore)=>_coreJs.flatMap(restore(this.take(n)), (permits)=>_fiberRuntimeJs.ensuring(restore(self), this.release(permits))));
    withPermitsIfAvailable = (n)=>(self)=>_coreJs.uninterruptibleMask((restore)=>_coreJs.suspend(()=>{
                    if (this.free < n) return _coreEffectJs.succeedNone;
                    this.taken += n;
                    return _fiberRuntimeJs.ensuring(restore(_coreEffectJs.asSome(self)), this.release(n));
                }));
}
const unsafeMakeSemaphore = (permits)=>new Semaphore(permits);
const makeSemaphore = (permits)=>_coreJs.sync(()=>unsafeMakeSemaphore(permits));
class Latch extends _effectableJs.Class {
    isOpen;
    waiters = [];
    scheduled = false;
    constructor(isOpen){
        super();
        this.isOpen = isOpen;
    }
    commit() {
        return this.await;
    }
    unsafeSchedule(fiber) {
        if (this.scheduled || this.waiters.length === 0) return _coreJs.void;
        this.scheduled = true;
        fiber.currentScheduler.scheduleTask(this.flushWaiters, fiber.getFiberRef(_coreJs.currentSchedulingPriority));
        return _coreJs.void;
    }
    flushWaiters = ()=>{
        this.scheduled = false;
        const waiters = this.waiters;
        this.waiters = [];
        for(let i = 0; i < waiters.length; i++)waiters[i](_coreJs.exitVoid);
    };
    open = /*#__PURE__*/ _coreJs.withFiberRuntime((fiber)=>{
        if (this.isOpen) return _coreJs.void;
        this.isOpen = true;
        return this.unsafeSchedule(fiber);
    });
    unsafeOpen() {
        if (this.isOpen) return;
        this.isOpen = true;
        this.flushWaiters();
    }
    release = /*#__PURE__*/ _coreJs.withFiberRuntime((fiber)=>{
        if (this.isOpen) return _coreJs.void;
        return this.unsafeSchedule(fiber);
    });
    await = /*#__PURE__*/ _coreJs.asyncInterrupt((resume)=>{
        if (this.isOpen) return resume(_coreJs.void);
        this.waiters.push(resume);
        return _coreJs.sync(()=>{
            const index = this.waiters.indexOf(resume);
            if (index !== -1) this.waiters.splice(index, 1);
        });
    });
    unsafeClose() {
        this.isOpen = false;
    }
    close = /*#__PURE__*/ _coreJs.sync(()=>{
        this.isOpen = false;
    });
    whenOpen = (self)=>{
        return _coreJs.zipRight(this.await, self);
    };
}
const unsafeMakeLatch = (open)=>new Latch(open ?? false);
const makeLatch = (open)=>_coreJs.sync(()=>unsafeMakeLatch(open));
const awaitAllChildren = (self)=>ensuringChildren(self, _fiberRuntimeJs.fiberAwaitAll);
const cached = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, timeToLive)=>_coreJs.map(cachedInvalidateWithTTL(self, timeToLive), (tuple)=>tuple[0]));
const cachedInvalidateWithTTL = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, timeToLive)=>{
    const duration = _durationJs.decode(timeToLive);
    return _coreJs.flatMap(_coreJs.context(), (env)=>_coreJs.map(makeSynchronized(_optionJs.none()), (cache)=>[
                _coreJs.provideContext(getCachedValue(self, duration, cache), env),
                invalidateCache(cache)
            ]));
});
/** @internal */ const computeCachedValue = (self, timeToLive, start)=>{
    const timeToLiveMillis = _durationJs.toMillis(_durationJs.decode(timeToLive));
    return (0, _functionJs.pipe)(_coreJs.deferredMake(), _coreJs.tap((deferred)=>_coreJs.intoDeferred(self, deferred)), _coreJs.map((deferred)=>_optionJs.some([
            start + timeToLiveMillis,
            deferred
        ])));
};
/** @internal */ const getCachedValue = (self, timeToLive, cache)=>_coreJs.uninterruptibleMask((restore)=>(0, _functionJs.pipe)(_coreEffectJs.clockWith((clock)=>clock.currentTimeMillis), _coreJs.flatMap((time)=>updateSomeAndGetEffectSynchronized(cache, (option)=>{
                switch(option._tag){
                    case "None":
                        return _optionJs.some(computeCachedValue(self, timeToLive, time));
                    case "Some":
                        {
                            const [end] = option.value;
                            return end - time <= 0 ? _optionJs.some(computeCachedValue(self, timeToLive, time)) : _optionJs.none();
                        }
                }
            })), _coreJs.flatMap((option)=>_optionJs.isNone(option) ? _coreJs.dieMessage("BUG: Effect.cachedInvalidate - please report an issue at https://github.com/Effect-TS/effect/issues") : restore(_coreJs.deferredAwait(option.value[1])))));
/** @internal */ const invalidateCache = (cache)=>_refJs.set(cache, _optionJs.none());
const ensuringChild = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>ensuringChildren(self, (children)=>f(_fiberRuntimeJs.fiberAll(children))));
const ensuringChildren = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, children)=>_coreJs.flatMap(_supervisorJs.track, (supervisor)=>(0, _functionJs.pipe)(supervised(self, supervisor), _fiberRuntimeJs.ensuring(_coreJs.flatMap(supervisor.value, children)))));
const forkAll = /*#__PURE__*/ (0, _functionJs.dual)((args)=>_predicateJs.isIterable(args[0]), (effects, options)=>options?.discard ? _coreJs.forEachSequentialDiscard(effects, _fiberRuntimeJs.fork) : _coreJs.map(_coreJs.forEachSequential(effects, _fiberRuntimeJs.fork), _fiberRuntimeJs.fiberAll));
const forkIn = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, scope)=>_coreJs.withFiberRuntime((parent, parentStatus)=>{
        const scopeImpl = scope;
        const fiber = _fiberRuntimeJs.unsafeFork(self, parent, parentStatus.runtimeFlags, (0, _fiberScopeJs.globalScope));
        if (scopeImpl.state._tag === "Open") {
            const finalizer = ()=>_coreJs.fiberIdWith((fiberId)=>_equalJs.equals(fiberId, fiber.id()) ? _coreJs.void : _coreJs.asVoid(_coreJs.interruptFiber(fiber)));
            const key = {};
            scopeImpl.state.finalizers.set(key, finalizer);
            fiber.addObserver(()=>{
                if (scopeImpl.state._tag === "Closed") return;
                scopeImpl.state.finalizers.delete(key);
            });
        } else fiber.unsafeInterruptAsFork(parent.id());
        return _coreJs.succeed(fiber);
    }));
const forkScoped = (self)=>_fiberRuntimeJs.scopeWith((scope)=>forkIn(self, scope));
const fromFiber = (fiber)=>_fiberJs.join(fiber);
const fromFiberEffect = (fiber)=>_coreJs.suspend(()=>_coreJs.flatMap(fiber, _fiberJs.join));
const memoKeySymbol = /*#__PURE__*/ Symbol.for("effect/Effect/memoizeFunction.key");
class Key {
    a;
    eq;
    [memoKeySymbol] = memoKeySymbol;
    constructor(a, eq){
        this.a = a;
        this.eq = eq;
    }
    [_equalJs.symbol](that) {
        if (_predicateJs.hasProperty(that, memoKeySymbol)) {
            if (this.eq) return this.eq(this.a, that.a);
            else return _equalJs.equals(this.a, that.a);
        }
        return false;
    }
    [_hashJs.symbol]() {
        return this.eq ? 0 : _hashJs.cached(this, _hashJs.hash(this.a));
    }
}
const cachedFunction = (f, eq)=>{
    return (0, _functionJs.pipe)(_coreJs.sync(()=>_mutableHashMapJs.empty()), _coreJs.flatMap(makeSynchronized), _coreJs.map((ref)=>(a)=>(0, _functionJs.pipe)(ref.modifyEffect((map)=>{
                const result = (0, _functionJs.pipe)(map, _mutableHashMapJs.get(new Key(a, eq)));
                if (_optionJs.isNone(result)) return (0, _functionJs.pipe)(_coreJs.deferredMake(), _coreJs.tap((deferred)=>(0, _functionJs.pipe)(_coreEffectJs.diffFiberRefs(f(a)), _coreJs.intoDeferred(deferred), _fiberRuntimeJs.fork)), _coreJs.map((deferred)=>[
                        deferred,
                        (0, _functionJs.pipe)(map, _mutableHashMapJs.set(new Key(a, eq), deferred))
                    ]));
                return _coreJs.succeed([
                    result.value,
                    map
                ]);
            }), _coreJs.flatMap(_coreJs.deferredAwait), _coreJs.flatMap(([patch, b])=>(0, _functionJs.pipe)(_coreEffectJs.patchFiberRefs(patch), _coreJs.as(b))))));
};
const raceFirst = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>(0, _functionJs.pipe)(_coreJs.exit(self), _fiberRuntimeJs.race(_coreJs.exit(that)), (effect)=>_coreJs.flatten(effect)));
const scheduleForked = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, schedule)=>(0, _functionJs.pipe)(self, _scheduleJs.schedule_Effect(schedule), forkScoped));
const supervised = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, supervisor)=>{
    const supervise = _coreJs.fiberRefLocallyWith(_fiberRuntimeJs.currentSupervisor, (s)=>s.zip(supervisor));
    return supervise(self);
});
const timeout = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, duration)=>timeoutFail(self, {
        onTimeout: ()=>_coreJs.timeoutExceptionFromDuration(duration),
        duration
    }));
const timeoutFail = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, { duration, onTimeout })=>_coreJs.flatten(timeoutTo(self, {
        onTimeout: ()=>_coreJs.failSync(onTimeout),
        onSuccess: _coreJs.succeed,
        duration
    })));
const timeoutFailCause = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, { duration, onTimeout })=>_coreJs.flatten(timeoutTo(self, {
        onTimeout: ()=>_coreJs.failCauseSync(onTimeout),
        onSuccess: _coreJs.succeed,
        duration
    })));
const timeoutOption = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, duration)=>timeoutTo(self, {
        duration,
        onSuccess: _optionJs.some,
        onTimeout: _optionJs.none
    }));
const timeoutTo = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, { duration, onSuccess, onTimeout })=>_coreJs.fiberIdWith((parentFiberId)=>_coreJs.uninterruptibleMask((restore)=>_fiberRuntimeJs.raceFibersWith(restore(self), _coreJs.interruptible(_coreEffectJs.sleep(duration)), {
                onSelfWin: (winner, loser)=>_coreJs.flatMap(winner.await, (exit)=>{
                        if (exit._tag === "Success") return _coreJs.flatMap(winner.inheritAll, ()=>_coreJs.as(_coreJs.interruptAsFiber(loser, parentFiberId), onSuccess(exit.value)));
                        else return _coreJs.flatMap(_coreJs.interruptAsFiber(loser, parentFiberId), ()=>_coreJs.exitFailCause(exit.cause));
                    }),
                onOtherWin: (winner, loser)=>_coreJs.flatMap(winner.await, (exit)=>{
                        if (exit._tag === "Success") return _coreJs.flatMap(winner.inheritAll, ()=>_coreJs.as(_coreJs.interruptAsFiber(loser, parentFiberId), onTimeout()));
                        else return _coreJs.flatMap(_coreJs.interruptAsFiber(loser, parentFiberId), ()=>_coreJs.exitFailCause(exit.cause));
                    }),
                otherScope: (0, _fiberScopeJs.globalScope)
            }))));
// circular with Synchronized
/** @internal */ const SynchronizedSymbolKey = "effect/Ref/SynchronizedRef";
const SynchronizedTypeId = /*#__PURE__*/ Symbol.for(SynchronizedSymbolKey);
const synchronizedVariance = {
    /* c8 ignore next */ _A: (_)=>_
};
/** @internal */ class SynchronizedImpl extends _effectableJs.Class {
    ref;
    withLock;
    [SynchronizedTypeId] = synchronizedVariance;
    [_refJs.RefTypeId] = _refJs.refVariance;
    [_readableJs.TypeId] = _readableJs.TypeId;
    constructor(ref, withLock){
        super();
        this.ref = ref;
        this.withLock = withLock;
        this.get = _refJs.get(this.ref);
    }
    get;
    commit() {
        return this.get;
    }
    modify(f) {
        return this.modifyEffect((a)=>_coreJs.succeed(f(a)));
    }
    modifyEffect(f) {
        return this.withLock((0, _functionJs.pipe)(_coreJs.flatMap(_refJs.get(this.ref), f), _coreJs.flatMap(([b, a])=>_coreJs.as(_refJs.set(this.ref, a), b))));
    }
}
const makeSynchronized = (value)=>_coreJs.sync(()=>unsafeMakeSynchronized(value));
const unsafeMakeSynchronized = (value)=>{
    const ref = _refJs.unsafeMake(value);
    const sem = unsafeMakeSemaphore(1);
    return new SynchronizedImpl(ref, sem.withPermits(1));
};
const updateSomeAndGetEffectSynchronized = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, pf)=>self.modifyEffect((value)=>{
        const result = pf(value);
        switch(result._tag){
            case "None":
                return _coreJs.succeed([
                    value,
                    value
                ]);
            case "Some":
                return _coreJs.map(result.value, (a)=>[
                        a,
                        a
                    ]);
        }
    }));
const zipFiber = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>zipWithFiber(self, that, (a, b)=>[
            a,
            b
        ]));
const zipLeftFiber = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>zipWithFiber(self, that, (a, _)=>a));
const zipRightFiber = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>zipWithFiber(self, that, (_, b)=>b));
const zipWithFiber = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, that, f)=>({
        ..._effectableJs.CommitPrototype,
        commit () {
            return _fiberJs.join(this);
        },
        [_fiberJs.FiberTypeId]: _fiberJs.fiberVariance,
        id: ()=>(0, _functionJs.pipe)(self.id(), _fiberIdJs.getOrElse(that.id())),
        await: (0, _functionJs.pipe)(self.await, _coreJs.flatten, _fiberRuntimeJs.zipWithOptions(_coreJs.flatten(that.await), f, {
            concurrent: true
        }), _coreJs.exit),
        children: self.children,
        inheritAll: _coreJs.zipRight(that.inheritAll, self.inheritAll),
        poll: _coreJs.zipWith(self.poll, that.poll, (optionA, optionB)=>(0, _functionJs.pipe)(optionA, _optionJs.flatMap((exitA)=>(0, _functionJs.pipe)(optionB, _optionJs.map((exitB)=>_exitJs.zipWith(exitA, exitB, {
                        onSuccess: f,
                        onFailure: _causeJs.parallel
                    })))))),
        interruptAsFork: (id)=>_coreJs.zipRight(self.interruptAsFork(id), that.interruptAsFork(id)),
        pipe () {
            return (0, _pipeableJs.pipeArguments)(this, arguments);
        }
    }));
const bindAll = /*#__PURE__*/ (0, _functionJs.dual)((args)=>_coreJs.isEffect(args[0]), (self, f, options)=>_coreJs.flatMap(self, (a)=>_fiberRuntimeJs.all(f(a), options).pipe(_coreJs.map((record)=>Object.assign({}, a, record)))));

},{"../../Duration.js":"czLLe","../../Effectable.js":"kxbGz","../../Equal.js":"gA0qD","../../Exit.js":"eUJDu","../../FiberId.js":"4K4GG","../../Function.js":"21gOL","../../Hash.js":"gFMwE","../../MutableHashMap.js":"1goeS","../../Option.js":"6sHA7","../../Pipeable.js":"b5RU2","../../Predicate.js":"gW5pd","../../Readable.js":"5KKZ9","../../Scheduler.js":"hR5Dj","../cause.js":"l3ev0","../core-effect.js":"k8F3C","../core.js":"cr3YV","../fiber.js":"65P25","../fiberRuntime.js":"2spXK","../fiberScope.js":"f4YSV","../ref.js":"90h4v","../schedule.js":"laYcX","../supervisor.js":"bryLt","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"laYcX":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ScheduleTypeId", ()=>ScheduleTypeId);
parcelHelpers.export(exports, "isSchedule", ()=>isSchedule);
parcelHelpers.export(exports, "ScheduleDriverTypeId", ()=>ScheduleDriverTypeId);
parcelHelpers.export(exports, "makeWithState", ()=>makeWithState);
parcelHelpers.export(exports, "addDelay", ()=>addDelay);
parcelHelpers.export(exports, "addDelayEffect", ()=>addDelayEffect);
parcelHelpers.export(exports, "andThen", ()=>andThen);
parcelHelpers.export(exports, "andThenEither", ()=>andThenEither);
parcelHelpers.export(exports, "as", ()=>as);
parcelHelpers.export(exports, "asVoid", ()=>asVoid);
parcelHelpers.export(exports, "bothInOut", ()=>bothInOut);
parcelHelpers.export(exports, "check", ()=>check);
parcelHelpers.export(exports, "checkEffect", ()=>checkEffect);
parcelHelpers.export(exports, "collectAllInputs", ()=>collectAllInputs);
parcelHelpers.export(exports, "collectAllOutputs", ()=>collectAllOutputs);
parcelHelpers.export(exports, "collectUntil", ()=>collectUntil);
parcelHelpers.export(exports, "collectUntilEffect", ()=>collectUntilEffect);
parcelHelpers.export(exports, "collectWhile", ()=>collectWhile);
parcelHelpers.export(exports, "collectWhileEffect", ()=>collectWhileEffect);
parcelHelpers.export(exports, "compose", ()=>compose);
parcelHelpers.export(exports, "mapInput", ()=>mapInput);
parcelHelpers.export(exports, "mapInputContext", ()=>mapInputContext);
parcelHelpers.export(exports, "mapInputEffect", ()=>mapInputEffect);
parcelHelpers.export(exports, "cron", ()=>cron);
parcelHelpers.export(exports, "dayOfMonth", ()=>dayOfMonth);
parcelHelpers.export(exports, "dayOfWeek", ()=>dayOfWeek);
parcelHelpers.export(exports, "delayed", ()=>delayed);
parcelHelpers.export(exports, "delayedEffect", ()=>delayedEffect);
parcelHelpers.export(exports, "delayedSchedule", ()=>delayedSchedule);
parcelHelpers.export(exports, "delays", ()=>delays);
parcelHelpers.export(exports, "mapBoth", ()=>mapBoth);
parcelHelpers.export(exports, "mapBothEffect", ()=>mapBothEffect);
parcelHelpers.export(exports, "driver", ()=>driver);
parcelHelpers.export(exports, "duration", ()=>duration);
parcelHelpers.export(exports, "either", ()=>either);
parcelHelpers.export(exports, "eitherWith", ()=>eitherWith);
parcelHelpers.export(exports, "ensuring", ()=>ensuring);
parcelHelpers.export(exports, "exponential", ()=>exponential);
parcelHelpers.export(exports, "fibonacci", ()=>fibonacci);
parcelHelpers.export(exports, "fixed", ()=>fixed);
parcelHelpers.export(exports, "fromDelay", ()=>fromDelay);
parcelHelpers.export(exports, "fromDelays", ()=>fromDelays);
parcelHelpers.export(exports, "fromFunction", ()=>fromFunction);
parcelHelpers.export(exports, "hourOfDay", ()=>hourOfDay);
parcelHelpers.export(exports, "identity", ()=>identity);
parcelHelpers.export(exports, "intersect", ()=>intersect);
parcelHelpers.export(exports, "intersectWith", ()=>intersectWith);
parcelHelpers.export(exports, "jittered", ()=>jittered);
parcelHelpers.export(exports, "jitteredWith", ()=>jitteredWith);
parcelHelpers.export(exports, "linear", ()=>linear);
parcelHelpers.export(exports, "map", ()=>map);
parcelHelpers.export(exports, "mapEffect", ()=>mapEffect);
parcelHelpers.export(exports, "minuteOfHour", ()=>minuteOfHour);
parcelHelpers.export(exports, "modifyDelay", ()=>modifyDelay);
parcelHelpers.export(exports, "modifyDelayEffect", ()=>modifyDelayEffect);
parcelHelpers.export(exports, "onDecision", ()=>onDecision);
parcelHelpers.export(exports, "passthrough", ()=>passthrough);
parcelHelpers.export(exports, "provideContext", ()=>provideContext);
parcelHelpers.export(exports, "provideService", ()=>provideService);
parcelHelpers.export(exports, "recurUntil", ()=>recurUntil);
parcelHelpers.export(exports, "recurUntilEffect", ()=>recurUntilEffect);
parcelHelpers.export(exports, "recurUntilOption", ()=>recurUntilOption);
parcelHelpers.export(exports, "recurUpTo", ()=>recurUpTo);
parcelHelpers.export(exports, "recurWhile", ()=>recurWhile);
parcelHelpers.export(exports, "recurWhileEffect", ()=>recurWhileEffect);
parcelHelpers.export(exports, "recurs", ()=>recurs);
parcelHelpers.export(exports, "reduce", ()=>reduce);
parcelHelpers.export(exports, "reduceEffect", ()=>reduceEffect);
parcelHelpers.export(exports, "repeatForever", ()=>repeatForever);
parcelHelpers.export(exports, "repetitions", ()=>repetitions);
parcelHelpers.export(exports, "resetAfter", ()=>resetAfter);
parcelHelpers.export(exports, "resetWhen", ()=>resetWhen);
parcelHelpers.export(exports, "run", ()=>run);
parcelHelpers.export(exports, "secondOfMinute", ()=>secondOfMinute);
parcelHelpers.export(exports, "spaced", ()=>spaced);
parcelHelpers.export(exports, "succeed", ()=>succeed);
parcelHelpers.export(exports, "sync", ()=>sync);
parcelHelpers.export(exports, "tapInput", ()=>tapInput);
parcelHelpers.export(exports, "tapOutput", ()=>tapOutput);
parcelHelpers.export(exports, "unfold", ()=>unfold);
parcelHelpers.export(exports, "union", ()=>union);
parcelHelpers.export(exports, "unionWith", ()=>unionWith);
parcelHelpers.export(exports, "untilInput", ()=>untilInput);
parcelHelpers.export(exports, "untilInputEffect", ()=>untilInputEffect);
parcelHelpers.export(exports, "untilOutput", ()=>untilOutput);
parcelHelpers.export(exports, "untilOutputEffect", ()=>untilOutputEffect);
parcelHelpers.export(exports, "upTo", ()=>upTo);
parcelHelpers.export(exports, "whileInput", ()=>whileInput);
parcelHelpers.export(exports, "whileInputEffect", ()=>whileInputEffect);
parcelHelpers.export(exports, "whileOutput", ()=>whileOutput);
parcelHelpers.export(exports, "whileOutputEffect", ()=>whileOutputEffect);
parcelHelpers.export(exports, "windowed", ()=>windowed);
parcelHelpers.export(exports, "zipLeft", ()=>zipLeft);
parcelHelpers.export(exports, "zipRight", ()=>zipRight);
parcelHelpers.export(exports, "zipWith", ()=>zipWith);
parcelHelpers.export(exports, "beginningOfSecond", ()=>beginningOfSecond);
parcelHelpers.export(exports, "endOfSecond", ()=>endOfSecond);
parcelHelpers.export(exports, "nextSecond", ()=>nextSecond);
parcelHelpers.export(exports, "beginningOfMinute", ()=>beginningOfMinute);
parcelHelpers.export(exports, "endOfMinute", ()=>endOfMinute);
parcelHelpers.export(exports, "nextMinute", ()=>nextMinute);
parcelHelpers.export(exports, "beginningOfHour", ()=>beginningOfHour);
parcelHelpers.export(exports, "endOfHour", ()=>endOfHour);
parcelHelpers.export(exports, "nextHour", ()=>nextHour);
parcelHelpers.export(exports, "beginningOfDay", ()=>beginningOfDay);
parcelHelpers.export(exports, "endOfDay", ()=>endOfDay);
parcelHelpers.export(exports, "nextDay", ()=>nextDay);
parcelHelpers.export(exports, "nextDayOfMonth", ()=>nextDayOfMonth);
parcelHelpers.export(exports, "findNextMonth", ()=>findNextMonth);
parcelHelpers.export(exports, "repeat_Effect", ()=>repeat_Effect);
parcelHelpers.export(exports, "repeat_combined", ()=>repeat_combined);
parcelHelpers.export(exports, "repeatOrElse_Effect", ()=>repeatOrElse_Effect);
parcelHelpers.export(exports, "retry_Effect", ()=>retry_Effect);
parcelHelpers.export(exports, "retry_combined", ()=>retry_combined);
parcelHelpers.export(exports, "retryOrElse_Effect", ()=>retryOrElse_Effect);
parcelHelpers.export(exports, "schedule_Effect", ()=>schedule_Effect);
parcelHelpers.export(exports, "scheduleFrom_Effect", ()=>scheduleFrom_Effect);
parcelHelpers.export(exports, "count", ()=>count);
parcelHelpers.export(exports, "elapsed", ()=>elapsed);
parcelHelpers.export(exports, "forever", ()=>forever);
parcelHelpers.export(exports, "once", ()=>once);
parcelHelpers.export(exports, "stop", ()=>stop);
var _chunkJs = require("../Chunk.js");
var _clockJs = require("../Clock.js");
var _contextJs = require("../Context.js");
var _cronJs = require("../Cron.js");
var _durationJs = require("../Duration.js");
var _eitherJs = require("../Either.js");
var _equalJs = require("../Equal.js");
var _functionJs = require("../Function.js");
var _optionJs = require("../Option.js");
var _pipeableJs = require("../Pipeable.js");
var _predicateJs = require("../Predicate.js");
var _randomJs = require("../Random.js");
var _scheduleDecisionJs = require("../ScheduleDecision.js");
var _scheduleIntervalJs = require("../ScheduleInterval.js");
var _scheduleIntervalsJs = require("../ScheduleIntervals.js");
var _causeJs = require("./cause.js");
var _coreEffectJs = require("./core-effect.js");
var _coreJs = require("./core.js");
var _refJs = require("./ref.js");
/** @internal */ const ScheduleSymbolKey = "effect/Schedule";
const ScheduleTypeId = /*#__PURE__*/ Symbol.for(ScheduleSymbolKey);
const isSchedule = (u)=>(0, _predicateJs.hasProperty)(u, ScheduleTypeId);
/** @internal */ const ScheduleDriverSymbolKey = "effect/ScheduleDriver";
const ScheduleDriverTypeId = /*#__PURE__*/ Symbol.for(ScheduleDriverSymbolKey);
const scheduleVariance = {
    /* c8 ignore next */ _Out: (_)=>_,
    /* c8 ignore next */ _In: (_)=>_,
    /* c8 ignore next */ _R: (_)=>_
};
const scheduleDriverVariance = {
    /* c8 ignore next */ _Out: (_)=>_,
    /* c8 ignore next */ _In: (_)=>_,
    /* c8 ignore next */ _R: (_)=>_
};
/** @internal */ class ScheduleImpl {
    initial;
    step;
    [ScheduleTypeId] = scheduleVariance;
    constructor(initial, step){
        this.initial = initial;
        this.step = step;
    }
    pipe() {
        return (0, _pipeableJs.pipeArguments)(this, arguments);
    }
}
/** @internal */ class ScheduleDriverImpl {
    schedule;
    ref;
    [ScheduleDriverTypeId] = scheduleDriverVariance;
    constructor(schedule, ref){
        this.schedule = schedule;
        this.ref = ref;
    }
    get state() {
        return _coreJs.map(_refJs.get(this.ref), (tuple)=>tuple[1]);
    }
    get last() {
        return _coreJs.flatMap(_refJs.get(this.ref), ([element, _])=>{
            switch(element._tag){
                case "None":
                    return _coreJs.failSync(()=>new _coreJs.NoSuchElementException());
                case "Some":
                    return _coreJs.succeed(element.value);
            }
        });
    }
    get reset() {
        return _refJs.set(this.ref, [
            _optionJs.none(),
            this.schedule.initial
        ]);
    }
    next(input) {
        return (0, _functionJs.pipe)(_coreJs.map(_refJs.get(this.ref), (tuple)=>tuple[1]), _coreJs.flatMap((state)=>(0, _functionJs.pipe)(_clockJs.currentTimeMillis, _coreJs.flatMap((now)=>(0, _functionJs.pipe)(_coreJs.suspend(()=>this.schedule.step(now, input, state)), _coreJs.flatMap(([state, out, decision])=>{
                    const setState = _refJs.set(this.ref, [
                        _optionJs.some(out),
                        state
                    ]);
                    if (_scheduleDecisionJs.isDone(decision)) return _coreJs.zipRight(setState, _coreJs.fail(_optionJs.none()));
                    const millis = _scheduleIntervalsJs.start(decision.intervals) - now;
                    if (millis <= 0) return _coreJs.as(setState, out);
                    return (0, _functionJs.pipe)(setState, _coreJs.zipRight(_coreEffectJs.sleep(_durationJs.millis(millis))), _coreJs.as(out));
                }))))));
    }
}
const makeWithState = (initial, step)=>new ScheduleImpl(initial, step);
const addDelay = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>addDelayEffect(self, (out)=>_coreJs.sync(()=>f(out))));
const addDelayEffect = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>modifyDelayEffect(self, (out, duration)=>_coreJs.map(f(out), (delay)=>_durationJs.sum(duration, _durationJs.decode(delay)))));
const andThen = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>map(andThenEither(self, that), _eitherJs.merge));
const andThenEither = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>makeWithState([
        self.initial,
        that.initial,
        true
    ], (now, input, state)=>state[2] ? _coreJs.flatMap(self.step(now, input, state[0]), ([lState, out, decision])=>{
            if (_scheduleDecisionJs.isDone(decision)) return _coreJs.map(that.step(now, input, state[1]), ([rState, out, decision])=>[
                    [
                        lState,
                        rState,
                        false
                    ],
                    _eitherJs.right(out),
                    decision
                ]);
            return _coreJs.succeed([
                [
                    lState,
                    state[1],
                    true
                ],
                _eitherJs.left(out),
                decision
            ]);
        }) : _coreJs.map(that.step(now, input, state[1]), ([rState, out, decision])=>[
                [
                    state[0],
                    rState,
                    false
                ],
                _eitherJs.right(out),
                decision
            ])));
const as = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, out)=>map(self, ()=>out));
const asVoid = (self)=>map(self, (0, _functionJs.constVoid));
const bothInOut = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>makeWithState([
        self.initial,
        that.initial
    ], (now, [in1, in2], state)=>_coreJs.zipWith(self.step(now, in1, state[0]), that.step(now, in2, state[1]), ([lState, out, lDecision], [rState, out2, rDecision])=>{
            if (_scheduleDecisionJs.isContinue(lDecision) && _scheduleDecisionJs.isContinue(rDecision)) {
                const interval = (0, _functionJs.pipe)(lDecision.intervals, _scheduleIntervalsJs.union(rDecision.intervals));
                return [
                    [
                        lState,
                        rState
                    ],
                    [
                        out,
                        out2
                    ],
                    _scheduleDecisionJs.continue(interval)
                ];
            }
            return [
                [
                    lState,
                    rState
                ],
                [
                    out,
                    out2
                ],
                _scheduleDecisionJs.done
            ];
        })));
const check = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, test)=>checkEffect(self, (input, out)=>_coreJs.sync(()=>test(input, out))));
const checkEffect = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, test)=>makeWithState(self.initial, (now, input, state)=>_coreJs.flatMap(self.step(now, input, state), ([state, out, decision])=>{
            if (_scheduleDecisionJs.isDone(decision)) return _coreJs.succeed([
                state,
                out,
                _scheduleDecisionJs.done
            ]);
            return _coreJs.map(test(input, out), (cont)=>cont ? [
                    state,
                    out,
                    decision
                ] : [
                    state,
                    out,
                    _scheduleDecisionJs.done
                ]);
        })));
const collectAllInputs = ()=>collectAllOutputs(identity());
const collectAllOutputs = (self)=>reduce(self, _chunkJs.empty(), (outs, out)=>(0, _functionJs.pipe)(outs, _chunkJs.append(out)));
const collectUntil = (f)=>collectAllOutputs(recurUntil(f));
const collectUntilEffect = (f)=>collectAllOutputs(recurUntilEffect(f));
const collectWhile = (f)=>collectAllOutputs(recurWhile(f));
const collectWhileEffect = (f)=>collectAllOutputs(recurWhileEffect(f));
const compose = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>makeWithState([
        self.initial,
        that.initial
    ], (now, input, state)=>_coreJs.flatMap(self.step(now, input, state[0]), ([lState, out, lDecision])=>_coreJs.map(that.step(now, out, state[1]), ([rState, out2, rDecision])=>_scheduleDecisionJs.isDone(lDecision) ? [
                    [
                        lState,
                        rState
                    ],
                    out2,
                    _scheduleDecisionJs.done
                ] : _scheduleDecisionJs.isDone(rDecision) ? [
                    [
                        lState,
                        rState
                    ],
                    out2,
                    _scheduleDecisionJs.done
                ] : [
                    [
                        lState,
                        rState
                    ],
                    out2,
                    _scheduleDecisionJs.continue((0, _functionJs.pipe)(lDecision.intervals, _scheduleIntervalsJs.max(rDecision.intervals)))
                ]))));
const mapInput = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>mapInputEffect(self, (input2)=>_coreJs.sync(()=>f(input2))));
const mapInputContext = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>makeWithState(self.initial, (now, input, state)=>_coreJs.mapInputContext(self.step(now, input, state), f)));
const mapInputEffect = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>makeWithState(self.initial, (now, input2, state)=>_coreJs.flatMap(f(input2), (input)=>self.step(now, input, state))));
const cron = (expression, tz)=>{
    const parsed = _cronJs.isCron(expression) ? _eitherJs.right(expression) : _cronJs.parse(expression, tz);
    return makeWithState([
        true,
        [
            Number.MIN_SAFE_INTEGER,
            0,
            0
        ]
    ], (now, _, [initial, previous])=>{
        if (now < previous[0]) return _coreJs.succeed([
            [
                false,
                previous
            ],
            [
                previous[1],
                previous[2]
            ],
            _scheduleDecisionJs.continueWith(_scheduleIntervalJs.make(previous[1], previous[2]))
        ]);
        if (_eitherJs.isLeft(parsed)) return _coreJs.die(parsed.left);
        const cron = parsed.right;
        const date = new Date(now);
        let next;
        if (initial && _cronJs.match(cron, date)) next = now;
        next = _cronJs.next(cron, date).getTime();
        const start = beginningOfSecond(next);
        const end = endOfSecond(next);
        return _coreJs.succeed([
            [
                false,
                [
                    next,
                    start,
                    end
                ]
            ],
            [
                start,
                end
            ],
            _scheduleDecisionJs.continueWith(_scheduleIntervalJs.make(start, end))
        ]);
    });
};
const dayOfMonth = (day)=>{
    return makeWithState([
        Number.NEGATIVE_INFINITY,
        0
    ], (now, _, state)=>{
        if (!Number.isInteger(day) || day < 1 || 31 < day) return _coreJs.dieSync(()=>new _coreJs.IllegalArgumentException(`Invalid argument in: dayOfMonth(${day}). Must be in range 1...31`));
        const n = state[1];
        const initial = n === 0;
        const day0 = nextDayOfMonth(now, day, initial);
        const start = beginningOfDay(day0);
        const end = endOfDay(day0);
        const interval = _scheduleIntervalJs.make(start, end);
        return _coreJs.succeed([
            [
                end,
                n + 1
            ],
            n,
            _scheduleDecisionJs.continueWith(interval)
        ]);
    });
};
const dayOfWeek = (day)=>{
    return makeWithState([
        Number.MIN_SAFE_INTEGER,
        0
    ], (now, _, state)=>{
        if (!Number.isInteger(day) || day < 1 || 7 < day) return _coreJs.dieSync(()=>new _coreJs.IllegalArgumentException(`Invalid argument in: dayOfWeek(${day}). Must be in range 1 (Monday)...7 (Sunday)`));
        const n = state[1];
        const initial = n === 0;
        const day0 = nextDay(now, day, initial);
        const start = beginningOfDay(day0);
        const end = endOfDay(day0);
        const interval = _scheduleIntervalJs.make(start, end);
        return _coreJs.succeed([
            [
                end,
                n + 1
            ],
            n,
            _scheduleDecisionJs.continueWith(interval)
        ]);
    });
};
const delayed = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>delayedEffect(self, (duration)=>_coreJs.sync(()=>f(duration))));
const delayedEffect = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>modifyDelayEffect(self, (_, delay)=>f(delay)));
const delayedSchedule = (schedule)=>addDelay(schedule, (x)=>x);
const delays = (self)=>makeWithState(self.initial, (now, input, state)=>(0, _functionJs.pipe)(self.step(now, input, state), _coreJs.flatMap(([state, _, decision])=>{
            if (_scheduleDecisionJs.isDone(decision)) return _coreJs.succeed([
                state,
                _durationJs.zero,
                decision
            ]);
            return _coreJs.succeed([
                state,
                _durationJs.millis(_scheduleIntervalsJs.start(decision.intervals) - now),
                decision
            ]);
        })));
const mapBoth = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, { onInput, onOutput })=>map(mapInput(self, onInput), onOutput));
const mapBothEffect = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, { onInput, onOutput })=>mapEffect(mapInputEffect(self, onInput), onOutput));
const driver = (self)=>(0, _functionJs.pipe)(_refJs.make([
        _optionJs.none(),
        self.initial
    ]), _coreJs.map((ref)=>new ScheduleDriverImpl(self, ref)));
const duration = (durationInput)=>{
    const duration = _durationJs.decode(durationInput);
    const durationMillis = _durationJs.toMillis(duration);
    return makeWithState(true, (now, _, state)=>_coreJs.succeed(state ? [
            false,
            duration,
            _scheduleDecisionJs.continueWith(_scheduleIntervalJs.after(now + durationMillis))
        ] : [
            false,
            _durationJs.zero,
            _scheduleDecisionJs.done
        ]));
};
const either = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>union(self, that));
const eitherWith = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, that, f)=>unionWith(self, that, f));
const ensuring = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, finalizer)=>makeWithState(self.initial, (now, input, state)=>_coreJs.flatMap(self.step(now, input, state), ([state, out, decision])=>_scheduleDecisionJs.isDone(decision) ? _coreJs.as(finalizer, [
                state,
                out,
                decision
            ]) : _coreJs.succeed([
                state,
                out,
                decision
            ]))));
const exponential = (baseInput, factor = 2.0)=>{
    const base = _durationJs.decode(baseInput);
    return delayedSchedule(map(forever, (i)=>_durationJs.times(base, Math.pow(factor, i))));
};
const fibonacci = (oneInput)=>{
    const one = _durationJs.decode(oneInput);
    return delayedSchedule((0, _functionJs.pipe)(unfold([
        one,
        one
    ], ([a, b])=>[
            b,
            _durationJs.sum(a, b)
        ]), map((out)=>out[0])));
};
const fixed = (intervalInput)=>{
    const interval = _durationJs.decode(intervalInput);
    const intervalMillis = _durationJs.toMillis(interval);
    return makeWithState([
        _optionJs.none(),
        0
    ], (now, _, [option, n])=>_coreJs.sync(()=>{
            switch(option._tag){
                case "None":
                    return [
                        [
                            _optionJs.some([
                                now,
                                now + intervalMillis
                            ]),
                            n + 1
                        ],
                        n,
                        _scheduleDecisionJs.continueWith(_scheduleIntervalJs.after(now + intervalMillis))
                    ];
                case "Some":
                    {
                        const [startMillis, lastRun] = option.value;
                        const runningBehind = now > lastRun + intervalMillis;
                        const boundary = _equalJs.equals(interval, _durationJs.zero) ? interval : _durationJs.millis(intervalMillis - (now - startMillis) % intervalMillis);
                        const sleepTime = _equalJs.equals(boundary, _durationJs.zero) ? interval : boundary;
                        const nextRun = runningBehind ? now : now + _durationJs.toMillis(sleepTime);
                        return [
                            [
                                _optionJs.some([
                                    startMillis,
                                    nextRun
                                ]),
                                n + 1
                            ],
                            n,
                            _scheduleDecisionJs.continueWith(_scheduleIntervalJs.after(nextRun))
                        ];
                    }
            }
        }));
};
const fromDelay = (delay)=>duration(delay);
const fromDelays = (delay, ...delays)=>makeWithState([
        [
            delay,
            ...delays
        ].map((_)=>_durationJs.decode(_)),
        true
    ], (now, _, [durations, cont])=>_coreJs.sync(()=>{
            if (cont) {
                const x = durations[0];
                const interval = _scheduleIntervalJs.after(now + _durationJs.toMillis(x));
                if (durations.length >= 2) return [
                    [
                        durations.slice(1),
                        true
                    ],
                    x,
                    _scheduleDecisionJs.continueWith(interval)
                ];
                const y = durations.slice(1);
                return [
                    [
                        [
                            x,
                            ...y
                        ],
                        false
                    ],
                    x,
                    _scheduleDecisionJs.continueWith(interval)
                ];
            }
            return [
                [
                    durations,
                    false
                ],
                _durationJs.zero,
                _scheduleDecisionJs.done
            ];
        }));
const fromFunction = (f)=>map(identity(), f);
const hourOfDay = (hour)=>makeWithState([
        Number.NEGATIVE_INFINITY,
        0
    ], (now, _, state)=>{
        if (!Number.isInteger(hour) || hour < 0 || 23 < hour) return _coreJs.dieSync(()=>new _coreJs.IllegalArgumentException(`Invalid argument in: hourOfDay(${hour}). Must be in range 0...23`));
        const n = state[1];
        const initial = n === 0;
        const hour0 = nextHour(now, hour, initial);
        const start = beginningOfHour(hour0);
        const end = endOfHour(hour0);
        const interval = _scheduleIntervalJs.make(start, end);
        return _coreJs.succeed([
            [
                end,
                n + 1
            ],
            n,
            _scheduleDecisionJs.continueWith(interval)
        ]);
    });
const identity = ()=>makeWithState(void 0, (now, input, state)=>_coreJs.succeed([
            state,
            input,
            _scheduleDecisionJs.continueWith(_scheduleIntervalJs.after(now))
        ]));
const intersect = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>intersectWith(self, that, _scheduleIntervalsJs.intersect));
const intersectWith = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, that, f)=>makeWithState([
        self.initial,
        that.initial
    ], (now, input, state)=>(0, _functionJs.pipe)(_coreJs.zipWith(self.step(now, input, state[0]), that.step(now, input, state[1]), (a, b)=>[
                a,
                b
            ]), _coreJs.flatMap(([[lState, out, lDecision], [rState, out2, rDecision]])=>{
            if (_scheduleDecisionJs.isContinue(lDecision) && _scheduleDecisionJs.isContinue(rDecision)) return intersectWithLoop(self, that, input, lState, out, lDecision.intervals, rState, out2, rDecision.intervals, f);
            return _coreJs.succeed([
                [
                    lState,
                    rState
                ],
                [
                    out,
                    out2
                ],
                _scheduleDecisionJs.done
            ]);
        }))));
/** @internal */ const intersectWithLoop = (self, that, input, lState, out, lInterval, rState, out2, rInterval, f)=>{
    const combined = f(lInterval, rInterval);
    if (_scheduleIntervalsJs.isNonEmpty(combined)) return _coreJs.succeed([
        [
            lState,
            rState
        ],
        [
            out,
            out2
        ],
        _scheduleDecisionJs.continue(combined)
    ]);
    if ((0, _functionJs.pipe)(lInterval, _scheduleIntervalsJs.lessThan(rInterval))) return _coreJs.flatMap(self.step(_scheduleIntervalsJs.end(lInterval), input, lState), ([lState, out, decision])=>{
        if (_scheduleDecisionJs.isDone(decision)) return _coreJs.succeed([
            [
                lState,
                rState
            ],
            [
                out,
                out2
            ],
            _scheduleDecisionJs.done
        ]);
        return intersectWithLoop(self, that, input, lState, out, decision.intervals, rState, out2, rInterval, f);
    });
    return _coreJs.flatMap(that.step(_scheduleIntervalsJs.end(rInterval), input, rState), ([rState, out2, decision])=>{
        if (_scheduleDecisionJs.isDone(decision)) return _coreJs.succeed([
            [
                lState,
                rState
            ],
            [
                out,
                out2
            ],
            _scheduleDecisionJs.done
        ]);
        return intersectWithLoop(self, that, input, lState, out, lInterval, rState, out2, decision.intervals, f);
    });
};
const jittered = (self)=>jitteredWith(self, {
        min: 0.8,
        max: 1.2
    });
const jitteredWith = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, options)=>{
    const { max, min } = Object.assign({
        min: 0.8,
        max: 1.2
    }, options);
    return delayedEffect(self, (duration)=>_coreJs.map(_randomJs.next, (random)=>{
            const d = _durationJs.toMillis(duration);
            const jittered = d * min * (1 - random) + d * max * random;
            return _durationJs.millis(jittered);
        }));
});
const linear = (baseInput)=>{
    const base = _durationJs.decode(baseInput);
    return delayedSchedule(map(forever, (i)=>_durationJs.times(base, i + 1)));
};
const map = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>mapEffect(self, (out)=>_coreJs.sync(()=>f(out))));
const mapEffect = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>makeWithState(self.initial, (now, input, state)=>_coreJs.flatMap(self.step(now, input, state), ([state, out, decision])=>_coreJs.map(f(out), (out2)=>[
                    state,
                    out2,
                    decision
                ]))));
const minuteOfHour = (minute)=>makeWithState([
        Number.MIN_SAFE_INTEGER,
        0
    ], (now, _, state)=>{
        if (!Number.isInteger(minute) || minute < 0 || 59 < minute) return _coreJs.dieSync(()=>new _coreJs.IllegalArgumentException(`Invalid argument in: minuteOfHour(${minute}). Must be in range 0...59`));
        const n = state[1];
        const initial = n === 0;
        const minute0 = nextMinute(now, minute, initial);
        const start = beginningOfMinute(minute0);
        const end = endOfMinute(minute0);
        const interval = _scheduleIntervalJs.make(start, end);
        return _coreJs.succeed([
            [
                end,
                n + 1
            ],
            n,
            _scheduleDecisionJs.continueWith(interval)
        ]);
    });
const modifyDelay = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>modifyDelayEffect(self, (out, duration)=>_coreJs.sync(()=>f(out, duration))));
const modifyDelayEffect = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>makeWithState(self.initial, (now, input, state)=>_coreJs.flatMap(self.step(now, input, state), ([state, out, decision])=>{
            if (_scheduleDecisionJs.isDone(decision)) return _coreJs.succeed([
                state,
                out,
                decision
            ]);
            const intervals = decision.intervals;
            const delay = _scheduleIntervalJs.size(_scheduleIntervalJs.make(now, _scheduleIntervalsJs.start(intervals)));
            return _coreJs.map(f(out, delay), (durationInput)=>{
                const duration = _durationJs.decode(durationInput);
                const oldStart = _scheduleIntervalsJs.start(intervals);
                const newStart = now + _durationJs.toMillis(duration);
                const delta = newStart - oldStart;
                const newEnd = Math.max(0, _scheduleIntervalsJs.end(intervals) + delta);
                const newInterval = _scheduleIntervalJs.make(newStart, newEnd);
                return [
                    state,
                    out,
                    _scheduleDecisionJs.continueWith(newInterval)
                ];
            });
        })));
const onDecision = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>makeWithState(self.initial, (now, input, state)=>_coreJs.flatMap(self.step(now, input, state), ([state, out, decision])=>_coreJs.as(f(out, decision), [
                state,
                out,
                decision
            ]))));
const passthrough = (self)=>makeWithState(self.initial, (now, input, state)=>(0, _functionJs.pipe)(self.step(now, input, state), _coreJs.map(([state, _, decision])=>[
                state,
                input,
                decision
            ])));
const provideContext = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, context)=>makeWithState(self.initial, (now, input, state)=>_coreJs.provideContext(self.step(now, input, state), context)));
const provideService = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, tag, service)=>makeWithState(self.initial, (now, input, state)=>_coreJs.contextWithEffect((env)=>_coreJs.provideContext(// @ts-expect-error
            self.step(now, input, state), _contextJs.add(env, tag, service)))));
const recurUntil = (f)=>untilInput(identity(), f);
const recurUntilEffect = (f)=>untilInputEffect(identity(), f);
const recurUntilOption = (pf)=>untilOutput(map(identity(), pf), _optionJs.isSome);
const recurUpTo = (durationInput)=>{
    const duration = _durationJs.decode(durationInput);
    return whileOutput(elapsed, (elapsed)=>_durationJs.lessThan(elapsed, duration));
};
const recurWhile = (f)=>whileInput(identity(), f);
const recurWhileEffect = (f)=>whileInputEffect(identity(), f);
const recurs = (n)=>whileOutput(forever, (out)=>out < n);
const reduce = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, zero, f)=>reduceEffect(self, zero, (z, out)=>_coreJs.sync(()=>f(z, out))));
const reduceEffect = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, zero, f)=>makeWithState([
        self.initial,
        zero
    ], (now, input, [s, z])=>_coreJs.flatMap(self.step(now, input, s), ([s, out, decision])=>_scheduleDecisionJs.isDone(decision) ? _coreJs.succeed([
                [
                    s,
                    z
                ],
                z,
                decision
            ]) : _coreJs.map(f(z, out), (z2)=>[
                    [
                        s,
                        z2
                    ],
                    z,
                    decision
                ]))));
const repeatForever = (self)=>makeWithState(self.initial, (now, input, state)=>{
        const step = (now, input, state)=>_coreJs.flatMap(self.step(now, input, state), ([state, out, decision])=>_scheduleDecisionJs.isDone(decision) ? step(now, input, self.initial) : _coreJs.succeed([
                    state,
                    out,
                    decision
                ]));
        return step(now, input, state);
    });
const repetitions = (self)=>reduce(self, 0, (n, _)=>n + 1);
const resetAfter = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, durationInput)=>{
    const duration = _durationJs.decode(durationInput);
    return (0, _functionJs.pipe)(self, intersect(elapsed), resetWhen(([, time])=>_durationJs.greaterThanOrEqualTo(time, duration)), map((out)=>out[0]));
});
const resetWhen = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>makeWithState(self.initial, (now, input, state)=>_coreJs.flatMap(self.step(now, input, state), ([state, out, decision])=>f(out) ? self.step(now, input, self.initial) : _coreJs.succeed([
                state,
                out,
                decision
            ]))));
const run = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, now, input)=>(0, _functionJs.pipe)(runLoop(self, now, _chunkJs.fromIterable(input), self.initial, _chunkJs.empty()), _coreJs.map((list)=>_chunkJs.reverse(list))));
/** @internal */ const runLoop = (self, now, inputs, state, acc)=>{
    if (!_chunkJs.isNonEmpty(inputs)) return _coreJs.succeed(acc);
    const input = _chunkJs.headNonEmpty(inputs);
    const nextInputs = _chunkJs.tailNonEmpty(inputs);
    return _coreJs.flatMap(self.step(now, input, state), ([state, out, decision])=>{
        if (_scheduleDecisionJs.isDone(decision)) return _coreJs.sync(()=>(0, _functionJs.pipe)(acc, _chunkJs.prepend(out)));
        return runLoop(self, _scheduleIntervalsJs.start(decision.intervals), nextInputs, state, _chunkJs.prepend(acc, out));
    });
};
const secondOfMinute = (second)=>makeWithState([
        Number.NEGATIVE_INFINITY,
        0
    ], (now, _, state)=>{
        if (!Number.isInteger(second) || second < 0 || 59 < second) return _coreJs.dieSync(()=>new _coreJs.IllegalArgumentException(`Invalid argument in: secondOfMinute(${second}). Must be in range 0...59`));
        const n = state[1];
        const initial = n === 0;
        const second0 = nextSecond(now, second, initial);
        const start = beginningOfSecond(second0);
        const end = endOfSecond(second0);
        const interval = _scheduleIntervalJs.make(start, end);
        return _coreJs.succeed([
            [
                end,
                n + 1
            ],
            n,
            _scheduleDecisionJs.continueWith(interval)
        ]);
    });
const spaced = (duration)=>addDelay(forever, ()=>duration);
const succeed = (value)=>map(forever, ()=>value);
const sync = (evaluate)=>map(forever, evaluate);
const tapInput = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>makeWithState(self.initial, (now, input, state)=>_coreJs.zipRight(f(input), self.step(now, input, state))));
const tapOutput = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>makeWithState(self.initial, (now, input, state)=>_coreJs.tap(self.step(now, input, state), ([, out])=>f(out))));
const unfold = (initial, f)=>makeWithState(initial, (now, _, state)=>_coreJs.sync(()=>[
                f(state),
                state,
                _scheduleDecisionJs.continueWith(_scheduleIntervalJs.after(now))
            ]));
const union = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>unionWith(self, that, _scheduleIntervalsJs.union));
const unionWith = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, that, f)=>makeWithState([
        self.initial,
        that.initial
    ], (now, input, state)=>_coreJs.zipWith(self.step(now, input, state[0]), that.step(now, input, state[1]), ([lState, l, lDecision], [rState, r, rDecision])=>{
            if (_scheduleDecisionJs.isDone(lDecision) && _scheduleDecisionJs.isDone(rDecision)) return [
                [
                    lState,
                    rState
                ],
                [
                    l,
                    r
                ],
                _scheduleDecisionJs.done
            ];
            if (_scheduleDecisionJs.isDone(lDecision) && _scheduleDecisionJs.isContinue(rDecision)) return [
                [
                    lState,
                    rState
                ],
                [
                    l,
                    r
                ],
                _scheduleDecisionJs.continue(rDecision.intervals)
            ];
            if (_scheduleDecisionJs.isContinue(lDecision) && _scheduleDecisionJs.isDone(rDecision)) return [
                [
                    lState,
                    rState
                ],
                [
                    l,
                    r
                ],
                _scheduleDecisionJs.continue(lDecision.intervals)
            ];
            if (_scheduleDecisionJs.isContinue(lDecision) && _scheduleDecisionJs.isContinue(rDecision)) {
                const combined = f(lDecision.intervals, rDecision.intervals);
                return [
                    [
                        lState,
                        rState
                    ],
                    [
                        l,
                        r
                    ],
                    _scheduleDecisionJs.continue(combined)
                ];
            }
            throw new Error("BUG: Schedule.unionWith - please report an issue at https://github.com/Effect-TS/effect/issues");
        })));
const untilInput = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>check(self, (input, _)=>!f(input)));
const untilInputEffect = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>checkEffect(self, (input, _)=>_coreEffectJs.negate(f(input))));
const untilOutput = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>check(self, (_, out)=>!f(out)));
const untilOutputEffect = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>checkEffect(self, (_, out)=>_coreEffectJs.negate(f(out))));
const upTo = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, duration)=>zipLeft(self, recurUpTo(duration)));
const whileInput = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>check(self, (input, _)=>f(input)));
const whileInputEffect = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>checkEffect(self, (input, _)=>f(input)));
const whileOutput = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>check(self, (_, out)=>f(out)));
const whileOutputEffect = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>checkEffect(self, (_, out)=>f(out)));
const windowed = (intervalInput)=>{
    const interval = _durationJs.decode(intervalInput);
    const millis = _durationJs.toMillis(interval);
    return makeWithState([
        _optionJs.none(),
        0
    ], (now, _, [option, n])=>{
        switch(option._tag){
            case "None":
                return _coreJs.succeed([
                    [
                        _optionJs.some(now),
                        n + 1
                    ],
                    n,
                    _scheduleDecisionJs.continueWith(_scheduleIntervalJs.after(now + millis))
                ]);
            case "Some":
                return _coreJs.succeed([
                    [
                        _optionJs.some(option.value),
                        n + 1
                    ],
                    n,
                    _scheduleDecisionJs.continueWith(_scheduleIntervalJs.after(now + (millis - (now - option.value) % millis)))
                ]);
        }
    });
};
const zipLeft = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>map(intersect(self, that), (out)=>out[0]));
const zipRight = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>map(intersect(self, that), (out)=>out[1]));
const zipWith = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, that, f)=>map(intersect(self, that), ([out, out2])=>f(out, out2)));
const beginningOfSecond = (now)=>{
    const date = new Date(now);
    return new Date(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), 0).getTime();
};
const endOfSecond = (now)=>{
    const date = new Date(beginningOfSecond(now));
    return date.setSeconds(date.getSeconds() + 1);
};
const nextSecond = (now, second, initial)=>{
    const date = new Date(now);
    if (date.getSeconds() === second && initial) return now;
    if (date.getSeconds() < second) return date.setSeconds(second);
    // Set seconds to the provided value and add one minute
    const newDate = new Date(date.setSeconds(second));
    return newDate.setTime(newDate.getTime() + 60000);
};
const beginningOfMinute = (now)=>{
    const date = new Date(now);
    return new Date(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), 0, 0).getTime();
};
const endOfMinute = (now)=>{
    const date = new Date(beginningOfMinute(now));
    return date.setMinutes(date.getMinutes() + 1);
};
const nextMinute = (now, minute, initial)=>{
    const date = new Date(now);
    if (date.getMinutes() === minute && initial) return now;
    if (date.getMinutes() < minute) return date.setMinutes(minute);
    // Set minutes to the provided value and add one hour
    const newDate = new Date(date.setMinutes(minute));
    return newDate.setTime(newDate.getTime() + 3600000);
};
const beginningOfHour = (now)=>{
    const date = new Date(now);
    return new Date(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), 0, 0, 0).getTime();
};
const endOfHour = (now)=>{
    const date = new Date(beginningOfHour(now));
    return date.setHours(date.getHours() + 1);
};
const nextHour = (now, hour, initial)=>{
    const date = new Date(now);
    if (date.getHours() === hour && initial) return now;
    if (date.getHours() < hour) return date.setHours(hour);
    // Set hours to the provided value and add one day
    const newDate = new Date(date.setHours(hour));
    return newDate.setTime(newDate.getTime() + 86400000);
};
const beginningOfDay = (now)=>{
    const date = new Date(now);
    return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0).getTime();
};
const endOfDay = (now)=>{
    const date = new Date(beginningOfDay(now));
    return date.setDate(date.getDate() + 1);
};
const nextDay = (now, dayOfWeek, initial)=>{
    const date = new Date(now);
    if (date.getDay() === dayOfWeek && initial) return now;
    const nextDayOfWeek = (7 + dayOfWeek - date.getDay()) % 7;
    return date.setDate(date.getDate() + (nextDayOfWeek === 0 ? 7 : nextDayOfWeek));
};
const nextDayOfMonth = (now, day, initial)=>{
    const date = new Date(now);
    if (date.getDate() === day && initial) return now;
    if (date.getDate() < day) return date.setDate(day);
    return findNextMonth(now, day, 1);
};
const findNextMonth = (now, day, months)=>{
    const d = new Date(now);
    const tmp1 = new Date(d.setDate(day));
    const tmp2 = new Date(tmp1.setMonth(tmp1.getMonth() + months));
    if (tmp2.getDate() === day) {
        const d2 = new Date(now);
        const tmp3 = new Date(d2.setDate(day));
        return tmp3.setMonth(tmp3.getMonth() + months);
    }
    return findNextMonth(now, day, months + 1);
};
// circular with Effect
const ScheduleDefectTypeId = /*#__PURE__*/ Symbol.for("effect/Schedule/ScheduleDefect");
class ScheduleDefect {
    error;
    [ScheduleDefectTypeId];
    constructor(error){
        this.error = error;
        this[ScheduleDefectTypeId] = ScheduleDefectTypeId;
    }
}
const isScheduleDefect = (u)=>(0, _predicateJs.hasProperty)(u, ScheduleDefectTypeId);
const scheduleDefectWrap = (self)=>_coreJs.catchAll(self, (e)=>_coreJs.die(new ScheduleDefect(e)));
const scheduleDefectRefail = (self)=>_coreJs.catchAllCause(self, (cause)=>_optionJs.match(_causeJs.find(cause, (_)=>_causeJs.isDieType(_) && isScheduleDefect(_.defect) ? _optionJs.some(_.defect) : _optionJs.none()), {
            onNone: ()=>_coreJs.failCause(cause),
            onSome: (error)=>_coreJs.fail(error.error)
        }));
const repeat_Effect = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, schedule)=>repeatOrElse_Effect(self, schedule, (e, _)=>_coreJs.fail(e)));
const repeat_combined = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, options)=>{
    if (isSchedule(options)) return repeat_Effect(self, options);
    const base = options.schedule ?? passthrough(forever);
    const withWhile = options.while ? whileInputEffect(base, (a)=>{
        const applied = options.while(a);
        if (typeof applied === "boolean") return _coreJs.succeed(applied);
        return scheduleDefectWrap(applied);
    }) : base;
    const withUntil = options.until ? untilInputEffect(withWhile, (a)=>{
        const applied = options.until(a);
        if (typeof applied === "boolean") return _coreJs.succeed(applied);
        return scheduleDefectWrap(applied);
    }) : withWhile;
    const withTimes = options.times ? intersect(withUntil, recurs(options.times)).pipe(map((intersectionPair)=>intersectionPair[0])) : withUntil;
    return scheduleDefectRefail(repeat_Effect(self, withTimes));
});
const repeatOrElse_Effect = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, schedule, orElse)=>_coreJs.flatMap(driver(schedule), (driver)=>_coreJs.matchEffect(self, {
            onFailure: (error)=>orElse(error, _optionJs.none()),
            onSuccess: (value)=>repeatOrElseEffectLoop(self, driver, orElse, value)
        })));
/** @internal */ const repeatOrElseEffectLoop = (self, driver, orElse, value)=>{
    return _coreJs.matchEffect(driver.next(value), {
        onFailure: ()=>_coreJs.orDie(driver.last),
        onSuccess: (b)=>_coreJs.matchEffect(self, {
                onFailure: (error)=>orElse(error, _optionJs.some(b)),
                onSuccess: (value)=>repeatOrElseEffectLoop(self, driver, orElse, value)
            })
    });
};
const retry_Effect = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, policy)=>retryOrElse_Effect(self, policy, (e, _)=>_coreJs.fail(e)));
const retry_combined = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, options)=>{
    if (isSchedule(options)) return retry_Effect(self, options);
    const base = options.schedule ?? forever;
    const withWhile = options.while ? whileInputEffect(base, (e)=>{
        const applied = options.while(e);
        if (typeof applied === "boolean") return _coreJs.succeed(applied);
        return scheduleDefectWrap(applied);
    }) : base;
    const withUntil = options.until ? untilInputEffect(withWhile, (e)=>{
        const applied = options.until(e);
        if (typeof applied === "boolean") return _coreJs.succeed(applied);
        return scheduleDefectWrap(applied);
    }) : withWhile;
    const withTimes = options.times ? intersect(withUntil, recurs(options.times)) : withUntil;
    return scheduleDefectRefail(retry_Effect(self, withTimes));
});
const retryOrElse_Effect = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, policy, orElse)=>_coreJs.flatMap(driver(policy), (driver)=>retryOrElse_EffectLoop(self, driver, orElse)));
/** @internal */ const retryOrElse_EffectLoop = (self, driver, orElse)=>{
    return _coreJs.catchAll(self, (e)=>_coreJs.matchEffect(driver.next(e), {
            onFailure: ()=>(0, _functionJs.pipe)(driver.last, _coreJs.orDie, _coreJs.flatMap((out)=>orElse(e, out))),
            onSuccess: ()=>retryOrElse_EffectLoop(self, driver, orElse)
        }));
};
const schedule_Effect = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, schedule)=>scheduleFrom_Effect(self, void 0, schedule));
const scheduleFrom_Effect = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, initial, schedule)=>_coreJs.flatMap(driver(schedule), (driver)=>scheduleFrom_EffectLoop(self, initial, driver)));
/** @internal */ const scheduleFrom_EffectLoop = (self, initial, driver)=>_coreJs.matchEffect(driver.next(initial), {
        onFailure: ()=>_coreJs.orDie(driver.last),
        onSuccess: ()=>_coreJs.flatMap(self, (a)=>scheduleFrom_EffectLoop(self, a, driver))
    });
const count = /*#__PURE__*/ unfold(0, (n)=>n + 1);
const elapsed = /*#__PURE__*/ makeWithState(/*#__PURE__*/ _optionJs.none(), (now, _, state)=>{
    switch(state._tag){
        case "None":
            return _coreJs.succeed([
                _optionJs.some(now),
                _durationJs.zero,
                _scheduleDecisionJs.continueWith(_scheduleIntervalJs.after(now))
            ]);
        case "Some":
            return _coreJs.succeed([
                _optionJs.some(state.value),
                _durationJs.millis(now - state.value),
                _scheduleDecisionJs.continueWith(_scheduleIntervalJs.after(now))
            ]);
    }
});
const forever = /*#__PURE__*/ unfold(0, (n)=>n + 1);
const once = /*#__PURE__*/ asVoid(/*#__PURE__*/ recurs(1));
const stop = /*#__PURE__*/ asVoid(/*#__PURE__*/ recurs(0));

},{"../Chunk.js":"dL1OO","../Clock.js":"2Ndj4","../Context.js":"c2abN","../Cron.js":"4hfdQ","../Duration.js":"czLLe","../Either.js":"4amnT","../Equal.js":"gA0qD","../Function.js":"21gOL","../Option.js":"6sHA7","../Pipeable.js":"b5RU2","../Predicate.js":"gW5pd","../Random.js":"7XRWU","../ScheduleDecision.js":"23h1w","../ScheduleInterval.js":"MON0z","../ScheduleIntervals.js":"cBPei","./cause.js":"l3ev0","./core-effect.js":"k8F3C","./core.js":"cr3YV","./ref.js":"90h4v","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"7XRWU":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RandomTypeId", ()=>RandomTypeId);
parcelHelpers.export(exports, "next", ()=>next);
parcelHelpers.export(exports, "nextInt", ()=>nextInt);
parcelHelpers.export(exports, "nextBoolean", ()=>nextBoolean);
parcelHelpers.export(exports, "nextRange", ()=>nextRange);
parcelHelpers.export(exports, "nextIntBetween", ()=>nextIntBetween);
parcelHelpers.export(exports, "shuffle", ()=>shuffle);
parcelHelpers.export(exports, "choice", ()=>choice);
parcelHelpers.export(exports, "randomWith", ()=>randomWith);
parcelHelpers.export(exports, "Random", ()=>Random);
parcelHelpers.export(exports, "make", ()=>make);
var _defaultServicesJs = require("./internal/defaultServices.js");
var _randomJs = require("./internal/random.js");
const RandomTypeId = _randomJs.RandomTypeId;
const next = _defaultServicesJs.next;
const nextInt = _defaultServicesJs.nextInt;
const nextBoolean = _defaultServicesJs.nextBoolean;
const nextRange = _defaultServicesJs.nextRange;
const nextIntBetween = _defaultServicesJs.nextIntBetween;
const shuffle = _defaultServicesJs.shuffle;
const choice = _defaultServicesJs.choice;
const randomWith = _defaultServicesJs.randomWith;
const Random = _randomJs.randomTag;
const make = _randomJs.make;

},{"./internal/defaultServices.js":"aF4q8","./internal/random.js":"br4fL","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"hPPdd":[function(require,module,exports,__globalThis) {
// circular with Layer
/** @internal */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TypeId", ()=>TypeId);
const TypeId = /*#__PURE__*/ Symbol.for("effect/ManagedRuntime");

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"5D59K":[function(require,module,exports,__globalThis) {
/** @internal */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "OP_EXTEND_SCOPE", ()=>OP_EXTEND_SCOPE);
parcelHelpers.export(exports, "OP_FOLD", ()=>OP_FOLD);
parcelHelpers.export(exports, "OP_FRESH", ()=>OP_FRESH);
parcelHelpers.export(exports, "OP_FROM_EFFECT", ()=>OP_FROM_EFFECT);
parcelHelpers.export(exports, "OP_SCOPED", ()=>OP_SCOPED);
parcelHelpers.export(exports, "OP_SUSPEND", ()=>OP_SUSPEND);
parcelHelpers.export(exports, "OP_PROVIDE", ()=>OP_PROVIDE);
parcelHelpers.export(exports, "OP_PROVIDE_MERGE", ()=>OP_PROVIDE_MERGE);
parcelHelpers.export(exports, "OP_ZIP_WITH", ()=>OP_ZIP_WITH);
const OP_EXTEND_SCOPE = "ExtendScope";
const OP_FOLD = "Fold";
const OP_FRESH = "Fresh";
const OP_FROM_EFFECT = "FromEffect";
const OP_SCOPED = "Scoped";
const OP_SUSPEND = "Suspend";
const OP_PROVIDE = "Provide";
const OP_PROVIDE_MERGE = "ProvideMerge";
const OP_ZIP_WITH = "ZipWith";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"criei":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "unsafeFork", ()=>unsafeFork);
parcelHelpers.export(exports, "unsafeRunCallback", ()=>unsafeRunCallback);
parcelHelpers.export(exports, "unsafeRunSync", ()=>unsafeRunSync);
parcelHelpers.export(exports, "isAsyncFiberException", ()=>isAsyncFiberException);
parcelHelpers.export(exports, "FiberFailureId", ()=>FiberFailureId);
parcelHelpers.export(exports, "FiberFailureCauseId", ()=>FiberFailureCauseId);
parcelHelpers.export(exports, "fiberFailure", ()=>fiberFailure);
parcelHelpers.export(exports, "isFiberFailure", ()=>isFiberFailure);
parcelHelpers.export(exports, "unsafeRunSyncExit", ()=>unsafeRunSyncExit);
parcelHelpers.export(exports, "unsafeRunPromise", ()=>unsafeRunPromise);
parcelHelpers.export(exports, "unsafeRunPromiseExit", ()=>unsafeRunPromiseExit);
/** @internal */ parcelHelpers.export(exports, "RuntimeImpl", ()=>RuntimeImpl);
parcelHelpers.export(exports, "make", ()=>make);
parcelHelpers.export(exports, "runtime", ()=>runtime);
parcelHelpers.export(exports, "defaultRuntimeFlags", ()=>defaultRuntimeFlags);
parcelHelpers.export(exports, "defaultRuntime", ()=>defaultRuntime);
parcelHelpers.export(exports, "updateRuntimeFlags", ()=>updateRuntimeFlags);
parcelHelpers.export(exports, "disableRuntimeFlag", ()=>disableRuntimeFlag);
parcelHelpers.export(exports, "enableRuntimeFlag", ()=>enableRuntimeFlag);
parcelHelpers.export(exports, "updateContext", ()=>updateContext);
parcelHelpers.export(exports, "provideService", ()=>provideService);
parcelHelpers.export(exports, "updateFiberRefs", ()=>updateFiberRefs);
parcelHelpers.export(exports, "setFiberRef", ()=>setFiberRef);
parcelHelpers.export(exports, "deleteFiberRef", ()=>deleteFiberRef);
parcelHelpers.export(exports, "unsafeRunEffect", ()=>unsafeRunEffect);
parcelHelpers.export(exports, "unsafeForkEffect", ()=>unsafeForkEffect);
parcelHelpers.export(exports, "unsafeRunPromiseEffect", ()=>unsafeRunPromiseEffect);
parcelHelpers.export(exports, "unsafeRunPromiseExitEffect", ()=>unsafeRunPromiseExitEffect);
parcelHelpers.export(exports, "unsafeRunSyncEffect", ()=>unsafeRunSyncEffect);
parcelHelpers.export(exports, "unsafeRunSyncExitEffect", ()=>unsafeRunSyncExitEffect);
parcelHelpers.export(exports, "asyncEffect", ()=>asyncEffect);
var _contextJs = require("../Context.js");
var _equalJs = require("../Equal.js");
var _exitJs = require("../Exit.js");
var _fiberJs = require("../Fiber.js");
var _fiberIdJs = require("../FiberId.js");
var _fiberRefsJs = require("../FiberRefs.js");
var _functionJs = require("../Function.js");
var _inspectableJs = require("../Inspectable.js");
var _optionJs = require("../Option.js");
var _pipeableJs = require("../Pipeable.js");
var _predicateJs = require("../Predicate.js");
var _schedulerJs = require("../Scheduler.js");
var _scopeJs = require("../Scope.js");
var _causeJs = require("./cause.js");
var _coreJs = require("./core.js");
var _executionStrategyJs = require("./executionStrategy.js");
var _fiberRuntimeJs = require("./fiberRuntime.js");
var _fiberScopeJs = require("./fiberScope.js");
var _effectJs = require("./opCodes/effect.js");
var _runtimeFlagsJs = require("./runtimeFlags.js");
var _supervisorJs = require("./supervisor.js");
const makeDual = (f)=>function() {
        if (arguments.length === 1) {
            const runtime = arguments[0];
            return (effect, ...args)=>f(runtime, effect, ...args);
        }
        return f.apply(this, arguments);
    };
const unsafeFork = /*#__PURE__*/ makeDual((runtime, self, options)=>{
    const fiberId = _fiberIdJs.unsafeMake();
    const fiberRefUpdates = [
        [
            _coreJs.currentContext,
            [
                [
                    fiberId,
                    runtime.context
                ]
            ]
        ]
    ];
    if (options?.scheduler) fiberRefUpdates.push([
        _schedulerJs.currentScheduler,
        [
            [
                fiberId,
                options.scheduler
            ]
        ]
    ]);
    let fiberRefs = _fiberRefsJs.updateManyAs(runtime.fiberRefs, {
        entries: fiberRefUpdates,
        forkAs: fiberId
    });
    if (options?.updateRefs) fiberRefs = options.updateRefs(fiberRefs, fiberId);
    const fiberRuntime = new _fiberRuntimeJs.FiberRuntime(fiberId, fiberRefs, runtime.runtimeFlags);
    let effect = self;
    if (options?.scope) effect = _coreJs.flatMap(_scopeJs.fork(options.scope, _executionStrategyJs.sequential), (closeableScope)=>_coreJs.zipRight(_coreJs.scopeAddFinalizer(closeableScope, _coreJs.fiberIdWith((id)=>(0, _equalJs.equals)(id, fiberRuntime.id()) ? _coreJs.void : _coreJs.interruptAsFiber(fiberRuntime, id))), _coreJs.onExit(self, (exit)=>_scopeJs.close(closeableScope, exit))));
    const supervisor = fiberRuntime.currentSupervisor;
    // we can compare by reference here as _supervisor.none is wrapped with globalValue
    if (supervisor !== _supervisorJs.none) {
        supervisor.onStart(runtime.context, effect, _optionJs.none(), fiberRuntime);
        fiberRuntime.addObserver((exit)=>supervisor.onEnd(exit, fiberRuntime));
    }
    _fiberScopeJs.globalScope.add(runtime.runtimeFlags, fiberRuntime);
    // Only an explicit false will prevent immediate execution
    if (options?.immediate === false) fiberRuntime.resume(effect);
    else fiberRuntime.start(effect);
    return fiberRuntime;
});
const unsafeRunCallback = /*#__PURE__*/ makeDual((runtime, effect, options = {})=>{
    const fiberRuntime = unsafeFork(runtime, effect, options);
    if (options.onExit) fiberRuntime.addObserver((exit)=>{
        options.onExit(exit);
    });
    return (id, cancelOptions)=>unsafeRunCallback(runtime)((0, _functionJs.pipe)(fiberRuntime, _fiberJs.interruptAs(id ?? _fiberIdJs.none)), {
            ...cancelOptions,
            onExit: cancelOptions?.onExit ? (exit)=>cancelOptions.onExit(_exitJs.flatten(exit)) : undefined
        });
});
const unsafeRunSync = /*#__PURE__*/ makeDual((runtime, effect)=>{
    const result = unsafeRunSyncExit(runtime)(effect);
    if (result._tag === "Failure") throw fiberFailure(result.effect_instruction_i0);
    return result.effect_instruction_i0;
});
class AsyncFiberExceptionImpl extends Error {
    fiber;
    _tag = "AsyncFiberException";
    constructor(fiber){
        super(`Fiber #${fiber.id().id} cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work`);
        this.fiber = fiber;
        this.name = this._tag;
        this.stack = this.message;
    }
}
const asyncFiberException = (fiber)=>{
    const limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 0;
    const error = new AsyncFiberExceptionImpl(fiber);
    Error.stackTraceLimit = limit;
    return error;
};
const isAsyncFiberException = (u)=>_predicateJs.isTagged(u, "AsyncFiberException") && "fiber" in u;
const FiberFailureId = /*#__PURE__*/ Symbol.for("effect/Runtime/FiberFailure");
const FiberFailureCauseId = /*#__PURE__*/ Symbol.for("effect/Runtime/FiberFailure/Cause");
class FiberFailureImpl extends Error {
    [FiberFailureId];
    [FiberFailureCauseId];
    constructor(cause){
        const head = _causeJs.prettyErrors(cause)[0];
        super(head?.message || "An error has occurred");
        this[FiberFailureId] = FiberFailureId;
        this[FiberFailureCauseId] = cause;
        this.name = head ? `(FiberFailure) ${head.name}` : "FiberFailure";
        if (head?.stack) this.stack = head.stack;
    }
    toJSON() {
        return {
            _id: "FiberFailure",
            cause: this[FiberFailureCauseId].toJSON()
        };
    }
    toString() {
        return "(FiberFailure) " + _causeJs.pretty(this[FiberFailureCauseId], {
            renderErrorCause: true
        });
    }
    [_inspectableJs.NodeInspectSymbol]() {
        return this.toString();
    }
}
const fiberFailure = (cause)=>{
    const limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 0;
    const error = new FiberFailureImpl(cause);
    Error.stackTraceLimit = limit;
    return error;
};
const isFiberFailure = (u)=>_predicateJs.hasProperty(u, FiberFailureId);
const fastPath = (effect)=>{
    const op = effect;
    switch(op._op){
        case "Failure":
        case "Success":
            // @ts-expect-error
            return op;
        case "Left":
            return _coreJs.exitFail(op.left);
        case "Right":
            return _coreJs.exitSucceed(op.right);
        case "Some":
            return _coreJs.exitSucceed(op.value);
        case "None":
            // @ts-expect-error
            return _coreJs.exitFail(_coreJs.NoSuchElementException());
    }
};
const unsafeRunSyncExit = /*#__PURE__*/ makeDual((runtime, effect)=>{
    const op = fastPath(effect);
    if (op) return op;
    const scheduler = new _schedulerJs.SyncScheduler();
    const fiberRuntime = unsafeFork(runtime)(effect, {
        scheduler
    });
    scheduler.flush();
    const result = fiberRuntime.unsafePoll();
    if (result) return result;
    return _coreJs.exitDie(_coreJs.capture(asyncFiberException(fiberRuntime), _coreJs.currentSpanFromFiber(fiberRuntime)));
});
const unsafeRunPromise = /*#__PURE__*/ makeDual((runtime, effect, options)=>unsafeRunPromiseExit(runtime, effect, options).then((result)=>{
        switch(result._tag){
            case _effectJs.OP_SUCCESS:
                return result.effect_instruction_i0;
            case _effectJs.OP_FAILURE:
                throw fiberFailure(result.effect_instruction_i0);
        }
    }));
const unsafeRunPromiseExit = /*#__PURE__*/ makeDual((runtime, effect, options)=>new Promise((resolve)=>{
        const op = fastPath(effect);
        if (op) resolve(op);
        const fiber = unsafeFork(runtime)(effect);
        fiber.addObserver((exit)=>{
            resolve(exit);
        });
        if (options?.signal !== undefined) {
            if (options.signal.aborted) fiber.unsafeInterruptAsFork(fiber.id());
            else options.signal.addEventListener("abort", ()=>{
                fiber.unsafeInterruptAsFork(fiber.id());
            }, {
                once: true
            });
        }
    }));
class RuntimeImpl {
    context;
    runtimeFlags;
    fiberRefs;
    constructor(context, runtimeFlags, fiberRefs){
        this.context = context;
        this.runtimeFlags = runtimeFlags;
        this.fiberRefs = fiberRefs;
    }
    pipe() {
        return (0, _pipeableJs.pipeArguments)(this, arguments);
    }
}
const make = (options)=>new RuntimeImpl(options.context, options.runtimeFlags, options.fiberRefs);
const runtime = ()=>_coreJs.withFiberRuntime((state, status)=>_coreJs.succeed(new RuntimeImpl(state.getFiberRef(_coreJs.currentContext), status.runtimeFlags, state.getFiberRefs())));
const defaultRuntimeFlags = /*#__PURE__*/ _runtimeFlagsJs.make(_runtimeFlagsJs.Interruption, _runtimeFlagsJs.CooperativeYielding, _runtimeFlagsJs.RuntimeMetrics);
const defaultRuntime = /*#__PURE__*/ make({
    context: /*#__PURE__*/ _contextJs.empty(),
    runtimeFlags: defaultRuntimeFlags,
    fiberRefs: /*#__PURE__*/ _fiberRefsJs.empty()
});
const updateRuntimeFlags = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>make({
        context: self.context,
        runtimeFlags: f(self.runtimeFlags),
        fiberRefs: self.fiberRefs
    }));
const disableRuntimeFlag = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, flag)=>updateRuntimeFlags(self, _runtimeFlagsJs.disable(flag)));
const enableRuntimeFlag = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, flag)=>updateRuntimeFlags(self, _runtimeFlagsJs.enable(flag)));
const updateContext = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>make({
        context: f(self.context),
        runtimeFlags: self.runtimeFlags,
        fiberRefs: self.fiberRefs
    }));
const provideService = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, tag, service)=>updateContext(self, _contextJs.add(tag, service)));
const updateFiberRefs = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>make({
        context: self.context,
        runtimeFlags: self.runtimeFlags,
        fiberRefs: f(self.fiberRefs)
    }));
const setFiberRef = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, fiberRef, value)=>updateFiberRefs(self, _fiberRefsJs.updateAs({
        fiberId: _fiberIdJs.none,
        fiberRef,
        value
    })));
const deleteFiberRef = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, fiberRef)=>updateFiberRefs(self, _fiberRefsJs.delete(fiberRef)));
const unsafeRunEffect = /*#__PURE__*/ unsafeRunCallback(defaultRuntime);
const unsafeForkEffect = /*#__PURE__*/ unsafeFork(defaultRuntime);
const unsafeRunPromiseEffect = /*#__PURE__*/ unsafeRunPromise(defaultRuntime);
const unsafeRunPromiseExitEffect = /*#__PURE__*/ unsafeRunPromiseExit(defaultRuntime);
const unsafeRunSyncEffect = /*#__PURE__*/ unsafeRunSync(defaultRuntime);
const unsafeRunSyncExitEffect = /*#__PURE__*/ unsafeRunSyncExit(defaultRuntime);
const asyncEffect = (register)=>_coreJs.suspend(()=>{
        let cleanup = undefined;
        return _coreJs.flatMap(_coreJs.deferredMake(), (deferred)=>_coreJs.flatMap(runtime(), (runtime)=>_coreJs.uninterruptibleMask((restore)=>_coreJs.zipRight(_fiberRuntimeJs.fork(restore(_coreJs.matchCauseEffect(register((cb)=>unsafeRunCallback(runtime)(_coreJs.intoDeferred(cb, deferred))), {
                        onFailure: (cause)=>_coreJs.deferredFailCause(deferred, cause),
                        onSuccess: (cleanup_)=>{
                            cleanup = cleanup_;
                            return _coreJs.void;
                        }
                    }))), restore(_coreJs.onInterrupt(_coreJs.deferredAwait(deferred), ()=>cleanup ?? _coreJs.void))))));
    });

},{"../Context.js":"c2abN","../Equal.js":"gA0qD","../Exit.js":"eUJDu","../Fiber.js":"cV03A","../FiberId.js":"4K4GG","../FiberRefs.js":"lIa2I","../Function.js":"21gOL","../Inspectable.js":"1Ur70","../Option.js":"6sHA7","../Pipeable.js":"b5RU2","../Predicate.js":"gW5pd","../Scheduler.js":"hR5Dj","../Scope.js":"kZhIw","./cause.js":"l3ev0","./core.js":"cr3YV","./executionStrategy.js":"hbtwH","./fiberRuntime.js":"2spXK","./fiberScope.js":"f4YSV","./opCodes/effect.js":"9RoDl","./runtimeFlags.js":"9rFhC","./supervisor.js":"bryLt","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"cV03A":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FiberTypeId", ()=>FiberTypeId);
parcelHelpers.export(exports, "RuntimeFiberTypeId", ()=>RuntimeFiberTypeId);
parcelHelpers.export(exports, "Order", ()=>Order);
parcelHelpers.export(exports, "isFiber", ()=>isFiber);
parcelHelpers.export(exports, "isRuntimeFiber", ()=>isRuntimeFiber);
parcelHelpers.export(exports, "id", ()=>id);
parcelHelpers.export(exports, "await", ()=>/**
 * Awaits the fiber, which suspends the awaiting fiber until the result of the
 * fiber has been determined.
 *
 * @since 2.0.0
 * @category getters
 */ _await);
parcelHelpers.export(exports, "awaitAll", ()=>awaitAll);
parcelHelpers.export(exports, "children", ()=>children);
parcelHelpers.export(exports, "all", ()=>all);
parcelHelpers.export(exports, "done", ()=>done);
parcelHelpers.export(exports, "dump", ()=>dump);
parcelHelpers.export(exports, "dumpAll", ()=>dumpAll);
parcelHelpers.export(exports, "fail", ()=>fail);
parcelHelpers.export(exports, "failCause", ()=>failCause);
parcelHelpers.export(exports, "fromEffect", ()=>fromEffect);
parcelHelpers.export(exports, "getCurrentFiber", ()=>getCurrentFiber);
parcelHelpers.export(exports, "inheritAll", ()=>inheritAll);
parcelHelpers.export(exports, "interrupt", ()=>interrupt);
parcelHelpers.export(exports, "interrupted", ()=>interrupted);
parcelHelpers.export(exports, "interruptAs", ()=>interruptAs);
parcelHelpers.export(exports, "interruptAsFork", ()=>interruptAsFork);
parcelHelpers.export(exports, "interruptAll", ()=>interruptAll);
parcelHelpers.export(exports, "interruptAllAs", ()=>interruptAllAs);
parcelHelpers.export(exports, "interruptFork", ()=>interruptFork);
parcelHelpers.export(exports, "join", ()=>join);
parcelHelpers.export(exports, "joinAll", ()=>joinAll);
parcelHelpers.export(exports, "map", ()=>map);
parcelHelpers.export(exports, "mapEffect", ()=>mapEffect);
parcelHelpers.export(exports, "mapFiber", ()=>mapFiber);
parcelHelpers.export(exports, "match", ()=>match);
parcelHelpers.export(exports, "never", ()=>never);
parcelHelpers.export(exports, "orElse", ()=>orElse);
parcelHelpers.export(exports, "orElseEither", ()=>orElseEither);
parcelHelpers.export(exports, "poll", ()=>poll);
parcelHelpers.export(exports, "pretty", ()=>pretty);
parcelHelpers.export(exports, "roots", ()=>roots);
parcelHelpers.export(exports, "unsafeRoots", ()=>unsafeRoots);
parcelHelpers.export(exports, "scoped", ()=>scoped);
parcelHelpers.export(exports, "status", ()=>status);
parcelHelpers.export(exports, "succeed", ()=>succeed);
parcelHelpers.export(exports, "void", ()=>/**
 * A fiber that has already succeeded with unit.
 *
 * @since 2.0.0
 * @category constructors
 */ void_);
parcelHelpers.export(exports, "zip", ()=>zip);
parcelHelpers.export(exports, "zipLeft", ()=>zipLeft);
parcelHelpers.export(exports, "zipRight", ()=>zipRight);
parcelHelpers.export(exports, "zipWith", ()=>zipWith);
var _coreJs = require("./internal/core.js");
var _circularJs = require("./internal/effect/circular.js");
var _fiberJs = require("./internal/fiber.js");
var _fiberRuntimeJs = require("./internal/fiberRuntime.js");
const FiberTypeId = _fiberJs.FiberTypeId;
const RuntimeFiberTypeId = _fiberJs.RuntimeFiberTypeId;
const Order = _fiberJs.Order;
const isFiber = _fiberJs.isFiber;
const isRuntimeFiber = _fiberJs.isRuntimeFiber;
const id = _fiberJs.id;
const _await = _fiberJs._await;
const awaitAll = _fiberRuntimeJs.fiberAwaitAll;
const children = _fiberJs.children;
const all = _fiberRuntimeJs.fiberAll;
const done = _fiberJs.done;
const dump = _fiberJs.dump;
const dumpAll = _fiberJs.dumpAll;
const fail = _fiberJs.fail;
const failCause = _fiberJs.failCause;
const fromEffect = _fiberJs.fromEffect;
const getCurrentFiber = _fiberJs.getCurrentFiber;
const inheritAll = _fiberJs.inheritAll;
const interrupt = _coreJs.interruptFiber;
const interrupted = _fiberJs.interrupted;
const interruptAs = _coreJs.interruptAsFiber;
const interruptAsFork = _fiberJs.interruptAsFork;
const interruptAll = _fiberJs.interruptAll;
const interruptAllAs = _fiberJs.interruptAllAs;
const interruptFork = _fiberRuntimeJs.fiberInterruptFork;
const join = _fiberJs.join;
const joinAll = _fiberRuntimeJs.fiberJoinAll;
const map = _fiberJs.map;
const mapEffect = _fiberJs.mapEffect;
const mapFiber = _fiberJs.mapFiber;
const match = _fiberJs.match;
const never = _fiberJs.never;
const orElse = _fiberJs.orElse;
const orElseEither = _fiberJs.orElseEither;
const poll = _fiberJs.poll;
const pretty = _fiberJs.pretty;
const roots = _fiberJs.roots;
const unsafeRoots = _fiberJs.unsafeRoots;
const scoped = _fiberRuntimeJs.fiberScoped;
const status = _fiberJs.status;
const succeed = _fiberJs.succeed;
const void_ = _fiberJs.void;
const zip = _circularJs.zipFiber;
const zipLeft = _circularJs.zipLeftFiber;
const zipRight = _circularJs.zipRightFiber;
const zipWith = _circularJs.zipWithFiber;

},{"./internal/core.js":"cr3YV","./internal/effect/circular.js":"VvDt4","./internal/fiber.js":"65P25","./internal/fiberRuntime.js":"2spXK","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"cDm3c":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getAndUpdateEffect", ()=>getAndUpdateEffect);
parcelHelpers.export(exports, "getAndUpdateSomeEffect", ()=>getAndUpdateSomeEffect);
parcelHelpers.export(exports, "modify", ()=>modify);
parcelHelpers.export(exports, "modifyEffect", ()=>modifyEffect);
parcelHelpers.export(exports, "modifySomeEffect", ()=>modifySomeEffect);
parcelHelpers.export(exports, "updateEffect", ()=>updateEffect);
parcelHelpers.export(exports, "updateAndGetEffect", ()=>updateAndGetEffect);
parcelHelpers.export(exports, "updateSomeEffect", ()=>updateSomeEffect);
var _functionJs = require("../Function.js");
var _optionJs = require("../Option.js");
var _coreJs = require("./core.js");
const getAndUpdateEffect = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>self.modifyEffect((value)=>_coreJs.map(f(value), (result)=>[
                value,
                result
            ])));
const getAndUpdateSomeEffect = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, pf)=>self.modifyEffect((value)=>{
        const result = pf(value);
        switch(result._tag){
            case "None":
                return _coreJs.succeed([
                    value,
                    value
                ]);
            case "Some":
                return _coreJs.map(result.value, (newValue)=>[
                        value,
                        newValue
                    ]);
        }
    }));
const modify = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>self.modify(f));
const modifyEffect = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>self.modifyEffect(f));
const modifySomeEffect = /*#__PURE__*/ (0, _functionJs.dual)(3, (self, fallback, pf)=>self.modifyEffect((value)=>(0, _functionJs.pipe)(pf(value), _optionJs.getOrElse(()=>_coreJs.succeed([
                fallback,
                value
            ])))));
const updateEffect = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>self.modifyEffect((value)=>_coreJs.map(f(value), (result)=>[
                undefined,
                result
            ])));
const updateAndGetEffect = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>self.modifyEffect((value)=>_coreJs.map(f(value), (result)=>[
                result,
                result
            ])));
const updateSomeEffect = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, pf)=>self.modifyEffect((value)=>{
        const result = pf(value);
        switch(result._tag){
            case "None":
                return _coreJs.succeed([
                    void 0,
                    value
                ]);
            case "Some":
                return _coreJs.map(result.value, (a)=>[
                        void 0,
                        a
                    ]);
        }
    }));

},{"../Function.js":"21gOL","../Option.js":"6sHA7","./core.js":"cr3YV","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"4BGGH":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "currentCache", ()=>currentCache);
parcelHelpers.export(exports, "currentCacheEnabled", ()=>currentCacheEnabled);
parcelHelpers.export(exports, "fromRequest", ()=>fromRequest);
parcelHelpers.export(exports, "cacheRequest", ()=>cacheRequest);
parcelHelpers.export(exports, "withRequestCaching", ()=>withRequestCaching);
parcelHelpers.export(exports, "withRequestCache", ()=>withRequestCache);
var _durationJs = require("../Duration.js");
var _functionJs = require("../Function.js");
var _globalValueJs = require("../GlobalValue.js");
var _blockedRequestsJs = require("./blockedRequests.js");
var _cacheJs = require("./cache.js");
var _coreJs = require("./core.js");
var _fiberRuntimeJs = require("./fiberRuntime.js");
var _requestJs = require("./request.js");
const currentCache = /*#__PURE__*/ (0, _globalValueJs.globalValue)(/*#__PURE__*/ Symbol.for("effect/FiberRef/currentCache"), ()=>_coreJs.fiberRefUnsafeMake((0, _cacheJs.unsafeMakeWith)(65536, ()=>_coreJs.map(_coreJs.deferredMake(), (handle)=>({
                listeners: new (0, _requestJs.Listeners)(),
                handle
            })), ()=>(0, _durationJs.seconds)(60))));
const currentCacheEnabled = /*#__PURE__*/ (0, _globalValueJs.globalValue)(/*#__PURE__*/ Symbol.for("effect/FiberRef/currentCacheEnabled"), ()=>_coreJs.fiberRefUnsafeMake(false));
const fromRequest = (request, dataSource)=>_coreJs.flatMap(_coreJs.isEffect(dataSource) ? dataSource : _coreJs.succeed(dataSource), (ds)=>_coreJs.fiberIdWith((id)=>{
            const proxy = new Proxy(request, {});
            return _coreJs.fiberRefGetWith(currentCacheEnabled, (cacheEnabled)=>{
                if (cacheEnabled) {
                    const cached = _coreJs.fiberRefGetWith(currentCache, (cache)=>_coreJs.flatMap(cache.getEither(proxy), (orNew)=>{
                            switch(orNew._tag){
                                case "Left":
                                    if (orNew.left.listeners.interrupted) return _coreJs.flatMap(cache.invalidateWhen(proxy, (entry)=>entry.handle === orNew.left.handle), ()=>cached);
                                    orNew.left.listeners.increment();
                                    return _coreJs.uninterruptibleMask((restore)=>_coreJs.flatMap(_coreJs.exit(_coreJs.blocked(_blockedRequestsJs.empty, restore(_coreJs.deferredAwait(orNew.left.handle)))), (exit)=>{
                                            orNew.left.listeners.decrement();
                                            return exit;
                                        }));
                                case "Right":
                                    orNew.right.listeners.increment();
                                    return _coreJs.uninterruptibleMask((restore)=>_coreJs.flatMap(_coreJs.exit(_coreJs.blocked(_blockedRequestsJs.single(ds, _blockedRequestsJs.makeEntry({
                                            request: proxy,
                                            result: orNew.right.handle,
                                            listeners: orNew.right.listeners,
                                            ownerId: id,
                                            state: {
                                                completed: false
                                            }
                                        })), restore(_coreJs.deferredAwait(orNew.right.handle)))), ()=>{
                                            orNew.right.listeners.decrement();
                                            return _coreJs.deferredAwait(orNew.right.handle);
                                        }));
                            }
                        }));
                    return cached;
                }
                const listeners = new (0, _requestJs.Listeners)();
                listeners.increment();
                return _coreJs.flatMap(_coreJs.deferredMake(), (ref)=>(0, _fiberRuntimeJs.ensuring)(_coreJs.blocked(_blockedRequestsJs.single(ds, _blockedRequestsJs.makeEntry({
                        request: proxy,
                        result: ref,
                        listeners,
                        ownerId: id,
                        state: {
                            completed: false
                        }
                    })), _coreJs.deferredAwait(ref)), _coreJs.sync(()=>listeners.decrement())));
            });
        }));
const cacheRequest = (request, result)=>{
    return _coreJs.fiberRefGetWith(currentCacheEnabled, (cacheEnabled)=>{
        if (cacheEnabled) return _coreJs.fiberRefGetWith(currentCache, (cache)=>_coreJs.flatMap(cache.getEither(request), (orNew)=>{
                switch(orNew._tag){
                    case "Left":
                        return _coreJs.void;
                    case "Right":
                        return _coreJs.deferredComplete(orNew.right.handle, result);
                }
            }));
        return _coreJs.void;
    });
};
const withRequestCaching = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, strategy)=>_coreJs.fiberRefLocally(self, currentCacheEnabled, strategy));
const withRequestCache = /*#__PURE__*/ (0, _functionJs.dual)(2, // @ts-expect-error
(self, cache)=>_coreJs.fiberRefLocally(self, currentCache, cache));

},{"../Duration.js":"czLLe","../Function.js":"21gOL","../GlobalValue.js":"5w3Hn","./blockedRequests.js":"2UYO5","./cache.js":"7groi","./core.js":"cr3YV","./fiberRuntime.js":"2spXK","./request.js":"j7pmc","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"7groi":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "complete", ()=>complete);
parcelHelpers.export(exports, "pending", ()=>pending);
parcelHelpers.export(exports, "refreshing", ()=>refreshing);
parcelHelpers.export(exports, "MapKeyTypeId", ()=>MapKeyTypeId);
parcelHelpers.export(exports, "makeMapKey", ()=>makeMapKey);
parcelHelpers.export(exports, "isMapKey", ()=>isMapKey);
parcelHelpers.export(exports, "makeKeySet", ()=>makeKeySet);
parcelHelpers.export(exports, "makeCacheState", ()=>makeCacheState);
parcelHelpers.export(exports, "initialCacheState", ()=>initialCacheState);
parcelHelpers.export(exports, "CacheTypeId", ()=>CacheTypeId);
parcelHelpers.export(exports, "ConsumerCacheTypeId", ()=>ConsumerCacheTypeId);
parcelHelpers.export(exports, "makeCacheStats", ()=>makeCacheStats);
parcelHelpers.export(exports, "makeEntryStats", ()=>makeEntryStats);
parcelHelpers.export(exports, "make", ()=>make);
parcelHelpers.export(exports, "makeWith", ()=>makeWith);
parcelHelpers.export(exports, "unsafeMakeWith", ()=>unsafeMakeWith);
var _contextJs = require("../Context.js");
var _deferredJs = require("../Deferred.js");
var _durationJs = require("../Duration.js");
var _eitherJs = require("../Either.js");
var _equalJs = require("../Equal.js");
var _exitJs = require("../Exit.js");
var _functionJs = require("../Function.js");
var _hashJs = require("../Hash.js");
var _mutableHashMapJs = require("../MutableHashMap.js");
var _mutableQueueJs = require("../MutableQueue.js");
var _mutableRefJs = require("../MutableRef.js");
var _optionJs = require("../Option.js");
var _predicateJs = require("../Predicate.js");
var _coreEffectJs = require("./core-effect.js");
var _coreJs = require("./core.js");
var _dataJs = require("./data.js");
var _fiberIdJs = require("./fiberId.js");
var _fiberRuntimeJs = require("./fiberRuntime.js");
const complete = (key, exit, entryStats, timeToLiveMillis)=>_dataJs.struct({
        _tag: "Complete",
        key,
        exit,
        entryStats,
        timeToLiveMillis
    });
const pending = (key, deferred)=>_dataJs.struct({
        _tag: "Pending",
        key,
        deferred
    });
const refreshing = (deferred, complete)=>_dataJs.struct({
        _tag: "Refreshing",
        deferred,
        complete
    });
const MapKeyTypeId = /*#__PURE__*/ Symbol.for("effect/Cache/MapKey");
class MapKeyImpl {
    current;
    [MapKeyTypeId] = MapKeyTypeId;
    previous = undefined;
    next = undefined;
    constructor(current){
        this.current = current;
    }
    [_hashJs.symbol]() {
        return (0, _functionJs.pipe)(_hashJs.hash(this.current), _hashJs.combine(_hashJs.hash(this.previous)), _hashJs.combine(_hashJs.hash(this.next)), _hashJs.cached(this));
    }
    [_equalJs.symbol](that) {
        if (this === that) return true;
        return isMapKey(that) && _equalJs.equals(this.current, that.current) && _equalJs.equals(this.previous, that.previous) && _equalJs.equals(this.next, that.next);
    }
}
const makeMapKey = (current)=>new MapKeyImpl(current);
const isMapKey = (u)=>(0, _predicateJs.hasProperty)(u, MapKeyTypeId);
class KeySetImpl {
    head = undefined;
    tail = undefined;
    add(key) {
        if (key !== this.tail) {
            if (this.tail === undefined) {
                this.head = key;
                this.tail = key;
            } else {
                const previous = key.previous;
                const next = key.next;
                if (next !== undefined) {
                    key.next = undefined;
                    if (previous !== undefined) {
                        previous.next = next;
                        next.previous = previous;
                    } else {
                        this.head = next;
                        this.head.previous = undefined;
                    }
                }
                this.tail.next = key;
                key.previous = this.tail;
                this.tail = key;
            }
        }
    }
    remove() {
        const key = this.head;
        if (key !== undefined) {
            const next = key.next;
            if (next !== undefined) {
                key.next = undefined;
                this.head = next;
                this.head.previous = undefined;
            } else {
                this.head = undefined;
                this.tail = undefined;
            }
        }
        return key;
    }
}
const makeKeySet = ()=>new KeySetImpl();
const makeCacheState = (map, keys, accesses, updating, hits, misses)=>({
        map,
        keys,
        accesses,
        updating,
        hits,
        misses
    });
const initialCacheState = ()=>makeCacheState(_mutableHashMapJs.empty(), makeKeySet(), _mutableQueueJs.unbounded(), _mutableRefJs.make(false), 0, 0);
/** @internal */ const CacheSymbolKey = "effect/Cache";
const CacheTypeId = /*#__PURE__*/ Symbol.for(CacheSymbolKey);
const cacheVariance = {
    /* c8 ignore next */ _Key: (_)=>_,
    /* c8 ignore next */ _Error: (_)=>_,
    /* c8 ignore next */ _Value: (_)=>_
};
/** @internal */ const ConsumerCacheSymbolKey = "effect/ConsumerCache";
const ConsumerCacheTypeId = /*#__PURE__*/ Symbol.for(ConsumerCacheSymbolKey);
const consumerCacheVariance = {
    /* c8 ignore next */ _Key: (_)=>_,
    /* c8 ignore next */ _Error: (_)=>_,
    /* c8 ignore next */ _Value: (_)=>_
};
const makeCacheStats = (options)=>options;
const makeEntryStats = (loadedMillis)=>({
        loadedMillis
    });
class CacheImpl {
    capacity;
    context;
    fiberId;
    lookup;
    timeToLive;
    [CacheTypeId] = cacheVariance;
    [ConsumerCacheTypeId] = consumerCacheVariance;
    cacheState;
    constructor(capacity, context, fiberId, lookup, timeToLive){
        this.capacity = capacity;
        this.context = context;
        this.fiberId = fiberId;
        this.lookup = lookup;
        this.timeToLive = timeToLive;
        this.cacheState = initialCacheState();
    }
    get(key) {
        return _coreJs.map(this.getEither(key), _eitherJs.merge);
    }
    get cacheStats() {
        return _coreJs.sync(()=>makeCacheStats({
                hits: this.cacheState.hits,
                misses: this.cacheState.misses,
                size: _mutableHashMapJs.size(this.cacheState.map)
            }));
    }
    getOption(key) {
        return _coreJs.suspend(()=>_optionJs.match(_mutableHashMapJs.get(this.cacheState.map, key), {
                onNone: ()=>{
                    const mapKey = makeMapKey(key);
                    this.trackAccess(mapKey);
                    this.trackMiss();
                    return _coreJs.succeed(_optionJs.none());
                },
                onSome: (value)=>this.resolveMapValue(value)
            }));
    }
    getOptionComplete(key) {
        return _coreJs.suspend(()=>_optionJs.match(_mutableHashMapJs.get(this.cacheState.map, key), {
                onNone: ()=>{
                    const mapKey = makeMapKey(key);
                    this.trackAccess(mapKey);
                    this.trackMiss();
                    return _coreJs.succeed(_optionJs.none());
                },
                onSome: (value)=>this.resolveMapValue(value, true)
            }));
    }
    contains(key) {
        return _coreJs.sync(()=>_mutableHashMapJs.has(this.cacheState.map, key));
    }
    entryStats(key) {
        return _coreJs.sync(()=>{
            const option = _mutableHashMapJs.get(this.cacheState.map, key);
            if (_optionJs.isSome(option)) switch(option.value._tag){
                case "Complete":
                    {
                        const loaded = option.value.entryStats.loadedMillis;
                        return _optionJs.some(makeEntryStats(loaded));
                    }
                case "Pending":
                    return _optionJs.none();
                case "Refreshing":
                    {
                        const loaded = option.value.complete.entryStats.loadedMillis;
                        return _optionJs.some(makeEntryStats(loaded));
                    }
            }
            return _optionJs.none();
        });
    }
    getEither(key) {
        return _coreJs.suspend(()=>{
            const k = key;
            let mapKey = undefined;
            let deferred = undefined;
            let value = _optionJs.getOrUndefined(_mutableHashMapJs.get(this.cacheState.map, k));
            if (value === undefined) {
                deferred = _deferredJs.unsafeMake(this.fiberId);
                mapKey = makeMapKey(k);
                if (_mutableHashMapJs.has(this.cacheState.map, k)) value = _optionJs.getOrUndefined(_mutableHashMapJs.get(this.cacheState.map, k));
                else _mutableHashMapJs.set(this.cacheState.map, k, pending(mapKey, deferred));
            }
            if (value === undefined) {
                this.trackAccess(mapKey);
                this.trackMiss();
                return _coreJs.map(this.lookupValueOf(key, deferred), _eitherJs.right);
            } else return _coreJs.flatMap(this.resolveMapValue(value), _optionJs.match({
                onNone: ()=>this.getEither(key),
                onSome: (value)=>_coreJs.succeed(_eitherJs.left(value))
            }));
        });
    }
    invalidate(key) {
        return _coreJs.sync(()=>{
            _mutableHashMapJs.remove(this.cacheState.map, key);
        });
    }
    invalidateWhen(key, when) {
        return _coreJs.sync(()=>{
            const value = _mutableHashMapJs.get(this.cacheState.map, key);
            if (_optionJs.isSome(value) && value.value._tag === "Complete") {
                if (value.value.exit._tag === "Success") {
                    if (when(value.value.exit.value)) _mutableHashMapJs.remove(this.cacheState.map, key);
                }
            }
        });
    }
    get invalidateAll() {
        return _coreJs.sync(()=>{
            this.cacheState.map = _mutableHashMapJs.empty();
        });
    }
    refresh(key) {
        return _coreEffectJs.clockWith((clock)=>_coreJs.suspend(()=>{
                const k = key;
                const deferred = _deferredJs.unsafeMake(this.fiberId);
                let value = _optionJs.getOrUndefined(_mutableHashMapJs.get(this.cacheState.map, k));
                if (value === undefined) {
                    if (_mutableHashMapJs.has(this.cacheState.map, k)) value = _optionJs.getOrUndefined(_mutableHashMapJs.get(this.cacheState.map, k));
                    else _mutableHashMapJs.set(this.cacheState.map, k, pending(makeMapKey(k), deferred));
                }
                if (value === undefined) return _coreJs.asVoid(this.lookupValueOf(key, deferred));
                else switch(value._tag){
                    case "Complete":
                        if (this.hasExpired(clock, value.timeToLiveMillis)) {
                            const found = _optionJs.getOrUndefined(_mutableHashMapJs.get(this.cacheState.map, k));
                            if (_equalJs.equals(found, value)) _mutableHashMapJs.remove(this.cacheState.map, k);
                            return _coreJs.asVoid(this.get(key));
                        }
                        // Only trigger the lookup if we're still the current value, `completedResult`
                        return (0, _functionJs.pipe)(this.lookupValueOf(key, deferred), _coreEffectJs.when(()=>{
                            const current = _optionJs.getOrUndefined(_mutableHashMapJs.get(this.cacheState.map, k));
                            if (_equalJs.equals(current, value)) {
                                const mapValue = refreshing(deferred, value);
                                _mutableHashMapJs.set(this.cacheState.map, k, mapValue);
                                return true;
                            }
                            return false;
                        }), _coreJs.asVoid);
                    case "Pending":
                        return _deferredJs.await(value.deferred);
                    case "Refreshing":
                        return _deferredJs.await(value.deferred);
                }
            }));
    }
    set(key, value) {
        return _coreEffectJs.clockWith((clock)=>_coreJs.sync(()=>{
                const now = clock.unsafeCurrentTimeMillis();
                const k = key;
                const lookupResult = _exitJs.succeed(value);
                const mapValue = complete(makeMapKey(k), lookupResult, makeEntryStats(now), now + _durationJs.toMillis(_durationJs.decode(this.timeToLive(lookupResult))));
                _mutableHashMapJs.set(this.cacheState.map, k, mapValue);
            }));
    }
    get size() {
        return _coreJs.sync(()=>{
            return _mutableHashMapJs.size(this.cacheState.map);
        });
    }
    get values() {
        return _coreJs.sync(()=>{
            const values = [];
            for (const entry of this.cacheState.map)if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") values.push(entry[1].exit.value);
            return values;
        });
    }
    get entries() {
        return _coreJs.sync(()=>{
            const values = [];
            for (const entry of this.cacheState.map)if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") values.push([
                entry[0],
                entry[1].exit.value
            ]);
            return values;
        });
    }
    get keys() {
        return _coreJs.sync(()=>{
            const keys = [];
            for (const entry of this.cacheState.map)if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") keys.push(entry[0]);
            return keys;
        });
    }
    resolveMapValue(value, ignorePending = false) {
        return _coreEffectJs.clockWith((clock)=>{
            switch(value._tag){
                case "Complete":
                    this.trackAccess(value.key);
                    if (this.hasExpired(clock, value.timeToLiveMillis)) {
                        _mutableHashMapJs.remove(this.cacheState.map, value.key.current);
                        return _coreJs.succeed(_optionJs.none());
                    }
                    this.trackHit();
                    return _coreJs.map(value.exit, _optionJs.some);
                case "Pending":
                    this.trackAccess(value.key);
                    this.trackHit();
                    if (ignorePending) return _coreJs.succeed(_optionJs.none());
                    return _coreJs.map(_deferredJs.await(value.deferred), _optionJs.some);
                case "Refreshing":
                    this.trackAccess(value.complete.key);
                    this.trackHit();
                    if (this.hasExpired(clock, value.complete.timeToLiveMillis)) {
                        if (ignorePending) return _coreJs.succeed(_optionJs.none());
                        return _coreJs.map(_deferredJs.await(value.deferred), _optionJs.some);
                    }
                    return _coreJs.map(value.complete.exit, _optionJs.some);
            }
        });
    }
    trackHit() {
        this.cacheState.hits = this.cacheState.hits + 1;
    }
    trackMiss() {
        this.cacheState.misses = this.cacheState.misses + 1;
    }
    trackAccess(key) {
        _mutableQueueJs.offer(this.cacheState.accesses, key);
        if (_mutableRefJs.compareAndSet(this.cacheState.updating, false, true)) {
            let loop = true;
            while(loop){
                const key = _mutableQueueJs.poll(this.cacheState.accesses, _mutableQueueJs.EmptyMutableQueue);
                if (key === _mutableQueueJs.EmptyMutableQueue) loop = false;
                else this.cacheState.keys.add(key);
            }
            let size = _mutableHashMapJs.size(this.cacheState.map);
            loop = size > this.capacity;
            while(loop){
                const key = this.cacheState.keys.remove();
                if (key !== undefined) {
                    if (_mutableHashMapJs.has(this.cacheState.map, key.current)) {
                        _mutableHashMapJs.remove(this.cacheState.map, key.current);
                        size = size - 1;
                        loop = size > this.capacity;
                    }
                } else loop = false;
            }
            _mutableRefJs.set(this.cacheState.updating, false);
        }
    }
    hasExpired(clock, timeToLiveMillis) {
        return clock.unsafeCurrentTimeMillis() > timeToLiveMillis;
    }
    lookupValueOf(input, deferred) {
        return _coreEffectJs.clockWith((clock)=>_coreJs.suspend(()=>{
                const key = input;
                return (0, _functionJs.pipe)(this.lookup(input), _coreJs.provideContext(this.context), _coreJs.exit, _coreJs.flatMap((exit)=>{
                    const now = clock.unsafeCurrentTimeMillis();
                    const stats = makeEntryStats(now);
                    const value = complete(makeMapKey(key), exit, stats, now + _durationJs.toMillis(_durationJs.decode(this.timeToLive(exit))));
                    _mutableHashMapJs.set(this.cacheState.map, key, value);
                    return _coreJs.zipRight(_deferredJs.done(deferred, exit), exit);
                }), _coreJs.onInterrupt(()=>_coreJs.zipRight(_deferredJs.interrupt(deferred), _coreJs.sync(()=>{
                        _mutableHashMapJs.remove(this.cacheState.map, key);
                    }))));
            }));
    }
}
const make = (options)=>{
    const timeToLive = _durationJs.decode(options.timeToLive);
    return makeWith({
        capacity: options.capacity,
        lookup: options.lookup,
        timeToLive: ()=>timeToLive
    });
};
const makeWith = (options)=>_coreJs.map(_fiberRuntimeJs.all([
        _coreJs.context(),
        _coreJs.fiberId
    ]), ([context, fiberId])=>new CacheImpl(options.capacity, context, fiberId, options.lookup, (exit)=>_durationJs.decode(options.timeToLive(exit))));
const unsafeMakeWith = (capacity, lookup, timeToLive)=>new CacheImpl(capacity, _contextJs.empty(), (0, _fiberIdJs.none), lookup, (exit)=>_durationJs.decode(timeToLive(exit)));

},{"../Context.js":"c2abN","../Deferred.js":"cfKDq","../Duration.js":"czLLe","../Either.js":"4amnT","../Equal.js":"gA0qD","../Exit.js":"eUJDu","../Function.js":"21gOL","../Hash.js":"gFMwE","../MutableHashMap.js":"1goeS","../MutableQueue.js":"bknoK","../MutableRef.js":"aCyaL","../Option.js":"6sHA7","../Predicate.js":"gW5pd","./core-effect.js":"k8F3C","./core.js":"cr3YV","./data.js":"fk0Pw","./fiberId.js":"azUa1","./fiberRuntime.js":"2spXK","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"bknoK":[function(require,module,exports,__globalThis) {
/**
 * @since 2.0.0
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EmptyMutableQueue", ()=>EmptyMutableQueue);
parcelHelpers.export(exports, "bounded", ()=>bounded);
parcelHelpers.export(exports, "unbounded", ()=>unbounded);
parcelHelpers.export(exports, "length", ()=>length);
parcelHelpers.export(exports, "isEmpty", ()=>isEmpty);
parcelHelpers.export(exports, "isFull", ()=>isFull);
parcelHelpers.export(exports, "capacity", ()=>capacity);
parcelHelpers.export(exports, "offer", ()=>offer);
parcelHelpers.export(exports, "offerAll", ()=>offerAll);
parcelHelpers.export(exports, "poll", ()=>poll);
parcelHelpers.export(exports, "pollUpTo", ()=>pollUpTo);
var _chunkJs = require("./Chunk.js");
var _functionJs = require("./Function.js");
var _inspectableJs = require("./Inspectable.js");
var _mutableListJs = require("./MutableList.js");
var _pipeableJs = require("./Pipeable.js");
const TypeId = /*#__PURE__*/ Symbol.for("effect/MutableQueue");
const EmptyMutableQueue = /*#__PURE__*/ Symbol.for("effect/mutable/MutableQueue/Empty");
const MutableQueueProto = {
    [TypeId]: TypeId,
    [Symbol.iterator] () {
        return Array.from(this.queue)[Symbol.iterator]();
    },
    toString () {
        return (0, _inspectableJs.format)(this.toJSON());
    },
    toJSON () {
        return {
            _id: "MutableQueue",
            values: Array.from(this).map((0, _inspectableJs.toJSON))
        };
    },
    [(0, _inspectableJs.NodeInspectSymbol)] () {
        return this.toJSON();
    },
    pipe () {
        return (0, _pipeableJs.pipeArguments)(this, arguments);
    }
};
const make = (capacity)=>{
    const queue = Object.create(MutableQueueProto);
    queue.queue = _mutableListJs.empty();
    queue.capacity = capacity;
    return queue;
};
const bounded = (capacity)=>make(capacity);
const unbounded = ()=>make(undefined);
const length = (self)=>_mutableListJs.length(self.queue);
const isEmpty = (self)=>_mutableListJs.isEmpty(self.queue);
const isFull = (self)=>self.capacity === undefined ? false : _mutableListJs.length(self.queue) === self.capacity;
const capacity = (self)=>self.capacity === undefined ? Infinity : self.capacity;
const offer = /*#__PURE__*/ _functionJs.dual(2, (self, value)=>{
    const queueLength = _mutableListJs.length(self.queue);
    if (self.capacity !== undefined && queueLength === self.capacity) return false;
    _mutableListJs.append(value)(self.queue);
    return true;
});
const offerAll = /*#__PURE__*/ _functionJs.dual(2, (self, values)=>{
    const iterator = values[Symbol.iterator]();
    let next;
    let remainder = _chunkJs.empty();
    let offering = true;
    while(offering && (next = iterator.next()) && !next.done)offering = offer(next.value)(self);
    while(next != null && !next.done){
        remainder = _chunkJs.prepend(next.value)(remainder);
        next = iterator.next();
    }
    return _chunkJs.reverse(remainder);
});
const poll = /*#__PURE__*/ _functionJs.dual(2, (self, def)=>{
    if (_mutableListJs.isEmpty(self.queue)) return def;
    return _mutableListJs.shift(self.queue);
});
const pollUpTo = /*#__PURE__*/ _functionJs.dual(2, (self, n)=>{
    let result = _chunkJs.empty();
    let count = 0;
    while(count < n){
        const element = poll(EmptyMutableQueue)(self);
        if (element === EmptyMutableQueue) break;
        result = _chunkJs.prepend(element)(result);
        count += 1;
    }
    return _chunkJs.reverse(result);
});

},{"./Chunk.js":"dL1OO","./Function.js":"21gOL","./Inspectable.js":"1Ur70","./MutableList.js":"7t3bH","./Pipeable.js":"b5RU2","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"7t3bH":[function(require,module,exports,__globalThis) {
/**
 * @since 2.0.0
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "empty", ()=>empty);
parcelHelpers.export(exports, "fromIterable", ()=>fromIterable);
parcelHelpers.export(exports, "make", ()=>make);
parcelHelpers.export(exports, "isEmpty", ()=>isEmpty);
parcelHelpers.export(exports, "length", ()=>length);
parcelHelpers.export(exports, "tail", ()=>tail);
parcelHelpers.export(exports, "head", ()=>head);
parcelHelpers.export(exports, "forEach", ()=>forEach);
parcelHelpers.export(exports, "reset", ()=>reset);
parcelHelpers.export(exports, "append", ()=>append);
parcelHelpers.export(exports, "shift", ()=>shift);
parcelHelpers.export(exports, "pop", ()=>pop);
parcelHelpers.export(exports, "prepend", ()=>prepend);
var _functionJs = require("./Function.js");
var _inspectableJs = require("./Inspectable.js");
var _pipeableJs = require("./Pipeable.js");
const TypeId = /*#__PURE__*/ Symbol.for("effect/MutableList");
const MutableListProto = {
    [TypeId]: TypeId,
    [Symbol.iterator] () {
        let done = false;
        let head = this.head;
        return {
            next () {
                if (done) return this.return();
                if (head == null) {
                    done = true;
                    return this.return();
                }
                const value = head.value;
                head = head.next;
                return {
                    done,
                    value
                };
            },
            return (value) {
                if (!done) done = true;
                return {
                    done: true,
                    value
                };
            }
        };
    },
    toString () {
        return (0, _inspectableJs.format)(this.toJSON());
    },
    toJSON () {
        return {
            _id: "MutableList",
            values: Array.from(this).map((0, _inspectableJs.toJSON))
        };
    },
    [(0, _inspectableJs.NodeInspectSymbol)] () {
        return this.toJSON();
    },
    pipe () {
        return (0, _pipeableJs.pipeArguments)(this, arguments);
    }
};
/** @internal */ const makeNode = (value)=>({
        value,
        removed: false,
        prev: undefined,
        next: undefined
    });
const empty = ()=>{
    const list = Object.create(MutableListProto);
    list.head = undefined;
    list.tail = undefined;
    list._length = 0;
    return list;
};
const fromIterable = (iterable)=>{
    const list = empty();
    for (const element of iterable)append(list, element);
    return list;
};
const make = (...elements)=>fromIterable(elements);
const isEmpty = (self)=>length(self) === 0;
const length = (self)=>self._length;
const tail = (self)=>self.tail === undefined ? undefined : self.tail.value;
const head = (self)=>self.head === undefined ? undefined : self.head.value;
const forEach = /*#__PURE__*/ _functionJs.dual(2, (self, f)=>{
    let current = self.head;
    while(current !== undefined){
        f(current.value);
        current = current.next;
    }
});
const reset = (self)=>{
    self._length = 0;
    self.head = undefined;
    self.tail = undefined;
    return self;
};
const append = /*#__PURE__*/ _functionJs.dual(2, (self, value)=>{
    const node = makeNode(value);
    if (self.head === undefined) self.head = node;
    if (self.tail === undefined) self.tail = node;
    else {
        self.tail.next = node;
        node.prev = self.tail;
        self.tail = node;
    }
    self._length += 1;
    return self;
});
const shift = (self)=>{
    const head = self.head;
    if (head !== undefined) {
        remove(self, head);
        return head.value;
    }
    return undefined;
};
const pop = (self)=>{
    const tail = self.tail;
    if (tail !== undefined) {
        remove(self, tail);
        return tail.value;
    }
    return undefined;
};
const prepend = /*#__PURE__*/ _functionJs.dual(2, (self, value)=>{
    const node = makeNode(value);
    node.next = self.head;
    if (self.head !== undefined) self.head.prev = node;
    self.head = node;
    if (self.tail === undefined) self.tail = node;
    self._length += 1;
    return self;
});
const remove = (self, node)=>{
    if (node.removed) return;
    node.removed = true;
    if (node.prev !== undefined && node.next !== undefined) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    } else if (node.prev !== undefined) {
        self.tail = node.prev;
        node.prev.next = undefined;
    } else if (node.next !== undefined) {
        self.head = node.next;
        node.next.prev = undefined;
    } else {
        self.tail = undefined;
        self.head = undefined;
    }
    if (self._length > 0) self._length -= 1;
};

},{"./Function.js":"21gOL","./Inspectable.js":"1Ur70","./Pipeable.js":"b5RU2","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"ggSSM":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RequestTypeId", ()=>RequestTypeId);
parcelHelpers.export(exports, "isRequest", ()=>isRequest);
parcelHelpers.export(exports, "of", ()=>of);
parcelHelpers.export(exports, "tagged", ()=>tagged);
parcelHelpers.export(exports, "Class", ()=>Class);
parcelHelpers.export(exports, "TaggedClass", ()=>TaggedClass);
parcelHelpers.export(exports, "complete", ()=>complete);
parcelHelpers.export(exports, "interruptWhenPossible", ()=>interruptWhenPossible);
parcelHelpers.export(exports, "completeEffect", ()=>completeEffect);
parcelHelpers.export(exports, "fail", ()=>fail);
parcelHelpers.export(exports, "failCause", ()=>failCause);
parcelHelpers.export(exports, "succeed", ()=>succeed);
parcelHelpers.export(exports, "makeCache", ()=>makeCache);
parcelHelpers.export(exports, "EntryTypeId", ()=>EntryTypeId);
parcelHelpers.export(exports, "isEntry", ()=>isEntry);
parcelHelpers.export(exports, "makeEntry", ()=>makeEntry);
var _blockedRequestsJs = require("./internal/blockedRequests.js");
var _cacheJs = require("./internal/cache.js");
var _coreJs = require("./internal/core.js");
var _fiberRuntimeJs = require("./internal/fiberRuntime.js");
var _requestJs = require("./internal/request.js");
const RequestTypeId = _requestJs.RequestTypeId;
const isRequest = _requestJs.isRequest;
const of = _requestJs.of;
const tagged = _requestJs.tagged;
const Class = _requestJs.Class;
const TaggedClass = _requestJs.TaggedClass;
const complete = _requestJs.complete;
const interruptWhenPossible = _fiberRuntimeJs.interruptWhenPossible;
const completeEffect = _requestJs.completeEffect;
const fail = _requestJs.fail;
const failCause = _requestJs.failCause;
const succeed = _requestJs.succeed;
const makeCache = (options)=>_cacheJs.make({
        ...options,
        lookup: ()=>_coreJs.map(_coreJs.deferredMake(), (handle)=>({
                    listeners: new _requestJs.Listeners(),
                    handle
                }))
    });
const EntryTypeId = /*#__PURE__*/ Symbol.for("effect/RequestBlock.Entry");
const isEntry = _blockedRequestsJs.isEntry;
const makeEntry = _blockedRequestsJs.makeEntry;

},{"./internal/blockedRequests.js":"2UYO5","./internal/cache.js":"7groi","./internal/core.js":"cr3YV","./internal/fiberRuntime.js":"2spXK","./internal/request.js":"j7pmc","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"h0tE0":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "LayerTypeId", ()=>LayerTypeId);
parcelHelpers.export(exports, "MemoMapTypeId", ()=>MemoMapTypeId);
parcelHelpers.export(exports, "CurrentMemoMap", ()=>CurrentMemoMap);
parcelHelpers.export(exports, "isLayer", ()=>isLayer);
parcelHelpers.export(exports, "isFresh", ()=>isFresh);
parcelHelpers.export(exports, "annotateLogs", ()=>annotateLogs);
parcelHelpers.export(exports, "annotateSpans", ()=>annotateSpans);
parcelHelpers.export(exports, "build", ()=>build);
parcelHelpers.export(exports, "buildWithScope", ()=>buildWithScope);
parcelHelpers.export(exports, "catchAll", ()=>catchAll);
parcelHelpers.export(exports, "catchAllCause", ()=>catchAllCause);
parcelHelpers.export(exports, "context", ()=>context);
parcelHelpers.export(exports, "die", ()=>die);
parcelHelpers.export(exports, "dieSync", ()=>dieSync);
parcelHelpers.export(exports, "discard", ()=>discard);
parcelHelpers.export(exports, "effect", ()=>effect);
parcelHelpers.export(exports, "effectDiscard", ()=>effectDiscard);
parcelHelpers.export(exports, "effectContext", ()=>effectContext);
parcelHelpers.export(exports, "empty", ()=>empty);
parcelHelpers.export(exports, "extendScope", ()=>extendScope);
parcelHelpers.export(exports, "fail", ()=>fail);
parcelHelpers.export(exports, "failSync", ()=>failSync);
parcelHelpers.export(exports, "failCause", ()=>failCause);
parcelHelpers.export(exports, "failCauseSync", ()=>failCauseSync);
parcelHelpers.export(exports, "flatMap", ()=>flatMap);
parcelHelpers.export(exports, "flatten", ()=>flatten);
parcelHelpers.export(exports, "fresh", ()=>fresh);
parcelHelpers.export(exports, "function", ()=>/**
 * Constructs a layer from the context using the specified function.
 *
 * @since 2.0.0
 * @category constructors
 */ fromFunction);
parcelHelpers.export(exports, "launch", ()=>launch);
parcelHelpers.export(exports, "map", ()=>map);
parcelHelpers.export(exports, "mapError", ()=>mapError);
parcelHelpers.export(exports, "match", ()=>match);
parcelHelpers.export(exports, "matchCause", ()=>matchCause);
parcelHelpers.export(exports, "memoize", ()=>memoize);
parcelHelpers.export(exports, "merge", ()=>merge);
parcelHelpers.export(exports, "mergeAll", ()=>mergeAll);
parcelHelpers.export(exports, "orDie", ()=>orDie);
parcelHelpers.export(exports, "orElse", ()=>orElse);
parcelHelpers.export(exports, "passthrough", ()=>passthrough);
parcelHelpers.export(exports, "project", ()=>project);
parcelHelpers.export(exports, "locallyEffect", ()=>locallyEffect);
parcelHelpers.export(exports, "locally", ()=>locally);
parcelHelpers.export(exports, "locallyWith", ()=>locallyWith);
parcelHelpers.export(exports, "locallyScoped", ()=>locallyScoped);
parcelHelpers.export(exports, "fiberRefLocallyScopedWith", ()=>fiberRefLocallyScopedWith);
parcelHelpers.export(exports, "retry", ()=>retry);
parcelHelpers.export(exports, "scope", ()=>scope);
parcelHelpers.export(exports, "scoped", ()=>scoped);
parcelHelpers.export(exports, "scopedDiscard", ()=>scopedDiscard);
parcelHelpers.export(exports, "scopedContext", ()=>scopedContext);
parcelHelpers.export(exports, "service", ()=>service);
parcelHelpers.export(exports, "succeed", ()=>succeed);
parcelHelpers.export(exports, "succeedContext", ()=>succeedContext);
parcelHelpers.export(exports, "suspend", ()=>suspend);
parcelHelpers.export(exports, "sync", ()=>sync);
parcelHelpers.export(exports, "syncContext", ()=>syncContext);
parcelHelpers.export(exports, "tap", ()=>tap);
parcelHelpers.export(exports, "tapError", ()=>tapError);
parcelHelpers.export(exports, "tapErrorCause", ()=>tapErrorCause);
parcelHelpers.export(exports, "toRuntime", ()=>toRuntime);
parcelHelpers.export(exports, "toRuntimeWithMemoMap", ()=>toRuntimeWithMemoMap);
parcelHelpers.export(exports, "provide", ()=>provide);
parcelHelpers.export(exports, "provideMerge", ()=>provideMerge);
parcelHelpers.export(exports, "zipWith", ()=>zipWith);
parcelHelpers.export(exports, "unwrapEffect", ()=>unwrapEffect);
parcelHelpers.export(exports, "unwrapScoped", ()=>unwrapScoped);
parcelHelpers.export(exports, "setClock", ()=>setClock);
parcelHelpers.export(exports, "setConfigProvider", ()=>setConfigProvider);
parcelHelpers.export(exports, "parentSpan", ()=>parentSpan);
parcelHelpers.export(exports, "setRequestBatching", ()=>setRequestBatching);
parcelHelpers.export(exports, "setRequestCaching", ()=>setRequestCaching);
parcelHelpers.export(exports, "setRequestCache", ()=>setRequestCache);
parcelHelpers.export(exports, "setScheduler", ()=>setScheduler);
parcelHelpers.export(exports, "span", ()=>span);
parcelHelpers.export(exports, "setTracer", ()=>setTracer);
parcelHelpers.export(exports, "setTracerEnabled", ()=>setTracerEnabled);
parcelHelpers.export(exports, "setTracerTiming", ()=>setTracerTiming);
parcelHelpers.export(exports, "setUnhandledErrorLogLevel", ()=>setUnhandledErrorLogLevel);
parcelHelpers.export(exports, "withSpan", ()=>withSpan);
parcelHelpers.export(exports, "withParentSpan", ()=>withParentSpan);
parcelHelpers.export(exports, "makeMemoMap", ()=>makeMemoMap);
parcelHelpers.export(exports, "buildWithMemoMap", ()=>buildWithMemoMap);
parcelHelpers.export(exports, "updateService", ()=>updateService);
var _contextJs = require("./Context.js");
var _functionJs = require("./Function.js");
var _clockJs = require("./internal/clock.js");
var _coreJs = require("./internal/core.js");
var _defaultServicesJs = require("./internal/defaultServices.js");
var _fiberRuntimeJs = require("./internal/fiberRuntime.js");
var _layerJs = require("./internal/layer.js");
var _circularJs = require("./internal/layer/circular.js");
var _queryJs = require("./internal/query.js");
var _schedulerJs = require("./Scheduler.js");
const LayerTypeId = _layerJs.LayerTypeId;
const MemoMapTypeId = _layerJs.MemoMapTypeId;
const CurrentMemoMap = _layerJs.CurrentMemoMap;
const isLayer = _layerJs.isLayer;
const isFresh = _layerJs.isFresh;
const annotateLogs = _layerJs.annotateLogs;
const annotateSpans = _layerJs.annotateSpans;
const build = _layerJs.build;
const buildWithScope = _layerJs.buildWithScope;
const catchAll = _layerJs.catchAll;
const catchAllCause = _layerJs.catchAllCause;
const context = _layerJs.context;
const die = _layerJs.die;
const dieSync = _layerJs.dieSync;
const discard = _layerJs.discard;
const effect = _layerJs.fromEffect;
const effectDiscard = _layerJs.fromEffectDiscard;
const effectContext = _layerJs.fromEffectContext;
const empty = _layerJs.empty;
const extendScope = _layerJs.extendScope;
const fail = _layerJs.fail;
const failSync = _layerJs.failSync;
const failCause = _layerJs.failCause;
const failCauseSync = _layerJs.failCauseSync;
const flatMap = _layerJs.flatMap;
const flatten = _layerJs.flatten;
const fresh = _layerJs.fresh;
const fromFunction = _layerJs.fromFunction;
const launch = _layerJs.launch;
const map = _layerJs.map;
const mapError = _layerJs.mapError;
const match = _layerJs.match;
const matchCause = _layerJs.matchCause;
const memoize = _layerJs.memoize;
const merge = _layerJs.merge;
const mergeAll = _layerJs.mergeAll;
const orDie = _layerJs.orDie;
const orElse = _layerJs.orElse;
const passthrough = _layerJs.passthrough;
const project = _layerJs.project;
const locallyEffect = _layerJs.locallyEffect;
const locally = _layerJs.fiberRefLocally;
const locallyWith = _layerJs.fiberRefLocallyWith;
const locallyScoped = _layerJs.fiberRefLocallyScoped;
const fiberRefLocallyScopedWith = _layerJs.fiberRefLocallyScopedWith;
const retry = _layerJs.retry;
const scope = _layerJs.scope;
const scoped = _layerJs.scoped;
const scopedDiscard = _layerJs.scopedDiscard;
const scopedContext = _layerJs.scopedContext;
const service = _layerJs.service;
const succeed = _layerJs.succeed;
const succeedContext = _layerJs.succeedContext;
const suspend = _layerJs.suspend;
const sync = _layerJs.sync;
const syncContext = _layerJs.syncContext;
const tap = _layerJs.tap;
const tapError = _layerJs.tapError;
const tapErrorCause = _layerJs.tapErrorCause;
const toRuntime = _layerJs.toRuntime;
const toRuntimeWithMemoMap = _layerJs.toRuntimeWithMemoMap;
const provide = _layerJs.provide;
const provideMerge = _layerJs.provideMerge;
const zipWith = _layerJs.zipWith;
const unwrapEffect = _layerJs.unwrapEffect;
const unwrapScoped = _layerJs.unwrapScoped;
const setClock = (clock)=>scopedDiscard(_fiberRuntimeJs.fiberRefLocallyScopedWith(_defaultServicesJs.currentServices, _contextJs.add((0, _clockJs.clockTag), clock)));
const setConfigProvider = _circularJs.setConfigProvider;
const parentSpan = _circularJs.parentSpan;
const setRequestBatching = (requestBatching)=>scopedDiscard(_fiberRuntimeJs.fiberRefLocallyScoped(_coreJs.currentRequestBatching, requestBatching));
const setRequestCaching = (requestCaching)=>scopedDiscard(_fiberRuntimeJs.fiberRefLocallyScoped(_queryJs.currentCacheEnabled, requestCaching));
const setRequestCache = (cache)=>scopedDiscard(_coreJs.isEffect(cache) ? _coreJs.flatMap(cache, (x)=>_fiberRuntimeJs.fiberRefLocallyScoped(_queryJs.currentCache, x)) : _fiberRuntimeJs.fiberRefLocallyScoped(_queryJs.currentCache, cache));
const setScheduler = (scheduler)=>scopedDiscard(_fiberRuntimeJs.fiberRefLocallyScoped(_schedulerJs.currentScheduler, scheduler));
const span = _circularJs.span;
const setTracer = _circularJs.setTracer;
const setTracerEnabled = (enabled)=>scopedDiscard(_fiberRuntimeJs.fiberRefLocallyScoped(_coreJs.currentTracerEnabled, enabled));
const setTracerTiming = (enabled)=>scopedDiscard(_fiberRuntimeJs.fiberRefLocallyScoped(_coreJs.currentTracerTimingEnabled, enabled));
const setUnhandledErrorLogLevel = (level)=>scopedDiscard(_fiberRuntimeJs.fiberRefLocallyScoped(_coreJs.currentUnhandledErrorLogLevel, level));
const withSpan = _layerJs.withSpan;
const withParentSpan = _layerJs.withParentSpan;
const makeMemoMap = _layerJs.makeMemoMap;
const buildWithMemoMap = _layerJs.buildWithMemoMap;
const updateService = /*#__PURE__*/ (0, _functionJs.dual)(3, (layer, tag, f)=>provide(layer, map(context(), (c)=>_contextJs.add(c, tag, f(_contextJs.unsafeGet(c, tag))))));

},{"./Context.js":"c2abN","./Function.js":"21gOL","./internal/clock.js":"27hJp","./internal/core.js":"cr3YV","./internal/defaultServices.js":"aF4q8","./internal/fiberRuntime.js":"2spXK","./internal/layer.js":"aHmA5","./internal/layer/circular.js":"1hFWm","./internal/query.js":"4BGGH","./Scheduler.js":"hR5Dj","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"1hFWm":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "minimumLogLevel", ()=>minimumLogLevel);
parcelHelpers.export(exports, "withMinimumLogLevel", ()=>withMinimumLogLevel);
parcelHelpers.export(exports, "addLogger", ()=>addLogger);
parcelHelpers.export(exports, "addLoggerEffect", ()=>addLoggerEffect);
parcelHelpers.export(exports, "addLoggerScoped", ()=>addLoggerScoped);
parcelHelpers.export(exports, "removeLogger", ()=>removeLogger);
parcelHelpers.export(exports, "replaceLogger", ()=>replaceLogger);
parcelHelpers.export(exports, "replaceLoggerEffect", ()=>replaceLoggerEffect);
parcelHelpers.export(exports, "replaceLoggerScoped", ()=>replaceLoggerScoped);
parcelHelpers.export(exports, "addSupervisor", ()=>addSupervisor);
parcelHelpers.export(exports, "enableCooperativeYielding", ()=>enableCooperativeYielding);
parcelHelpers.export(exports, "enableInterruption", ()=>enableInterruption);
parcelHelpers.export(exports, "enableOpSupervision", ()=>enableOpSupervision);
parcelHelpers.export(exports, "enableRuntimeMetrics", ()=>enableRuntimeMetrics);
parcelHelpers.export(exports, "enableWindDown", ()=>enableWindDown);
parcelHelpers.export(exports, "disableCooperativeYielding", ()=>disableCooperativeYielding);
parcelHelpers.export(exports, "disableInterruption", ()=>disableInterruption);
parcelHelpers.export(exports, "disableOpSupervision", ()=>disableOpSupervision);
parcelHelpers.export(exports, "disableRuntimeMetrics", ()=>disableRuntimeMetrics);
parcelHelpers.export(exports, "disableWindDown", ()=>disableWindDown);
parcelHelpers.export(exports, "setConfigProvider", ()=>setConfigProvider);
parcelHelpers.export(exports, "parentSpan", ()=>parentSpan);
parcelHelpers.export(exports, "span", ()=>span);
parcelHelpers.export(exports, "setTracer", ()=>setTracer);
var _contextJs = require("../../Context.js");
var _functionJs = require("../../Function.js");
var _hashSetJs = require("../../HashSet.js");
var _coreJs = require("../core.js");
var _fiberRuntimeJs = require("../fiberRuntime.js");
var _layerJs = require("../layer.js");
var _runtimeFlagsJs = require("../runtimeFlags.js");
var _runtimeFlagsPatchJs = require("../runtimeFlagsPatch.js");
var _supervisorJs = require("../supervisor.js");
var _tracerJs = require("../tracer.js");
const minimumLogLevel = (level)=>_layerJs.scopedDiscard(_fiberRuntimeJs.fiberRefLocallyScoped(_fiberRuntimeJs.currentMinimumLogLevel, level));
const withMinimumLogLevel = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, level)=>_coreJs.fiberRefLocally(_fiberRuntimeJs.currentMinimumLogLevel, level)(self));
const addLogger = (logger)=>_layerJs.scopedDiscard(_fiberRuntimeJs.fiberRefLocallyScopedWith(_fiberRuntimeJs.currentLoggers, _hashSetJs.add(logger)));
const addLoggerEffect = (effect)=>_layerJs.unwrapEffect(_coreJs.map(effect, addLogger));
const addLoggerScoped = (effect)=>_layerJs.unwrapScoped(_coreJs.map(effect, addLogger));
const removeLogger = (logger)=>_layerJs.scopedDiscard(_fiberRuntimeJs.fiberRefLocallyScopedWith(_fiberRuntimeJs.currentLoggers, _hashSetJs.remove(logger)));
const replaceLogger = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>_layerJs.flatMap(removeLogger(self), ()=>addLogger(that)));
const replaceLoggerEffect = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>_layerJs.flatMap(removeLogger(self), ()=>addLoggerEffect(that)));
const replaceLoggerScoped = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>_layerJs.flatMap(removeLogger(self), ()=>addLoggerScoped(that)));
const addSupervisor = (supervisor)=>_layerJs.scopedDiscard(_fiberRuntimeJs.fiberRefLocallyScopedWith(_fiberRuntimeJs.currentSupervisor, (current)=>new _supervisorJs.Zip(current, supervisor)));
const enableCooperativeYielding = /*#__PURE__*/ _layerJs.scopedDiscard(/*#__PURE__*/ _fiberRuntimeJs.withRuntimeFlagsScoped(/*#__PURE__*/ _runtimeFlagsPatchJs.enable(_runtimeFlagsJs.CooperativeYielding)));
const enableInterruption = /*#__PURE__*/ _layerJs.scopedDiscard(/*#__PURE__*/ _fiberRuntimeJs.withRuntimeFlagsScoped(/*#__PURE__*/ _runtimeFlagsPatchJs.enable(_runtimeFlagsJs.Interruption)));
const enableOpSupervision = /*#__PURE__*/ _layerJs.scopedDiscard(/*#__PURE__*/ _fiberRuntimeJs.withRuntimeFlagsScoped(/*#__PURE__*/ _runtimeFlagsPatchJs.enable(_runtimeFlagsJs.OpSupervision)));
const enableRuntimeMetrics = /*#__PURE__*/ _layerJs.scopedDiscard(/*#__PURE__*/ _fiberRuntimeJs.withRuntimeFlagsScoped(/*#__PURE__*/ _runtimeFlagsPatchJs.enable(_runtimeFlagsJs.RuntimeMetrics)));
const enableWindDown = /*#__PURE__*/ _layerJs.scopedDiscard(/*#__PURE__*/ _fiberRuntimeJs.withRuntimeFlagsScoped(/*#__PURE__*/ _runtimeFlagsPatchJs.enable(_runtimeFlagsJs.WindDown)));
const disableCooperativeYielding = /*#__PURE__*/ _layerJs.scopedDiscard(/*#__PURE__*/ _fiberRuntimeJs.withRuntimeFlagsScoped(/*#__PURE__*/ _runtimeFlagsPatchJs.disable(_runtimeFlagsJs.CooperativeYielding)));
const disableInterruption = /*#__PURE__*/ _layerJs.scopedDiscard(/*#__PURE__*/ _fiberRuntimeJs.withRuntimeFlagsScoped(/*#__PURE__*/ _runtimeFlagsPatchJs.disable(_runtimeFlagsJs.Interruption)));
const disableOpSupervision = /*#__PURE__*/ _layerJs.scopedDiscard(/*#__PURE__*/ _fiberRuntimeJs.withRuntimeFlagsScoped(/*#__PURE__*/ _runtimeFlagsPatchJs.disable(_runtimeFlagsJs.OpSupervision)));
const disableRuntimeMetrics = /*#__PURE__*/ _layerJs.scopedDiscard(/*#__PURE__*/ _fiberRuntimeJs.withRuntimeFlagsScoped(/*#__PURE__*/ _runtimeFlagsPatchJs.disable(_runtimeFlagsJs.RuntimeMetrics)));
const disableWindDown = /*#__PURE__*/ _layerJs.scopedDiscard(/*#__PURE__*/ _fiberRuntimeJs.withRuntimeFlagsScoped(/*#__PURE__*/ _runtimeFlagsPatchJs.disable(_runtimeFlagsJs.WindDown)));
const setConfigProvider = (configProvider)=>_layerJs.scopedDiscard(_fiberRuntimeJs.withConfigProviderScoped(configProvider));
const parentSpan = (span)=>_layerJs.succeedContext(_contextJs.make(_tracerJs.spanTag, span));
const span = (name, options)=>{
    options = _tracerJs.addSpanStackTrace(options);
    return _layerJs.scoped(_tracerJs.spanTag, options?.onEnd ? _coreJs.tap(_fiberRuntimeJs.makeSpanScoped(name, options), (span)=>_fiberRuntimeJs.addFinalizer((exit)=>options.onEnd(span, exit))) : _fiberRuntimeJs.makeSpanScoped(name, options));
};
const setTracer = (tracer)=>_layerJs.scopedDiscard(_fiberRuntimeJs.withTracerScoped(tracer));

},{"../../Context.js":"c2abN","../../Function.js":"21gOL","../../HashSet.js":"aKFFV","../core.js":"cr3YV","../fiberRuntime.js":"2spXK","../layer.js":"aHmA5","../runtimeFlags.js":"9rFhC","../runtimeFlagsPatch.js":"4PDkQ","../supervisor.js":"bryLt","../tracer.js":"aAsvB","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"dyM1C":[function(require,module,exports,__globalThis) {
/**
 * This module provides encoding & decoding functionality for:
 *
 * - base64 (RFC4648)
 * - base64 (URL)
 * - hex
 *
 * @since 2.0.0
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "encodeBase64", ()=>encodeBase64);
parcelHelpers.export(exports, "decodeBase64", ()=>decodeBase64);
parcelHelpers.export(exports, "decodeBase64String", ()=>decodeBase64String);
parcelHelpers.export(exports, "encodeBase64Url", ()=>encodeBase64Url);
parcelHelpers.export(exports, "decodeBase64Url", ()=>decodeBase64Url);
parcelHelpers.export(exports, "decodeBase64UrlString", ()=>decodeBase64UrlString);
parcelHelpers.export(exports, "encodeHex", ()=>encodeHex);
parcelHelpers.export(exports, "decodeHex", ()=>decodeHex);
parcelHelpers.export(exports, "decodeHexString", ()=>decodeHexString);
parcelHelpers.export(exports, "encodeUriComponent", ()=>encodeUriComponent);
parcelHelpers.export(exports, "decodeUriComponent", ()=>decodeUriComponent);
parcelHelpers.export(exports, "DecodeExceptionTypeId", ()=>DecodeExceptionTypeId);
parcelHelpers.export(exports, "DecodeException", ()=>DecodeException);
parcelHelpers.export(exports, "isDecodeException", ()=>isDecodeException);
parcelHelpers.export(exports, "EncodeExceptionTypeId", ()=>EncodeExceptionTypeId);
parcelHelpers.export(exports, "EncodeException", ()=>EncodeException);
parcelHelpers.export(exports, "isEncodeException", ()=>isEncodeException);
var _eitherJs = require("./Either.js");
var _base64Js = require("./internal/encoding/base64.js");
var _base64UrlJs = require("./internal/encoding/base64Url.js");
var _commonJs = require("./internal/encoding/common.js");
var _hexJs = require("./internal/encoding/hex.js");
const encodeBase64 = (input)=>typeof input === "string" ? _base64Js.encode(_commonJs.encoder.encode(input)) : _base64Js.encode(input);
const decodeBase64 = (str)=>_base64Js.decode(str);
const decodeBase64String = (str)=>_eitherJs.map(decodeBase64(str), (_)=>_commonJs.decoder.decode(_));
const encodeBase64Url = (input)=>typeof input === "string" ? _base64UrlJs.encode(_commonJs.encoder.encode(input)) : _base64UrlJs.encode(input);
const decodeBase64Url = (str)=>_base64UrlJs.decode(str);
const decodeBase64UrlString = (str)=>_eitherJs.map(decodeBase64Url(str), (_)=>_commonJs.decoder.decode(_));
const encodeHex = (input)=>typeof input === "string" ? _hexJs.encode(_commonJs.encoder.encode(input)) : _hexJs.encode(input);
const decodeHex = (str)=>_hexJs.decode(str);
const decodeHexString = (str)=>_eitherJs.map(decodeHex(str), (_)=>_commonJs.decoder.decode(_));
const encodeUriComponent = (str)=>_eitherJs.try({
        try: ()=>encodeURIComponent(str),
        catch: (e)=>EncodeException(str, e instanceof Error ? e.message : "Invalid input")
    });
const decodeUriComponent = (str)=>_eitherJs.try({
        try: ()=>decodeURIComponent(str),
        catch: (e)=>DecodeException(str, e instanceof Error ? e.message : "Invalid input")
    });
const DecodeExceptionTypeId = _commonJs.DecodeExceptionTypeId;
const DecodeException = _commonJs.DecodeException;
const isDecodeException = _commonJs.isDecodeException;
const EncodeExceptionTypeId = _commonJs.EncodeExceptionTypeId;
const EncodeException = _commonJs.EncodeException;
const isEncodeException = _commonJs.isEncodeException;

},{"./Either.js":"4amnT","./internal/encoding/base64.js":"4vI8L","./internal/encoding/base64Url.js":"9JLTe","./internal/encoding/common.js":"7zlyc","./internal/encoding/hex.js":"17rVW","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"4vI8L":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "encode", ()=>encode);
parcelHelpers.export(exports, "decode", ()=>decode);
parcelHelpers.export(exports, "stripCrlf", ()=>stripCrlf);
var _eitherJs = require("../../Either.js");
var _commonJs = require("./common.js");
const encode = (bytes)=>{
    const length = bytes.length;
    let result = "";
    let i;
    for(i = 2; i < length; i += 3){
        result += base64abc[bytes[i - 2] >> 2];
        result += base64abc[(bytes[i - 2] & 0x03) << 4 | bytes[i - 1] >> 4];
        result += base64abc[(bytes[i - 1] & 0x0f) << 2 | bytes[i] >> 6];
        result += base64abc[bytes[i] & 0x3f];
    }
    if (i === length + 1) {
        // 1 octet yet to write
        result += base64abc[bytes[i - 2] >> 2];
        result += base64abc[(bytes[i - 2] & 0x03) << 4];
        result += "==";
    }
    if (i === length) {
        // 2 octets yet to write
        result += base64abc[bytes[i - 2] >> 2];
        result += base64abc[(bytes[i - 2] & 0x03) << 4 | bytes[i - 1] >> 4];
        result += base64abc[(bytes[i - 1] & 0x0f) << 2];
        result += "=";
    }
    return result;
};
const decode = (str)=>{
    const stripped = stripCrlf(str);
    const length = stripped.length;
    if (length % 4 !== 0) return _eitherJs.left((0, _commonJs.DecodeException)(stripped, `Length must be a multiple of 4, but is ${length}`));
    const index = stripped.indexOf("=");
    if (index !== -1 && (index < length - 2 || index === length - 2 && stripped[length - 1] !== "=")) return _eitherJs.left((0, _commonJs.DecodeException)(stripped, "Found a '=' character, but it is not at the end"));
    try {
        const missingOctets = stripped.endsWith("==") ? 2 : stripped.endsWith("=") ? 1 : 0;
        const result = new Uint8Array(3 * (length / 4) - missingOctets);
        for(let i = 0, j = 0; i < length; i += 4, j += 3){
            const buffer = getBase64Code(stripped.charCodeAt(i)) << 18 | getBase64Code(stripped.charCodeAt(i + 1)) << 12 | getBase64Code(stripped.charCodeAt(i + 2)) << 6 | getBase64Code(stripped.charCodeAt(i + 3));
            result[j] = buffer >> 16;
            result[j + 1] = buffer >> 8 & 0xff;
            result[j + 2] = buffer & 0xff;
        }
        return _eitherJs.right(result);
    } catch (e) {
        return _eitherJs.left((0, _commonJs.DecodeException)(stripped, e instanceof Error ? e.message : "Invalid input"));
    }
};
const stripCrlf = (str)=>str.replace(/[\n\r]/g, "");
/** @internal */ function getBase64Code(charCode) {
    if (charCode >= base64codes.length) throw new TypeError(`Invalid character ${String.fromCharCode(charCode)}`);
    const code = base64codes[charCode];
    if (code === 255) throw new TypeError(`Invalid character ${String.fromCharCode(charCode)}`);
    return code;
}
/** @internal */ const base64abc = [
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "+",
    "/"
];
/** @internal */ const base64codes = [
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    62,
    255,
    255,
    255,
    63,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    255,
    255,
    255,
    0,
    255,
    255,
    255,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    255,
    255,
    255,
    255,
    255,
    255,
    26,
    27,
    28,
    29,
    30,
    31,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51
];

},{"../../Either.js":"4amnT","./common.js":"7zlyc","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"7zlyc":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DecodeExceptionTypeId", ()=>DecodeExceptionTypeId);
parcelHelpers.export(exports, "DecodeException", ()=>DecodeException);
parcelHelpers.export(exports, "isDecodeException", ()=>isDecodeException);
parcelHelpers.export(exports, "EncodeExceptionTypeId", ()=>EncodeExceptionTypeId);
parcelHelpers.export(exports, "EncodeException", ()=>EncodeException);
parcelHelpers.export(exports, "isEncodeException", ()=>isEncodeException);
parcelHelpers.export(exports, "encoder", ()=>encoder);
parcelHelpers.export(exports, "decoder", ()=>decoder);
var _predicateJs = require("../../Predicate.js");
const DecodeExceptionTypeId = /*#__PURE__*/ Symbol.for("effect/Encoding/errors/Decode");
const DecodeException = (input, message)=>{
    const out = {
        _tag: "DecodeException",
        [DecodeExceptionTypeId]: DecodeExceptionTypeId,
        input
    };
    if ((0, _predicateJs.isString)(message)) out.message = message;
    return out;
};
const isDecodeException = (u)=>(0, _predicateJs.hasProperty)(u, DecodeExceptionTypeId);
const EncodeExceptionTypeId = /*#__PURE__*/ Symbol.for("effect/Encoding/errors/Encode");
const EncodeException = (input, message)=>{
    const out = {
        _tag: "EncodeException",
        [EncodeExceptionTypeId]: EncodeExceptionTypeId,
        input
    };
    if ((0, _predicateJs.isString)(message)) out.message = message;
    return out;
};
const isEncodeException = (u)=>(0, _predicateJs.hasProperty)(u, EncodeExceptionTypeId);
const encoder = /*#__PURE__*/ new TextEncoder();
const decoder = /*#__PURE__*/ new TextDecoder();

},{"../../Predicate.js":"gW5pd","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"9JLTe":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "encode", ()=>encode);
parcelHelpers.export(exports, "decode", ()=>decode);
var _eitherJs = require("../../Either.js");
var _base64Js = require("./base64.js");
var _commonJs = require("./common.js");
const encode = (data)=>_base64Js.encode(data).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
const decode = (str)=>{
    const stripped = _base64Js.stripCrlf(str);
    const length = stripped.length;
    if (length % 4 === 1) return _eitherJs.left((0, _commonJs.DecodeException)(stripped, `Length should be a multiple of 4, but is ${length}`));
    if (!/^[-_A-Z0-9]*?={0,2}$/i.test(stripped)) return _eitherJs.left((0, _commonJs.DecodeException)(stripped, "Invalid input"));
    // Some variants allow or require omitting the padding '=' signs
    let sanitized = length % 4 === 2 ? `${stripped}==` : length % 4 === 3 ? `${stripped}=` : stripped;
    sanitized = sanitized.replace(/-/g, "+").replace(/_/g, "/");
    return _base64Js.decode(sanitized);
};

},{"../../Either.js":"4amnT","./base64.js":"4vI8L","./common.js":"7zlyc","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"17rVW":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "encode", ()=>encode);
parcelHelpers.export(exports, "decode", ()=>decode);
var _eitherJs = require("../../Either.js");
var _commonJs = require("./common.js");
const encode = (bytes)=>{
    let result = "";
    for(let i = 0; i < bytes.length; ++i)result += bytesToHex[bytes[i]];
    return result;
};
const decode = (str)=>{
    const bytes = new TextEncoder().encode(str);
    if (bytes.length % 2 !== 0) return _eitherJs.left((0, _commonJs.DecodeException)(str, `Length must be a multiple of 2, but is ${bytes.length}`));
    try {
        const length = bytes.length / 2;
        const result = new Uint8Array(length);
        for(let i = 0; i < length; i++){
            const a = fromHexChar(bytes[i * 2]);
            const b = fromHexChar(bytes[i * 2 + 1]);
            result[i] = a << 4 | b;
        }
        return _eitherJs.right(result);
    } catch (e) {
        return _eitherJs.left((0, _commonJs.DecodeException)(str, e instanceof Error ? e.message : "Invalid input"));
    }
};
/** @internal */ const bytesToHex = [
    "00",
    "01",
    "02",
    "03",
    "04",
    "05",
    "06",
    "07",
    "08",
    "09",
    "0a",
    "0b",
    "0c",
    "0d",
    "0e",
    "0f",
    "10",
    "11",
    "12",
    "13",
    "14",
    "15",
    "16",
    "17",
    "18",
    "19",
    "1a",
    "1b",
    "1c",
    "1d",
    "1e",
    "1f",
    "20",
    "21",
    "22",
    "23",
    "24",
    "25",
    "26",
    "27",
    "28",
    "29",
    "2a",
    "2b",
    "2c",
    "2d",
    "2e",
    "2f",
    "30",
    "31",
    "32",
    "33",
    "34",
    "35",
    "36",
    "37",
    "38",
    "39",
    "3a",
    "3b",
    "3c",
    "3d",
    "3e",
    "3f",
    "40",
    "41",
    "42",
    "43",
    "44",
    "45",
    "46",
    "47",
    "48",
    "49",
    "4a",
    "4b",
    "4c",
    "4d",
    "4e",
    "4f",
    "50",
    "51",
    "52",
    "53",
    "54",
    "55",
    "56",
    "57",
    "58",
    "59",
    "5a",
    "5b",
    "5c",
    "5d",
    "5e",
    "5f",
    "60",
    "61",
    "62",
    "63",
    "64",
    "65",
    "66",
    "67",
    "68",
    "69",
    "6a",
    "6b",
    "6c",
    "6d",
    "6e",
    "6f",
    "70",
    "71",
    "72",
    "73",
    "74",
    "75",
    "76",
    "77",
    "78",
    "79",
    "7a",
    "7b",
    "7c",
    "7d",
    "7e",
    "7f",
    "80",
    "81",
    "82",
    "83",
    "84",
    "85",
    "86",
    "87",
    "88",
    "89",
    "8a",
    "8b",
    "8c",
    "8d",
    "8e",
    "8f",
    "90",
    "91",
    "92",
    "93",
    "94",
    "95",
    "96",
    "97",
    "98",
    "99",
    "9a",
    "9b",
    "9c",
    "9d",
    "9e",
    "9f",
    "a0",
    "a1",
    "a2",
    "a3",
    "a4",
    "a5",
    "a6",
    "a7",
    "a8",
    "a9",
    "aa",
    "ab",
    "ac",
    "ad",
    "ae",
    "af",
    "b0",
    "b1",
    "b2",
    "b3",
    "b4",
    "b5",
    "b6",
    "b7",
    "b8",
    "b9",
    "ba",
    "bb",
    "bc",
    "bd",
    "be",
    "bf",
    "c0",
    "c1",
    "c2",
    "c3",
    "c4",
    "c5",
    "c6",
    "c7",
    "c8",
    "c9",
    "ca",
    "cb",
    "cc",
    "cd",
    "ce",
    "cf",
    "d0",
    "d1",
    "d2",
    "d3",
    "d4",
    "d5",
    "d6",
    "d7",
    "d8",
    "d9",
    "da",
    "db",
    "dc",
    "dd",
    "de",
    "df",
    "e0",
    "e1",
    "e2",
    "e3",
    "e4",
    "e5",
    "e6",
    "e7",
    "e8",
    "e9",
    "ea",
    "eb",
    "ec",
    "ed",
    "ee",
    "ef",
    "f0",
    "f1",
    "f2",
    "f3",
    "f4",
    "f5",
    "f6",
    "f7",
    "f8",
    "f9",
    "fa",
    "fb",
    "fc",
    "fd",
    "fe",
    "ff"
];
/** @internal */ const fromHexChar = (byte)=>{
    // '0' <= byte && byte <= '9'
    if (48 <= byte && byte <= 57) return byte - 48;
    // 'a' <= byte && byte <= 'f'
    if (97 <= byte && byte <= 102) return byte - 97 + 10;
    // 'A' <= byte && byte <= 'F'
    if (65 <= byte && byte <= 70) return byte - 65 + 10;
    throw new TypeError("Invalid input");
};

},{"../../Either.js":"4amnT","./common.js":"7zlyc","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"eWStv":[function(require,module,exports,__globalThis) {
/**
 * @since 3.10.0
 */ /**
 * @category re-exports
 * @since 3.10.0
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _fastCheck = require("fast-check");
parcelHelpers.exportAll(_fastCheck, exports);

},{"fast-check":"1GaMQ","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"1GaMQ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _fastCheckDefaultJs = require("./fast-check-default.js");
parcelHelpers.exportAll(_fastCheckDefaultJs, exports);
exports.default = _fastCheckDefaultJs;

},{"./fast-check-default.js":"agCjL","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"agCjL":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "__type", ()=>__type);
parcelHelpers.export(exports, "__version", ()=>__version);
parcelHelpers.export(exports, "__commitHash", ()=>__commitHash);
parcelHelpers.export(exports, "sample", ()=>(0, _samplerJs.sample));
parcelHelpers.export(exports, "statistics", ()=>(0, _samplerJs.statistics));
parcelHelpers.export(exports, "check", ()=>(0, _runnerJs.check));
parcelHelpers.export(exports, "assert", ()=>(0, _runnerJs.assert));
parcelHelpers.export(exports, "pre", ()=>(0, _preJs.pre));
parcelHelpers.export(exports, "PreconditionFailure", ()=>(0, _preconditionFailureJs.PreconditionFailure));
parcelHelpers.export(exports, "property", ()=>(0, _propertyJs.property));
parcelHelpers.export(exports, "asyncProperty", ()=>(0, _asyncPropertyJs.asyncProperty));
parcelHelpers.export(exports, "boolean", ()=>(0, _booleanJs.boolean));
parcelHelpers.export(exports, "falsy", ()=>(0, _falsyJs.falsy));
parcelHelpers.export(exports, "float", ()=>(0, _floatJs.float));
parcelHelpers.export(exports, "double", ()=>(0, _doubleJs.double));
parcelHelpers.export(exports, "integer", ()=>(0, _integerJs.integer));
parcelHelpers.export(exports, "nat", ()=>(0, _natJs.nat));
parcelHelpers.export(exports, "maxSafeInteger", ()=>(0, _maxSafeIntegerJs.maxSafeInteger));
parcelHelpers.export(exports, "maxSafeNat", ()=>(0, _maxSafeNatJs.maxSafeNat));
parcelHelpers.export(exports, "bigIntN", ()=>(0, _bigIntNJs.bigIntN));
parcelHelpers.export(exports, "bigUintN", ()=>(0, _bigUintNJs.bigUintN));
parcelHelpers.export(exports, "bigInt", ()=>(0, _bigIntJs.bigInt));
parcelHelpers.export(exports, "bigUint", ()=>(0, _bigUintJs.bigUint));
parcelHelpers.export(exports, "char", ()=>(0, _charJs.char));
parcelHelpers.export(exports, "ascii", ()=>(0, _asciiJs.ascii));
parcelHelpers.export(exports, "char16bits", ()=>(0, _char16BitsJs.char16bits));
parcelHelpers.export(exports, "unicode", ()=>(0, _unicodeJs.unicode));
parcelHelpers.export(exports, "fullUnicode", ()=>(0, _fullUnicodeJs.fullUnicode));
parcelHelpers.export(exports, "hexa", ()=>(0, _hexaJs.hexa));
parcelHelpers.export(exports, "base64", ()=>(0, _base64Js.base64));
parcelHelpers.export(exports, "mixedCase", ()=>(0, _mixedCaseJs.mixedCase));
parcelHelpers.export(exports, "string", ()=>(0, _stringJs.string));
parcelHelpers.export(exports, "asciiString", ()=>(0, _asciiStringJs.asciiString));
parcelHelpers.export(exports, "string16bits", ()=>(0, _string16BitsJs.string16bits));
parcelHelpers.export(exports, "stringOf", ()=>(0, _stringOfJs.stringOf));
parcelHelpers.export(exports, "unicodeString", ()=>(0, _unicodeStringJs.unicodeString));
parcelHelpers.export(exports, "fullUnicodeString", ()=>(0, _fullUnicodeStringJs.fullUnicodeString));
parcelHelpers.export(exports, "hexaString", ()=>(0, _hexaStringJs.hexaString));
parcelHelpers.export(exports, "base64String", ()=>(0, _base64StringJs.base64String));
parcelHelpers.export(exports, "stringMatching", ()=>(0, _stringMatchingJs.stringMatching));
parcelHelpers.export(exports, "limitShrink", ()=>(0, _limitShrinkJs.limitShrink));
parcelHelpers.export(exports, "lorem", ()=>(0, _loremJs.lorem));
parcelHelpers.export(exports, "constant", ()=>(0, _constantJs.constant));
parcelHelpers.export(exports, "constantFrom", ()=>(0, _constantFromJs.constantFrom));
parcelHelpers.export(exports, "mapToConstant", ()=>(0, _mapToConstantJs.mapToConstant));
parcelHelpers.export(exports, "option", ()=>(0, _optionJs.option));
parcelHelpers.export(exports, "oneof", ()=>(0, _oneofJs.oneof));
parcelHelpers.export(exports, "clone", ()=>(0, _cloneJs.clone));
parcelHelpers.export(exports, "noBias", ()=>(0, _noBiasJs.noBias));
parcelHelpers.export(exports, "noShrink", ()=>(0, _noShrinkJs.noShrink));
parcelHelpers.export(exports, "shuffledSubarray", ()=>(0, _shuffledSubarrayJs.shuffledSubarray));
parcelHelpers.export(exports, "subarray", ()=>(0, _subarrayJs.subarray));
parcelHelpers.export(exports, "array", ()=>(0, _arrayJs.array));
parcelHelpers.export(exports, "sparseArray", ()=>(0, _sparseArrayJs.sparseArray));
parcelHelpers.export(exports, "infiniteStream", ()=>(0, _infiniteStreamJs.infiniteStream));
parcelHelpers.export(exports, "uniqueArray", ()=>(0, _uniqueArrayJs.uniqueArray));
parcelHelpers.export(exports, "tuple", ()=>(0, _tupleJs.tuple));
parcelHelpers.export(exports, "record", ()=>(0, _recordJs.record));
parcelHelpers.export(exports, "dictionary", ()=>(0, _dictionaryJs.dictionary));
parcelHelpers.export(exports, "anything", ()=>(0, _anythingJs.anything));
parcelHelpers.export(exports, "object", ()=>(0, _objectJs.object));
parcelHelpers.export(exports, "json", ()=>(0, _jsonJs.json));
parcelHelpers.export(exports, "jsonValue", ()=>(0, _jsonValueJs.jsonValue));
parcelHelpers.export(exports, "unicodeJson", ()=>(0, _unicodeJsonJs.unicodeJson));
parcelHelpers.export(exports, "unicodeJsonValue", ()=>(0, _unicodeJsonValueJs.unicodeJsonValue));
parcelHelpers.export(exports, "letrec", ()=>(0, _letrecJs.letrec));
parcelHelpers.export(exports, "memo", ()=>(0, _memoJs.memo));
parcelHelpers.export(exports, "compareBooleanFunc", ()=>(0, _compareBooleanFuncJs.compareBooleanFunc));
parcelHelpers.export(exports, "compareFunc", ()=>(0, _compareFuncJs.compareFunc));
parcelHelpers.export(exports, "func", ()=>(0, _funcJs.func));
parcelHelpers.export(exports, "context", ()=>(0, _contextJs.context));
parcelHelpers.export(exports, "gen", ()=>(0, _genJs.gen));
parcelHelpers.export(exports, "date", ()=>(0, _dateJs.date));
parcelHelpers.export(exports, "ipV4", ()=>(0, _ipV4Js.ipV4));
parcelHelpers.export(exports, "ipV4Extended", ()=>(0, _ipV4ExtendedJs.ipV4Extended));
parcelHelpers.export(exports, "ipV6", ()=>(0, _ipV6Js.ipV6));
parcelHelpers.export(exports, "domain", ()=>(0, _domainJs.domain));
parcelHelpers.export(exports, "webAuthority", ()=>(0, _webAuthorityJs.webAuthority));
parcelHelpers.export(exports, "webSegment", ()=>(0, _webSegmentJs.webSegment));
parcelHelpers.export(exports, "webFragments", ()=>(0, _webFragmentsJs.webFragments));
parcelHelpers.export(exports, "webPath", ()=>(0, _webPathJs.webPath));
parcelHelpers.export(exports, "webQueryParameters", ()=>(0, _webQueryParametersJs.webQueryParameters));
parcelHelpers.export(exports, "webUrl", ()=>(0, _webUrlJs.webUrl));
parcelHelpers.export(exports, "emailAddress", ()=>(0, _emailAddressJs.emailAddress));
parcelHelpers.export(exports, "ulid", ()=>(0, _ulidJs.ulid));
parcelHelpers.export(exports, "uuid", ()=>(0, _uuidJs.uuid));
parcelHelpers.export(exports, "uuidV", ()=>(0, _uuidVJs.uuidV));
parcelHelpers.export(exports, "int8Array", ()=>(0, _int8ArrayJs.int8Array));
parcelHelpers.export(exports, "uint8Array", ()=>(0, _uint8ArrayJs.uint8Array));
parcelHelpers.export(exports, "uint8ClampedArray", ()=>(0, _uint8ClampedArrayJs.uint8ClampedArray));
parcelHelpers.export(exports, "int16Array", ()=>(0, _int16ArrayJs.int16Array));
parcelHelpers.export(exports, "uint16Array", ()=>(0, _uint16ArrayJs.uint16Array));
parcelHelpers.export(exports, "int32Array", ()=>(0, _int32ArrayJs.int32Array));
parcelHelpers.export(exports, "uint32Array", ()=>(0, _uint32ArrayJs.uint32Array));
parcelHelpers.export(exports, "float32Array", ()=>(0, _float32ArrayJs.float32Array));
parcelHelpers.export(exports, "float64Array", ()=>(0, _float64ArrayJs.float64Array));
parcelHelpers.export(exports, "bigInt64Array", ()=>(0, _bigInt64ArrayJs.bigInt64Array));
parcelHelpers.export(exports, "bigUint64Array", ()=>(0, _bigUint64ArrayJs.bigUint64Array));
parcelHelpers.export(exports, "asyncModelRun", ()=>(0, _modelRunnerJs.asyncModelRun));
parcelHelpers.export(exports, "modelRun", ()=>(0, _modelRunnerJs.modelRun));
parcelHelpers.export(exports, "scheduledModelRun", ()=>(0, _modelRunnerJs.scheduledModelRun));
parcelHelpers.export(exports, "commands", ()=>(0, _commandsJs.commands));
parcelHelpers.export(exports, "scheduler", ()=>(0, _schedulerJs.scheduler));
parcelHelpers.export(exports, "schedulerFor", ()=>(0, _schedulerJs.schedulerFor));
parcelHelpers.export(exports, "Arbitrary", ()=>(0, _arbitraryJs.Arbitrary));
parcelHelpers.export(exports, "Value", ()=>(0, _valueJs.Value));
parcelHelpers.export(exports, "cloneMethod", ()=>(0, _symbolsJs.cloneMethod));
parcelHelpers.export(exports, "cloneIfNeeded", ()=>(0, _symbolsJs.cloneIfNeeded));
parcelHelpers.export(exports, "hasCloneMethod", ()=>(0, _symbolsJs.hasCloneMethod));
parcelHelpers.export(exports, "toStringMethod", ()=>(0, _stringifyJs.toStringMethod));
parcelHelpers.export(exports, "hasToStringMethod", ()=>(0, _stringifyJs.hasToStringMethod));
parcelHelpers.export(exports, "asyncToStringMethod", ()=>(0, _stringifyJs.asyncToStringMethod));
parcelHelpers.export(exports, "hasAsyncToStringMethod", ()=>(0, _stringifyJs.hasAsyncToStringMethod));
parcelHelpers.export(exports, "getDepthContextFor", ()=>(0, _depthContextJs.getDepthContextFor));
parcelHelpers.export(exports, "stringify", ()=>(0, _stringifyJs.stringify));
parcelHelpers.export(exports, "asyncStringify", ()=>(0, _stringifyJs.asyncStringify));
parcelHelpers.export(exports, "defaultReportMessage", ()=>(0, _runDetailsFormatterJs.defaultReportMessage));
parcelHelpers.export(exports, "asyncDefaultReportMessage", ()=>(0, _runDetailsFormatterJs.asyncDefaultReportMessage));
parcelHelpers.export(exports, "hash", ()=>(0, _hashJs.hash));
parcelHelpers.export(exports, "VerbosityLevel", ()=>(0, _verbosityLevelJs.VerbosityLevel));
parcelHelpers.export(exports, "configureGlobal", ()=>(0, _globalParametersJs.configureGlobal));
parcelHelpers.export(exports, "readConfigureGlobal", ()=>(0, _globalParametersJs.readConfigureGlobal));
parcelHelpers.export(exports, "resetConfigureGlobal", ()=>(0, _globalParametersJs.resetConfigureGlobal));
parcelHelpers.export(exports, "ExecutionStatus", ()=>(0, _executionStatusJs.ExecutionStatus));
parcelHelpers.export(exports, "Random", ()=>(0, _randomJs.Random));
parcelHelpers.export(exports, "Stream", ()=>(0, _streamJs.Stream));
parcelHelpers.export(exports, "stream", ()=>(0, _streamJs.stream));
parcelHelpers.export(exports, "createDepthIdentifier", ()=>(0, _depthContextJs.createDepthIdentifier));
var _preJs = require("./check/precondition/Pre.js");
var _asyncPropertyJs = require("./check/property/AsyncProperty.js");
var _propertyJs = require("./check/property/Property.js");
var _runnerJs = require("./check/runner/Runner.js");
var _samplerJs = require("./check/runner/Sampler.js");
var _genJs = require("./arbitrary/gen.js");
var _arrayJs = require("./arbitrary/array.js");
var _bigIntJs = require("./arbitrary/bigInt.js");
var _bigIntNJs = require("./arbitrary/bigIntN.js");
var _bigUintJs = require("./arbitrary/bigUint.js");
var _bigUintNJs = require("./arbitrary/bigUintN.js");
var _booleanJs = require("./arbitrary/boolean.js");
var _falsyJs = require("./arbitrary/falsy.js");
var _asciiJs = require("./arbitrary/ascii.js");
var _base64Js = require("./arbitrary/base64.js");
var _charJs = require("./arbitrary/char.js");
var _char16BitsJs = require("./arbitrary/char16bits.js");
var _fullUnicodeJs = require("./arbitrary/fullUnicode.js");
var _hexaJs = require("./arbitrary/hexa.js");
var _unicodeJs = require("./arbitrary/unicode.js");
var _constantJs = require("./arbitrary/constant.js");
var _constantFromJs = require("./arbitrary/constantFrom.js");
var _contextJs = require("./arbitrary/context.js");
var _dateJs = require("./arbitrary/date.js");
var _cloneJs = require("./arbitrary/clone.js");
var _dictionaryJs = require("./arbitrary/dictionary.js");
var _emailAddressJs = require("./arbitrary/emailAddress.js");
var _doubleJs = require("./arbitrary/double.js");
var _floatJs = require("./arbitrary/float.js");
var _compareBooleanFuncJs = require("./arbitrary/compareBooleanFunc.js");
var _compareFuncJs = require("./arbitrary/compareFunc.js");
var _funcJs = require("./arbitrary/func.js");
var _domainJs = require("./arbitrary/domain.js");
var _integerJs = require("./arbitrary/integer.js");
var _maxSafeIntegerJs = require("./arbitrary/maxSafeInteger.js");
var _maxSafeNatJs = require("./arbitrary/maxSafeNat.js");
var _natJs = require("./arbitrary/nat.js");
var _ipV4Js = require("./arbitrary/ipV4.js");
var _ipV4ExtendedJs = require("./arbitrary/ipV4Extended.js");
var _ipV6Js = require("./arbitrary/ipV6.js");
var _letrecJs = require("./arbitrary/letrec.js");
var _loremJs = require("./arbitrary/lorem.js");
var _mapToConstantJs = require("./arbitrary/mapToConstant.js");
var _memoJs = require("./arbitrary/memo.js");
var _mixedCaseJs = require("./arbitrary/mixedCase.js");
var _objectJs = require("./arbitrary/object.js");
var _jsonJs = require("./arbitrary/json.js");
var _anythingJs = require("./arbitrary/anything.js");
var _unicodeJsonValueJs = require("./arbitrary/unicodeJsonValue.js");
var _jsonValueJs = require("./arbitrary/jsonValue.js");
var _unicodeJsonJs = require("./arbitrary/unicodeJson.js");
var _oneofJs = require("./arbitrary/oneof.js");
var _optionJs = require("./arbitrary/option.js");
var _recordJs = require("./arbitrary/record.js");
var _uniqueArrayJs = require("./arbitrary/uniqueArray.js");
var _infiniteStreamJs = require("./arbitrary/infiniteStream.js");
var _asciiStringJs = require("./arbitrary/asciiString.js");
var _base64StringJs = require("./arbitrary/base64String.js");
var _fullUnicodeStringJs = require("./arbitrary/fullUnicodeString.js");
var _hexaStringJs = require("./arbitrary/hexaString.js");
var _stringJs = require("./arbitrary/string.js");
var _string16BitsJs = require("./arbitrary/string16bits.js");
var _stringOfJs = require("./arbitrary/stringOf.js");
var _unicodeStringJs = require("./arbitrary/unicodeString.js");
var _subarrayJs = require("./arbitrary/subarray.js");
var _shuffledSubarrayJs = require("./arbitrary/shuffledSubarray.js");
var _tupleJs = require("./arbitrary/tuple.js");
var _ulidJs = require("./arbitrary/ulid.js");
var _uuidJs = require("./arbitrary/uuid.js");
var _uuidVJs = require("./arbitrary/uuidV.js");
var _webAuthorityJs = require("./arbitrary/webAuthority.js");
var _webFragmentsJs = require("./arbitrary/webFragments.js");
var _webPathJs = require("./arbitrary/webPath.js");
var _webQueryParametersJs = require("./arbitrary/webQueryParameters.js");
var _webSegmentJs = require("./arbitrary/webSegment.js");
var _webUrlJs = require("./arbitrary/webUrl.js");
var _commandsJs = require("./arbitrary/commands.js");
var _modelRunnerJs = require("./check/model/ModelRunner.js");
var _randomJs = require("./random/generator/Random.js");
var _globalParametersJs = require("./check/runner/configuration/GlobalParameters.js");
var _verbosityLevelJs = require("./check/runner/configuration/VerbosityLevel.js");
var _executionStatusJs = require("./check/runner/reporter/ExecutionStatus.js");
var _symbolsJs = require("./check/symbols.js");
var _streamJs = require("./stream/Stream.js");
var _hashJs = require("./utils/hash.js");
var _stringifyJs = require("./utils/stringify.js");
var _schedulerJs = require("./arbitrary/scheduler.js");
var _runDetailsFormatterJs = require("./check/runner/utils/RunDetailsFormatter.js");
var _preconditionFailureJs = require("./check/precondition/PreconditionFailure.js");
var _int8ArrayJs = require("./arbitrary/int8Array.js");
var _int16ArrayJs = require("./arbitrary/int16Array.js");
var _int32ArrayJs = require("./arbitrary/int32Array.js");
var _uint8ArrayJs = require("./arbitrary/uint8Array.js");
var _uint8ClampedArrayJs = require("./arbitrary/uint8ClampedArray.js");
var _uint16ArrayJs = require("./arbitrary/uint16Array.js");
var _uint32ArrayJs = require("./arbitrary/uint32Array.js");
var _float32ArrayJs = require("./arbitrary/float32Array.js");
var _float64ArrayJs = require("./arbitrary/float64Array.js");
var _sparseArrayJs = require("./arbitrary/sparseArray.js");
var _arbitraryJs = require("./check/arbitrary/definition/Arbitrary.js");
var _valueJs = require("./check/arbitrary/definition/Value.js");
var _depthContextJs = require("./arbitrary/_internals/helpers/DepthContext.js");
var _bigInt64ArrayJs = require("./arbitrary/bigInt64Array.js");
var _bigUint64ArrayJs = require("./arbitrary/bigUint64Array.js");
var _stringMatchingJs = require("./arbitrary/stringMatching.js");
var _noShrinkJs = require("./arbitrary/noShrink.js");
var _noBiasJs = require("./arbitrary/noBias.js");
var _limitShrinkJs = require("./arbitrary/limitShrink.js");
const __type = 'module';
const __version = '3.23.2';
const __commitHash = 'a4a600eaa08c833707067a877db144289a724b91';

},{"./check/precondition/Pre.js":"hfUu7","./check/property/AsyncProperty.js":"1PXNZ","./check/property/Property.js":"etepV","./check/runner/Runner.js":"jtEkW","./check/runner/Sampler.js":"3qMUZ","./arbitrary/gen.js":"10I3z","./arbitrary/array.js":"eZMHg","./arbitrary/bigInt.js":"ffHa9","./arbitrary/bigIntN.js":"ixzwX","./arbitrary/bigUint.js":"gj8Pi","./arbitrary/bigUintN.js":"7ttyT","./arbitrary/boolean.js":"bazde","./arbitrary/falsy.js":"j13qK","./arbitrary/ascii.js":"bbQ9F","./arbitrary/base64.js":"jfhtz","./arbitrary/char.js":"NNpK4","./arbitrary/char16bits.js":"8ydXM","./arbitrary/fullUnicode.js":"1lTh1","./arbitrary/hexa.js":"1PNQs","./arbitrary/unicode.js":"2sTN2","./arbitrary/constant.js":"6Ey5n","./arbitrary/constantFrom.js":"bZWfh","./arbitrary/context.js":"aJsw3","./arbitrary/date.js":"dhAUk","./arbitrary/clone.js":"gPSBk","./arbitrary/dictionary.js":"k8d7Y","./arbitrary/emailAddress.js":"92bJU","./arbitrary/double.js":"8I26L","./arbitrary/float.js":"4Tn1Y","./arbitrary/compareBooleanFunc.js":"iuKCt","./arbitrary/compareFunc.js":"4xJOs","./arbitrary/func.js":"iiwYq","./arbitrary/domain.js":"irrWS","./arbitrary/integer.js":"embjo","./arbitrary/maxSafeInteger.js":"auNd7","./arbitrary/maxSafeNat.js":"fw31I","./arbitrary/nat.js":"isueS","./arbitrary/ipV4.js":"lIWCt","./arbitrary/ipV4Extended.js":"d0QLr","./arbitrary/ipV6.js":"gHrQA","./arbitrary/letrec.js":"1mp3E","./arbitrary/lorem.js":"iqGts","./arbitrary/mapToConstant.js":"QKun9","./arbitrary/memo.js":"1qE8M","./arbitrary/mixedCase.js":"55a0V","./arbitrary/object.js":"aQQuy","./arbitrary/json.js":"gH44o","./arbitrary/anything.js":"843Dd","./arbitrary/unicodeJsonValue.js":"6IvVE","./arbitrary/jsonValue.js":"jQpeh","./arbitrary/unicodeJson.js":"2meNn","./arbitrary/oneof.js":"cTys0","./arbitrary/option.js":"8sNMn","./arbitrary/record.js":"ct0c7","./arbitrary/uniqueArray.js":"8dSfb","./arbitrary/infiniteStream.js":"7HEQI","./arbitrary/asciiString.js":"fxuVr","./arbitrary/base64String.js":"gohPH","./arbitrary/fullUnicodeString.js":"9AgbI","./arbitrary/hexaString.js":"iMh3o","./arbitrary/string.js":"iHGKT","./arbitrary/string16bits.js":"bmjQM","./arbitrary/stringOf.js":"5vl42","./arbitrary/unicodeString.js":"16ziD","./arbitrary/subarray.js":"kgeWD","./arbitrary/shuffledSubarray.js":"61HTX","./arbitrary/tuple.js":"dw0Pn","./arbitrary/ulid.js":"aBd18","./arbitrary/uuid.js":"b5hPH","./arbitrary/uuidV.js":"6Ocm7","./arbitrary/webAuthority.js":"5rYqd","./arbitrary/webFragments.js":"32wkl","./arbitrary/webPath.js":"5YO6L","./arbitrary/webQueryParameters.js":"cHcCa","./arbitrary/webSegment.js":"8Xxs3","./arbitrary/webUrl.js":"2v3ev","./arbitrary/commands.js":"cER6c","./check/model/ModelRunner.js":"jj37H","./random/generator/Random.js":"2GKne","./check/runner/configuration/GlobalParameters.js":"f6Bj0","./check/runner/configuration/VerbosityLevel.js":"gkUPE","./check/runner/reporter/ExecutionStatus.js":"glGVI","./check/symbols.js":"2AK80","./stream/Stream.js":"2sjal","./utils/hash.js":"6kEiE","./utils/stringify.js":"gOa8u","./arbitrary/scheduler.js":"S5kCw","./check/runner/utils/RunDetailsFormatter.js":"2mhrC","./check/precondition/PreconditionFailure.js":"7yplK","./arbitrary/int8Array.js":"7QGjS","./arbitrary/int16Array.js":"8x0zl","./arbitrary/int32Array.js":"6wLbr","./arbitrary/uint8Array.js":"qWlHB","./arbitrary/uint8ClampedArray.js":"7X0R7","./arbitrary/uint16Array.js":"58AkQ","./arbitrary/uint32Array.js":"5UMvJ","./arbitrary/float32Array.js":"bDHOa","./arbitrary/float64Array.js":"NC4jW","./arbitrary/sparseArray.js":"atKfO","./check/arbitrary/definition/Arbitrary.js":"e6f1K","./check/arbitrary/definition/Value.js":"8Cf1j","./arbitrary/_internals/helpers/DepthContext.js":"dsS0S","./arbitrary/bigInt64Array.js":"8uZyS","./arbitrary/bigUint64Array.js":"eu8NS","./arbitrary/stringMatching.js":"cfmkC","./arbitrary/noShrink.js":"iaGEG","./arbitrary/noBias.js":"likNP","./arbitrary/limitShrink.js":"jmGf1","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"hfUu7":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "pre", ()=>pre);
var _preconditionFailureJs = require("./PreconditionFailure.js");
function pre(expectTruthy) {
    if (!expectTruthy) throw new (0, _preconditionFailureJs.PreconditionFailure)();
}

},{"./PreconditionFailure.js":"7yplK","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"7yplK":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PreconditionFailure", ()=>PreconditionFailure);
class PreconditionFailure extends Error {
    constructor(interruptExecution = false){
        super();
        this.interruptExecution = interruptExecution;
        this.footprint = PreconditionFailure.SharedFootPrint;
    }
    static isFailure(err) {
        return err != null && err.footprint === PreconditionFailure.SharedFootPrint;
    }
}
PreconditionFailure.SharedFootPrint = Symbol.for('fast-check/PreconditionFailure');

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"1PXNZ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "asyncProperty", ()=>asyncProperty);
var _arbitraryJs = require("../arbitrary/definition/Arbitrary.js");
var _tupleJs = require("../../arbitrary/tuple.js");
var _asyncPropertyGenericJs = require("./AsyncProperty.generic.js");
var _alwaysShrinkableArbitraryJs = require("../../arbitrary/_internals/AlwaysShrinkableArbitrary.js");
var _globalsJs = require("../../utils/globals.js");
function asyncProperty(...args) {
    if (args.length < 2) throw new Error('asyncProperty expects at least two parameters');
    const arbs = (0, _globalsJs.safeSlice)(args, 0, args.length - 1);
    const p = args[args.length - 1];
    (0, _globalsJs.safeForEach)(arbs, (0, _arbitraryJs.assertIsArbitrary));
    const mappedArbs = (0, _globalsJs.safeMap)(arbs, (arb)=>new (0, _alwaysShrinkableArbitraryJs.AlwaysShrinkableArbitrary)(arb));
    return new (0, _asyncPropertyGenericJs.AsyncProperty)((0, _tupleJs.tuple)(...mappedArbs), (t)=>p(...t));
}

},{"../arbitrary/definition/Arbitrary.js":"e6f1K","../../arbitrary/tuple.js":"dw0Pn","./AsyncProperty.generic.js":"kBPMe","../../arbitrary/_internals/AlwaysShrinkableArbitrary.js":"2VXzX","../../utils/globals.js":"aTuwn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"e6f1K":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Arbitrary", ()=>Arbitrary);
parcelHelpers.export(exports, "isArbitrary", ()=>isArbitrary);
parcelHelpers.export(exports, "assertIsArbitrary", ()=>assertIsArbitrary);
var _streamJs = require("../../../stream/Stream.js");
var _symbolsJs = require("../../symbols.js");
var _valueJs = require("./Value.js");
const safeObjectAssign = Object.assign;
class Arbitrary {
    filter(refinement) {
        return new FilterArbitrary(this, refinement);
    }
    map(mapper, unmapper) {
        return new MapArbitrary(this, mapper, unmapper);
    }
    chain(chainer) {
        return new ChainArbitrary(this, chainer);
    }
    noShrink() {
        return new NoShrinkArbitrary(this);
    }
    noBias() {
        return new NoBiasArbitrary(this);
    }
}
class ChainArbitrary extends Arbitrary {
    constructor(arb, chainer){
        super();
        this.arb = arb;
        this.chainer = chainer;
    }
    generate(mrng, biasFactor) {
        const clonedMrng = mrng.clone();
        const src = this.arb.generate(mrng, biasFactor);
        return this.valueChainer(src, mrng, clonedMrng, biasFactor);
    }
    canShrinkWithoutContext(value) {
        return false;
    }
    shrink(value, context) {
        if (this.isSafeContext(context)) return (!context.stoppedForOriginal ? this.arb.shrink(context.originalValue, context.originalContext).map((v)=>this.valueChainer(v, context.clonedMrng.clone(), context.clonedMrng, context.originalBias)) : (0, _streamJs.Stream).nil()).join(context.chainedArbitrary.shrink(value, context.chainedContext).map((dst)=>{
            const newContext = safeObjectAssign(safeObjectAssign({}, context), {
                chainedContext: dst.context,
                stoppedForOriginal: true
            });
            return new (0, _valueJs.Value)(dst.value_, newContext);
        }));
        return (0, _streamJs.Stream).nil();
    }
    valueChainer(v, generateMrng, clonedMrng, biasFactor) {
        const chainedArbitrary = this.chainer(v.value_);
        const dst = chainedArbitrary.generate(generateMrng, biasFactor);
        const context = {
            originalBias: biasFactor,
            originalValue: v.value_,
            originalContext: v.context,
            stoppedForOriginal: false,
            chainedArbitrary,
            chainedContext: dst.context,
            clonedMrng
        };
        return new (0, _valueJs.Value)(dst.value_, context);
    }
    isSafeContext(context) {
        return context != null && typeof context === 'object' && 'originalBias' in context && 'originalValue' in context && 'originalContext' in context && 'stoppedForOriginal' in context && 'chainedArbitrary' in context && 'chainedContext' in context && 'clonedMrng' in context;
    }
}
class MapArbitrary extends Arbitrary {
    constructor(arb, mapper, unmapper){
        super();
        this.arb = arb;
        this.mapper = mapper;
        this.unmapper = unmapper;
        this.bindValueMapper = (v)=>this.valueMapper(v);
    }
    generate(mrng, biasFactor) {
        const g = this.arb.generate(mrng, biasFactor);
        return this.valueMapper(g);
    }
    canShrinkWithoutContext(value) {
        if (this.unmapper !== undefined) try {
            const unmapped = this.unmapper(value);
            return this.arb.canShrinkWithoutContext(unmapped);
        } catch (_err) {
            return false;
        }
        return false;
    }
    shrink(value, context) {
        if (this.isSafeContext(context)) return this.arb.shrink(context.originalValue, context.originalContext).map(this.bindValueMapper);
        if (this.unmapper !== undefined) {
            const unmapped = this.unmapper(value);
            return this.arb.shrink(unmapped, undefined).map(this.bindValueMapper);
        }
        return (0, _streamJs.Stream).nil();
    }
    mapperWithCloneIfNeeded(v) {
        const sourceValue = v.value;
        const mappedValue = this.mapper(sourceValue);
        if (v.hasToBeCloned && (typeof mappedValue === 'object' && mappedValue !== null || typeof mappedValue === 'function') && Object.isExtensible(mappedValue) && !(0, _symbolsJs.hasCloneMethod)(mappedValue)) Object.defineProperty(mappedValue, (0, _symbolsJs.cloneMethod), {
            get: ()=>()=>this.mapperWithCloneIfNeeded(v)[0]
        });
        return [
            mappedValue,
            sourceValue
        ];
    }
    valueMapper(v) {
        const [mappedValue, sourceValue] = this.mapperWithCloneIfNeeded(v);
        const context = {
            originalValue: sourceValue,
            originalContext: v.context
        };
        return new (0, _valueJs.Value)(mappedValue, context);
    }
    isSafeContext(context) {
        return context != null && typeof context === 'object' && 'originalValue' in context && 'originalContext' in context;
    }
}
class FilterArbitrary extends Arbitrary {
    constructor(arb, refinement){
        super();
        this.arb = arb;
        this.refinement = refinement;
        this.bindRefinementOnValue = (v)=>this.refinementOnValue(v);
    }
    generate(mrng, biasFactor) {
        while(true){
            const g = this.arb.generate(mrng, biasFactor);
            if (this.refinementOnValue(g)) return g;
        }
    }
    canShrinkWithoutContext(value) {
        return this.arb.canShrinkWithoutContext(value) && this.refinement(value);
    }
    shrink(value, context) {
        return this.arb.shrink(value, context).filter(this.bindRefinementOnValue);
    }
    refinementOnValue(v) {
        return this.refinement(v.value);
    }
}
class NoShrinkArbitrary extends Arbitrary {
    constructor(arb){
        super();
        this.arb = arb;
    }
    generate(mrng, biasFactor) {
        return this.arb.generate(mrng, biasFactor);
    }
    canShrinkWithoutContext(value) {
        return this.arb.canShrinkWithoutContext(value);
    }
    shrink(_value, _context) {
        return (0, _streamJs.Stream).nil();
    }
    noShrink() {
        return this;
    }
}
class NoBiasArbitrary extends Arbitrary {
    constructor(arb){
        super();
        this.arb = arb;
    }
    generate(mrng, _biasFactor) {
        return this.arb.generate(mrng, undefined);
    }
    canShrinkWithoutContext(value) {
        return this.arb.canShrinkWithoutContext(value);
    }
    shrink(value, context) {
        return this.arb.shrink(value, context);
    }
    noBias() {
        return this;
    }
}
function isArbitrary(instance) {
    return typeof instance === 'object' && instance !== null && 'generate' in instance && 'shrink' in instance && 'canShrinkWithoutContext' in instance;
}
function assertIsArbitrary(instance) {
    if (!isArbitrary(instance)) throw new Error('Unexpected value received: not an instance of Arbitrary');
}

},{"../../../stream/Stream.js":"2sjal","../../symbols.js":"2AK80","./Value.js":"8Cf1j","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"2sjal":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Stream", ()=>Stream);
parcelHelpers.export(exports, "stream", ()=>stream);
var _streamHelpersJs = require("./StreamHelpers.js");
const safeSymbolIterator = Symbol.iterator;
class Stream {
    static nil() {
        return new Stream((0, _streamHelpersJs.nilHelper)());
    }
    static of(...elements) {
        return new Stream(elements[safeSymbolIterator]());
    }
    constructor(g){
        this.g = g;
    }
    next() {
        return this.g.next();
    }
    [Symbol.iterator]() {
        return this.g;
    }
    map(f) {
        return new Stream((0, _streamHelpersJs.mapHelper)(this.g, f));
    }
    flatMap(f) {
        return new Stream((0, _streamHelpersJs.flatMapHelper)(this.g, f));
    }
    dropWhile(f) {
        let foundEligible = false;
        function* helper(v) {
            if (foundEligible || !f(v)) {
                foundEligible = true;
                yield v;
            }
        }
        return this.flatMap(helper);
    }
    drop(n) {
        if (n <= 0) return this;
        let idx = 0;
        function helper() {
            return idx++ < n;
        }
        return this.dropWhile(helper);
    }
    takeWhile(f) {
        return new Stream((0, _streamHelpersJs.takeWhileHelper)(this.g, f));
    }
    take(n) {
        return new Stream((0, _streamHelpersJs.takeNHelper)(this.g, n));
    }
    filter(f) {
        return new Stream((0, _streamHelpersJs.filterHelper)(this.g, f));
    }
    every(f) {
        for (const v of this.g){
            if (!f(v)) return false;
        }
        return true;
    }
    has(f) {
        for (const v of this.g){
            if (f(v)) return [
                true,
                v
            ];
        }
        return [
            false,
            null
        ];
    }
    join(...others) {
        return new Stream((0, _streamHelpersJs.joinHelper)(this.g, others));
    }
    getNthOrLast(nth) {
        let remaining = nth;
        let last = null;
        for (const v of this.g){
            if (remaining-- === 0) return v;
            last = v;
        }
        return last;
    }
}
function stream(g) {
    return new Stream(g);
}

},{"./StreamHelpers.js":"4ooFV","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"4ooFV":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "nilHelper", ()=>nilHelper);
parcelHelpers.export(exports, "mapHelper", ()=>mapHelper);
parcelHelpers.export(exports, "flatMapHelper", ()=>flatMapHelper);
parcelHelpers.export(exports, "filterHelper", ()=>filterHelper);
parcelHelpers.export(exports, "takeNHelper", ()=>takeNHelper);
parcelHelpers.export(exports, "takeWhileHelper", ()=>takeWhileHelper);
parcelHelpers.export(exports, "joinHelper", ()=>joinHelper);
class Nil {
    [Symbol.iterator]() {
        return this;
    }
    next(value) {
        return {
            value,
            done: true
        };
    }
}
Nil.nil = new Nil();
function nilHelper() {
    return Nil.nil;
}
function* mapHelper(g, f) {
    for (const v of g)yield f(v);
}
function* flatMapHelper(g, f) {
    for (const v of g)yield* f(v);
}
function* filterHelper(g, f) {
    for (const v of g)if (f(v)) yield v;
}
function* takeNHelper(g, n) {
    for(let i = 0; i < n; ++i){
        const cur = g.next();
        if (cur.done) break;
        yield cur.value;
    }
}
function* takeWhileHelper(g, f) {
    let cur = g.next();
    while(!cur.done && f(cur.value)){
        yield cur.value;
        cur = g.next();
    }
}
function* joinHelper(g, others) {
    for(let cur = g.next(); !cur.done; cur = g.next())yield cur.value;
    for (const s of others)for(let cur = s.next(); !cur.done; cur = s.next())yield cur.value;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"2AK80":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "cloneMethod", ()=>cloneMethod);
parcelHelpers.export(exports, "hasCloneMethod", ()=>hasCloneMethod);
parcelHelpers.export(exports, "cloneIfNeeded", ()=>cloneIfNeeded);
const cloneMethod = Symbol.for('fast-check/cloneMethod');
function hasCloneMethod(instance) {
    return instance !== null && (typeof instance === 'object' || typeof instance === 'function') && cloneMethod in instance && typeof instance[cloneMethod] === 'function';
}
function cloneIfNeeded(instance) {
    return hasCloneMethod(instance) ? instance[cloneMethod]() : instance;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"8Cf1j":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Value", ()=>Value);
var _symbolsJs = require("../../symbols.js");
const safeObjectDefineProperty = Object.defineProperty;
class Value {
    constructor(value_, context, customGetValue){
        this.value_ = value_;
        this.context = context;
        this.hasToBeCloned = customGetValue !== undefined || (0, _symbolsJs.hasCloneMethod)(value_);
        this.readOnce = false;
        if (this.hasToBeCloned) safeObjectDefineProperty(this, 'value', {
            get: customGetValue !== undefined ? customGetValue : this.getValue
        });
        else this.value = value_;
    }
    getValue() {
        if (this.hasToBeCloned) {
            if (!this.readOnce) {
                this.readOnce = true;
                return this.value_;
            }
            return this.value_[0, _symbolsJs.cloneMethod]();
        }
        return this.value_;
    }
}

},{"../../symbols.js":"2AK80","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"dw0Pn":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "tuple", ()=>tuple);
var _tupleArbitraryJs = require("./_internals/TupleArbitrary.js");
function tuple(...arbs) {
    return new (0, _tupleArbitraryJs.TupleArbitrary)(arbs);
}

},{"./_internals/TupleArbitrary.js":"9Zf7s","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"9Zf7s":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "tupleShrink", ()=>tupleShrink);
parcelHelpers.export(exports, "TupleArbitrary", ()=>TupleArbitrary);
var _streamJs = require("../../stream/Stream.js");
var _symbolsJs = require("../../check/symbols.js");
var _arbitraryJs = require("../../check/arbitrary/definition/Arbitrary.js");
var _valueJs = require("../../check/arbitrary/definition/Value.js");
var _globalsJs = require("../../utils/globals.js");
var _lazyIterableIteratorJs = require("../../stream/LazyIterableIterator.js");
const safeArrayIsArray = Array.isArray;
const safeObjectDefineProperty = Object.defineProperty;
function tupleMakeItCloneable(vs, values) {
    return safeObjectDefineProperty(vs, (0, _symbolsJs.cloneMethod), {
        value: ()=>{
            const cloned = [];
            for(let idx = 0; idx !== values.length; ++idx)(0, _globalsJs.safePush)(cloned, values[idx].value);
            tupleMakeItCloneable(cloned, values);
            return cloned;
        }
    });
}
function tupleWrapper(values) {
    let cloneable = false;
    const vs = [];
    const ctxs = [];
    for(let idx = 0; idx !== values.length; ++idx){
        const v = values[idx];
        cloneable = cloneable || v.hasToBeCloned;
        (0, _globalsJs.safePush)(vs, v.value);
        (0, _globalsJs.safePush)(ctxs, v.context);
    }
    if (cloneable) tupleMakeItCloneable(vs, values);
    return new (0, _valueJs.Value)(vs, ctxs);
}
function tupleShrink(arbs, value, context) {
    const shrinks = [];
    const safeContext = safeArrayIsArray(context) ? context : [];
    for(let idx = 0; idx !== arbs.length; ++idx)(0, _globalsJs.safePush)(shrinks, (0, _lazyIterableIteratorJs.makeLazy)(()=>arbs[idx].shrink(value[idx], safeContext[idx]).map((v)=>{
            const nextValues = (0, _globalsJs.safeMap)(value, (v, idx)=>new (0, _valueJs.Value)((0, _symbolsJs.cloneIfNeeded)(v), safeContext[idx]));
            return [
                ...(0, _globalsJs.safeSlice)(nextValues, 0, idx),
                v,
                ...(0, _globalsJs.safeSlice)(nextValues, idx + 1)
            ];
        }).map(tupleWrapper)));
    return (0, _streamJs.Stream).nil().join(...shrinks);
}
class TupleArbitrary extends (0, _arbitraryJs.Arbitrary) {
    constructor(arbs){
        super();
        this.arbs = arbs;
        for(let idx = 0; idx !== arbs.length; ++idx){
            const arb = arbs[idx];
            if (arb == null || arb.generate == null) throw new Error(`Invalid parameter encountered at index ${idx}: expecting an Arbitrary`);
        }
    }
    generate(mrng, biasFactor) {
        const mapped = [];
        for(let idx = 0; idx !== this.arbs.length; ++idx)(0, _globalsJs.safePush)(mapped, this.arbs[idx].generate(mrng, biasFactor));
        return tupleWrapper(mapped);
    }
    canShrinkWithoutContext(value) {
        if (!safeArrayIsArray(value) || value.length !== this.arbs.length) return false;
        for(let index = 0; index !== this.arbs.length; ++index){
            if (!this.arbs[index].canShrinkWithoutContext(value[index])) return false;
        }
        return true;
    }
    shrink(value, context) {
        return tupleShrink(this.arbs, value, context);
    }
}

},{"../../stream/Stream.js":"2sjal","../../check/symbols.js":"2AK80","../../check/arbitrary/definition/Arbitrary.js":"e6f1K","../../check/arbitrary/definition/Value.js":"8Cf1j","../../utils/globals.js":"aTuwn","../../stream/LazyIterableIterator.js":"bnj2K","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"aTuwn":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Array", ()=>SArray);
parcelHelpers.export(exports, "BigInt", ()=>SBigInt);
parcelHelpers.export(exports, "BigInt64Array", ()=>SBigInt64Array);
parcelHelpers.export(exports, "BigUint64Array", ()=>SBigUint64Array);
parcelHelpers.export(exports, "Boolean", ()=>SBoolean);
parcelHelpers.export(exports, "Date", ()=>SDate);
parcelHelpers.export(exports, "Error", ()=>SError);
parcelHelpers.export(exports, "Float32Array", ()=>SFloat32Array);
parcelHelpers.export(exports, "Float64Array", ()=>SFloat64Array);
parcelHelpers.export(exports, "Int8Array", ()=>SInt8Array);
parcelHelpers.export(exports, "Int16Array", ()=>SInt16Array);
parcelHelpers.export(exports, "Int32Array", ()=>SInt32Array);
parcelHelpers.export(exports, "Number", ()=>SNumber);
parcelHelpers.export(exports, "String", ()=>SString);
parcelHelpers.export(exports, "Set", ()=>SSet);
parcelHelpers.export(exports, "Uint8Array", ()=>SUint8Array);
parcelHelpers.export(exports, "Uint8ClampedArray", ()=>SUint8ClampedArray);
parcelHelpers.export(exports, "Uint16Array", ()=>SUint16Array);
parcelHelpers.export(exports, "Uint32Array", ()=>SUint32Array);
parcelHelpers.export(exports, "encodeURIComponent", ()=>SencodeURIComponent);
parcelHelpers.export(exports, "Map", ()=>SMap);
parcelHelpers.export(exports, "Symbol", ()=>SSymbol);
parcelHelpers.export(exports, "safeForEach", ()=>safeForEach);
parcelHelpers.export(exports, "safeIndexOf", ()=>safeIndexOf);
parcelHelpers.export(exports, "safeJoin", ()=>safeJoin);
parcelHelpers.export(exports, "safeMap", ()=>safeMap);
parcelHelpers.export(exports, "safeFilter", ()=>safeFilter);
parcelHelpers.export(exports, "safePush", ()=>safePush);
parcelHelpers.export(exports, "safePop", ()=>safePop);
parcelHelpers.export(exports, "safeSplice", ()=>safeSplice);
parcelHelpers.export(exports, "safeSlice", ()=>safeSlice);
parcelHelpers.export(exports, "safeSort", ()=>safeSort);
parcelHelpers.export(exports, "safeEvery", ()=>safeEvery);
parcelHelpers.export(exports, "safeGetTime", ()=>safeGetTime);
parcelHelpers.export(exports, "safeToISOString", ()=>safeToISOString);
parcelHelpers.export(exports, "safeAdd", ()=>safeAdd);
parcelHelpers.export(exports, "safeHas", ()=>safeHas);
parcelHelpers.export(exports, "safeSet", ()=>safeSet);
parcelHelpers.export(exports, "safeGet", ()=>safeGet);
parcelHelpers.export(exports, "safeMapSet", ()=>safeMapSet);
parcelHelpers.export(exports, "safeMapGet", ()=>safeMapGet);
parcelHelpers.export(exports, "safeSplit", ()=>safeSplit);
parcelHelpers.export(exports, "safeStartsWith", ()=>safeStartsWith);
parcelHelpers.export(exports, "safeEndsWith", ()=>safeEndsWith);
parcelHelpers.export(exports, "safeSubstring", ()=>safeSubstring);
parcelHelpers.export(exports, "safeToLowerCase", ()=>safeToLowerCase);
parcelHelpers.export(exports, "safeToUpperCase", ()=>safeToUpperCase);
parcelHelpers.export(exports, "safePadStart", ()=>safePadStart);
parcelHelpers.export(exports, "safeCharCodeAt", ()=>safeCharCodeAt);
parcelHelpers.export(exports, "safeNormalize", ()=>safeNormalize);
parcelHelpers.export(exports, "safeReplace", ()=>safeReplace);
parcelHelpers.export(exports, "safeNumberToString", ()=>safeNumberToString);
parcelHelpers.export(exports, "safeHasOwnProperty", ()=>safeHasOwnProperty);
parcelHelpers.export(exports, "safeToString", ()=>safeToString);
var _applyJs = require("./apply.js");
const SArray = typeof Array !== 'undefined' ? Array : undefined;
const SBigInt = typeof BigInt !== 'undefined' ? BigInt : undefined;
const SBigInt64Array = typeof BigInt64Array !== 'undefined' ? BigInt64Array : undefined;
const SBigUint64Array = typeof BigUint64Array !== 'undefined' ? BigUint64Array : undefined;
const SBoolean = typeof Boolean !== 'undefined' ? Boolean : undefined;
const SDate = typeof Date !== 'undefined' ? Date : undefined;
const SError = typeof Error !== 'undefined' ? Error : undefined;
const SFloat32Array = typeof Float32Array !== 'undefined' ? Float32Array : undefined;
const SFloat64Array = typeof Float64Array !== 'undefined' ? Float64Array : undefined;
const SInt8Array = typeof Int8Array !== 'undefined' ? Int8Array : undefined;
const SInt16Array = typeof Int16Array !== 'undefined' ? Int16Array : undefined;
const SInt32Array = typeof Int32Array !== 'undefined' ? Int32Array : undefined;
const SNumber = typeof Number !== 'undefined' ? Number : undefined;
const SString = typeof String !== 'undefined' ? String : undefined;
const SSet = typeof Set !== 'undefined' ? Set : undefined;
const SUint8Array = typeof Uint8Array !== 'undefined' ? Uint8Array : undefined;
const SUint8ClampedArray = typeof Uint8ClampedArray !== 'undefined' ? Uint8ClampedArray : undefined;
const SUint16Array = typeof Uint16Array !== 'undefined' ? Uint16Array : undefined;
const SUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : undefined;
const SencodeURIComponent = typeof encodeURIComponent !== 'undefined' ? encodeURIComponent : undefined;
const SMap = Map;
const SSymbol = Symbol;
const untouchedForEach = Array.prototype.forEach;
const untouchedIndexOf = Array.prototype.indexOf;
const untouchedJoin = Array.prototype.join;
const untouchedMap = Array.prototype.map;
const untouchedFilter = Array.prototype.filter;
const untouchedPush = Array.prototype.push;
const untouchedPop = Array.prototype.pop;
const untouchedSplice = Array.prototype.splice;
const untouchedSlice = Array.prototype.slice;
const untouchedSort = Array.prototype.sort;
const untouchedEvery = Array.prototype.every;
function extractForEach(instance) {
    try {
        return instance.forEach;
    } catch (err) {
        return undefined;
    }
}
function extractIndexOf(instance) {
    try {
        return instance.indexOf;
    } catch (err) {
        return undefined;
    }
}
function extractJoin(instance) {
    try {
        return instance.join;
    } catch (err) {
        return undefined;
    }
}
function extractMap(instance) {
    try {
        return instance.map;
    } catch (err) {
        return undefined;
    }
}
function extractFilter(instance) {
    try {
        return instance.filter;
    } catch (err) {
        return undefined;
    }
}
function extractPush(instance) {
    try {
        return instance.push;
    } catch (err) {
        return undefined;
    }
}
function extractPop(instance) {
    try {
        return instance.pop;
    } catch (err) {
        return undefined;
    }
}
function extractSplice(instance) {
    try {
        return instance.splice;
    } catch (err) {
        return undefined;
    }
}
function extractSlice(instance) {
    try {
        return instance.slice;
    } catch (err) {
        return undefined;
    }
}
function extractSort(instance) {
    try {
        return instance.sort;
    } catch (err) {
        return undefined;
    }
}
function extractEvery(instance) {
    try {
        return instance.every;
    } catch (err) {
        return undefined;
    }
}
function safeForEach(instance, fn) {
    if (extractForEach(instance) === untouchedForEach) return instance.forEach(fn);
    return (0, _applyJs.safeApply)(untouchedForEach, instance, [
        fn
    ]);
}
function safeIndexOf(instance, ...args) {
    if (extractIndexOf(instance) === untouchedIndexOf) return instance.indexOf(...args);
    return (0, _applyJs.safeApply)(untouchedIndexOf, instance, args);
}
function safeJoin(instance, ...args) {
    if (extractJoin(instance) === untouchedJoin) return instance.join(...args);
    return (0, _applyJs.safeApply)(untouchedJoin, instance, args);
}
function safeMap(instance, fn) {
    if (extractMap(instance) === untouchedMap) return instance.map(fn);
    return (0, _applyJs.safeApply)(untouchedMap, instance, [
        fn
    ]);
}
function safeFilter(instance, predicate) {
    if (extractFilter(instance) === untouchedFilter) return instance.filter(predicate);
    return (0, _applyJs.safeApply)(untouchedFilter, instance, [
        predicate
    ]);
}
function safePush(instance, ...args) {
    if (extractPush(instance) === untouchedPush) return instance.push(...args);
    return (0, _applyJs.safeApply)(untouchedPush, instance, args);
}
function safePop(instance) {
    if (extractPop(instance) === untouchedPop) return instance.pop();
    return (0, _applyJs.safeApply)(untouchedPop, instance, []);
}
function safeSplice(instance, ...args) {
    if (extractSplice(instance) === untouchedSplice) return instance.splice(...args);
    return (0, _applyJs.safeApply)(untouchedSplice, instance, args);
}
function safeSlice(instance, ...args) {
    if (extractSlice(instance) === untouchedSlice) return instance.slice(...args);
    return (0, _applyJs.safeApply)(untouchedSlice, instance, args);
}
function safeSort(instance, ...args) {
    if (extractSort(instance) === untouchedSort) return instance.sort(...args);
    return (0, _applyJs.safeApply)(untouchedSort, instance, args);
}
function safeEvery(instance, ...args) {
    if (extractEvery(instance) === untouchedEvery) return instance.every(...args);
    return (0, _applyJs.safeApply)(untouchedEvery, instance, args);
}
const untouchedGetTime = Date.prototype.getTime;
const untouchedToISOString = Date.prototype.toISOString;
function extractGetTime(instance) {
    try {
        return instance.getTime;
    } catch (err) {
        return undefined;
    }
}
function extractToISOString(instance) {
    try {
        return instance.toISOString;
    } catch (err) {
        return undefined;
    }
}
function safeGetTime(instance) {
    if (extractGetTime(instance) === untouchedGetTime) return instance.getTime();
    return (0, _applyJs.safeApply)(untouchedGetTime, instance, []);
}
function safeToISOString(instance) {
    if (extractToISOString(instance) === untouchedToISOString) return instance.toISOString();
    return (0, _applyJs.safeApply)(untouchedToISOString, instance, []);
}
const untouchedAdd = Set.prototype.add;
const untouchedHas = Set.prototype.has;
function extractAdd(instance) {
    try {
        return instance.add;
    } catch (err) {
        return undefined;
    }
}
function extractHas(instance) {
    try {
        return instance.has;
    } catch (err) {
        return undefined;
    }
}
function safeAdd(instance, value) {
    if (extractAdd(instance) === untouchedAdd) return instance.add(value);
    return (0, _applyJs.safeApply)(untouchedAdd, instance, [
        value
    ]);
}
function safeHas(instance, value) {
    if (extractHas(instance) === untouchedHas) return instance.has(value);
    return (0, _applyJs.safeApply)(untouchedHas, instance, [
        value
    ]);
}
const untouchedSet = WeakMap.prototype.set;
const untouchedGet = WeakMap.prototype.get;
function extractSet(instance) {
    try {
        return instance.set;
    } catch (err) {
        return undefined;
    }
}
function extractGet(instance) {
    try {
        return instance.get;
    } catch (err) {
        return undefined;
    }
}
function safeSet(instance, key, value) {
    if (extractSet(instance) === untouchedSet) return instance.set(key, value);
    return (0, _applyJs.safeApply)(untouchedSet, instance, [
        key,
        value
    ]);
}
function safeGet(instance, key) {
    if (extractGet(instance) === untouchedGet) return instance.get(key);
    return (0, _applyJs.safeApply)(untouchedGet, instance, [
        key
    ]);
}
const untouchedMapSet = Map.prototype.set;
const untouchedMapGet = Map.prototype.get;
function extractMapSet(instance) {
    try {
        return instance.set;
    } catch (err) {
        return undefined;
    }
}
function extractMapGet(instance) {
    try {
        return instance.get;
    } catch (err) {
        return undefined;
    }
}
function safeMapSet(instance, key, value) {
    if (extractMapSet(instance) === untouchedMapSet) return instance.set(key, value);
    return (0, _applyJs.safeApply)(untouchedMapSet, instance, [
        key,
        value
    ]);
}
function safeMapGet(instance, key) {
    if (extractMapGet(instance) === untouchedMapGet) return instance.get(key);
    return (0, _applyJs.safeApply)(untouchedMapGet, instance, [
        key
    ]);
}
const untouchedSplit = String.prototype.split;
const untouchedStartsWith = String.prototype.startsWith;
const untouchedEndsWith = String.prototype.endsWith;
const untouchedSubstring = String.prototype.substring;
const untouchedToLowerCase = String.prototype.toLowerCase;
const untouchedToUpperCase = String.prototype.toUpperCase;
const untouchedPadStart = String.prototype.padStart;
const untouchedCharCodeAt = String.prototype.charCodeAt;
const untouchedNormalize = String.prototype.normalize;
const untouchedReplace = String.prototype.replace;
function extractSplit(instance) {
    try {
        return instance.split;
    } catch (err) {
        return undefined;
    }
}
function extractStartsWith(instance) {
    try {
        return instance.startsWith;
    } catch (err) {
        return undefined;
    }
}
function extractEndsWith(instance) {
    try {
        return instance.endsWith;
    } catch (err) {
        return undefined;
    }
}
function extractSubstring(instance) {
    try {
        return instance.substring;
    } catch (err) {
        return undefined;
    }
}
function extractToLowerCase(instance) {
    try {
        return instance.toLowerCase;
    } catch (err) {
        return undefined;
    }
}
function extractToUpperCase(instance) {
    try {
        return instance.toUpperCase;
    } catch (err) {
        return undefined;
    }
}
function extractPadStart(instance) {
    try {
        return instance.padStart;
    } catch (err) {
        return undefined;
    }
}
function extractCharCodeAt(instance) {
    try {
        return instance.charCodeAt;
    } catch (err) {
        return undefined;
    }
}
function extractNormalize(instance) {
    try {
        return instance.normalize;
    } catch (err) {
        return undefined;
    }
}
function extractReplace(instance) {
    try {
        return instance.replace;
    } catch (err) {
        return undefined;
    }
}
function safeSplit(instance, ...args) {
    if (extractSplit(instance) === untouchedSplit) return instance.split(...args);
    return (0, _applyJs.safeApply)(untouchedSplit, instance, args);
}
function safeStartsWith(instance, ...args) {
    if (extractStartsWith(instance) === untouchedStartsWith) return instance.startsWith(...args);
    return (0, _applyJs.safeApply)(untouchedStartsWith, instance, args);
}
function safeEndsWith(instance, ...args) {
    if (extractEndsWith(instance) === untouchedEndsWith) return instance.endsWith(...args);
    return (0, _applyJs.safeApply)(untouchedEndsWith, instance, args);
}
function safeSubstring(instance, ...args) {
    if (extractSubstring(instance) === untouchedSubstring) return instance.substring(...args);
    return (0, _applyJs.safeApply)(untouchedSubstring, instance, args);
}
function safeToLowerCase(instance) {
    if (extractToLowerCase(instance) === untouchedToLowerCase) return instance.toLowerCase();
    return (0, _applyJs.safeApply)(untouchedToLowerCase, instance, []);
}
function safeToUpperCase(instance) {
    if (extractToUpperCase(instance) === untouchedToUpperCase) return instance.toUpperCase();
    return (0, _applyJs.safeApply)(untouchedToUpperCase, instance, []);
}
function safePadStart(instance, ...args) {
    if (extractPadStart(instance) === untouchedPadStart) return instance.padStart(...args);
    return (0, _applyJs.safeApply)(untouchedPadStart, instance, args);
}
function safeCharCodeAt(instance, index) {
    if (extractCharCodeAt(instance) === untouchedCharCodeAt) return instance.charCodeAt(index);
    return (0, _applyJs.safeApply)(untouchedCharCodeAt, instance, [
        index
    ]);
}
function safeNormalize(instance, form) {
    if (extractNormalize(instance) === untouchedNormalize) return instance.normalize(form);
    return (0, _applyJs.safeApply)(untouchedNormalize, instance, [
        form
    ]);
}
function safeReplace(instance, pattern, replacement) {
    if (extractReplace(instance) === untouchedReplace) return instance.replace(pattern, replacement);
    return (0, _applyJs.safeApply)(untouchedReplace, instance, [
        pattern,
        replacement
    ]);
}
const untouchedNumberToString = Number.prototype.toString;
function extractNumberToString(instance) {
    try {
        return instance.toString;
    } catch (err) {
        return undefined;
    }
}
function safeNumberToString(instance, ...args) {
    if (extractNumberToString(instance) === untouchedNumberToString) return instance.toString(...args);
    return (0, _applyJs.safeApply)(untouchedNumberToString, instance, args);
}
const untouchedHasOwnProperty = Object.prototype.hasOwnProperty;
const untouchedToString = Object.prototype.toString;
function safeHasOwnProperty(instance, v) {
    return (0, _applyJs.safeApply)(untouchedHasOwnProperty, instance, [
        v
    ]);
}
function safeToString(instance) {
    return (0, _applyJs.safeApply)(untouchedToString, instance, []);
}

},{"./apply.js":"53OA1","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"53OA1":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "safeApply", ()=>safeApply);
const untouchedApply = Function.prototype.apply;
const ApplySymbol = Symbol('apply');
function safeExtractApply(f) {
    try {
        return f.apply;
    } catch (err) {
        return undefined;
    }
}
function safeApplyHacky(f, instance, args) {
    const ff = f;
    ff[ApplySymbol] = untouchedApply;
    const out = ff[ApplySymbol](instance, args);
    delete ff[ApplySymbol];
    return out;
}
function safeApply(f, instance, args) {
    if (safeExtractApply(f) === untouchedApply) return f.apply(instance, args);
    return safeApplyHacky(f, instance, args);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"bnj2K":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeLazy", ()=>makeLazy);
class LazyIterableIterator {
    constructor(producer){
        this.producer = producer;
    }
    [Symbol.iterator]() {
        if (this.it === undefined) this.it = this.producer();
        return this.it;
    }
    next() {
        if (this.it === undefined) this.it = this.producer();
        return this.it.next();
    }
}
function makeLazy(producer) {
    return new LazyIterableIterator(producer);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"kBPMe":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AsyncProperty", ()=>AsyncProperty);
var _preconditionFailureJs = require("../precondition/PreconditionFailure.js");
var _irawPropertyJs = require("./IRawProperty.js");
var _globalParametersJs = require("../runner/configuration/GlobalParameters.js");
var _streamJs = require("../../stream/Stream.js");
var _noUndefinedAsContextJs = require("../../arbitrary/_internals/helpers/NoUndefinedAsContext.js");
var _globalsJs = require("../../utils/globals.js");
class AsyncProperty {
    constructor(arb, predicate){
        this.arb = arb;
        this.predicate = predicate;
        const { asyncBeforeEach, asyncAfterEach, beforeEach, afterEach } = (0, _globalParametersJs.readConfigureGlobal)() || {};
        if (asyncBeforeEach !== undefined && beforeEach !== undefined) throw (0, _globalsJs.Error)('Global "asyncBeforeEach" and "beforeEach" parameters can\'t be set at the same time when running async properties');
        if (asyncAfterEach !== undefined && afterEach !== undefined) throw (0, _globalsJs.Error)('Global "asyncAfterEach" and "afterEach" parameters can\'t be set at the same time when running async properties');
        this.beforeEachHook = asyncBeforeEach || beforeEach || AsyncProperty.dummyHook;
        this.afterEachHook = asyncAfterEach || afterEach || AsyncProperty.dummyHook;
    }
    isAsync() {
        return true;
    }
    generate(mrng, runId) {
        const value = this.arb.generate(mrng, runId != null ? (0, _irawPropertyJs.runIdToFrequency)(runId) : undefined);
        return (0, _noUndefinedAsContextJs.noUndefinedAsContext)(value);
    }
    shrink(value) {
        if (value.context === undefined && !this.arb.canShrinkWithoutContext(value.value_)) return (0, _streamJs.Stream).nil();
        const safeContext = value.context !== (0, _noUndefinedAsContextJs.UndefinedContextPlaceholder) ? value.context : undefined;
        return this.arb.shrink(value.value_, safeContext).map((0, _noUndefinedAsContextJs.noUndefinedAsContext));
    }
    async runBeforeEach() {
        await this.beforeEachHook();
    }
    async runAfterEach() {
        await this.afterEachHook();
    }
    async run(v, dontRunHook) {
        if (!dontRunHook) await this.beforeEachHook();
        try {
            const output = await this.predicate(v);
            return output == null || output === true ? null : {
                error: new (0, _globalsJs.Error)('Property failed by returning false'),
                errorMessage: 'Error: Property failed by returning false'
            };
        } catch (err) {
            if ((0, _preconditionFailureJs.PreconditionFailure).isFailure(err)) return err;
            if (err instanceof (0, _globalsJs.Error) && err.stack) return {
                error: err,
                errorMessage: err.stack
            };
            return {
                error: err,
                errorMessage: (0, _globalsJs.String)(err)
            };
        } finally{
            if (!dontRunHook) await this.afterEachHook();
        }
    }
    beforeEach(hookFunction) {
        const previousBeforeEachHook = this.beforeEachHook;
        this.beforeEachHook = ()=>hookFunction(previousBeforeEachHook);
        return this;
    }
    afterEach(hookFunction) {
        const previousAfterEachHook = this.afterEachHook;
        this.afterEachHook = ()=>hookFunction(previousAfterEachHook);
        return this;
    }
}
AsyncProperty.dummyHook = ()=>{};

},{"../precondition/PreconditionFailure.js":"7yplK","./IRawProperty.js":"3KS1o","../runner/configuration/GlobalParameters.js":"f6Bj0","../../stream/Stream.js":"2sjal","../../arbitrary/_internals/helpers/NoUndefinedAsContext.js":"b32Rp","../../utils/globals.js":"aTuwn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"3KS1o":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "runIdToFrequency", ()=>runIdToFrequency);
const safeMathLog = Math.log;
function runIdToFrequency(runId) {
    return 2 + ~~(safeMathLog(runId + 1) * 0.4342944819032518);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"f6Bj0":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "configureGlobal", ()=>configureGlobal);
parcelHelpers.export(exports, "readConfigureGlobal", ()=>readConfigureGlobal);
parcelHelpers.export(exports, "resetConfigureGlobal", ()=>resetConfigureGlobal);
let globalParameters = {};
function configureGlobal(parameters) {
    globalParameters = parameters;
}
function readConfigureGlobal() {
    return globalParameters;
}
function resetConfigureGlobal() {
    globalParameters = {};
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"b32Rp":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "UndefinedContextPlaceholder", ()=>UndefinedContextPlaceholder);
parcelHelpers.export(exports, "noUndefinedAsContext", ()=>noUndefinedAsContext);
var _valueJs = require("../../../check/arbitrary/definition/Value.js");
const UndefinedContextPlaceholder = Symbol('UndefinedContextPlaceholder');
function noUndefinedAsContext(value) {
    if (value.context !== undefined) return value;
    if (value.hasToBeCloned) return new (0, _valueJs.Value)(value.value_, UndefinedContextPlaceholder, ()=>value.value);
    return new (0, _valueJs.Value)(value.value_, UndefinedContextPlaceholder);
}

},{"../../../check/arbitrary/definition/Value.js":"8Cf1j","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"2VXzX":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AlwaysShrinkableArbitrary", ()=>AlwaysShrinkableArbitrary);
var _arbitraryJs = require("../../check/arbitrary/definition/Arbitrary.js");
var _streamJs = require("../../stream/Stream.js");
var _noUndefinedAsContextJs = require("./helpers/NoUndefinedAsContext.js");
class AlwaysShrinkableArbitrary extends (0, _arbitraryJs.Arbitrary) {
    constructor(arb){
        super();
        this.arb = arb;
    }
    generate(mrng, biasFactor) {
        const value = this.arb.generate(mrng, biasFactor);
        return (0, _noUndefinedAsContextJs.noUndefinedAsContext)(value);
    }
    canShrinkWithoutContext(value) {
        return true;
    }
    shrink(value, context) {
        if (context === undefined && !this.arb.canShrinkWithoutContext(value)) return (0, _streamJs.Stream).nil();
        const safeContext = context !== (0, _noUndefinedAsContextJs.UndefinedContextPlaceholder) ? context : undefined;
        return this.arb.shrink(value, safeContext).map((0, _noUndefinedAsContextJs.noUndefinedAsContext));
    }
}

},{"../../check/arbitrary/definition/Arbitrary.js":"e6f1K","../../stream/Stream.js":"2sjal","./helpers/NoUndefinedAsContext.js":"b32Rp","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"etepV":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "property", ()=>property);
var _arbitraryJs = require("../arbitrary/definition/Arbitrary.js");
var _tupleJs = require("../../arbitrary/tuple.js");
var _propertyGenericJs = require("./Property.generic.js");
var _alwaysShrinkableArbitraryJs = require("../../arbitrary/_internals/AlwaysShrinkableArbitrary.js");
var _globalsJs = require("../../utils/globals.js");
function property(...args) {
    if (args.length < 2) throw new Error('property expects at least two parameters');
    const arbs = (0, _globalsJs.safeSlice)(args, 0, args.length - 1);
    const p = args[args.length - 1];
    (0, _globalsJs.safeForEach)(arbs, (0, _arbitraryJs.assertIsArbitrary));
    const mappedArbs = (0, _globalsJs.safeMap)(arbs, (arb)=>new (0, _alwaysShrinkableArbitraryJs.AlwaysShrinkableArbitrary)(arb));
    return new (0, _propertyGenericJs.Property)((0, _tupleJs.tuple)(...mappedArbs), (t)=>p(...t));
}

},{"../arbitrary/definition/Arbitrary.js":"e6f1K","../../arbitrary/tuple.js":"dw0Pn","./Property.generic.js":"5KTN2","../../arbitrary/_internals/AlwaysShrinkableArbitrary.js":"2VXzX","../../utils/globals.js":"aTuwn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"5KTN2":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Property", ()=>Property);
var _preconditionFailureJs = require("../precondition/PreconditionFailure.js");
var _irawPropertyJs = require("./IRawProperty.js");
var _globalParametersJs = require("../runner/configuration/GlobalParameters.js");
var _streamJs = require("../../stream/Stream.js");
var _noUndefinedAsContextJs = require("../../arbitrary/_internals/helpers/NoUndefinedAsContext.js");
var _globalsJs = require("../../utils/globals.js");
class Property {
    constructor(arb, predicate){
        this.arb = arb;
        this.predicate = predicate;
        const { beforeEach = Property.dummyHook, afterEach = Property.dummyHook, asyncBeforeEach, asyncAfterEach } = (0, _globalParametersJs.readConfigureGlobal)() || {};
        if (asyncBeforeEach !== undefined) throw (0, _globalsJs.Error)('"asyncBeforeEach" can\'t be set when running synchronous properties');
        if (asyncAfterEach !== undefined) throw (0, _globalsJs.Error)('"asyncAfterEach" can\'t be set when running synchronous properties');
        this.beforeEachHook = beforeEach;
        this.afterEachHook = afterEach;
    }
    isAsync() {
        return false;
    }
    generate(mrng, runId) {
        const value = this.arb.generate(mrng, runId != null ? (0, _irawPropertyJs.runIdToFrequency)(runId) : undefined);
        return (0, _noUndefinedAsContextJs.noUndefinedAsContext)(value);
    }
    shrink(value) {
        if (value.context === undefined && !this.arb.canShrinkWithoutContext(value.value_)) return (0, _streamJs.Stream).nil();
        const safeContext = value.context !== (0, _noUndefinedAsContextJs.UndefinedContextPlaceholder) ? value.context : undefined;
        return this.arb.shrink(value.value_, safeContext).map((0, _noUndefinedAsContextJs.noUndefinedAsContext));
    }
    runBeforeEach() {
        this.beforeEachHook();
    }
    runAfterEach() {
        this.afterEachHook();
    }
    run(v, dontRunHook) {
        if (!dontRunHook) this.beforeEachHook();
        try {
            const output = this.predicate(v);
            return output == null || output === true ? null : {
                error: new (0, _globalsJs.Error)('Property failed by returning false'),
                errorMessage: 'Error: Property failed by returning false'
            };
        } catch (err) {
            if ((0, _preconditionFailureJs.PreconditionFailure).isFailure(err)) return err;
            if (err instanceof (0, _globalsJs.Error) && err.stack) return {
                error: err,
                errorMessage: err.stack
            };
            return {
                error: err,
                errorMessage: (0, _globalsJs.String)(err)
            };
        } finally{
            if (!dontRunHook) this.afterEachHook();
        }
    }
    beforeEach(hookFunction) {
        const previousBeforeEachHook = this.beforeEachHook;
        this.beforeEachHook = ()=>hookFunction(previousBeforeEachHook);
        return this;
    }
    afterEach(hookFunction) {
        const previousAfterEachHook = this.afterEachHook;
        this.afterEachHook = ()=>hookFunction(previousAfterEachHook);
        return this;
    }
}
Property.dummyHook = ()=>{};

},{"../precondition/PreconditionFailure.js":"7yplK","./IRawProperty.js":"3KS1o","../runner/configuration/GlobalParameters.js":"f6Bj0","../../stream/Stream.js":"2sjal","../../arbitrary/_internals/helpers/NoUndefinedAsContext.js":"b32Rp","../../utils/globals.js":"aTuwn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"jtEkW":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "check", ()=>check);
parcelHelpers.export(exports, "assert", ()=>assert);
var _streamJs = require("../../stream/Stream.js");
var _globalParametersJs = require("./configuration/GlobalParameters.js");
var _qualifiedParametersJs = require("./configuration/QualifiedParameters.js");
var _decoratePropertyJs = require("./DecorateProperty.js");
var _runnerIteratorJs = require("./RunnerIterator.js");
var _sourceValuesIteratorJs = require("./SourceValuesIterator.js");
var _tosserJs = require("./Tosser.js");
var _pathWalkerJs = require("./utils/PathWalker.js");
var _runDetailsFormatterJs = require("./utils/RunDetailsFormatter.js");
const safeObjectAssign = Object.assign;
function runIt(property, shrink, sourceValues, verbose, interruptedAsFailure) {
    const isModernProperty = property.runBeforeEach !== undefined && property.runAfterEach !== undefined;
    const runner = new (0, _runnerIteratorJs.RunnerIterator)(sourceValues, shrink, verbose, interruptedAsFailure);
    for (const v of runner){
        if (isModernProperty) property.runBeforeEach();
        const out = property.run(v, isModernProperty);
        if (isModernProperty) property.runAfterEach();
        runner.handleResult(out);
    }
    return runner.runExecution;
}
async function asyncRunIt(property, shrink, sourceValues, verbose, interruptedAsFailure) {
    const isModernProperty = property.runBeforeEach !== undefined && property.runAfterEach !== undefined;
    const runner = new (0, _runnerIteratorJs.RunnerIterator)(sourceValues, shrink, verbose, interruptedAsFailure);
    for (const v of runner){
        if (isModernProperty) await property.runBeforeEach();
        const out = await property.run(v, isModernProperty);
        if (isModernProperty) await property.runAfterEach();
        runner.handleResult(out);
    }
    return runner.runExecution;
}
function check(rawProperty, params) {
    if (rawProperty == null || rawProperty.generate == null) throw new Error('Invalid property encountered, please use a valid property');
    if (rawProperty.run == null) throw new Error('Invalid property encountered, please use a valid property not an arbitrary');
    const qParams = (0, _qualifiedParametersJs.QualifiedParameters).read(safeObjectAssign(safeObjectAssign({}, (0, _globalParametersJs.readConfigureGlobal)()), params));
    if (qParams.reporter !== null && qParams.asyncReporter !== null) throw new Error('Invalid parameters encountered, reporter and asyncReporter cannot be specified together');
    if (qParams.asyncReporter !== null && !rawProperty.isAsync()) throw new Error('Invalid parameters encountered, only asyncProperty can be used when asyncReporter specified');
    const property = (0, _decoratePropertyJs.decorateProperty)(rawProperty, qParams);
    const maxInitialIterations = qParams.path.length === 0 || qParams.path.indexOf(':') === -1 ? qParams.numRuns : -1;
    const maxSkips = qParams.numRuns * qParams.maxSkipsPerRun;
    const shrink = (...args)=>property.shrink(...args);
    const initialValues = qParams.path.length === 0 ? (0, _tosserJs.toss)(property, qParams.seed, qParams.randomType, qParams.examples) : (0, _pathWalkerJs.pathWalk)(qParams.path, (0, _streamJs.stream)((0, _tosserJs.lazyToss)(property, qParams.seed, qParams.randomType, qParams.examples)), shrink);
    const sourceValues = new (0, _sourceValuesIteratorJs.SourceValuesIterator)(initialValues, maxInitialIterations, maxSkips);
    const finalShrink = !qParams.endOnFailure ? shrink : (0, _streamJs.Stream).nil;
    return property.isAsync() ? asyncRunIt(property, finalShrink, sourceValues, qParams.verbose, qParams.markInterruptAsFailure).then((e)=>e.toRunDetails(qParams.seed, qParams.path, maxSkips, qParams)) : runIt(property, finalShrink, sourceValues, qParams.verbose, qParams.markInterruptAsFailure).toRunDetails(qParams.seed, qParams.path, maxSkips, qParams);
}
function assert(property, params) {
    const out = check(property, params);
    if (property.isAsync()) return out.then((0, _runDetailsFormatterJs.asyncReportRunDetails));
    else (0, _runDetailsFormatterJs.reportRunDetails)(out);
}

},{"../../stream/Stream.js":"2sjal","./configuration/GlobalParameters.js":"f6Bj0","./configuration/QualifiedParameters.js":"cWXiY","./DecorateProperty.js":"ekneR","./RunnerIterator.js":"dMEL3","./SourceValuesIterator.js":"gOtuF","./Tosser.js":"c3XFo","./utils/PathWalker.js":"gzSoL","./utils/RunDetailsFormatter.js":"2mhrC","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"cWXiY":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "QualifiedParameters", ()=>QualifiedParameters);
var _pureRand = require("pure-rand");
var _pureRandDefault = parcelHelpers.interopDefault(_pureRand);
var _verbosityLevelJs = require("./VerbosityLevel.js");
const safeDateNow = Date.now;
const safeMathMin = Math.min;
const safeMathRandom = Math.random;
class QualifiedParameters {
    constructor(op){
        const p = op || {};
        this.seed = QualifiedParameters.readSeed(p);
        this.randomType = QualifiedParameters.readRandomType(p);
        this.numRuns = QualifiedParameters.readNumRuns(p);
        this.verbose = QualifiedParameters.readVerbose(p);
        this.maxSkipsPerRun = QualifiedParameters.readOrDefault(p, 'maxSkipsPerRun', 100);
        this.timeout = QualifiedParameters.safeTimeout(QualifiedParameters.readOrDefault(p, 'timeout', null));
        this.skipAllAfterTimeLimit = QualifiedParameters.safeTimeout(QualifiedParameters.readOrDefault(p, 'skipAllAfterTimeLimit', null));
        this.interruptAfterTimeLimit = QualifiedParameters.safeTimeout(QualifiedParameters.readOrDefault(p, 'interruptAfterTimeLimit', null));
        this.markInterruptAsFailure = QualifiedParameters.readBoolean(p, 'markInterruptAsFailure');
        this.skipEqualValues = QualifiedParameters.readBoolean(p, 'skipEqualValues');
        this.ignoreEqualValues = QualifiedParameters.readBoolean(p, 'ignoreEqualValues');
        this.logger = QualifiedParameters.readOrDefault(p, 'logger', (v)=>{
            console.log(v);
        });
        this.path = QualifiedParameters.readOrDefault(p, 'path', '');
        this.unbiased = QualifiedParameters.readBoolean(p, 'unbiased');
        this.examples = QualifiedParameters.readOrDefault(p, 'examples', []);
        this.endOnFailure = QualifiedParameters.readBoolean(p, 'endOnFailure');
        this.reporter = QualifiedParameters.readOrDefault(p, 'reporter', null);
        this.asyncReporter = QualifiedParameters.readOrDefault(p, 'asyncReporter', null);
        this.errorWithCause = QualifiedParameters.readBoolean(p, 'errorWithCause');
    }
    toParameters() {
        const orUndefined = (value)=>value !== null ? value : undefined;
        const parameters = {
            seed: this.seed,
            randomType: this.randomType,
            numRuns: this.numRuns,
            maxSkipsPerRun: this.maxSkipsPerRun,
            timeout: orUndefined(this.timeout),
            skipAllAfterTimeLimit: orUndefined(this.skipAllAfterTimeLimit),
            interruptAfterTimeLimit: orUndefined(this.interruptAfterTimeLimit),
            markInterruptAsFailure: this.markInterruptAsFailure,
            skipEqualValues: this.skipEqualValues,
            ignoreEqualValues: this.ignoreEqualValues,
            path: this.path,
            logger: this.logger,
            unbiased: this.unbiased,
            verbose: this.verbose,
            examples: this.examples,
            endOnFailure: this.endOnFailure,
            reporter: orUndefined(this.reporter),
            asyncReporter: orUndefined(this.asyncReporter),
            errorWithCause: this.errorWithCause
        };
        return parameters;
    }
    static read(op) {
        return new QualifiedParameters(op);
    }
}
QualifiedParameters.createQualifiedRandomGenerator = (random)=>{
    return (seed)=>{
        const rng = random(seed);
        if (rng.unsafeJump === undefined) rng.unsafeJump = ()=>(0, _pureRand.unsafeSkipN)(rng, 42);
        return rng;
    };
};
QualifiedParameters.readSeed = (p)=>{
    if (p.seed == null) return safeDateNow() ^ safeMathRandom() * 0x100000000;
    const seed32 = p.seed | 0;
    if (p.seed === seed32) return seed32;
    const gap = p.seed - seed32;
    return seed32 ^ gap * 0x100000000;
};
QualifiedParameters.readRandomType = (p)=>{
    if (p.randomType == null) return (0, _pureRandDefault.default).xorshift128plus;
    if (typeof p.randomType === 'string') switch(p.randomType){
        case 'mersenne':
            return QualifiedParameters.createQualifiedRandomGenerator((0, _pureRandDefault.default).mersenne);
        case 'congruential':
        case 'congruential32':
            return QualifiedParameters.createQualifiedRandomGenerator((0, _pureRandDefault.default).congruential32);
        case 'xorshift128plus':
            return (0, _pureRandDefault.default).xorshift128plus;
        case 'xoroshiro128plus':
            return (0, _pureRandDefault.default).xoroshiro128plus;
        default:
            throw new Error(`Invalid random specified: '${p.randomType}'`);
    }
    const mrng = p.randomType(0);
    if ('min' in mrng && mrng.min !== -2147483648) throw new Error(`Invalid random number generator: min must equal -0x80000000, got ${String(mrng.min)}`);
    if ('max' in mrng && mrng.max !== 0x7fffffff) throw new Error(`Invalid random number generator: max must equal 0x7fffffff, got ${String(mrng.max)}`);
    if ('unsafeJump' in mrng) return p.randomType;
    return QualifiedParameters.createQualifiedRandomGenerator(p.randomType);
};
QualifiedParameters.readNumRuns = (p)=>{
    const defaultValue = 100;
    if (p.numRuns != null) return p.numRuns;
    if (p.num_runs != null) return p.num_runs;
    return defaultValue;
};
QualifiedParameters.readVerbose = (p)=>{
    if (p.verbose == null) return (0, _verbosityLevelJs.VerbosityLevel).None;
    if (typeof p.verbose === 'boolean') return p.verbose === true ? (0, _verbosityLevelJs.VerbosityLevel).Verbose : (0, _verbosityLevelJs.VerbosityLevel).None;
    if (p.verbose <= (0, _verbosityLevelJs.VerbosityLevel).None) return (0, _verbosityLevelJs.VerbosityLevel).None;
    if (p.verbose >= (0, _verbosityLevelJs.VerbosityLevel).VeryVerbose) return (0, _verbosityLevelJs.VerbosityLevel).VeryVerbose;
    return p.verbose | 0;
};
QualifiedParameters.readBoolean = (p, key)=>p[key] === true;
QualifiedParameters.readOrDefault = (p, key, defaultValue)=>{
    const value = p[key];
    return value != null ? value : defaultValue;
};
QualifiedParameters.safeTimeout = (value)=>{
    if (value === null) return null;
    return safeMathMin(value, 0x7fffffff);
};

},{"pure-rand":"lhKSo","./VerbosityLevel.js":"gkUPE","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"lhKSo":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _pureRandDefaultJs = require("./pure-rand-default.js");
parcelHelpers.exportAll(_pureRandDefaultJs, exports);
exports.default = _pureRandDefaultJs;

},{"./pure-rand-default.js":"9wnwE","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"9wnwE":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "__type", ()=>__type);
parcelHelpers.export(exports, "__version", ()=>__version);
parcelHelpers.export(exports, "__commitHash", ()=>__commitHash);
parcelHelpers.export(exports, "generateN", ()=>(0, _randomGeneratorJs.generateN));
parcelHelpers.export(exports, "skipN", ()=>(0, _randomGeneratorJs.skipN));
parcelHelpers.export(exports, "unsafeGenerateN", ()=>(0, _randomGeneratorJs.unsafeGenerateN));
parcelHelpers.export(exports, "unsafeSkipN", ()=>(0, _randomGeneratorJs.unsafeSkipN));
parcelHelpers.export(exports, "congruential32", ()=>(0, _linearCongruentialJs.congruential32));
parcelHelpers.export(exports, "mersenne", ()=>(0, _mersenneTwisterJsDefault.default));
parcelHelpers.export(exports, "xorshift128plus", ()=>(0, _xorShiftJs.xorshift128plus));
parcelHelpers.export(exports, "xoroshiro128plus", ()=>(0, _xoroShiroJs.xoroshiro128plus));
parcelHelpers.export(exports, "uniformArrayIntDistribution", ()=>(0, _uniformArrayIntDistributionJs.uniformArrayIntDistribution));
parcelHelpers.export(exports, "uniformBigIntDistribution", ()=>(0, _uniformBigIntDistributionJs.uniformBigIntDistribution));
parcelHelpers.export(exports, "uniformIntDistribution", ()=>(0, _uniformIntDistributionJs.uniformIntDistribution));
parcelHelpers.export(exports, "unsafeUniformArrayIntDistribution", ()=>(0, _unsafeUniformArrayIntDistributionJs.unsafeUniformArrayIntDistribution));
parcelHelpers.export(exports, "unsafeUniformBigIntDistribution", ()=>(0, _unsafeUniformBigIntDistributionJs.unsafeUniformBigIntDistribution));
parcelHelpers.export(exports, "unsafeUniformIntDistribution", ()=>(0, _unsafeUniformIntDistributionJs.unsafeUniformIntDistribution));
var _randomGeneratorJs = require("./generator/RandomGenerator.js");
var _linearCongruentialJs = require("./generator/LinearCongruential.js");
var _mersenneTwisterJs = require("./generator/MersenneTwister.js");
var _mersenneTwisterJsDefault = parcelHelpers.interopDefault(_mersenneTwisterJs);
var _xorShiftJs = require("./generator/XorShift.js");
var _xoroShiroJs = require("./generator/XoroShiro.js");
var _uniformArrayIntDistributionJs = require("./distribution/UniformArrayIntDistribution.js");
var _uniformBigIntDistributionJs = require("./distribution/UniformBigIntDistribution.js");
var _uniformIntDistributionJs = require("./distribution/UniformIntDistribution.js");
var _unsafeUniformArrayIntDistributionJs = require("./distribution/UnsafeUniformArrayIntDistribution.js");
var _unsafeUniformBigIntDistributionJs = require("./distribution/UnsafeUniformBigIntDistribution.js");
var _unsafeUniformIntDistributionJs = require("./distribution/UnsafeUniformIntDistribution.js");
var __type = 'module';
var __version = '6.1.0';
var __commitHash = 'a413dd2b721516be2ef29adffb515c5ae67bfbad';

},{"./generator/RandomGenerator.js":"5nLwB","./generator/LinearCongruential.js":"ipQOz","./generator/MersenneTwister.js":"69vQB","./generator/XorShift.js":"a9QKe","./generator/XoroShiro.js":"grEHZ","./distribution/UniformArrayIntDistribution.js":"3DMQt","./distribution/UniformBigIntDistribution.js":"6tnP1","./distribution/UniformIntDistribution.js":"4Sxwa","./distribution/UnsafeUniformArrayIntDistribution.js":"9oWP7","./distribution/UnsafeUniformBigIntDistribution.js":"8EF5d","./distribution/UnsafeUniformIntDistribution.js":"hnSM2","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"5nLwB":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "unsafeGenerateN", ()=>unsafeGenerateN);
parcelHelpers.export(exports, "generateN", ()=>generateN);
parcelHelpers.export(exports, "unsafeSkipN", ()=>unsafeSkipN);
parcelHelpers.export(exports, "skipN", ()=>skipN);
function unsafeGenerateN(rng, num) {
    var out = [];
    for(var idx = 0; idx != num; ++idx)out.push(rng.unsafeNext());
    return out;
}
function generateN(rng, num) {
    var nextRng = rng.clone();
    var out = unsafeGenerateN(nextRng, num);
    return [
        out,
        nextRng
    ];
}
function unsafeSkipN(rng, num) {
    for(var idx = 0; idx != num; ++idx)rng.unsafeNext();
}
function skipN(rng, num) {
    var nextRng = rng.clone();
    unsafeSkipN(nextRng, num);
    return nextRng;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"ipQOz":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "congruential32", ()=>congruential32);
var MULTIPLIER = 0x000343fd;
var INCREMENT = 0x00269ec3;
var MASK = 0xffffffff;
var MASK_2 = -2147483648 - 1;
var computeNextSeed = function(seed) {
    return seed * MULTIPLIER + INCREMENT & MASK;
};
var computeValueFromNextSeed = function(nextseed) {
    return (nextseed & MASK_2) >> 16;
};
var LinearCongruential32 = function() {
    function LinearCongruential32(seed) {
        this.seed = seed;
    }
    LinearCongruential32.prototype.clone = function() {
        return new LinearCongruential32(this.seed);
    };
    LinearCongruential32.prototype.next = function() {
        var nextRng = new LinearCongruential32(this.seed);
        var out = nextRng.unsafeNext();
        return [
            out,
            nextRng
        ];
    };
    LinearCongruential32.prototype.unsafeNext = function() {
        var s1 = computeNextSeed(this.seed);
        var v1 = computeValueFromNextSeed(s1);
        var s2 = computeNextSeed(s1);
        var v2 = computeValueFromNextSeed(s2);
        this.seed = computeNextSeed(s2);
        var v3 = computeValueFromNextSeed(this.seed);
        var vnext = v3 + (v2 + (v1 << 15) << 15);
        return vnext | 0;
    };
    LinearCongruential32.prototype.getState = function() {
        return [
            this.seed
        ];
    };
    return LinearCongruential32;
}();
function fromState(state) {
    var valid = state.length === 1;
    if (!valid) throw new Error('The state must have been produced by a congruential32 RandomGenerator');
    return new LinearCongruential32(state[0]);
}
var congruential32 = Object.assign(function(seed) {
    return new LinearCongruential32(seed);
}, {
    fromState: fromState
});

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"69vQB":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var __read = undefined && undefined.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spreadArray = undefined && undefined.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2) {
        for(var i = 0, l = from.length, ar; i < l; i++)if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var MersenneTwister = function() {
    function MersenneTwister(states, index) {
        this.states = states;
        this.index = index;
    }
    MersenneTwister.twist = function(prev) {
        var mt = prev.slice();
        for(var idx = 0; idx !== MersenneTwister.N - MersenneTwister.M; ++idx){
            var y_1 = (mt[idx] & MersenneTwister.MASK_UPPER) + (mt[idx + 1] & MersenneTwister.MASK_LOWER);
            mt[idx] = mt[idx + MersenneTwister.M] ^ y_1 >>> 1 ^ -(y_1 & 1) & MersenneTwister.A;
        }
        for(var idx = MersenneTwister.N - MersenneTwister.M; idx !== MersenneTwister.N - 1; ++idx){
            var y_2 = (mt[idx] & MersenneTwister.MASK_UPPER) + (mt[idx + 1] & MersenneTwister.MASK_LOWER);
            mt[idx] = mt[idx + MersenneTwister.M - MersenneTwister.N] ^ y_2 >>> 1 ^ -(y_2 & 1) & MersenneTwister.A;
        }
        var y = (mt[MersenneTwister.N - 1] & MersenneTwister.MASK_UPPER) + (mt[0] & MersenneTwister.MASK_LOWER);
        mt[MersenneTwister.N - 1] = mt[MersenneTwister.M - 1] ^ y >>> 1 ^ -(y & 1) & MersenneTwister.A;
        return mt;
    };
    MersenneTwister.seeded = function(seed) {
        var out = Array(MersenneTwister.N);
        out[0] = seed;
        for(var idx = 1; idx !== MersenneTwister.N; ++idx){
            var xored = out[idx - 1] ^ out[idx - 1] >>> 30;
            out[idx] = Math.imul(MersenneTwister.F, xored) + idx | 0;
        }
        return out;
    };
    MersenneTwister.from = function(seed) {
        return new MersenneTwister(MersenneTwister.twist(MersenneTwister.seeded(seed)), 0);
    };
    MersenneTwister.prototype.clone = function() {
        return new MersenneTwister(this.states, this.index);
    };
    MersenneTwister.prototype.next = function() {
        var nextRng = new MersenneTwister(this.states, this.index);
        var out = nextRng.unsafeNext();
        return [
            out,
            nextRng
        ];
    };
    MersenneTwister.prototype.unsafeNext = function() {
        var y = this.states[this.index];
        y ^= this.states[this.index] >>> MersenneTwister.U;
        y ^= y << MersenneTwister.S & MersenneTwister.B;
        y ^= y << MersenneTwister.T & MersenneTwister.C;
        y ^= y >>> MersenneTwister.L;
        if (++this.index >= MersenneTwister.N) {
            this.states = MersenneTwister.twist(this.states);
            this.index = 0;
        }
        return y;
    };
    MersenneTwister.prototype.getState = function() {
        return __spreadArray([
            this.index
        ], __read(this.states), false);
    };
    MersenneTwister.fromState = function(state) {
        var valid = state.length === MersenneTwister.N + 1 && state[0] >= 0 && state[0] < MersenneTwister.N;
        if (!valid) throw new Error('The state must have been produced by a mersenne RandomGenerator');
        return new MersenneTwister(state.slice(1), state[0]);
    };
    MersenneTwister.N = 624;
    MersenneTwister.M = 397;
    MersenneTwister.R = 31;
    MersenneTwister.A = 0x9908b0df;
    MersenneTwister.F = 1812433253;
    MersenneTwister.U = 11;
    MersenneTwister.S = 7;
    MersenneTwister.B = 0x9d2c5680;
    MersenneTwister.T = 15;
    MersenneTwister.C = 0xefc60000;
    MersenneTwister.L = 18;
    MersenneTwister.MASK_LOWER = Math.pow(2, MersenneTwister.R) - 1;
    MersenneTwister.MASK_UPPER = Math.pow(2, MersenneTwister.R);
    return MersenneTwister;
}();
function fromState(state) {
    return MersenneTwister.fromState(state);
}
exports.default = Object.assign(function(seed) {
    return MersenneTwister.from(seed);
}, {
    fromState: fromState
});

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"a9QKe":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "xorshift128plus", ()=>xorshift128plus);
var XorShift128Plus = function() {
    function XorShift128Plus(s01, s00, s11, s10) {
        this.s01 = s01;
        this.s00 = s00;
        this.s11 = s11;
        this.s10 = s10;
    }
    XorShift128Plus.prototype.clone = function() {
        return new XorShift128Plus(this.s01, this.s00, this.s11, this.s10);
    };
    XorShift128Plus.prototype.next = function() {
        var nextRng = new XorShift128Plus(this.s01, this.s00, this.s11, this.s10);
        var out = nextRng.unsafeNext();
        return [
            out,
            nextRng
        ];
    };
    XorShift128Plus.prototype.unsafeNext = function() {
        var a0 = this.s00 ^ this.s00 << 23;
        var a1 = this.s01 ^ (this.s01 << 23 | this.s00 >>> 9);
        var b0 = a0 ^ this.s10 ^ (a0 >>> 18 | a1 << 14) ^ (this.s10 >>> 5 | this.s11 << 27);
        var b1 = a1 ^ this.s11 ^ a1 >>> 18 ^ this.s11 >>> 5;
        var out = this.s00 + this.s10 | 0;
        this.s01 = this.s11;
        this.s00 = this.s10;
        this.s11 = b1;
        this.s10 = b0;
        return out;
    };
    XorShift128Plus.prototype.jump = function() {
        var nextRng = new XorShift128Plus(this.s01, this.s00, this.s11, this.s10);
        nextRng.unsafeJump();
        return nextRng;
    };
    XorShift128Plus.prototype.unsafeJump = function() {
        var ns01 = 0;
        var ns00 = 0;
        var ns11 = 0;
        var ns10 = 0;
        var jump = [
            0x635d2dff,
            0x8a5cd789,
            0x5c472f96,
            0x121fd215
        ];
        for(var i = 0; i !== 4; ++i)for(var mask = 1; mask; mask <<= 1){
            if (jump[i] & mask) {
                ns01 ^= this.s01;
                ns00 ^= this.s00;
                ns11 ^= this.s11;
                ns10 ^= this.s10;
            }
            this.unsafeNext();
        }
        this.s01 = ns01;
        this.s00 = ns00;
        this.s11 = ns11;
        this.s10 = ns10;
    };
    XorShift128Plus.prototype.getState = function() {
        return [
            this.s01,
            this.s00,
            this.s11,
            this.s10
        ];
    };
    return XorShift128Plus;
}();
function fromState(state) {
    var valid = state.length === 4;
    if (!valid) throw new Error('The state must have been produced by a xorshift128plus RandomGenerator');
    return new XorShift128Plus(state[0], state[1], state[2], state[3]);
}
var xorshift128plus = Object.assign(function(seed) {
    return new XorShift128Plus(-1, ~seed, seed | 0, 0);
}, {
    fromState: fromState
});

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"grEHZ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "xoroshiro128plus", ()=>xoroshiro128plus);
var XoroShiro128Plus = function() {
    function XoroShiro128Plus(s01, s00, s11, s10) {
        this.s01 = s01;
        this.s00 = s00;
        this.s11 = s11;
        this.s10 = s10;
    }
    XoroShiro128Plus.prototype.clone = function() {
        return new XoroShiro128Plus(this.s01, this.s00, this.s11, this.s10);
    };
    XoroShiro128Plus.prototype.next = function() {
        var nextRng = new XoroShiro128Plus(this.s01, this.s00, this.s11, this.s10);
        var out = nextRng.unsafeNext();
        return [
            out,
            nextRng
        ];
    };
    XoroShiro128Plus.prototype.unsafeNext = function() {
        var out = this.s00 + this.s10 | 0;
        var a0 = this.s10 ^ this.s00;
        var a1 = this.s11 ^ this.s01;
        var s00 = this.s00;
        var s01 = this.s01;
        this.s00 = s00 << 24 ^ s01 >>> 8 ^ a0 ^ a0 << 16;
        this.s01 = s01 << 24 ^ s00 >>> 8 ^ a1 ^ (a1 << 16 | a0 >>> 16);
        this.s10 = a1 << 5 ^ a0 >>> 27;
        this.s11 = a0 << 5 ^ a1 >>> 27;
        return out;
    };
    XoroShiro128Plus.prototype.jump = function() {
        var nextRng = new XoroShiro128Plus(this.s01, this.s00, this.s11, this.s10);
        nextRng.unsafeJump();
        return nextRng;
    };
    XoroShiro128Plus.prototype.unsafeJump = function() {
        var ns01 = 0;
        var ns00 = 0;
        var ns11 = 0;
        var ns10 = 0;
        var jump = [
            0xd8f554a5,
            0xdf900294,
            0x4b3201fc,
            0x170865df
        ];
        for(var i = 0; i !== 4; ++i)for(var mask = 1; mask; mask <<= 1){
            if (jump[i] & mask) {
                ns01 ^= this.s01;
                ns00 ^= this.s00;
                ns11 ^= this.s11;
                ns10 ^= this.s10;
            }
            this.unsafeNext();
        }
        this.s01 = ns01;
        this.s00 = ns00;
        this.s11 = ns11;
        this.s10 = ns10;
    };
    XoroShiro128Plus.prototype.getState = function() {
        return [
            this.s01,
            this.s00,
            this.s11,
            this.s10
        ];
    };
    return XoroShiro128Plus;
}();
function fromState(state) {
    var valid = state.length === 4;
    if (!valid) throw new Error('The state must have been produced by a xoroshiro128plus RandomGenerator');
    return new XoroShiro128Plus(state[0], state[1], state[2], state[3]);
}
var xoroshiro128plus = Object.assign(function(seed) {
    return new XoroShiro128Plus(-1, ~seed, seed | 0, 0);
}, {
    fromState: fromState
});

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"3DMQt":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "uniformArrayIntDistribution", ()=>uniformArrayIntDistribution);
var _unsafeUniformArrayIntDistributionJs = require("./UnsafeUniformArrayIntDistribution.js");
function uniformArrayIntDistribution(from, to, rng) {
    if (rng != null) {
        var nextRng = rng.clone();
        return [
            (0, _unsafeUniformArrayIntDistributionJs.unsafeUniformArrayIntDistribution)(from, to, nextRng),
            nextRng
        ];
    }
    return function(rng) {
        var nextRng = rng.clone();
        return [
            (0, _unsafeUniformArrayIntDistributionJs.unsafeUniformArrayIntDistribution)(from, to, nextRng),
            nextRng
        ];
    };
}

},{"./UnsafeUniformArrayIntDistribution.js":"9oWP7","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"9oWP7":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "unsafeUniformArrayIntDistribution", ()=>unsafeUniformArrayIntDistribution);
var _arrayIntJs = require("./internals/ArrayInt.js");
var _unsafeUniformArrayIntDistributionInternalJs = require("./internals/UnsafeUniformArrayIntDistributionInternal.js");
function unsafeUniformArrayIntDistribution(from, to, rng) {
    var rangeSize = (0, _arrayIntJs.trimArrayIntInplace)((0, _arrayIntJs.addOneToPositiveArrayInt)((0, _arrayIntJs.substractArrayIntToNew)(to, from)));
    var emptyArrayIntData = rangeSize.data.slice(0);
    var g = (0, _unsafeUniformArrayIntDistributionInternalJs.unsafeUniformArrayIntDistributionInternal)(emptyArrayIntData, rangeSize.data, rng);
    return (0, _arrayIntJs.trimArrayIntInplace)((0, _arrayIntJs.addArrayIntToNew)({
        sign: 1,
        data: g
    }, from));
}

},{"./internals/ArrayInt.js":"jc3ss","./internals/UnsafeUniformArrayIntDistributionInternal.js":"bOfZA","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"jc3ss":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "addArrayIntToNew", ()=>addArrayIntToNew);
parcelHelpers.export(exports, "addOneToPositiveArrayInt", ()=>addOneToPositiveArrayInt);
parcelHelpers.export(exports, "substractArrayIntToNew", ()=>substractArrayIntToNew);
parcelHelpers.export(exports, "trimArrayIntInplace", ()=>trimArrayIntInplace);
parcelHelpers.export(exports, "fromNumberToArrayInt64", ()=>fromNumberToArrayInt64);
parcelHelpers.export(exports, "substractArrayInt64", ()=>substractArrayInt64);
function addArrayIntToNew(arrayIntA, arrayIntB) {
    if (arrayIntA.sign !== arrayIntB.sign) return substractArrayIntToNew(arrayIntA, {
        sign: -arrayIntB.sign,
        data: arrayIntB.data
    });
    var data = [];
    var reminder = 0;
    var dataA = arrayIntA.data;
    var dataB = arrayIntB.data;
    for(var indexA = dataA.length - 1, indexB = dataB.length - 1; indexA >= 0 || indexB >= 0; --indexA, --indexB){
        var vA = indexA >= 0 ? dataA[indexA] : 0;
        var vB = indexB >= 0 ? dataB[indexB] : 0;
        var current = vA + vB + reminder;
        data.push(current >>> 0);
        reminder = ~~(current / 0x100000000);
    }
    if (reminder !== 0) data.push(reminder);
    return {
        sign: arrayIntA.sign,
        data: data.reverse()
    };
}
function addOneToPositiveArrayInt(arrayInt) {
    arrayInt.sign = 1;
    var data = arrayInt.data;
    for(var index = data.length - 1; index >= 0; --index)if (data[index] === 0xffffffff) data[index] = 0;
    else {
        data[index] += 1;
        return arrayInt;
    }
    data.unshift(1);
    return arrayInt;
}
function isStrictlySmaller(dataA, dataB) {
    var maxLength = Math.max(dataA.length, dataB.length);
    for(var index = 0; index < maxLength; ++index){
        var indexA = index + dataA.length - maxLength;
        var indexB = index + dataB.length - maxLength;
        var vA = indexA >= 0 ? dataA[indexA] : 0;
        var vB = indexB >= 0 ? dataB[indexB] : 0;
        if (vA < vB) return true;
        if (vA > vB) return false;
    }
    return false;
}
function substractArrayIntToNew(arrayIntA, arrayIntB) {
    if (arrayIntA.sign !== arrayIntB.sign) return addArrayIntToNew(arrayIntA, {
        sign: -arrayIntB.sign,
        data: arrayIntB.data
    });
    var dataA = arrayIntA.data;
    var dataB = arrayIntB.data;
    if (isStrictlySmaller(dataA, dataB)) {
        var out = substractArrayIntToNew(arrayIntB, arrayIntA);
        out.sign = -out.sign;
        return out;
    }
    var data = [];
    var reminder = 0;
    for(var indexA = dataA.length - 1, indexB = dataB.length - 1; indexA >= 0 || indexB >= 0; --indexA, --indexB){
        var vA = indexA >= 0 ? dataA[indexA] : 0;
        var vB = indexB >= 0 ? dataB[indexB] : 0;
        var current = vA - vB - reminder;
        data.push(current >>> 0);
        reminder = current < 0 ? 1 : 0;
    }
    return {
        sign: arrayIntA.sign,
        data: data.reverse()
    };
}
function trimArrayIntInplace(arrayInt) {
    var data = arrayInt.data;
    var firstNonZero = 0;
    for(; firstNonZero !== data.length && data[firstNonZero] === 0; ++firstNonZero);
    if (firstNonZero === data.length) {
        arrayInt.sign = 1;
        arrayInt.data = [
            0
        ];
        return arrayInt;
    }
    data.splice(0, firstNonZero);
    return arrayInt;
}
function fromNumberToArrayInt64(out, n) {
    if (n < 0) {
        var posN = -n;
        out.sign = -1;
        out.data[0] = ~~(posN / 0x100000000);
        out.data[1] = posN >>> 0;
    } else {
        out.sign = 1;
        out.data[0] = ~~(n / 0x100000000);
        out.data[1] = n >>> 0;
    }
    return out;
}
function substractArrayInt64(out, arrayIntA, arrayIntB) {
    var lowA = arrayIntA.data[1];
    var highA = arrayIntA.data[0];
    var signA = arrayIntA.sign;
    var lowB = arrayIntB.data[1];
    var highB = arrayIntB.data[0];
    var signB = arrayIntB.sign;
    out.sign = 1;
    if (signA === 1 && signB === -1) {
        var low_1 = lowA + lowB;
        var high = highA + highB + (low_1 > 0xffffffff ? 1 : 0);
        out.data[0] = high >>> 0;
        out.data[1] = low_1 >>> 0;
        return out;
    }
    var lowFirst = lowA;
    var highFirst = highA;
    var lowSecond = lowB;
    var highSecond = highB;
    if (signA === -1) {
        lowFirst = lowB;
        highFirst = highB;
        lowSecond = lowA;
        highSecond = highA;
    }
    var reminderLow = 0;
    var low = lowFirst - lowSecond;
    if (low < 0) {
        reminderLow = 1;
        low = low >>> 0;
    }
    out.data[0] = highFirst - highSecond - reminderLow;
    out.data[1] = low;
    return out;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"bOfZA":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "unsafeUniformArrayIntDistributionInternal", ()=>unsafeUniformArrayIntDistributionInternal);
var _unsafeUniformIntDistributionInternalJs = require("./UnsafeUniformIntDistributionInternal.js");
function unsafeUniformArrayIntDistributionInternal(out, rangeSize, rng) {
    var rangeLength = rangeSize.length;
    while(true){
        for(var index = 0; index !== rangeLength; ++index){
            var indexRangeSize = index === 0 ? rangeSize[0] + 1 : 0x100000000;
            var g = (0, _unsafeUniformIntDistributionInternalJs.unsafeUniformIntDistributionInternal)(indexRangeSize, rng);
            out[index] = g;
        }
        for(var index = 0; index !== rangeLength; ++index){
            var current = out[index];
            var currentInRange = rangeSize[index];
            if (current < currentInRange) return out;
            else if (current > currentInRange) break;
        }
    }
}

},{"./UnsafeUniformIntDistributionInternal.js":"ds0sm","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"ds0sm":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "unsafeUniformIntDistributionInternal", ()=>unsafeUniformIntDistributionInternal);
function unsafeUniformIntDistributionInternal(rangeSize, rng) {
    var MaxAllowed = rangeSize > 2 ? ~~(0x100000000 / rangeSize) * rangeSize : 0x100000000;
    var deltaV = rng.unsafeNext() + 0x80000000;
    while(deltaV >= MaxAllowed)deltaV = rng.unsafeNext() + 0x80000000;
    return deltaV % rangeSize;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"6tnP1":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "uniformBigIntDistribution", ()=>uniformBigIntDistribution);
var _unsafeUniformBigIntDistributionJs = require("./UnsafeUniformBigIntDistribution.js");
function uniformBigIntDistribution(from, to, rng) {
    if (rng != null) {
        var nextRng = rng.clone();
        return [
            (0, _unsafeUniformBigIntDistributionJs.unsafeUniformBigIntDistribution)(from, to, nextRng),
            nextRng
        ];
    }
    return function(rng) {
        var nextRng = rng.clone();
        return [
            (0, _unsafeUniformBigIntDistributionJs.unsafeUniformBigIntDistribution)(from, to, nextRng),
            nextRng
        ];
    };
}

},{"./UnsafeUniformBigIntDistribution.js":"8EF5d","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"8EF5d":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "unsafeUniformBigIntDistribution", ()=>unsafeUniformBigIntDistribution);
var SBigInt = typeof BigInt !== 'undefined' ? BigInt : undefined;
function unsafeUniformBigIntDistribution(from, to, rng) {
    var diff = to - from + SBigInt(1);
    var MinRng = SBigInt(-2147483648);
    var NumValues = SBigInt(0x100000000);
    var FinalNumValues = NumValues;
    var NumIterations = 1;
    while(FinalNumValues < diff){
        FinalNumValues *= NumValues;
        ++NumIterations;
    }
    var MaxAcceptedRandom = FinalNumValues - FinalNumValues % diff;
    while(true){
        var value = SBigInt(0);
        for(var num = 0; num !== NumIterations; ++num){
            var out = rng.unsafeNext();
            value = NumValues * value + (SBigInt(out) - MinRng);
        }
        if (value < MaxAcceptedRandom) {
            var inDiff = value % diff;
            return inDiff + from;
        }
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"4Sxwa":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "uniformIntDistribution", ()=>uniformIntDistribution);
var _unsafeUniformIntDistributionJs = require("./UnsafeUniformIntDistribution.js");
function uniformIntDistribution(from, to, rng) {
    if (rng != null) {
        var nextRng = rng.clone();
        return [
            (0, _unsafeUniformIntDistributionJs.unsafeUniformIntDistribution)(from, to, nextRng),
            nextRng
        ];
    }
    return function(rng) {
        var nextRng = rng.clone();
        return [
            (0, _unsafeUniformIntDistributionJs.unsafeUniformIntDistribution)(from, to, nextRng),
            nextRng
        ];
    };
}

},{"./UnsafeUniformIntDistribution.js":"hnSM2","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"hnSM2":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "unsafeUniformIntDistribution", ()=>unsafeUniformIntDistribution);
var _unsafeUniformIntDistributionInternalJs = require("./internals/UnsafeUniformIntDistributionInternal.js");
var _arrayIntJs = require("./internals/ArrayInt.js");
var _unsafeUniformArrayIntDistributionInternalJs = require("./internals/UnsafeUniformArrayIntDistributionInternal.js");
var safeNumberMaxSafeInteger = Number.MAX_SAFE_INTEGER;
var sharedA = {
    sign: 1,
    data: [
        0,
        0
    ]
};
var sharedB = {
    sign: 1,
    data: [
        0,
        0
    ]
};
var sharedC = {
    sign: 1,
    data: [
        0,
        0
    ]
};
var sharedData = [
    0,
    0
];
function uniformLargeIntInternal(from, to, rangeSize, rng) {
    var rangeSizeArrayIntValue = rangeSize <= safeNumberMaxSafeInteger ? (0, _arrayIntJs.fromNumberToArrayInt64)(sharedC, rangeSize) : (0, _arrayIntJs.substractArrayInt64)(sharedC, (0, _arrayIntJs.fromNumberToArrayInt64)(sharedA, to), (0, _arrayIntJs.fromNumberToArrayInt64)(sharedB, from));
    if (rangeSizeArrayIntValue.data[1] === 0xffffffff) {
        rangeSizeArrayIntValue.data[0] += 1;
        rangeSizeArrayIntValue.data[1] = 0;
    } else rangeSizeArrayIntValue.data[1] += 1;
    (0, _unsafeUniformArrayIntDistributionInternalJs.unsafeUniformArrayIntDistributionInternal)(sharedData, rangeSizeArrayIntValue.data, rng);
    return sharedData[0] * 0x100000000 + sharedData[1] + from;
}
function unsafeUniformIntDistribution(from, to, rng) {
    var rangeSize = to - from;
    if (rangeSize <= 0xffffffff) {
        var g = (0, _unsafeUniformIntDistributionInternalJs.unsafeUniformIntDistributionInternal)(rangeSize + 1, rng);
        return g + from;
    }
    return uniformLargeIntInternal(from, to, rangeSize, rng);
}

},{"./internals/UnsafeUniformIntDistributionInternal.js":"ds0sm","./internals/ArrayInt.js":"jc3ss","./internals/UnsafeUniformArrayIntDistributionInternal.js":"bOfZA","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"gkUPE":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VerbosityLevel", ()=>VerbosityLevel);
var VerbosityLevel;
(function(VerbosityLevel) {
    VerbosityLevel[VerbosityLevel["None"] = 0] = "None";
    VerbosityLevel[VerbosityLevel["Verbose"] = 1] = "Verbose";
    VerbosityLevel[VerbosityLevel["VeryVerbose"] = 2] = "VeryVerbose";
})(VerbosityLevel || (VerbosityLevel = {}));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"ekneR":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "decorateProperty", ()=>decorateProperty);
var _skipAfterPropertyJs = require("../property/SkipAfterProperty.js");
var _timeoutPropertyJs = require("../property/TimeoutProperty.js");
var _unbiasedPropertyJs = require("../property/UnbiasedProperty.js");
var _ignoreEqualValuesPropertyJs = require("../property/IgnoreEqualValuesProperty.js");
const safeDateNow = Date.now;
const safeSetTimeout = setTimeout;
const safeClearTimeout = clearTimeout;
function decorateProperty(rawProperty, qParams) {
    let prop = rawProperty;
    if (rawProperty.isAsync() && qParams.timeout != null) prop = new (0, _timeoutPropertyJs.TimeoutProperty)(prop, qParams.timeout, safeSetTimeout, safeClearTimeout);
    if (qParams.unbiased) prop = new (0, _unbiasedPropertyJs.UnbiasedProperty)(prop);
    if (qParams.skipAllAfterTimeLimit != null) prop = new (0, _skipAfterPropertyJs.SkipAfterProperty)(prop, safeDateNow, qParams.skipAllAfterTimeLimit, false, safeSetTimeout, safeClearTimeout);
    if (qParams.interruptAfterTimeLimit != null) prop = new (0, _skipAfterPropertyJs.SkipAfterProperty)(prop, safeDateNow, qParams.interruptAfterTimeLimit, true, safeSetTimeout, safeClearTimeout);
    if (qParams.skipEqualValues) prop = new (0, _ignoreEqualValuesPropertyJs.IgnoreEqualValuesProperty)(prop, true);
    if (qParams.ignoreEqualValues) prop = new (0, _ignoreEqualValuesPropertyJs.IgnoreEqualValuesProperty)(prop, false);
    return prop;
}

},{"../property/SkipAfterProperty.js":"70K8n","../property/TimeoutProperty.js":"8FH1e","../property/UnbiasedProperty.js":"1QInN","../property/IgnoreEqualValuesProperty.js":"iHdDW","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"70K8n":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SkipAfterProperty", ()=>SkipAfterProperty);
var _preconditionFailureJs = require("../precondition/PreconditionFailure.js");
function interruptAfter(timeMs, setTimeoutSafe, clearTimeoutSafe) {
    let timeoutHandle = null;
    const promise = new Promise((resolve)=>{
        timeoutHandle = setTimeoutSafe(()=>{
            const preconditionFailure = new (0, _preconditionFailureJs.PreconditionFailure)(true);
            resolve(preconditionFailure);
        }, timeMs);
    });
    return {
        clear: ()=>clearTimeoutSafe(timeoutHandle),
        promise
    };
}
class SkipAfterProperty {
    constructor(property, getTime, timeLimit, interruptExecution, setTimeoutSafe, clearTimeoutSafe){
        this.property = property;
        this.getTime = getTime;
        this.interruptExecution = interruptExecution;
        this.setTimeoutSafe = setTimeoutSafe;
        this.clearTimeoutSafe = clearTimeoutSafe;
        this.skipAfterTime = this.getTime() + timeLimit;
        if (this.property.runBeforeEach !== undefined && this.property.runAfterEach !== undefined) {
            this.runBeforeEach = ()=>this.property.runBeforeEach();
            this.runAfterEach = ()=>this.property.runAfterEach();
        }
    }
    isAsync() {
        return this.property.isAsync();
    }
    generate(mrng, runId) {
        return this.property.generate(mrng, runId);
    }
    shrink(value) {
        return this.property.shrink(value);
    }
    run(v, dontRunHook) {
        const remainingTime = this.skipAfterTime - this.getTime();
        if (remainingTime <= 0) {
            const preconditionFailure = new (0, _preconditionFailureJs.PreconditionFailure)(this.interruptExecution);
            if (this.isAsync()) return Promise.resolve(preconditionFailure);
            else return preconditionFailure;
        }
        if (this.interruptExecution && this.isAsync()) {
            const t = interruptAfter(remainingTime, this.setTimeoutSafe, this.clearTimeoutSafe);
            const propRun = Promise.race([
                this.property.run(v, dontRunHook),
                t.promise
            ]);
            propRun.then(t.clear, t.clear);
            return propRun;
        }
        return this.property.run(v, dontRunHook);
    }
}

},{"../precondition/PreconditionFailure.js":"7yplK","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"8FH1e":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TimeoutProperty", ()=>TimeoutProperty);
var _globalsJs = require("../../utils/globals.js");
const timeoutAfter = (timeMs, setTimeoutSafe, clearTimeoutSafe)=>{
    let timeoutHandle = null;
    const promise = new Promise((resolve)=>{
        timeoutHandle = setTimeoutSafe(()=>{
            resolve({
                error: new (0, _globalsJs.Error)(`Property timeout: exceeded limit of ${timeMs} milliseconds`),
                errorMessage: `Property timeout: exceeded limit of ${timeMs} milliseconds`
            });
        }, timeMs);
    });
    return {
        clear: ()=>clearTimeoutSafe(timeoutHandle),
        promise
    };
};
class TimeoutProperty {
    constructor(property, timeMs, setTimeoutSafe, clearTimeoutSafe){
        this.property = property;
        this.timeMs = timeMs;
        this.setTimeoutSafe = setTimeoutSafe;
        this.clearTimeoutSafe = clearTimeoutSafe;
        if (this.property.runBeforeEach !== undefined && this.property.runAfterEach !== undefined) {
            this.runBeforeEach = ()=>Promise.resolve(this.property.runBeforeEach());
            this.runAfterEach = ()=>Promise.resolve(this.property.runAfterEach());
        }
    }
    isAsync() {
        return true;
    }
    generate(mrng, runId) {
        return this.property.generate(mrng, runId);
    }
    shrink(value) {
        return this.property.shrink(value);
    }
    async run(v, dontRunHook) {
        const t = timeoutAfter(this.timeMs, this.setTimeoutSafe, this.clearTimeoutSafe);
        const propRun = Promise.race([
            this.property.run(v, dontRunHook),
            t.promise
        ]);
        propRun.then(t.clear, t.clear);
        return propRun;
    }
}

},{"../../utils/globals.js":"aTuwn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"1QInN":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "UnbiasedProperty", ()=>UnbiasedProperty);
class UnbiasedProperty {
    constructor(property){
        this.property = property;
        if (this.property.runBeforeEach !== undefined && this.property.runAfterEach !== undefined) {
            this.runBeforeEach = ()=>this.property.runBeforeEach();
            this.runAfterEach = ()=>this.property.runAfterEach();
        }
    }
    isAsync() {
        return this.property.isAsync();
    }
    generate(mrng, _runId) {
        return this.property.generate(mrng, undefined);
    }
    shrink(value) {
        return this.property.shrink(value);
    }
    run(v, dontRunHook) {
        return this.property.run(v, dontRunHook);
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"iHdDW":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "IgnoreEqualValuesProperty", ()=>IgnoreEqualValuesProperty);
var _stringifyJs = require("../../utils/stringify.js");
var _preconditionFailureJs = require("../precondition/PreconditionFailure.js");
function fromSyncCached(cachedValue) {
    return cachedValue === null ? new (0, _preconditionFailureJs.PreconditionFailure)() : cachedValue;
}
function fromCached(...data) {
    if (data[1]) return data[0].then(fromSyncCached);
    return fromSyncCached(data[0]);
}
function fromCachedUnsafe(cachedValue, isAsync) {
    return fromCached(cachedValue, isAsync);
}
class IgnoreEqualValuesProperty {
    constructor(property, skipRuns){
        this.property = property;
        this.skipRuns = skipRuns;
        this.coveredCases = new Map();
        if (this.property.runBeforeEach !== undefined && this.property.runAfterEach !== undefined) {
            this.runBeforeEach = ()=>this.property.runBeforeEach();
            this.runAfterEach = ()=>this.property.runAfterEach();
        }
    }
    isAsync() {
        return this.property.isAsync();
    }
    generate(mrng, runId) {
        return this.property.generate(mrng, runId);
    }
    shrink(value) {
        return this.property.shrink(value);
    }
    run(v, dontRunHook) {
        const stringifiedValue = (0, _stringifyJs.stringify)(v);
        if (this.coveredCases.has(stringifiedValue)) {
            const lastOutput = this.coveredCases.get(stringifiedValue);
            if (!this.skipRuns) return lastOutput;
            return fromCachedUnsafe(lastOutput, this.property.isAsync());
        }
        const out = this.property.run(v, dontRunHook);
        this.coveredCases.set(stringifiedValue, out);
        return out;
    }
}

},{"../../utils/stringify.js":"gOa8u","../precondition/PreconditionFailure.js":"7yplK","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"gOa8u":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "toStringMethod", ()=>toStringMethod);
parcelHelpers.export(exports, "hasToStringMethod", ()=>hasToStringMethod);
parcelHelpers.export(exports, "asyncToStringMethod", ()=>asyncToStringMethod);
parcelHelpers.export(exports, "hasAsyncToStringMethod", ()=>hasAsyncToStringMethod);
parcelHelpers.export(exports, "stringifyInternal", ()=>stringifyInternal);
parcelHelpers.export(exports, "stringify", ()=>stringify);
parcelHelpers.export(exports, "possiblyAsyncStringify", ()=>possiblyAsyncStringify);
parcelHelpers.export(exports, "asyncStringify", ()=>asyncStringify);
var _globalsJs = require("./globals.js");
var Buffer = require("aab129e9e6218dc4").Buffer;
const safeArrayFrom = Array.from;
const safeBufferIsBuffer = typeof Buffer !== 'undefined' ? Buffer.isBuffer : undefined;
const safeJsonStringify = JSON.stringify;
const safeNumberIsNaN = Number.isNaN;
const safeObjectKeys = Object.keys;
const safeObjectGetOwnPropertySymbols = Object.getOwnPropertySymbols;
const safeObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
const safeObjectGetPrototypeOf = Object.getPrototypeOf;
const safeNegativeInfinity = Number.NEGATIVE_INFINITY;
const safePositiveInfinity = Number.POSITIVE_INFINITY;
const toStringMethod = Symbol.for('fast-check/toStringMethod');
function hasToStringMethod(instance) {
    return instance !== null && (typeof instance === 'object' || typeof instance === 'function') && toStringMethod in instance && typeof instance[toStringMethod] === 'function';
}
const asyncToStringMethod = Symbol.for('fast-check/asyncToStringMethod');
function hasAsyncToStringMethod(instance) {
    return instance !== null && (typeof instance === 'object' || typeof instance === 'function') && asyncToStringMethod in instance && typeof instance[asyncToStringMethod] === 'function';
}
const findSymbolNameRegex = /^Symbol\((.*)\)$/;
function getSymbolDescription(s) {
    if (s.description !== undefined) return s.description;
    const m = findSymbolNameRegex.exec((0, _globalsJs.String)(s));
    return m && m[1].length ? m[1] : null;
}
function stringifyNumber(numValue) {
    switch(numValue){
        case 0:
            return 1 / numValue === safeNegativeInfinity ? '-0' : '0';
        case safeNegativeInfinity:
            return 'Number.NEGATIVE_INFINITY';
        case safePositiveInfinity:
            return 'Number.POSITIVE_INFINITY';
        default:
            return numValue === numValue ? (0, _globalsJs.String)(numValue) : 'Number.NaN';
    }
}
function isSparseArray(arr) {
    let previousNumberedIndex = -1;
    for(const index in arr){
        const numberedIndex = Number(index);
        if (numberedIndex !== previousNumberedIndex + 1) return true;
        previousNumberedIndex = numberedIndex;
    }
    return previousNumberedIndex + 1 !== arr.length;
}
function stringifyInternal(value, previousValues, getAsyncContent) {
    const currentValues = [
        ...previousValues,
        value
    ];
    if (typeof value === 'object') {
        if ((0, _globalsJs.safeIndexOf)(previousValues, value) !== -1) return '[cyclic]';
    }
    if (hasAsyncToStringMethod(value)) {
        const content = getAsyncContent(value);
        if (content.state === 'fulfilled') return content.value;
    }
    if (hasToStringMethod(value)) try {
        return value[toStringMethod]();
    } catch (err) {}
    switch((0, _globalsJs.safeToString)(value)){
        case '[object Array]':
            {
                const arr = value;
                if (arr.length >= 50 && isSparseArray(arr)) {
                    const assignments = [];
                    for(const index in arr)if (!safeNumberIsNaN(Number(index))) (0, _globalsJs.safePush)(assignments, `${index}:${stringifyInternal(arr[index], currentValues, getAsyncContent)}`);
                    return assignments.length !== 0 ? `Object.assign(Array(${arr.length}),{${(0, _globalsJs.safeJoin)(assignments, ',')}})` : `Array(${arr.length})`;
                }
                const stringifiedArray = (0, _globalsJs.safeJoin)((0, _globalsJs.safeMap)(arr, (v)=>stringifyInternal(v, currentValues, getAsyncContent)), ',');
                return arr.length === 0 || arr.length - 1 in arr ? `[${stringifiedArray}]` : `[${stringifiedArray},]`;
            }
        case '[object BigInt]':
            return `${value}n`;
        case '[object Boolean]':
            {
                const unboxedToString = value == true ? 'true' : 'false';
                return typeof value === 'boolean' ? unboxedToString : `new Boolean(${unboxedToString})`;
            }
        case '[object Date]':
            {
                const d = value;
                return safeNumberIsNaN((0, _globalsJs.safeGetTime)(d)) ? `new Date(NaN)` : `new Date(${safeJsonStringify((0, _globalsJs.safeToISOString)(d))})`;
            }
        case '[object Map]':
            return `new Map(${stringifyInternal(Array.from(value), currentValues, getAsyncContent)})`;
        case '[object Null]':
            return `null`;
        case '[object Number]':
            return typeof value === 'number' ? stringifyNumber(value) : `new Number(${stringifyNumber(Number(value))})`;
        case '[object Object]':
            {
                try {
                    const toStringAccessor = value.toString;
                    if (typeof toStringAccessor === 'function' && toStringAccessor !== Object.prototype.toString) return value.toString();
                } catch (err) {
                    return '[object Object]';
                }
                const mapper = (k)=>`${k === '__proto__' ? '["__proto__"]' : typeof k === 'symbol' ? `[${stringifyInternal(k, currentValues, getAsyncContent)}]` : safeJsonStringify(k)}:${stringifyInternal(value[k], currentValues, getAsyncContent)}`;
                const stringifiedProperties = [
                    ...(0, _globalsJs.safeMap)(safeObjectKeys(value), mapper),
                    ...(0, _globalsJs.safeMap)((0, _globalsJs.safeFilter)(safeObjectGetOwnPropertySymbols(value), (s)=>{
                        const descriptor = safeObjectGetOwnPropertyDescriptor(value, s);
                        return descriptor && descriptor.enumerable;
                    }), mapper)
                ];
                const rawRepr = '{' + (0, _globalsJs.safeJoin)(stringifiedProperties, ',') + '}';
                if (safeObjectGetPrototypeOf(value) === null) return rawRepr === '{}' ? 'Object.create(null)' : `Object.assign(Object.create(null),${rawRepr})`;
                return rawRepr;
            }
        case '[object Set]':
            return `new Set(${stringifyInternal(Array.from(value), currentValues, getAsyncContent)})`;
        case '[object String]':
            return typeof value === 'string' ? safeJsonStringify(value) : `new String(${safeJsonStringify(value)})`;
        case '[object Symbol]':
            {
                const s = value;
                if ((0, _globalsJs.Symbol).keyFor(s) !== undefined) return `Symbol.for(${safeJsonStringify((0, _globalsJs.Symbol).keyFor(s))})`;
                const desc = getSymbolDescription(s);
                if (desc === null) return 'Symbol()';
                const knownSymbol = desc.startsWith('Symbol.') && (0, _globalsJs.Symbol)[desc.substring(7)];
                return s === knownSymbol ? desc : `Symbol(${safeJsonStringify(desc)})`;
            }
        case '[object Promise]':
            {
                const promiseContent = getAsyncContent(value);
                switch(promiseContent.state){
                    case 'fulfilled':
                        return `Promise.resolve(${stringifyInternal(promiseContent.value, currentValues, getAsyncContent)})`;
                    case 'rejected':
                        return `Promise.reject(${stringifyInternal(promiseContent.value, currentValues, getAsyncContent)})`;
                    case 'pending':
                        return `new Promise(() => {/*pending*/})`;
                    case 'unknown':
                    default:
                        return `new Promise(() => {/*unknown*/})`;
                }
            }
        case '[object Error]':
            if (value instanceof Error) return `new Error(${stringifyInternal(value.message, currentValues, getAsyncContent)})`;
            break;
        case '[object Undefined]':
            return `undefined`;
        case '[object Int8Array]':
        case '[object Uint8Array]':
        case '[object Uint8ClampedArray]':
        case '[object Int16Array]':
        case '[object Uint16Array]':
        case '[object Int32Array]':
        case '[object Uint32Array]':
        case '[object Float32Array]':
        case '[object Float64Array]':
        case '[object BigInt64Array]':
        case '[object BigUint64Array]':
            {
                if (typeof safeBufferIsBuffer === 'function' && safeBufferIsBuffer(value)) return `Buffer.from(${stringifyInternal(safeArrayFrom(value.values()), currentValues, getAsyncContent)})`;
                const valuePrototype = safeObjectGetPrototypeOf(value);
                const className = valuePrototype && valuePrototype.constructor && valuePrototype.constructor.name;
                if (typeof className === 'string') {
                    const typedArray = value;
                    const valuesFromTypedArr = typedArray.values();
                    return `${className}.from(${stringifyInternal(safeArrayFrom(valuesFromTypedArr), currentValues, getAsyncContent)})`;
                }
                break;
            }
    }
    try {
        return value.toString();
    } catch (_a) {
        return (0, _globalsJs.safeToString)(value);
    }
}
function stringify(value) {
    return stringifyInternal(value, [], ()=>({
            state: 'unknown',
            value: undefined
        }));
}
function possiblyAsyncStringify(value) {
    const stillPendingMarker = (0, _globalsJs.Symbol)();
    const pendingPromisesForCache = [];
    const cache = new (0, _globalsJs.Map)();
    function createDelay0() {
        let handleId = null;
        const cancel = ()=>{
            if (handleId !== null) clearTimeout(handleId);
        };
        const delay = new Promise((resolve)=>{
            handleId = setTimeout(()=>{
                handleId = null;
                resolve(stillPendingMarker);
            }, 0);
        });
        return {
            delay,
            cancel
        };
    }
    const unknownState = {
        state: 'unknown',
        value: undefined
    };
    const getAsyncContent = function getAsyncContent(data) {
        const cacheKey = data;
        if (cache.has(cacheKey)) return cache.get(cacheKey);
        const delay0 = createDelay0();
        const p = asyncToStringMethod in data ? Promise.resolve().then(()=>data[asyncToStringMethod]()) : data;
        p.catch(()=>{});
        pendingPromisesForCache.push(Promise.race([
            p,
            delay0.delay
        ]).then((successValue)=>{
            if (successValue === stillPendingMarker) cache.set(cacheKey, {
                state: 'pending',
                value: undefined
            });
            else cache.set(cacheKey, {
                state: 'fulfilled',
                value: successValue
            });
            delay0.cancel();
        }, (errorValue)=>{
            cache.set(cacheKey, {
                state: 'rejected',
                value: errorValue
            });
            delay0.cancel();
        }));
        cache.set(cacheKey, unknownState);
        return unknownState;
    };
    function loop() {
        const stringifiedValue = stringifyInternal(value, [], getAsyncContent);
        if (pendingPromisesForCache.length === 0) return stringifiedValue;
        return Promise.all(pendingPromisesForCache.splice(0)).then(loop);
    }
    return loop();
}
async function asyncStringify(value) {
    return Promise.resolve(possiblyAsyncStringify(value));
}

},{"aab129e9e6218dc4":"gpccj","./globals.js":"aTuwn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"gpccj":[function(require,module,exports,__globalThis) {
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ /* eslint-disable no-proto */ 'use strict';
const base64 = require("8d7b0712b5ea2b3");
const ieee754 = require("603aed6e39afb648");
const customInspectSymbol = typeof Symbol === 'function' && typeof Symbol['for'] === 'function' // eslint-disable-line dot-notation
 ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
 : null;
exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
const K_MAX_LENGTH = 0x7fffffff;
exports.kMaxLength = K_MAX_LENGTH;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */ Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
function typedArraySupport() {
    // Can typed array instances can be augmented?
    try {
        const arr = new Uint8Array(1);
        const proto = {
            foo: function() {
                return 42;
            }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
    } catch (e) {
        return false;
    }
}
Object.defineProperty(Buffer.prototype, 'parent', {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.buffer;
    }
});
Object.defineProperty(Buffer.prototype, 'offset', {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.byteOffset;
    }
});
function createBuffer(length) {
    if (length > K_MAX_LENGTH) throw new RangeError('The value "' + length + '" is invalid for option "size"');
    // Return an augmented `Uint8Array` instance
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */ function Buffer(arg, encodingOrOffset, length) {
    // Common case.
    if (typeof arg === 'number') {
        if (typeof encodingOrOffset === 'string') throw new TypeError('The "string" argument must be of type string. Received type number');
        return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192 // not used by this implementation
;
function from(value, encodingOrOffset, length) {
    if (typeof value === 'string') return fromString(value, encodingOrOffset);
    if (ArrayBuffer.isView(value)) return fromArrayView(value);
    if (value == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof SharedArrayBuffer !== 'undefined' && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof value === 'number') throw new TypeError('The "value" argument must not be of type number. Received type number');
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) return Buffer.from(valueOf, encodingOrOffset, length);
    const b = fromObject(value);
    if (b) return b;
    if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/ Buffer.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
};
// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer, Uint8Array);
function assertSize(size) {
    if (typeof size !== 'number') throw new TypeError('"size" argument must be of type number');
    else if (size < 0) throw new RangeError('The value "' + size + '" is invalid for option "size"');
}
function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) return createBuffer(size);
    if (fill !== undefined) // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    return createBuffer(size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/ Buffer.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
};
function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */ Buffer.allocUnsafe = function(size) {
    return allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */ Buffer.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
};
function fromString(string, encoding) {
    if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8';
    if (!Buffer.isEncoding(encoding)) throw new TypeError('Unknown encoding: ' + encoding);
    const length = byteLength(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
    return buf;
}
function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for(let i = 0; i < length; i += 1)buf[i] = array[i] & 255;
    return buf;
}
function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
}
function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) throw new RangeError('"offset" is outside of buffer bounds');
    if (array.byteLength < byteOffset + (length || 0)) throw new RangeError('"length" is outside of buffer bounds');
    let buf;
    if (byteOffset === undefined && length === undefined) buf = new Uint8Array(array);
    else if (length === undefined) buf = new Uint8Array(array, byteOffset);
    else buf = new Uint8Array(array, byteOffset, length);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
function fromObject(obj) {
    if (Buffer.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) return buf;
        obj.copy(buf, 0, 0, len);
        return buf;
    }
    if (obj.length !== undefined) {
        if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) return createBuffer(0);
        return fromArrayLike(obj);
    }
    if (obj.type === 'Buffer' && Array.isArray(obj.data)) return fromArrayLike(obj.data);
}
function checked(length) {
    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= K_MAX_LENGTH) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + ' bytes');
    return length | 0;
}
function SlowBuffer(length) {
    if (+length != length) length = 0;
    return Buffer.alloc(+length);
}
Buffer.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
    ;
};
Buffer.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
    if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (a === b) return 0;
    let x = a.length;
    let y = b.length;
    for(let i = 0, len = Math.min(x, y); i < len; ++i)if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
    switch(String(encoding).toLowerCase()){
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return true;
        default:
            return false;
    }
};
Buffer.concat = function concat(list, length) {
    if (!Array.isArray(list)) throw new TypeError('"list" argument must be an Array of Buffers');
    if (list.length === 0) return Buffer.alloc(0);
    let i;
    if (length === undefined) {
        length = 0;
        for(i = 0; i < list.length; ++i)length += list[i].length;
    }
    const buffer = Buffer.allocUnsafe(length);
    let pos = 0;
    for(i = 0; i < list.length; ++i){
        let buf = list[i];
        if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) {
                if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
                buf.copy(buffer, pos);
            } else Uint8Array.prototype.set.call(buffer, buf, pos);
        } else if (!Buffer.isBuffer(buf)) throw new TypeError('"list" argument must be an Array of Buffers');
        else buf.copy(buffer, pos);
        pos += buf.length;
    }
    return buffer;
};
function byteLength(string, encoding) {
    if (Buffer.isBuffer(string)) return string.length;
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) return string.byteLength;
    if (typeof string !== 'string') throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    // Use a for loop to avoid recursion
    let loweredCase = false;
    for(;;)switch(encoding){
        case 'ascii':
        case 'latin1':
        case 'binary':
            return len;
        case 'utf8':
        case 'utf-8':
            return utf8ToBytes(string).length;
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return len * 2;
        case 'hex':
            return len >>> 1;
        case 'base64':
            return base64ToBytes(string).length;
        default:
            if (loweredCase) return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
            ;
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
    }
}
Buffer.byteLength = byteLength;
function slowToString(encoding, start, end) {
    let loweredCase = false;
    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.
    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) start = 0;
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) return '';
    if (end === undefined || end > this.length) end = this.length;
    if (end <= 0) return '';
    // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;
    if (end <= start) return '';
    if (!encoding) encoding = 'utf8';
    while(true)switch(encoding){
        case 'hex':
            return hexSlice(this, start, end);
        case 'utf8':
        case 'utf-8':
            return utf8Slice(this, start, end);
        case 'ascii':
            return asciiSlice(this, start, end);
        case 'latin1':
        case 'binary':
            return latin1Slice(this, start, end);
        case 'base64':
            return base64Slice(this, start, end);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return utf16leSlice(this, start, end);
        default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
            encoding = (encoding + '').toLowerCase();
            loweredCase = true;
    }
}
// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true;
function swap(b, n, m) {
    const i = b[n];
    b[n] = b[m];
    b[m] = i;
}
Buffer.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) throw new RangeError('Buffer size must be a multiple of 16-bits');
    for(let i = 0; i < len; i += 2)swap(this, i, i + 1);
    return this;
};
Buffer.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) throw new RangeError('Buffer size must be a multiple of 32-bits');
    for(let i = 0; i < len; i += 4){
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
    }
    return this;
};
Buffer.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) throw new RangeError('Buffer size must be a multiple of 64-bits');
    for(let i = 0; i < len; i += 8){
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
    }
    return this;
};
Buffer.prototype.toString = function toString() {
    const length = this.length;
    if (length === 0) return '';
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
};
Buffer.prototype.toLocaleString = Buffer.prototype.toString;
Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
    if (this === b) return true;
    return Buffer.compare(this, b) === 0;
};
Buffer.prototype.inspect = function inspect() {
    let str = '';
    const max = exports.INSPECT_MAX_BYTES;
    str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
    if (this.length > max) str += ' ... ';
    return '<Buffer ' + str + '>';
};
if (customInspectSymbol) Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) target = Buffer.from(target, target.offset, target.byteLength);
    if (!Buffer.isBuffer(target)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    if (start === undefined) start = 0;
    if (end === undefined) end = target ? target.length : 0;
    if (thisStart === undefined) thisStart = 0;
    if (thisEnd === undefined) thisEnd = this.length;
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) throw new RangeError('out of range index');
    if (thisStart >= thisEnd && start >= end) return 0;
    if (thisStart >= thisEnd) return -1;
    if (start >= end) return 1;
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    let x = thisEnd - thisStart;
    let y = end - start;
    const len = Math.min(x, y);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for(let i = 0; i < len; ++i)if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1;
    // Normalize byteOffset
    if (typeof byteOffset === 'string') {
        encoding = byteOffset;
        byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff;
    else if (byteOffset < -2147483648) byteOffset = -2147483648;
    byteOffset = +byteOffset // Coerce to Number.
    ;
    if (numberIsNaN(byteOffset)) // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
    }
    // Normalize val
    if (typeof val === 'string') val = Buffer.from(val, encoding);
    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) return -1;
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === 'number') {
        val = val & 0xFF // Search for a byte value [0-255]
        ;
        if (typeof Uint8Array.prototype.indexOf === 'function') {
            if (dir) return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            else return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
        return arrayIndexOf(buffer, [
            val
        ], byteOffset, encoding, dir);
    }
    throw new TypeError('val must be string, number or Buffer');
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
            if (arr.length < 2 || val.length < 2) return -1;
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
        }
    }
    function read(buf, i) {
        if (indexSize === 1) return buf[i];
        else return buf.readUInt16BE(i * indexSize);
    }
    let i;
    if (dir) {
        let foundIndex = -1;
        for(i = byteOffset; i < arrLength; i++)if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
        }
    } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for(i = byteOffset; i >= 0; i--){
            let found = true;
            for(let j = 0; j < valLength; j++)if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
            }
            if (found) return i;
        }
    }
    return -1;
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) length = remaining;
    else {
        length = Number(length);
        if (length > remaining) length = remaining;
    }
    const strLen = string.length;
    if (length > strLen / 2) length = strLen / 2;
    let i;
    for(i = 0; i < length; ++i){
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
    }
    return i;
}
function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
Buffer.prototype.write = function write(string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
        encoding = 'utf8';
        length = this.length;
        offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === 'string') {
        encoding = offset;
        length = this.length;
        offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === undefined) encoding = 'utf8';
        } else {
            encoding = length;
            length = undefined;
        }
    } else throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
    const remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) throw new RangeError('Attempt to write outside buffer bounds');
    if (!encoding) encoding = 'utf8';
    let loweredCase = false;
    for(;;)switch(encoding){
        case 'hex':
            return hexWrite(this, string, offset, length);
        case 'utf8':
        case 'utf-8':
            return utf8Write(this, string, offset, length);
        case 'ascii':
        case 'latin1':
        case 'binary':
            return asciiWrite(this, string, offset, length);
        case 'base64':
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return ucs2Write(this, string, offset, length);
        default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
    }
};
Buffer.prototype.toJSON = function toJSON() {
    return {
        type: 'Buffer',
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) return base64.fromByteArray(buf);
    else return base64.fromByteArray(buf.slice(start, end));
}
function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i = start;
    while(i < end){
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;
        if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch(bytesPerSequence){
                case 1:
                    if (firstByte < 0x80) codePoint = firstByte;
                    break;
                case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
                        if (tempCodePoint > 0x7F) codePoint = tempCodePoint;
                    }
                    break;
                case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) codePoint = tempCodePoint;
                    }
                    break;
                case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) codePoint = tempCodePoint;
                    }
            }
        }
        if (codePoint === null) {
            // we did not generate a valid codePoint so insert a
            // replacement char (U+FFFD) and advance only 1 byte
            codePoint = 0xFFFD;
            bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
            // encode to utf16 (surrogate pair dance)
            codePoint -= 0x10000;
            res.push(codePoint >>> 10 & 0x3FF | 0xD800);
            codePoint = 0xDC00 | codePoint & 0x3FF;
        }
        res.push(codePoint);
        i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
}
// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
const MAX_ARGUMENTS_LENGTH = 0x1000;
function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    ;
    // Decode in chunks to avoid "call stack size exceeded".
    let res = '';
    let i = 0;
    while(i < len)res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    return res;
}
function asciiSlice(buf, start, end) {
    let ret = '';
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i)ret += String.fromCharCode(buf[i] & 0x7F);
    return ret;
}
function latin1Slice(buf, start, end) {
    let ret = '';
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i)ret += String.fromCharCode(buf[i]);
    return ret;
}
function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    let out = '';
    for(let i = start; i < end; ++i)out += hexSliceLookupTable[buf[i]];
    return out;
}
function utf16leSlice(buf, start, end) {
    const bytes = buf.slice(start, end);
    let res = '';
    // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
    for(let i = 0; i < bytes.length - 1; i += 2)res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    return res;
}
Buffer.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0) start = 0;
    } else if (start > len) start = len;
    if (end < 0) {
        end += len;
        if (end < 0) end = 0;
    } else if (end > len) end = len;
    if (end < start) end = start;
    const newBuf = this.subarray(start, end);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(newBuf, Buffer.prototype);
    return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */ function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}
Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    return val;
};
Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let val = this[offset + --byteLength];
    let mul = 1;
    while(byteLength > 0 && (mul *= 0x100))val += this[offset + --byteLength] * mul;
    return val;
};
Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
};
Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
};
Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
};
Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};
Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, 'offset');
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const lo = first + this[++offset] * 256 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 256 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
});
Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, 'offset');
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
});
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let i = byteLength;
    let mul = 1;
    let val = this[offset + --i];
    while(i > 0 && (mul *= 0x100))val += this[offset + --i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return this[offset];
    return (0xff - this[offset] + 1) * -1;
};
Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, 'offset');
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const val = this[offset + 4] + this[offset + 5] * 256 + this[offset + 6] * 2 ** 16 + (last << 24 // Overflow
    );
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 256 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
});
Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, 'offset');
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 + this[++offset] * 256 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + last);
});
Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
};
function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
}
Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    let mul = 1;
    let i = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    let i = byteLength - 1;
    let mul = 1;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(0xffffffff));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
}
function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(0xffffffff));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
}
Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));
});
Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));
});
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    let i = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    let i = byteLength - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -128);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    if (value < 0) value = 0xffffffff + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
});
Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
});
function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
    if (offset < 0) throw new RangeError('Index out of range');
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -340282346638528860000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
}
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
}
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
};
// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    // Copy 0 bytes; we're done
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    // Fatal error conditions
    if (targetStart < 0) throw new RangeError('targetStart out of bounds');
    if (start < 0 || start >= this.length) throw new RangeError('Index out of range');
    if (end < 0) throw new RangeError('sourceEnd out of bounds');
    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) end = target.length - targetStart + start;
    const len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end);
    else Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    return len;
};
// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === 'string') {
        if (typeof start === 'string') {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === 'string') {
            encoding = end;
            end = this.length;
        }
        if (encoding !== undefined && typeof encoding !== 'string') throw new TypeError('encoding must be a string');
        if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) throw new TypeError('Unknown encoding: ' + encoding);
        if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === 'utf8' && code < 128 || encoding === 'latin1') // Fast path: If `val` fits into a single byte, use that numeric value.
            val = code;
        }
    } else if (typeof val === 'number') val = val & 255;
    else if (typeof val === 'boolean') val = Number(val);
    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) throw new RangeError('Out of range index');
    if (end <= start) return this;
    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;
    if (!val) val = 0;
    let i;
    if (typeof val === 'number') for(i = start; i < end; ++i)this[i] = val;
    else {
        const bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
        const len = bytes.length;
        if (len === 0) throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        for(i = 0; i < end - start; ++i)this[i + start] = bytes[i % len];
    }
    return this;
};
// CUSTOM ERRORS
// =============
// Simplified versions from Node, changed for Buffer-only usage
const errors = {};
function E(sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
        constructor(){
            super();
            Object.defineProperty(this, 'message', {
                value: getMessage.apply(this, arguments),
                writable: true,
                configurable: true
            });
            // Add the error code to the name to include it in the stack trace.
            this.name = `${this.name} [${sym}]`;
            // Access the stack to generate the error message including the error code
            // from the name.
            this.stack // eslint-disable-line no-unused-expressions
            ;
            // Reset the name to the actual name.
            delete this.name;
        }
        get code() {
            return sym;
        }
        set code(value) {
            Object.defineProperty(this, 'code', {
                configurable: true,
                enumerable: true,
                value,
                writable: true
            });
        }
        toString() {
            return `${this.name} [${sym}]: ${this.message}`;
        }
    };
}
E('ERR_BUFFER_OUT_OF_BOUNDS', function(name) {
    if (name) return `${name} is outside of buffer bounds`;
    return 'Attempt to access memory outside buffer bounds';
}, RangeError);
E('ERR_INVALID_ARG_TYPE', function(name, actual) {
    return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
}, TypeError);
E('ERR_OUT_OF_RANGE', function(str, range, input) {
    let msg = `The value of "${str}" is out of range.`;
    let received = input;
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) received = addNumericalSeparator(String(input));
    else if (typeof input === 'bigint') {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) received = addNumericalSeparator(received);
        received += 'n';
    }
    msg += ` It must be ${range}. Received ${received}`;
    return msg;
}, RangeError);
function addNumericalSeparator(val) {
    let res = '';
    let i = val.length;
    const start = val[0] === '-' ? 1 : 0;
    for(; i >= start + 4; i -= 3)res = `_${val.slice(i - 3, i)}${res}`;
    return `${val.slice(0, i)}${res}`;
}
// CHECK FUNCTIONS
// ===============
function checkBounds(buf, offset, byteLength) {
    validateNumber(offset, 'offset');
    if (buf[offset] === undefined || buf[offset + byteLength] === undefined) boundsError(offset, buf.length - (byteLength + 1));
}
function checkIntBI(value, min, max, buf, offset, byteLength) {
    if (value > max || value < min) {
        const n = typeof min === 'bigint' ? 'n' : '';
        let range;
        if (byteLength > 3) {
            if (min === 0 || min === BigInt(0)) range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;
            else range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` + `${(byteLength + 1) * 8 - 1}${n}`;
        } else range = `>= ${min}${n} and <= ${max}${n}`;
        throw new errors.ERR_OUT_OF_RANGE('value', range, value);
    }
    checkBounds(buf, offset, byteLength);
}
function validateNumber(value, name) {
    if (typeof value !== 'number') throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value);
}
function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value);
    }
    if (length < 0) throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', `>= ${type ? 1 : 0} and <= ${length}`, value);
}
// HELPER FUNCTIONS
// ================
const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
    // Node takes equal signs as end of the Base64 encoding
    str = str.split('=')[0];
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = str.trim().replace(INVALID_BASE64_RE, '');
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return '';
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while(str.length % 4 !== 0)str = str + '=';
    return str;
}
function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for(let i = 0; i < length; ++i){
        codePoint = string.charCodeAt(i);
        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
            // last char was a lead
            if (!leadSurrogate) {
                // no lead yet
                if (codePoint > 0xDBFF) {
                    // unexpected trail
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                } else if (i + 1 === length) {
                    // unpaired lead
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                }
                // valid lead
                leadSurrogate = codePoint;
                continue;
            }
            // 2 leads in a row
            if (codePoint < 0xDC00) {
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                leadSurrogate = codePoint;
                continue;
            }
            // valid surrogate pair
            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) // valid bmp char, but last char was a lead
        {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }
        leadSurrogate = null;
        // encode utf8
        if (codePoint < 0x80) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
        } else if (codePoint < 0x800) {
            if ((units -= 2) < 0) break;
            bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
            if ((units -= 3) < 0) break;
            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x110000) {
            if ((units -= 4) < 0) break;
            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else throw new Error('Invalid code point');
    }
    return bytes;
}
function asciiToBytes(str) {
    const byteArray = [];
    for(let i = 0; i < str.length; ++i)// Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
    return byteArray;
}
function utf16leToBytes(str, units) {
    let c, hi, lo;
    const byteArray = [];
    for(let i = 0; i < str.length; ++i){
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return byteArray;
}
function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
    let i;
    for(i = 0; i < length; ++i){
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
    }
    return i;
}
// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
function numberIsNaN(obj) {
    // For IE11 support
    return obj !== obj // eslint-disable-line no-self-compare
    ;
}
// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
const hexSliceLookupTable = function() {
    const alphabet = '0123456789abcdef';
    const table = new Array(256);
    for(let i = 0; i < 16; ++i){
        const i16 = i * 16;
        for(let j = 0; j < 16; ++j)table[i16 + j] = alphabet[i] + alphabet[j];
    }
    return table;
}();
// Return not function with Error if BigInt not supported
function defineBigIntMethod(fn) {
    return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn;
}
function BufferBigIntNotDefined() {
    throw new Error('BigInt not supported');
}

},{"8d7b0712b5ea2b3":"6sOOl","603aed6e39afb648":"jHM3g"}],"6sOOl":[function(require,module,exports,__globalThis) {
'use strict';
exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for(var i = 0, len = code.length; i < len; ++i){
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
}
// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;
function getLens(b64) {
    var len = b64.length;
    if (len % 4 > 0) throw new Error('Invalid string. Length must be a multiple of 4');
    // Trim off extra bytes after placeholder bytes are found
    // See: https://github.com/beatgammit/base64-js/issues/42
    var validLen = b64.indexOf('=');
    if (validLen === -1) validLen = len;
    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
    return [
        validLen,
        placeHoldersLen
    ];
}
// base64 is 4/3 + up to two characters of the original data
function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    // if there are placeholders, only get up to the last complete 4 chars
    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i;
    for(i = 0; i < len; i += 4){
        tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
        arr[curByte++] = tmp >> 16 & 0xFF;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    return arr;
}
function tripletToBase64(num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}
function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for(var i = start; i < end; i += 3){
        tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
        output.push(tripletToBase64(tmp));
    }
    return output.join('');
}
function fromByteArray(uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
    ;
    var parts = [];
    var maxChunkLength = 16383 // must be multiple of 3
    ;
    // go through the array every three bytes, we'll deal with trailing stuff later
    for(var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength)parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
        tmp = uint8[len - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
    } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
    }
    return parts.join('');
}

},{}],"jHM3g":[function(require,module,exports,__globalThis) {
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ exports.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);
    if (e === 0) e = 1 - eBias;
    else if (e === eMax) return m ? NaN : (s ? -1 : 1) * Infinity;
    else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
    } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
        }
        if (e + eBias >= 1) value += rt / c;
        else value += rt * Math.pow(2, 1 - eBias);
        if (value * c >= 2) {
            e++;
            c /= 2;
        }
        if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
        } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
        } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
        }
    }
    for(; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);
    e = e << mLen | m;
    eLen += mLen;
    for(; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);
    buffer[offset + i - d] |= s * 128;
};

},{}],"dMEL3":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RunnerIterator", ()=>RunnerIterator);
var _preconditionFailureJs = require("../precondition/PreconditionFailure.js");
var _runExecutionJs = require("./reporter/RunExecution.js");
class RunnerIterator {
    constructor(sourceValues, shrink, verbose, interruptedAsFailure){
        this.sourceValues = sourceValues;
        this.shrink = shrink;
        this.runExecution = new (0, _runExecutionJs.RunExecution)(verbose, interruptedAsFailure);
        this.currentIdx = -1;
        this.nextValues = sourceValues;
    }
    [Symbol.iterator]() {
        return this;
    }
    next() {
        const nextValue = this.nextValues.next();
        if (nextValue.done || this.runExecution.interrupted) return {
            done: true,
            value: undefined
        };
        this.currentValue = nextValue.value;
        ++this.currentIdx;
        return {
            done: false,
            value: nextValue.value.value_
        };
    }
    handleResult(result) {
        if (result != null && typeof result === 'object' && !(0, _preconditionFailureJs.PreconditionFailure).isFailure(result)) {
            this.runExecution.fail(this.currentValue.value_, this.currentIdx, result);
            this.currentIdx = -1;
            this.nextValues = this.shrink(this.currentValue);
        } else if (result != null) {
            if (!result.interruptExecution) {
                this.runExecution.skip(this.currentValue.value_);
                this.sourceValues.skippedOne();
            } else this.runExecution.interrupt();
        } else this.runExecution.success(this.currentValue.value_);
    }
}

},{"../precondition/PreconditionFailure.js":"7yplK","./reporter/RunExecution.js":"4U4YS","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"4U4YS":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RunExecution", ()=>RunExecution);
var _verbosityLevelJs = require("../configuration/VerbosityLevel.js");
var _executionStatusJs = require("./ExecutionStatus.js");
var _globalsJs = require("../../../utils/globals.js");
class RunExecution {
    constructor(verbosity, interruptedAsFailure){
        this.verbosity = verbosity;
        this.interruptedAsFailure = interruptedAsFailure;
        this.isSuccess = ()=>this.pathToFailure == null;
        this.firstFailure = ()=>this.pathToFailure ? +(0, _globalsJs.safeSplit)(this.pathToFailure, ':')[0] : -1;
        this.numShrinks = ()=>this.pathToFailure ? (0, _globalsJs.safeSplit)(this.pathToFailure, ':').length - 1 : 0;
        this.rootExecutionTrees = [];
        this.currentLevelExecutionTrees = this.rootExecutionTrees;
        this.failure = null;
        this.numSkips = 0;
        this.numSuccesses = 0;
        this.interrupted = false;
    }
    appendExecutionTree(status, value) {
        const currentTree = {
            status,
            value,
            children: []
        };
        this.currentLevelExecutionTrees.push(currentTree);
        return currentTree;
    }
    fail(value, id, failure) {
        if (this.verbosity >= (0, _verbosityLevelJs.VerbosityLevel).Verbose) {
            const currentTree = this.appendExecutionTree((0, _executionStatusJs.ExecutionStatus).Failure, value);
            this.currentLevelExecutionTrees = currentTree.children;
        }
        if (this.pathToFailure == null) this.pathToFailure = `${id}`;
        else this.pathToFailure += `:${id}`;
        this.value = value;
        this.failure = failure;
    }
    skip(value) {
        if (this.verbosity >= (0, _verbosityLevelJs.VerbosityLevel).VeryVerbose) this.appendExecutionTree((0, _executionStatusJs.ExecutionStatus).Skipped, value);
        if (this.pathToFailure == null) ++this.numSkips;
    }
    success(value) {
        if (this.verbosity >= (0, _verbosityLevelJs.VerbosityLevel).VeryVerbose) this.appendExecutionTree((0, _executionStatusJs.ExecutionStatus).Success, value);
        if (this.pathToFailure == null) ++this.numSuccesses;
    }
    interrupt() {
        this.interrupted = true;
    }
    extractFailures() {
        if (this.isSuccess()) return [];
        const failures = [];
        let cursor = this.rootExecutionTrees;
        while(cursor.length > 0 && cursor[cursor.length - 1].status === (0, _executionStatusJs.ExecutionStatus).Failure){
            const failureTree = cursor[cursor.length - 1];
            failures.push(failureTree.value);
            cursor = failureTree.children;
        }
        return failures;
    }
    toRunDetails(seed, basePath, maxSkips, qParams) {
        if (!this.isSuccess()) return {
            failed: true,
            interrupted: this.interrupted,
            numRuns: this.firstFailure() + 1 - this.numSkips,
            numSkips: this.numSkips,
            numShrinks: this.numShrinks(),
            seed,
            counterexample: this.value,
            counterexamplePath: RunExecution.mergePaths(basePath, this.pathToFailure),
            error: this.failure.errorMessage,
            errorInstance: this.failure.error,
            failures: this.extractFailures(),
            executionSummary: this.rootExecutionTrees,
            verbose: this.verbosity,
            runConfiguration: qParams.toParameters()
        };
        const considerInterruptedAsFailure = this.interruptedAsFailure || this.numSuccesses === 0;
        const failed = this.numSkips > maxSkips || this.interrupted && considerInterruptedAsFailure;
        const out = {
            failed,
            interrupted: this.interrupted,
            numRuns: this.numSuccesses,
            numSkips: this.numSkips,
            numShrinks: 0,
            seed,
            counterexample: null,
            counterexamplePath: null,
            error: null,
            errorInstance: null,
            failures: [],
            executionSummary: this.rootExecutionTrees,
            verbose: this.verbosity,
            runConfiguration: qParams.toParameters()
        };
        return out;
    }
}
RunExecution.mergePaths = (offsetPath, path)=>{
    if (offsetPath.length === 0) return path;
    const offsetItems = offsetPath.split(':');
    const remainingItems = path.split(':');
    const middle = +offsetItems[offsetItems.length - 1] + +remainingItems[0];
    return [
        ...offsetItems.slice(0, offsetItems.length - 1),
        `${middle}`,
        ...remainingItems.slice(1)
    ].join(':');
};

},{"../configuration/VerbosityLevel.js":"gkUPE","./ExecutionStatus.js":"glGVI","../../../utils/globals.js":"aTuwn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"glGVI":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ExecutionStatus", ()=>ExecutionStatus);
var ExecutionStatus;
(function(ExecutionStatus) {
    ExecutionStatus[ExecutionStatus["Success"] = 0] = "Success";
    ExecutionStatus[ExecutionStatus["Skipped"] = -1] = "Skipped";
    ExecutionStatus[ExecutionStatus["Failure"] = 1] = "Failure";
})(ExecutionStatus || (ExecutionStatus = {}));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"gOtuF":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SourceValuesIterator", ()=>SourceValuesIterator);
class SourceValuesIterator {
    constructor(initialValues, maxInitialIterations, remainingSkips){
        this.initialValues = initialValues;
        this.maxInitialIterations = maxInitialIterations;
        this.remainingSkips = remainingSkips;
    }
    [Symbol.iterator]() {
        return this;
    }
    next() {
        if (--this.maxInitialIterations !== -1 && this.remainingSkips >= 0) {
            const n = this.initialValues.next();
            if (!n.done) return {
                value: n.value,
                done: false
            };
        }
        return {
            value: undefined,
            done: true
        };
    }
    skippedOne() {
        --this.remainingSkips;
        ++this.maxInitialIterations;
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"c3XFo":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "toss", ()=>toss);
parcelHelpers.export(exports, "lazyToss", ()=>lazyToss);
var _pureRand = require("pure-rand");
var _randomJs = require("../../random/generator/Random.js");
var _valueJs = require("../arbitrary/definition/Value.js");
var _globalsJs = require("../../utils/globals.js");
function tossNext(generator, rng, index) {
    rng.unsafeJump();
    return generator.generate(new (0, _randomJs.Random)(rng), index);
}
function* toss(generator, seed, random, examples) {
    for(let idx = 0; idx !== examples.length; ++idx)yield new (0, _valueJs.Value)(examples[idx], undefined);
    for(let idx = 0, rng = random(seed);; ++idx)yield tossNext(generator, rng, idx);
}
function lazyGenerate(generator, rng, idx) {
    return ()=>generator.generate(new (0, _randomJs.Random)(rng), idx);
}
function* lazyToss(generator, seed, random, examples) {
    yield* (0, _globalsJs.safeMap)(examples, (e)=>()=>new (0, _valueJs.Value)(e, undefined));
    let idx = 0;
    let rng = random(seed);
    for(;;){
        rng = rng.jump ? rng.jump() : (0, _pureRand.skipN)(rng, 42);
        yield lazyGenerate(generator, rng, idx++);
    }
}

},{"pure-rand":"lhKSo","../../random/generator/Random.js":"2GKne","../arbitrary/definition/Value.js":"8Cf1j","../../utils/globals.js":"aTuwn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"2GKne":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Random", ()=>Random);
var _pureRand = require("pure-rand");
class Random {
    constructor(sourceRng){
        this.internalRng = sourceRng.clone();
    }
    clone() {
        return new Random(this.internalRng);
    }
    next(bits) {
        return (0, _pureRand.unsafeUniformIntDistribution)(0, (1 << bits) - 1, this.internalRng);
    }
    nextBoolean() {
        return (0, _pureRand.unsafeUniformIntDistribution)(0, 1, this.internalRng) == 1;
    }
    nextInt(min, max) {
        return (0, _pureRand.unsafeUniformIntDistribution)(min == null ? Random.MIN_INT : min, max == null ? Random.MAX_INT : max, this.internalRng);
    }
    nextBigInt(min, max) {
        return (0, _pureRand.unsafeUniformBigIntDistribution)(min, max, this.internalRng);
    }
    nextArrayInt(min, max) {
        return (0, _pureRand.unsafeUniformArrayIntDistribution)(min, max, this.internalRng);
    }
    nextDouble() {
        const a = this.next(26);
        const b = this.next(27);
        return (a * Random.DBL_FACTOR + b) * Random.DBL_DIVISOR;
    }
    getState() {
        if ('getState' in this.internalRng && typeof this.internalRng.getState === 'function') return this.internalRng.getState();
        return undefined;
    }
}
Random.MIN_INT = -2147483648;
Random.MAX_INT = 2147483647;
Random.DBL_FACTOR = Math.pow(2, 27);
Random.DBL_DIVISOR = Math.pow(2, -53);

},{"pure-rand":"lhKSo","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"gzSoL":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "pathWalk", ()=>pathWalk);
function produce(producer) {
    return producer();
}
function pathWalk(path, initialProducers, shrink) {
    const producers = initialProducers;
    const segments = path.split(':').map((text)=>+text);
    if (segments.length === 0) return producers.map(produce);
    if (!segments.every((v)=>!Number.isNaN(v))) throw new Error(`Unable to replay, got invalid path=${path}`);
    let values = producers.drop(segments[0]).map(produce);
    for (const s of segments.slice(1)){
        const valueToShrink = values.getNthOrLast(0);
        if (valueToShrink === null) throw new Error(`Unable to replay, got wrong path=${path}`);
        values = shrink(valueToShrink).drop(s);
    }
    return values;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"2mhrC":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "reportRunDetails", ()=>reportRunDetails);
parcelHelpers.export(exports, "asyncReportRunDetails", ()=>asyncReportRunDetails);
parcelHelpers.export(exports, "defaultReportMessage", ()=>defaultReportMessage);
parcelHelpers.export(exports, "asyncDefaultReportMessage", ()=>asyncDefaultReportMessage);
var _globalsJs = require("../../../utils/globals.js");
var _stringifyJs = require("../../../utils/stringify.js");
var _verbosityLevelJs = require("../configuration/VerbosityLevel.js");
var _executionStatusJs = require("../reporter/ExecutionStatus.js");
const safeObjectAssign = Object.assign;
function formatHints(hints) {
    if (hints.length === 1) return `Hint: ${hints[0]}`;
    return hints.map((h, idx)=>`Hint (${idx + 1}): ${h}`).join('\n');
}
function formatFailures(failures, stringifyOne) {
    return `Encountered failures were:\n- ${failures.map(stringifyOne).join('\n- ')}`;
}
function formatExecutionSummary(executionTrees, stringifyOne) {
    const summaryLines = [];
    const remainingTreesAndDepth = [];
    for (const tree of executionTrees.slice().reverse())remainingTreesAndDepth.push({
        depth: 1,
        tree
    });
    while(remainingTreesAndDepth.length !== 0){
        const currentTreeAndDepth = remainingTreesAndDepth.pop();
        const currentTree = currentTreeAndDepth.tree;
        const currentDepth = currentTreeAndDepth.depth;
        const statusIcon = currentTree.status === (0, _executionStatusJs.ExecutionStatus).Success ? '\x1b[32m\u221A\x1b[0m' : currentTree.status === (0, _executionStatusJs.ExecutionStatus).Failure ? '\x1b[31m\xD7\x1b[0m' : '\x1b[33m!\x1b[0m';
        const leftPadding = Array(currentDepth).join('. ');
        summaryLines.push(`${leftPadding}${statusIcon} ${stringifyOne(currentTree.value)}`);
        for (const tree of currentTree.children.slice().reverse())remainingTreesAndDepth.push({
            depth: currentDepth + 1,
            tree
        });
    }
    return `Execution summary:\n${summaryLines.join('\n')}`;
}
function preFormatTooManySkipped(out, stringifyOne) {
    const message = `Failed to run property, too many pre-condition failures encountered\n{ seed: ${out.seed} }\n\nRan ${out.numRuns} time(s)\nSkipped ${out.numSkips} time(s)`;
    let details = null;
    const hints = [
        'Try to reduce the number of rejected values by combining map, flatMap and built-in arbitraries',
        'Increase failure tolerance by setting maxSkipsPerRun to an higher value'
    ];
    if (out.verbose >= (0, _verbosityLevelJs.VerbosityLevel).VeryVerbose) details = formatExecutionSummary(out.executionSummary, stringifyOne);
    else (0, _globalsJs.safePush)(hints, 'Enable verbose mode at level VeryVerbose in order to check all generated values and their associated status');
    return {
        message,
        details,
        hints
    };
}
function preFormatFailure(out, stringifyOne) {
    const noErrorInMessage = out.runConfiguration.errorWithCause;
    const messageErrorPart = noErrorInMessage ? '' : `\nGot ${(0, _globalsJs.safeReplace)(out.error, /^Error: /, 'error: ')}`;
    const message = `Property failed after ${out.numRuns} tests\n{ seed: ${out.seed}, path: "${out.counterexamplePath}", endOnFailure: true }\nCounterexample: ${stringifyOne(out.counterexample)}\nShrunk ${out.numShrinks} time(s)${messageErrorPart}`;
    let details = null;
    const hints = [];
    if (out.verbose >= (0, _verbosityLevelJs.VerbosityLevel).VeryVerbose) details = formatExecutionSummary(out.executionSummary, stringifyOne);
    else if (out.verbose === (0, _verbosityLevelJs.VerbosityLevel).Verbose) details = formatFailures(out.failures, stringifyOne);
    else (0, _globalsJs.safePush)(hints, 'Enable verbose mode in order to have the list of all failing values encountered during the run');
    return {
        message,
        details,
        hints
    };
}
function preFormatEarlyInterrupted(out, stringifyOne) {
    const message = `Property interrupted after ${out.numRuns} tests\n{ seed: ${out.seed} }`;
    let details = null;
    const hints = [];
    if (out.verbose >= (0, _verbosityLevelJs.VerbosityLevel).VeryVerbose) details = formatExecutionSummary(out.executionSummary, stringifyOne);
    else (0, _globalsJs.safePush)(hints, 'Enable verbose mode at level VeryVerbose in order to check all generated values and their associated status');
    return {
        message,
        details,
        hints
    };
}
function defaultReportMessageInternal(out, stringifyOne) {
    if (!out.failed) return;
    const { message, details, hints } = out.counterexamplePath === null ? out.interrupted ? preFormatEarlyInterrupted(out, stringifyOne) : preFormatTooManySkipped(out, stringifyOne) : preFormatFailure(out, stringifyOne);
    let errorMessage = message;
    if (details != null) errorMessage += `\n\n${details}`;
    if (hints.length > 0) errorMessage += `\n\n${formatHints(hints)}`;
    return errorMessage;
}
function defaultReportMessage(out) {
    return defaultReportMessageInternal(out, (0, _stringifyJs.stringify));
}
async function asyncDefaultReportMessage(out) {
    const pendingStringifieds = [];
    function stringifyOne(value) {
        const stringified = (0, _stringifyJs.possiblyAsyncStringify)(value);
        if (typeof stringified === 'string') return stringified;
        pendingStringifieds.push(Promise.all([
            value,
            stringified
        ]));
        return '\u2026';
    }
    const firstTryMessage = defaultReportMessageInternal(out, stringifyOne);
    if (pendingStringifieds.length === 0) return firstTryMessage;
    const registeredValues = new (0, _globalsJs.Map)(await Promise.all(pendingStringifieds));
    function stringifySecond(value) {
        const asyncStringifiedIfRegistered = (0, _globalsJs.safeMapGet)(registeredValues, value);
        if (asyncStringifiedIfRegistered !== undefined) return asyncStringifiedIfRegistered;
        return (0, _stringifyJs.stringify)(value);
    }
    return defaultReportMessageInternal(out, stringifySecond);
}
function buildError(errorMessage, out) {
    if (!out.runConfiguration.errorWithCause) throw new (0, _globalsJs.Error)(errorMessage);
    const ErrorWithCause = (0, _globalsJs.Error);
    const error = new ErrorWithCause(errorMessage, {
        cause: out.errorInstance
    });
    if (!('cause' in error)) safeObjectAssign(error, {
        cause: out.errorInstance
    });
    return error;
}
function throwIfFailed(out) {
    if (!out.failed) return;
    throw buildError(defaultReportMessage(out), out);
}
async function asyncThrowIfFailed(out) {
    if (!out.failed) return;
    throw buildError(await asyncDefaultReportMessage(out), out);
}
function reportRunDetails(out) {
    if (out.runConfiguration.asyncReporter) return out.runConfiguration.asyncReporter(out);
    else if (out.runConfiguration.reporter) return out.runConfiguration.reporter(out);
    else return throwIfFailed(out);
}
async function asyncReportRunDetails(out) {
    if (out.runConfiguration.asyncReporter) return out.runConfiguration.asyncReporter(out);
    else if (out.runConfiguration.reporter) return out.runConfiguration.reporter(out);
    else return asyncThrowIfFailed(out);
}

},{"../../../utils/globals.js":"aTuwn","../../../utils/stringify.js":"gOa8u","../configuration/VerbosityLevel.js":"gkUPE","../reporter/ExecutionStatus.js":"glGVI","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"3qMUZ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "sample", ()=>sample);
parcelHelpers.export(exports, "statistics", ()=>statistics);
var _streamJs = require("../../stream/Stream.js");
var _propertyGenericJs = require("../property/Property.generic.js");
var _unbiasedPropertyJs = require("../property/UnbiasedProperty.js");
var _globalParametersJs = require("./configuration/GlobalParameters.js");
var _qualifiedParametersJs = require("./configuration/QualifiedParameters.js");
var _tosserJs = require("./Tosser.js");
var _pathWalkerJs = require("./utils/PathWalker.js");
function toProperty(generator, qParams) {
    const prop = !Object.prototype.hasOwnProperty.call(generator, 'isAsync') ? new (0, _propertyGenericJs.Property)(generator, ()=>true) : generator;
    return qParams.unbiased === true ? new (0, _unbiasedPropertyJs.UnbiasedProperty)(prop) : prop;
}
function streamSample(generator, params) {
    const extendedParams = typeof params === 'number' ? Object.assign(Object.assign({}, (0, _globalParametersJs.readConfigureGlobal)()), {
        numRuns: params
    }) : Object.assign(Object.assign({}, (0, _globalParametersJs.readConfigureGlobal)()), params);
    const qParams = (0, _qualifiedParametersJs.QualifiedParameters).read(extendedParams);
    const nextProperty = toProperty(generator, qParams);
    const shrink = nextProperty.shrink.bind(nextProperty);
    const tossedValues = qParams.path.length === 0 ? (0, _streamJs.stream)((0, _tosserJs.toss)(nextProperty, qParams.seed, qParams.randomType, qParams.examples)) : (0, _pathWalkerJs.pathWalk)(qParams.path, (0, _streamJs.stream)((0, _tosserJs.lazyToss)(nextProperty, qParams.seed, qParams.randomType, qParams.examples)), shrink);
    return tossedValues.take(qParams.numRuns).map((s)=>s.value_);
}
function sample(generator, params) {
    return [
        ...streamSample(generator, params)
    ];
}
function round2(n) {
    return (Math.round(n * 100) / 100).toFixed(2);
}
function statistics(generator, classify, params) {
    const extendedParams = typeof params === 'number' ? Object.assign(Object.assign({}, (0, _globalParametersJs.readConfigureGlobal)()), {
        numRuns: params
    }) : Object.assign(Object.assign({}, (0, _globalParametersJs.readConfigureGlobal)()), params);
    const qParams = (0, _qualifiedParametersJs.QualifiedParameters).read(extendedParams);
    const recorded = {};
    for (const g of streamSample(generator, params)){
        const out = classify(g);
        const categories = Array.isArray(out) ? out : [
            out
        ];
        for (const c of categories)recorded[c] = (recorded[c] || 0) + 1;
    }
    const data = Object.entries(recorded).sort((a, b)=>b[1] - a[1]).map((i)=>[
            i[0],
            `${round2(i[1] * 100.0 / qParams.numRuns)}%`
        ]);
    const longestName = data.map((i)=>i[0].length).reduce((p, c)=>Math.max(p, c), 0);
    const longestPercent = data.map((i)=>i[1].length).reduce((p, c)=>Math.max(p, c), 0);
    for (const item of data)qParams.logger(`${item[0].padEnd(longestName, '.')}..${item[1].padStart(longestPercent, '.')}`);
}

},{"../../stream/Stream.js":"2sjal","../property/Property.generic.js":"5KTN2","../property/UnbiasedProperty.js":"1QInN","./configuration/GlobalParameters.js":"f6Bj0","./configuration/QualifiedParameters.js":"cWXiY","./Tosser.js":"c3XFo","./utils/PathWalker.js":"gzSoL","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"10I3z":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "gen", ()=>gen);
var _generatorArbitraryJs = require("./_internals/GeneratorArbitrary.js");
function gen() {
    return new (0, _generatorArbitraryJs.GeneratorArbitrary)();
}

},{"./_internals/GeneratorArbitrary.js":"gvfgL","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"gvfgL":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "GeneratorArbitrary", ()=>GeneratorArbitrary);
var _arbitraryJs = require("../../check/arbitrary/definition/Arbitrary.js");
var _streamJs = require("../../stream/Stream.js");
var _globalsJs = require("../../utils/globals.js");
var _generatorValueBuilderJs = require("./builders/GeneratorValueBuilder.js");
var _stableArbitraryGeneratorCacheJs = require("./builders/StableArbitraryGeneratorCache.js");
var _tupleArbitraryJs = require("./TupleArbitrary.js");
class GeneratorArbitrary extends (0, _arbitraryJs.Arbitrary) {
    constructor(){
        super(...arguments);
        this.arbitraryCache = (0, _stableArbitraryGeneratorCacheJs.buildStableArbitraryGeneratorCache)((0, _stableArbitraryGeneratorCacheJs.naiveIsEqual));
    }
    generate(mrng, biasFactor) {
        return (0, _generatorValueBuilderJs.buildGeneratorValue)(mrng, biasFactor, ()=>[], this.arbitraryCache);
    }
    canShrinkWithoutContext(value) {
        return false;
    }
    shrink(_value, context) {
        if (context === undefined) return (0, _streamJs.Stream).nil();
        const safeContext = context;
        const mrng = safeContext.mrng;
        const biasFactor = safeContext.biasFactor;
        const history = safeContext.history;
        return (0, _tupleArbitraryJs.tupleShrink)(history.map((c)=>c.arb), history.map((c)=>c.value), history.map((c)=>c.context)).map((shrink)=>{
            function computePreBuiltValues() {
                const subValues = shrink.value;
                const subContexts = shrink.context;
                return (0, _globalsJs.safeMap)(history, (entry, index)=>({
                        arb: entry.arb,
                        value: subValues[index],
                        context: subContexts[index],
                        mrng: entry.mrng
                    }));
            }
            return (0, _generatorValueBuilderJs.buildGeneratorValue)(mrng, biasFactor, computePreBuiltValues, this.arbitraryCache);
        });
    }
}

},{"../../check/arbitrary/definition/Arbitrary.js":"e6f1K","../../stream/Stream.js":"2sjal","../../utils/globals.js":"aTuwn","./builders/GeneratorValueBuilder.js":"1ouH9","./builders/StableArbitraryGeneratorCache.js":"c5Exp","./TupleArbitrary.js":"9Zf7s","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"1ouH9":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "buildGeneratorValue", ()=>buildGeneratorValue);
var _valueJs = require("../../../check/arbitrary/definition/Value.js");
var _symbolsJs = require("../../../check/symbols.js");
var _globalsJs = require("../../../utils/globals.js");
var _stringifyJs = require("../../../utils/stringify.js");
const safeObjectAssign = Object.assign;
function buildGeneratorValue(mrng, biasFactor, computePreBuiltValues, arbitraryCache) {
    const preBuiltValues = computePreBuiltValues();
    let localMrng = mrng.clone();
    const context = {
        mrng: mrng.clone(),
        biasFactor,
        history: []
    };
    const valueFunction = (arb)=>{
        const preBuiltValue = preBuiltValues[context.history.length];
        if (preBuiltValue !== undefined && preBuiltValue.arb === arb) {
            const value = preBuiltValue.value;
            (0, _globalsJs.safePush)(context.history, {
                arb,
                value,
                context: preBuiltValue.context,
                mrng: preBuiltValue.mrng
            });
            localMrng = preBuiltValue.mrng.clone();
            return value;
        }
        const g = arb.generate(localMrng, biasFactor);
        (0, _globalsJs.safePush)(context.history, {
            arb,
            value: g.value_,
            context: g.context,
            mrng: localMrng.clone()
        });
        return g.value;
    };
    const memoedValueFunction = (arb, ...args)=>{
        return valueFunction(arbitraryCache(arb, args));
    };
    const valueMethods = {
        values () {
            return (0, _globalsJs.safeMap)(context.history, (c)=>c.value);
        },
        [(0, _symbolsJs.cloneMethod)] () {
            return buildGeneratorValue(mrng, biasFactor, computePreBuiltValues, arbitraryCache).value;
        },
        [(0, _stringifyJs.toStringMethod)] () {
            return (0, _stringifyJs.stringify)((0, _globalsJs.safeMap)(context.history, (c)=>c.value));
        }
    };
    const value = safeObjectAssign(memoedValueFunction, valueMethods);
    return new (0, _valueJs.Value)(value, context);
}

},{"../../../check/arbitrary/definition/Value.js":"8Cf1j","../../../check/symbols.js":"2AK80","../../../utils/globals.js":"aTuwn","../../../utils/stringify.js":"gOa8u","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"c5Exp":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "buildStableArbitraryGeneratorCache", ()=>buildStableArbitraryGeneratorCache);
parcelHelpers.export(exports, "naiveIsEqual", ()=>naiveIsEqual);
var _globalsJs = require("../../../utils/globals.js");
const safeArrayIsArray = Array.isArray;
const safeObjectKeys = Object.keys;
const safeObjectIs = Object.is;
function buildStableArbitraryGeneratorCache(isEqual) {
    const previousCallsPerBuilder = new (0, _globalsJs.Map)();
    return function stableArbitraryGeneratorCache(builder, args) {
        const entriesForBuilder = (0, _globalsJs.safeMapGet)(previousCallsPerBuilder, builder);
        if (entriesForBuilder === undefined) {
            const newValue = builder(...args);
            (0, _globalsJs.safeMapSet)(previousCallsPerBuilder, builder, [
                {
                    args,
                    value: newValue
                }
            ]);
            return newValue;
        }
        const safeEntriesForBuilder = entriesForBuilder;
        for (const entry of safeEntriesForBuilder){
            if (isEqual(args, entry.args)) return entry.value;
        }
        const newValue = builder(...args);
        (0, _globalsJs.safePush)(safeEntriesForBuilder, {
            args,
            value: newValue
        });
        return newValue;
    };
}
function naiveIsEqual(v1, v2) {
    if (v1 !== null && typeof v1 === 'object' && v2 !== null && typeof v2 === 'object') {
        if (safeArrayIsArray(v1)) {
            if (!safeArrayIsArray(v2)) return false;
            if (v1.length !== v2.length) return false;
        } else if (safeArrayIsArray(v2)) return false;
        if (safeObjectKeys(v1).length !== safeObjectKeys(v2).length) return false;
        for(const index in v1){
            if (!(index in v2)) return false;
            if (!naiveIsEqual(v1[index], v2[index])) return false;
        }
        return true;
    } else return safeObjectIs(v1, v2);
}

},{"../../../utils/globals.js":"aTuwn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"eZMHg":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "array", ()=>array);
var _arrayArbitraryJs = require("./_internals/ArrayArbitrary.js");
var _maxLengthFromMinLengthJs = require("./_internals/helpers/MaxLengthFromMinLength.js");
function array(arb, constraints = {}) {
    const size = constraints.size;
    const minLength = constraints.minLength || 0;
    const maxLengthOrUnset = constraints.maxLength;
    const depthIdentifier = constraints.depthIdentifier;
    const maxLength = maxLengthOrUnset !== undefined ? maxLengthOrUnset : (0, _maxLengthFromMinLengthJs.MaxLengthUpperBound);
    const specifiedMaxLength = maxLengthOrUnset !== undefined;
    const maxGeneratedLength = (0, _maxLengthFromMinLengthJs.maxGeneratedLengthFromSizeForArbitrary)(size, minLength, maxLength, specifiedMaxLength);
    const customSlices = constraints.experimentalCustomSlices || [];
    return new (0, _arrayArbitraryJs.ArrayArbitrary)(arb, minLength, maxGeneratedLength, maxLength, depthIdentifier, undefined, customSlices);
}

},{"./_internals/ArrayArbitrary.js":"9b3Dl","./_internals/helpers/MaxLengthFromMinLength.js":"5ilwx","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"9b3Dl":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ArrayArbitrary", ()=>ArrayArbitrary);
var _streamJs = require("../../stream/Stream.js");
var _symbolsJs = require("../../check/symbols.js");
var _integerJs = require("../integer.js");
var _lazyIterableIteratorJs = require("../../stream/LazyIterableIterator.js");
var _arbitraryJs = require("../../check/arbitrary/definition/Arbitrary.js");
var _valueJs = require("../../check/arbitrary/definition/Value.js");
var _depthContextJs = require("./helpers/DepthContext.js");
var _buildSlicedGeneratorJs = require("./helpers/BuildSlicedGenerator.js");
var _globalsJs = require("../../utils/globals.js");
const safeMathFloor = Math.floor;
const safeMathLog = Math.log;
const safeMathMax = Math.max;
const safeArrayIsArray = Array.isArray;
function biasedMaxLength(minLength, maxLength) {
    if (minLength === maxLength) return minLength;
    return minLength + safeMathFloor(safeMathLog(maxLength - minLength) / safeMathLog(2));
}
class ArrayArbitrary extends (0, _arbitraryJs.Arbitrary) {
    constructor(arb, minLength, maxGeneratedLength, maxLength, depthIdentifier, setBuilder, customSlices){
        super();
        this.arb = arb;
        this.minLength = minLength;
        this.maxGeneratedLength = maxGeneratedLength;
        this.maxLength = maxLength;
        this.setBuilder = setBuilder;
        this.customSlices = customSlices;
        this.lengthArb = (0, _integerJs.integer)({
            min: minLength,
            max: maxGeneratedLength
        });
        this.depthContext = (0, _depthContextJs.getDepthContextFor)(depthIdentifier);
    }
    preFilter(tab) {
        if (this.setBuilder === undefined) return tab;
        const s = this.setBuilder();
        for(let index = 0; index !== tab.length; ++index)s.tryAdd(tab[index]);
        return s.getData();
    }
    static makeItCloneable(vs, shrinkables) {
        vs[0, _symbolsJs.cloneMethod] = ()=>{
            const cloned = [];
            for(let idx = 0; idx !== shrinkables.length; ++idx)(0, _globalsJs.safePush)(cloned, shrinkables[idx].value);
            this.makeItCloneable(cloned, shrinkables);
            return cloned;
        };
        return vs;
    }
    generateNItemsNoDuplicates(setBuilder, N, mrng, biasFactorItems) {
        let numSkippedInRow = 0;
        const s = setBuilder();
        const slicedGenerator = (0, _buildSlicedGeneratorJs.buildSlicedGenerator)(this.arb, mrng, this.customSlices, biasFactorItems);
        while(s.size() < N && numSkippedInRow < this.maxGeneratedLength){
            const current = slicedGenerator.next();
            if (s.tryAdd(current)) numSkippedInRow = 0;
            else numSkippedInRow += 1;
        }
        return s.getData();
    }
    safeGenerateNItemsNoDuplicates(setBuilder, N, mrng, biasFactorItems) {
        const depthImpact = safeMathMax(0, N - biasedMaxLength(this.minLength, this.maxGeneratedLength));
        this.depthContext.depth += depthImpact;
        try {
            return this.generateNItemsNoDuplicates(setBuilder, N, mrng, biasFactorItems);
        } finally{
            this.depthContext.depth -= depthImpact;
        }
    }
    generateNItems(N, mrng, biasFactorItems) {
        const items = [];
        const slicedGenerator = (0, _buildSlicedGeneratorJs.buildSlicedGenerator)(this.arb, mrng, this.customSlices, biasFactorItems);
        slicedGenerator.attemptExact(N);
        for(let index = 0; index !== N; ++index){
            const current = slicedGenerator.next();
            (0, _globalsJs.safePush)(items, current);
        }
        return items;
    }
    safeGenerateNItems(N, mrng, biasFactorItems) {
        const depthImpact = safeMathMax(0, N - biasedMaxLength(this.minLength, this.maxGeneratedLength));
        this.depthContext.depth += depthImpact;
        try {
            return this.generateNItems(N, mrng, biasFactorItems);
        } finally{
            this.depthContext.depth -= depthImpact;
        }
    }
    wrapper(itemsRaw, shrunkOnce, itemsRawLengthContext, startIndex) {
        const items = shrunkOnce ? this.preFilter(itemsRaw) : itemsRaw;
        let cloneable = false;
        const vs = [];
        const itemsContexts = [];
        for(let idx = 0; idx !== items.length; ++idx){
            const s = items[idx];
            cloneable = cloneable || s.hasToBeCloned;
            (0, _globalsJs.safePush)(vs, s.value);
            (0, _globalsJs.safePush)(itemsContexts, s.context);
        }
        if (cloneable) ArrayArbitrary.makeItCloneable(vs, items);
        const context = {
            shrunkOnce,
            lengthContext: itemsRaw.length === items.length && itemsRawLengthContext !== undefined ? itemsRawLengthContext : undefined,
            itemsContexts,
            startIndex
        };
        return new (0, _valueJs.Value)(vs, context);
    }
    generate(mrng, biasFactor) {
        const biasMeta = this.applyBias(mrng, biasFactor);
        const targetSize = biasMeta.size;
        const items = this.setBuilder !== undefined ? this.safeGenerateNItemsNoDuplicates(this.setBuilder, targetSize, mrng, biasMeta.biasFactorItems) : this.safeGenerateNItems(targetSize, mrng, biasMeta.biasFactorItems);
        return this.wrapper(items, false, undefined, 0);
    }
    applyBias(mrng, biasFactor) {
        if (biasFactor === undefined) return {
            size: this.lengthArb.generate(mrng, undefined).value
        };
        if (this.minLength === this.maxGeneratedLength) return {
            size: this.lengthArb.generate(mrng, undefined).value,
            biasFactorItems: biasFactor
        };
        if (mrng.nextInt(1, biasFactor) !== 1) return {
            size: this.lengthArb.generate(mrng, undefined).value
        };
        if (mrng.nextInt(1, biasFactor) !== 1 || this.minLength === this.maxGeneratedLength) return {
            size: this.lengthArb.generate(mrng, undefined).value,
            biasFactorItems: biasFactor
        };
        const maxBiasedLength = biasedMaxLength(this.minLength, this.maxGeneratedLength);
        const targetSizeValue = (0, _integerJs.integer)({
            min: this.minLength,
            max: maxBiasedLength
        }).generate(mrng, undefined);
        return {
            size: targetSizeValue.value,
            biasFactorItems: biasFactor
        };
    }
    canShrinkWithoutContext(value) {
        if (!safeArrayIsArray(value) || this.minLength > value.length || value.length > this.maxLength) return false;
        for(let index = 0; index !== value.length; ++index){
            if (!(index in value)) return false;
            if (!this.arb.canShrinkWithoutContext(value[index])) return false;
        }
        const filtered = this.preFilter((0, _globalsJs.safeMap)(value, (item)=>new (0, _valueJs.Value)(item, undefined)));
        return filtered.length === value.length;
    }
    shrinkItemByItem(value, safeContext, endIndex) {
        const shrinks = [];
        for(let index = safeContext.startIndex; index < endIndex; ++index)(0, _globalsJs.safePush)(shrinks, (0, _lazyIterableIteratorJs.makeLazy)(()=>this.arb.shrink(value[index], safeContext.itemsContexts[index]).map((v)=>{
                const beforeCurrent = (0, _globalsJs.safeMap)((0, _globalsJs.safeSlice)(value, 0, index), (v, i)=>new (0, _valueJs.Value)((0, _symbolsJs.cloneIfNeeded)(v), safeContext.itemsContexts[i]));
                const afterCurrent = (0, _globalsJs.safeMap)((0, _globalsJs.safeSlice)(value, index + 1), (v, i)=>new (0, _valueJs.Value)((0, _symbolsJs.cloneIfNeeded)(v), safeContext.itemsContexts[i + index + 1]));
                return [
                    [
                        ...beforeCurrent,
                        v,
                        ...afterCurrent
                    ],
                    undefined,
                    index
                ];
            })));
        return (0, _streamJs.Stream).nil().join(...shrinks);
    }
    shrinkImpl(value, context) {
        if (value.length === 0) return (0, _streamJs.Stream).nil();
        const safeContext = context !== undefined ? context : {
            shrunkOnce: false,
            lengthContext: undefined,
            itemsContexts: [],
            startIndex: 0
        };
        return this.lengthArb.shrink(value.length, safeContext.lengthContext).drop(safeContext.shrunkOnce && safeContext.lengthContext === undefined && value.length > this.minLength + 1 ? 1 : 0).map((lengthValue)=>{
            const sliceStart = value.length - lengthValue.value;
            return [
                (0, _globalsJs.safeMap)((0, _globalsJs.safeSlice)(value, sliceStart), (v, index)=>new (0, _valueJs.Value)((0, _symbolsJs.cloneIfNeeded)(v), safeContext.itemsContexts[index + sliceStart])),
                lengthValue.context,
                0
            ];
        }).join((0, _lazyIterableIteratorJs.makeLazy)(()=>value.length > this.minLength ? this.shrinkItemByItem(value, safeContext, 1) : this.shrinkItemByItem(value, safeContext, value.length))).join(value.length > this.minLength ? (0, _lazyIterableIteratorJs.makeLazy)(()=>{
            const subContext = {
                shrunkOnce: false,
                lengthContext: undefined,
                itemsContexts: (0, _globalsJs.safeSlice)(safeContext.itemsContexts, 1),
                startIndex: 0
            };
            return this.shrinkImpl((0, _globalsJs.safeSlice)(value, 1), subContext).filter((v)=>this.minLength <= v[0].length + 1).map((v)=>{
                return [
                    [
                        new (0, _valueJs.Value)((0, _symbolsJs.cloneIfNeeded)(value[0]), safeContext.itemsContexts[0]),
                        ...v[0]
                    ],
                    undefined,
                    0
                ];
            });
        }) : (0, _streamJs.Stream).nil());
    }
    shrink(value, context) {
        return this.shrinkImpl(value, context).map((contextualValue)=>this.wrapper(contextualValue[0], true, contextualValue[1], contextualValue[2]));
    }
}

},{"../../stream/Stream.js":"2sjal","../../check/symbols.js":"2AK80","../integer.js":"embjo","../../stream/LazyIterableIterator.js":"bnj2K","../../check/arbitrary/definition/Arbitrary.js":"e6f1K","../../check/arbitrary/definition/Value.js":"8Cf1j","./helpers/DepthContext.js":"dsS0S","./helpers/BuildSlicedGenerator.js":"5RcAP","../../utils/globals.js":"aTuwn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"embjo":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "integer", ()=>integer);
var _integerArbitraryJs = require("./_internals/IntegerArbitrary.js");
const safeNumberIsInteger = Number.isInteger;
function buildCompleteIntegerConstraints(constraints) {
    const min = constraints.min !== undefined ? constraints.min : -2147483648;
    const max = constraints.max !== undefined ? constraints.max : 0x7fffffff;
    return {
        min,
        max
    };
}
function integer(constraints = {}) {
    const fullConstraints = buildCompleteIntegerConstraints(constraints);
    if (fullConstraints.min > fullConstraints.max) throw new Error('fc.integer maximum value should be equal or greater than the minimum one');
    if (!safeNumberIsInteger(fullConstraints.min)) throw new Error('fc.integer minimum value should be an integer');
    if (!safeNumberIsInteger(fullConstraints.max)) throw new Error('fc.integer maximum value should be an integer');
    return new (0, _integerArbitraryJs.IntegerArbitrary)(fullConstraints.min, fullConstraints.max);
}

},{"./_internals/IntegerArbitrary.js":"5m6ip","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"5m6ip":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "IntegerArbitrary", ()=>IntegerArbitrary);
var _arbitraryJs = require("../../check/arbitrary/definition/Arbitrary.js");
var _valueJs = require("../../check/arbitrary/definition/Value.js");
var _streamJs = require("../../stream/Stream.js");
var _biasNumericRangeJs = require("./helpers/BiasNumericRange.js");
var _shrinkIntegerJs = require("./helpers/ShrinkInteger.js");
const safeMathSign = Math.sign;
const safeNumberIsInteger = Number.isInteger;
const safeObjectIs = Object.is;
class IntegerArbitrary extends (0, _arbitraryJs.Arbitrary) {
    constructor(min, max){
        super();
        this.min = min;
        this.max = max;
    }
    generate(mrng, biasFactor) {
        const range = this.computeGenerateRange(mrng, biasFactor);
        return new (0, _valueJs.Value)(mrng.nextInt(range.min, range.max), undefined);
    }
    canShrinkWithoutContext(value) {
        return typeof value === 'number' && safeNumberIsInteger(value) && !safeObjectIs(value, -0) && this.min <= value && value <= this.max;
    }
    shrink(current, context) {
        if (!IntegerArbitrary.isValidContext(current, context)) {
            const target = this.defaultTarget();
            return (0, _shrinkIntegerJs.shrinkInteger)(current, target, true);
        }
        if (this.isLastChanceTry(current, context)) return (0, _streamJs.Stream).of(new (0, _valueJs.Value)(context, undefined));
        return (0, _shrinkIntegerJs.shrinkInteger)(current, context, false);
    }
    defaultTarget() {
        if (this.min <= 0 && this.max >= 0) return 0;
        return this.min < 0 ? this.max : this.min;
    }
    computeGenerateRange(mrng, biasFactor) {
        if (biasFactor === undefined || mrng.nextInt(1, biasFactor) !== 1) return {
            min: this.min,
            max: this.max
        };
        const ranges = (0, _biasNumericRangeJs.biasNumericRange)(this.min, this.max, (0, _biasNumericRangeJs.integerLogLike));
        if (ranges.length === 1) return ranges[0];
        const id = mrng.nextInt(-2 * (ranges.length - 1), ranges.length - 2);
        return id < 0 ? ranges[0] : ranges[id + 1];
    }
    isLastChanceTry(current, context) {
        if (current > 0) return current === context + 1 && current > this.min;
        if (current < 0) return current === context - 1 && current < this.max;
        return false;
    }
    static isValidContext(current, context) {
        if (context === undefined) return false;
        if (typeof context !== 'number') throw new Error(`Invalid context type passed to IntegerArbitrary (#1)`);
        if (context !== 0 && safeMathSign(current) !== safeMathSign(context)) throw new Error(`Invalid context value passed to IntegerArbitrary (#2)`);
        return true;
    }
}

},{"../../check/arbitrary/definition/Arbitrary.js":"e6f1K","../../check/arbitrary/definition/Value.js":"8Cf1j","../../stream/Stream.js":"2sjal","./helpers/BiasNumericRange.js":"jIggR","./helpers/ShrinkInteger.js":"gHDve","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"jIggR":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "integerLogLike", ()=>integerLogLike);
parcelHelpers.export(exports, "bigIntLogLike", ()=>bigIntLogLike);
parcelHelpers.export(exports, "biasNumericRange", ()=>biasNumericRange);
var _globalsJs = require("../../../utils/globals.js");
const safeMathFloor = Math.floor;
const safeMathLog = Math.log;
function integerLogLike(v) {
    return safeMathFloor(safeMathLog(v) / safeMathLog(2));
}
function bigIntLogLike(v) {
    if (v === (0, _globalsJs.BigInt)(0)) return (0, _globalsJs.BigInt)(0);
    return (0, _globalsJs.BigInt)((0, _globalsJs.String)(v).length);
}
function biasNumericRange(min, max, logLike) {
    if (min === max) return [
        {
            min: min,
            max: max
        }
    ];
    if (min < 0 && max > 0) {
        const logMin = logLike(-min);
        const logMax = logLike(max);
        return [
            {
                min: -logMin,
                max: logMax
            },
            {
                min: max - logMax,
                max: max
            },
            {
                min: min,
                max: min + logMin
            }
        ];
    }
    const logGap = logLike(max - min);
    const arbCloseToMin = {
        min: min,
        max: min + logGap
    };
    const arbCloseToMax = {
        min: max - logGap,
        max: max
    };
    return min < 0 ? [
        arbCloseToMax,
        arbCloseToMin
    ] : [
        arbCloseToMin,
        arbCloseToMax
    ];
}

},{"../../../utils/globals.js":"aTuwn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"gHDve":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "shrinkInteger", ()=>shrinkInteger);
var _valueJs = require("../../../check/arbitrary/definition/Value.js");
var _streamJs = require("../../../stream/Stream.js");
const safeMathCeil = Math.ceil;
const safeMathFloor = Math.floor;
function halvePosInteger(n) {
    return safeMathFloor(n / 2);
}
function halveNegInteger(n) {
    return safeMathCeil(n / 2);
}
function shrinkInteger(current, target, tryTargetAsap) {
    const realGap = current - target;
    function* shrinkDecr() {
        let previous = tryTargetAsap ? undefined : target;
        const gap = tryTargetAsap ? realGap : halvePosInteger(realGap);
        for(let toremove = gap; toremove > 0; toremove = halvePosInteger(toremove)){
            const next = toremove === realGap ? target : current - toremove;
            yield new (0, _valueJs.Value)(next, previous);
            previous = next;
        }
    }
    function* shrinkIncr() {
        let previous = tryTargetAsap ? undefined : target;
        const gap = tryTargetAsap ? realGap : halveNegInteger(realGap);
        for(let toremove = gap; toremove < 0; toremove = halveNegInteger(toremove)){
            const next = toremove === realGap ? target : current - toremove;
            yield new (0, _valueJs.Value)(next, previous);
            previous = next;
        }
    }
    return realGap > 0 ? (0, _streamJs.stream)(shrinkDecr()) : (0, _streamJs.stream)(shrinkIncr());
}

},{"../../../check/arbitrary/definition/Value.js":"8Cf1j","../../../stream/Stream.js":"2sjal","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"dsS0S":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getDepthContextFor", ()=>getDepthContextFor);
parcelHelpers.export(exports, "createDepthIdentifier", ()=>createDepthIdentifier);
var _globalsJs = require("../../../utils/globals.js");
const depthContextCache = new Map();
function getDepthContextFor(contextMeta) {
    if (contextMeta === undefined) return {
        depth: 0
    };
    if (typeof contextMeta !== 'string') return contextMeta;
    const cachedContext = (0, _globalsJs.safeMapGet)(depthContextCache, contextMeta);
    if (cachedContext !== undefined) return cachedContext;
    const context = {
        depth: 0
    };
    (0, _globalsJs.safeMapSet)(depthContextCache, contextMeta, context);
    return context;
}
function createDepthIdentifier() {
    const identifier = {
        depth: 0
    };
    return identifier;
}

},{"../../../utils/globals.js":"aTuwn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"5RcAP":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "buildSlicedGenerator", ()=>buildSlicedGenerator);
var _noopSlicedGeneratorJs = require("../implementations/NoopSlicedGenerator.js");
var _slicedBasedGeneratorJs = require("../implementations/SlicedBasedGenerator.js");
function buildSlicedGenerator(arb, mrng, slices, biasFactor) {
    if (biasFactor === undefined || slices.length === 0 || mrng.nextInt(1, biasFactor) !== 1) return new (0, _noopSlicedGeneratorJs.NoopSlicedGenerator)(arb, mrng, biasFactor);
    return new (0, _slicedBasedGeneratorJs.SlicedBasedGenerator)(arb, mrng, slices, biasFactor);
}

},{"../implementations/NoopSlicedGenerator.js":"qVn3E","../implementations/SlicedBasedGenerator.js":"flYsQ","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"qVn3E":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "NoopSlicedGenerator", ()=>NoopSlicedGenerator);
class NoopSlicedGenerator {
    constructor(arb, mrng, biasFactor){
        this.arb = arb;
        this.mrng = mrng;
        this.biasFactor = biasFactor;
    }
    attemptExact() {
        return;
    }
    next() {
        return this.arb.generate(this.mrng, this.biasFactor);
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"flYsQ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SlicedBasedGenerator", ()=>SlicedBasedGenerator);
var _valueJs = require("../../../check/arbitrary/definition/Value.js");
var _globalsJs = require("../../../utils/globals.js");
const safeMathMin = Math.min;
const safeMathMax = Math.max;
class SlicedBasedGenerator {
    constructor(arb, mrng, slices, biasFactor){
        this.arb = arb;
        this.mrng = mrng;
        this.slices = slices;
        this.biasFactor = biasFactor;
        this.activeSliceIndex = 0;
        this.nextIndexInSlice = 0;
        this.lastIndexInSlice = -1;
    }
    attemptExact(targetLength) {
        if (targetLength !== 0 && this.mrng.nextInt(1, this.biasFactor) === 1) {
            const eligibleIndices = [];
            for(let index = 0; index !== this.slices.length; ++index){
                const slice = this.slices[index];
                if (slice.length === targetLength) (0, _globalsJs.safePush)(eligibleIndices, index);
            }
            if (eligibleIndices.length === 0) return;
            this.activeSliceIndex = eligibleIndices[this.mrng.nextInt(0, eligibleIndices.length - 1)];
            this.nextIndexInSlice = 0;
            this.lastIndexInSlice = targetLength - 1;
        }
    }
    next() {
        if (this.nextIndexInSlice <= this.lastIndexInSlice) return new (0, _valueJs.Value)(this.slices[this.activeSliceIndex][this.nextIndexInSlice++], undefined);
        if (this.mrng.nextInt(1, this.biasFactor) !== 1) return this.arb.generate(this.mrng, this.biasFactor);
        this.activeSliceIndex = this.mrng.nextInt(0, this.slices.length - 1);
        const slice = this.slices[this.activeSliceIndex];
        if (this.mrng.nextInt(1, this.biasFactor) !== 1) {
            this.nextIndexInSlice = 1;
            this.lastIndexInSlice = slice.length - 1;
            return new (0, _valueJs.Value)(slice[0], undefined);
        }
        const rangeBoundaryA = this.mrng.nextInt(0, slice.length - 1);
        const rangeBoundaryB = this.mrng.nextInt(0, slice.length - 1);
        this.nextIndexInSlice = safeMathMin(rangeBoundaryA, rangeBoundaryB);
        this.lastIndexInSlice = safeMathMax(rangeBoundaryA, rangeBoundaryB);
        return new (0, _valueJs.Value)(slice[this.nextIndexInSlice++], undefined);
    }
}

},{"../../../check/arbitrary/definition/Value.js":"8Cf1j","../../../utils/globals.js":"aTuwn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"5ilwx":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MaxLengthUpperBound", ()=>MaxLengthUpperBound);
parcelHelpers.export(exports, "DefaultSize", ()=>DefaultSize);
parcelHelpers.export(exports, "maxLengthFromMinLength", ()=>maxLengthFromMinLength);
parcelHelpers.export(exports, "relativeSizeToSize", ()=>relativeSizeToSize);
parcelHelpers.export(exports, "maxGeneratedLengthFromSizeForArbitrary", ()=>maxGeneratedLengthFromSizeForArbitrary);
parcelHelpers.export(exports, "depthBiasFromSizeForArbitrary", ()=>depthBiasFromSizeForArbitrary);
parcelHelpers.export(exports, "resolveSize", ()=>resolveSize);
var _globalParametersJs = require("../../../check/runner/configuration/GlobalParameters.js");
var _globalsJs = require("../../../utils/globals.js");
const safeMathFloor = Math.floor;
const safeMathMin = Math.min;
const MaxLengthUpperBound = 0x7fffffff;
const orderedSize = [
    'xsmall',
    'small',
    'medium',
    'large',
    'xlarge'
];
const orderedRelativeSize = [
    '-4',
    '-3',
    '-2',
    '-1',
    '=',
    '+1',
    '+2',
    '+3',
    '+4'
];
const DefaultSize = 'small';
function maxLengthFromMinLength(minLength, size) {
    switch(size){
        case 'xsmall':
            return safeMathFloor(1.1 * minLength) + 1;
        case 'small':
            return 2 * minLength + 10;
        case 'medium':
            return 11 * minLength + 100;
        case 'large':
            return 101 * minLength + 1000;
        case 'xlarge':
            return 1001 * minLength + 10000;
        default:
            throw new Error(`Unable to compute lengths based on received size: ${size}`);
    }
}
function relativeSizeToSize(size, defaultSize) {
    const sizeInRelative = (0, _globalsJs.safeIndexOf)(orderedRelativeSize, size);
    if (sizeInRelative === -1) return size;
    const defaultSizeInSize = (0, _globalsJs.safeIndexOf)(orderedSize, defaultSize);
    if (defaultSizeInSize === -1) throw new Error(`Unable to offset size based on the unknown defaulted one: ${defaultSize}`);
    const resultingSizeInSize = defaultSizeInSize + sizeInRelative - 4;
    return resultingSizeInSize < 0 ? orderedSize[0] : resultingSizeInSize >= orderedSize.length ? orderedSize[orderedSize.length - 1] : orderedSize[resultingSizeInSize];
}
function maxGeneratedLengthFromSizeForArbitrary(size, minLength, maxLength, specifiedMaxLength) {
    const { baseSize: defaultSize = DefaultSize, defaultSizeToMaxWhenMaxSpecified } = (0, _globalParametersJs.readConfigureGlobal)() || {};
    const definedSize = size !== undefined ? size : specifiedMaxLength && defaultSizeToMaxWhenMaxSpecified ? 'max' : defaultSize;
    if (definedSize === 'max') return maxLength;
    const finalSize = relativeSizeToSize(definedSize, defaultSize);
    return safeMathMin(maxLengthFromMinLength(minLength, finalSize), maxLength);
}
function depthBiasFromSizeForArbitrary(depthSizeOrSize, specifiedMaxDepth) {
    if (typeof depthSizeOrSize === 'number') return 1 / depthSizeOrSize;
    const { baseSize: defaultSize = DefaultSize, defaultSizeToMaxWhenMaxSpecified } = (0, _globalParametersJs.readConfigureGlobal)() || {};
    const definedSize = depthSizeOrSize !== undefined ? depthSizeOrSize : specifiedMaxDepth && defaultSizeToMaxWhenMaxSpecified ? 'max' : defaultSize;
    if (definedSize === 'max') return 0;
    const finalSize = relativeSizeToSize(definedSize, defaultSize);
    switch(finalSize){
        case 'xsmall':
            return 1;
        case 'small':
            return 0.5;
        case 'medium':
            return 0.25;
        case 'large':
            return 0.125;
        case 'xlarge':
            return 0.0625;
    }
}
function resolveSize(size) {
    const { baseSize: defaultSize = DefaultSize } = (0, _globalParametersJs.readConfigureGlobal)() || {};
    if (size === undefined) return defaultSize;
    return relativeSizeToSize(size, defaultSize);
}

},{"../../../check/runner/configuration/GlobalParameters.js":"f6Bj0","../../../utils/globals.js":"aTuwn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"ffHa9":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "bigInt", ()=>bigInt);
var _globalsJs = require("../utils/globals.js");
var _bigIntArbitraryJs = require("./_internals/BigIntArbitrary.js");
function buildCompleteBigIntConstraints(constraints) {
    const DefaultPow = 256;
    const DefaultMin = (0, _globalsJs.BigInt)(-1) << (0, _globalsJs.BigInt)(DefaultPow - 1);
    const DefaultMax = ((0, _globalsJs.BigInt)(1) << (0, _globalsJs.BigInt)(DefaultPow - 1)) - (0, _globalsJs.BigInt)(1);
    const min = constraints.min;
    const max = constraints.max;
    return {
        min: min !== undefined ? min : DefaultMin - (max !== undefined && max < (0, _globalsJs.BigInt)(0) ? max * max : (0, _globalsJs.BigInt)(0)),
        max: max !== undefined ? max : DefaultMax + (min !== undefined && min > (0, _globalsJs.BigInt)(0) ? min * min : (0, _globalsJs.BigInt)(0))
    };
}
function extractBigIntConstraints(args) {
    if (args[0] === undefined) return {};
    if (args[1] === undefined) {
        const constraints = args[0];
        return constraints;
    }
    return {
        min: args[0],
        max: args[1]
    };
}
function bigInt(...args) {
    const constraints = buildCompleteBigIntConstraints(extractBigIntConstraints(args));
    if (constraints.min > constraints.max) throw new Error('fc.bigInt expects max to be greater than or equal to min');
    return new (0, _bigIntArbitraryJs.BigIntArbitrary)(constraints.min, constraints.max);
}

},{"../utils/globals.js":"aTuwn","./_internals/BigIntArbitrary.js":"MH7ts","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"MH7ts":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BigIntArbitrary", ()=>BigIntArbitrary);
var _streamJs = require("../../stream/Stream.js");
var _arbitraryJs = require("../../check/arbitrary/definition/Arbitrary.js");
var _valueJs = require("../../check/arbitrary/definition/Value.js");
var _biasNumericRangeJs = require("./helpers/BiasNumericRange.js");
var _shrinkBigIntJs = require("./helpers/ShrinkBigInt.js");
var _globalsJs = require("../../utils/globals.js");
class BigIntArbitrary extends (0, _arbitraryJs.Arbitrary) {
    constructor(min, max){
        super();
        this.min = min;
        this.max = max;
    }
    generate(mrng, biasFactor) {
        const range = this.computeGenerateRange(mrng, biasFactor);
        return new (0, _valueJs.Value)(mrng.nextBigInt(range.min, range.max), undefined);
    }
    computeGenerateRange(mrng, biasFactor) {
        if (biasFactor === undefined || mrng.nextInt(1, biasFactor) !== 1) return {
            min: this.min,
            max: this.max
        };
        const ranges = (0, _biasNumericRangeJs.biasNumericRange)(this.min, this.max, (0, _biasNumericRangeJs.bigIntLogLike));
        if (ranges.length === 1) return ranges[0];
        const id = mrng.nextInt(-2 * (ranges.length - 1), ranges.length - 2);
        return id < 0 ? ranges[0] : ranges[id + 1];
    }
    canShrinkWithoutContext(value) {
        return typeof value === 'bigint' && this.min <= value && value <= this.max;
    }
    shrink(current, context) {
        if (!BigIntArbitrary.isValidContext(current, context)) {
            const target = this.defaultTarget();
            return (0, _shrinkBigIntJs.shrinkBigInt)(current, target, true);
        }
        if (this.isLastChanceTry(current, context)) return (0, _streamJs.Stream).of(new (0, _valueJs.Value)(context, undefined));
        return (0, _shrinkBigIntJs.shrinkBigInt)(current, context, false);
    }
    defaultTarget() {
        if (this.min <= 0 && this.max >= 0) return (0, _globalsJs.BigInt)(0);
        return this.min < 0 ? this.max : this.min;
    }
    isLastChanceTry(current, context) {
        if (current > 0) return current === context + (0, _globalsJs.BigInt)(1) && current > this.min;
        if (current < 0) return current === context - (0, _globalsJs.BigInt)(1) && current < this.max;
        return false;
    }
    static isValidContext(current, context) {
        if (context === undefined) return false;
        if (typeof context !== 'bigint') throw new Error(`Invalid context type passed to BigIntArbitrary (#1)`);
        const differentSigns = current > 0 && context < 0 || current < 0 && context > 0;
        if (context !== (0, _globalsJs.BigInt)(0) && differentSigns) throw new Error(`Invalid context value passed to BigIntArbitrary (#2)`);
        return true;
    }
}

},{"../../stream/Stream.js":"2sjal","../../check/arbitrary/definition/Arbitrary.js":"e6f1K","../../check/arbitrary/definition/Value.js":"8Cf1j","./helpers/BiasNumericRange.js":"jIggR","./helpers/ShrinkBigInt.js":"1J5Wq","../../utils/globals.js":"aTuwn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"1J5Wq":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "shrinkBigInt", ()=>shrinkBigInt);
var _streamJs = require("../../../stream/Stream.js");
var _valueJs = require("../../../check/arbitrary/definition/Value.js");
var _globalsJs = require("../../../utils/globals.js");
function halveBigInt(n) {
    return n / (0, _globalsJs.BigInt)(2);
}
function shrinkBigInt(current, target, tryTargetAsap) {
    const realGap = current - target;
    function* shrinkDecr() {
        let previous = tryTargetAsap ? undefined : target;
        const gap = tryTargetAsap ? realGap : halveBigInt(realGap);
        for(let toremove = gap; toremove > 0; toremove = halveBigInt(toremove)){
            const next = current - toremove;
            yield new (0, _valueJs.Value)(next, previous);
            previous = next;
        }
    }
    function* shrinkIncr() {
        let previous = tryTargetAsap ? undefined : target;
        const gap = tryTargetAsap ? realGap : halveBigInt(realGap);
        for(let toremove = gap; toremove < 0; toremove = halveBigInt(toremove)){
            const next = current - toremove;
            yield new (0, _valueJs.Value)(next, previous);
            previous = next;
        }
    }
    return realGap > 0 ? (0, _streamJs.stream)(shrinkDecr()) : (0, _streamJs.stream)(shrinkIncr());
}

},{"../../../stream/Stream.js":"2sjal","../../../check/arbitrary/definition/Value.js":"8Cf1j","../../../utils/globals.js":"aTuwn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"ixzwX":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "bigIntN", ()=>bigIntN);
var _globalsJs = require("../utils/globals.js");
var _bigIntArbitraryJs = require("./_internals/BigIntArbitrary.js");
function bigIntN(n) {
    if (n < 1) throw new Error('fc.bigIntN expects requested number of bits to be superior or equal to 1');
    const min = (0, _globalsJs.BigInt)(-1) << (0, _globalsJs.BigInt)(n - 1);
    const max = ((0, _globalsJs.BigInt)(1) << (0, _globalsJs.BigInt)(n - 1)) - (0, _globalsJs.BigInt)(1);
    return new (0, _bigIntArbitraryJs.BigIntArbitrary)(min, max);
}

},{"../utils/globals.js":"aTuwn","./_internals/BigIntArbitrary.js":"MH7ts","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"gj8Pi":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "bigUint", ()=>bigUint);
var _globalsJs = require("../utils/globals.js");
var _bigIntArbitraryJs = require("./_internals/BigIntArbitrary.js");
function computeDefaultMax() {
    return ((0, _globalsJs.BigInt)(1) << (0, _globalsJs.BigInt)(256)) - (0, _globalsJs.BigInt)(1);
}
function bigUint(constraints) {
    const requestedMax = typeof constraints === 'object' ? constraints.max : constraints;
    const max = requestedMax !== undefined ? requestedMax : computeDefaultMax();
    if (max < 0) throw new Error('fc.bigUint expects max to be greater than or equal to zero');
    return new (0, _bigIntArbitraryJs.BigIntArbitrary)((0, _globalsJs.BigInt)(0), max);
}

},{"../utils/globals.js":"aTuwn","./_internals/BigIntArbitrary.js":"MH7ts","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"7ttyT":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "bigUintN", ()=>bigUintN);
var _globalsJs = require("../utils/globals.js");
var _bigIntArbitraryJs = require("./_internals/BigIntArbitrary.js");
function bigUintN(n) {
    if (n < 0) throw new Error('fc.bigUintN expects requested number of bits to be superior or equal to 0');
    const min = (0, _globalsJs.BigInt)(0);
    const max = ((0, _globalsJs.BigInt)(1) << (0, _globalsJs.BigInt)(n)) - (0, _globalsJs.BigInt)(1);
    return new (0, _bigIntArbitraryJs.BigIntArbitrary)(min, max);
}

},{"../utils/globals.js":"aTuwn","./_internals/BigIntArbitrary.js":"MH7ts","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"bazde":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "boolean", ()=>boolean);
var _integerJs = require("./integer.js");
var _noBiasJs = require("./noBias.js");
function booleanMapper(v) {
    return v === 1;
}
function booleanUnmapper(v) {
    if (typeof v !== 'boolean') throw new Error('Unsupported input type');
    return v === true ? 1 : 0;
}
function boolean() {
    return (0, _noBiasJs.noBias)((0, _integerJs.integer)({
        min: 0,
        max: 1
    }).map(booleanMapper, booleanUnmapper));
}

},{"./integer.js":"embjo","./noBias.js":"likNP","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"likNP":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "noBias", ()=>noBias);
function noBias(arb) {
    return arb.noBias();
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"j13qK":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "falsy", ()=>falsy);
var _globalsJs = require("../utils/globals.js");
var _constantFromJs = require("./constantFrom.js");
function falsy(constraints) {
    if (!constraints || !constraints.withBigInt) return (0, _constantFromJs.constantFrom)(false, null, undefined, 0, '', NaN);
    return (0, _constantFromJs.constantFrom)(false, null, undefined, 0, '', NaN, (0, _globalsJs.BigInt)(0));
}

},{"../utils/globals.js":"aTuwn","./constantFrom.js":"bZWfh","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"bZWfh":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "constantFrom", ()=>constantFrom);
var _constantArbitraryJs = require("./_internals/ConstantArbitrary.js");
function constantFrom(...values) {
    if (values.length === 0) throw new Error('fc.constantFrom expects at least one parameter');
    return new (0, _constantArbitraryJs.ConstantArbitrary)(values);
}

},{"./_internals/ConstantArbitrary.js":"6ApQt","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"6ApQt":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ConstantArbitrary", ()=>ConstantArbitrary);
var _streamJs = require("../../stream/Stream.js");
var _arbitraryJs = require("../../check/arbitrary/definition/Arbitrary.js");
var _valueJs = require("../../check/arbitrary/definition/Value.js");
var _symbolsJs = require("../../check/symbols.js");
var _globalsJs = require("../../utils/globals.js");
const safeObjectIs = Object.is;
class ConstantArbitrary extends (0, _arbitraryJs.Arbitrary) {
    constructor(values){
        super();
        this.values = values;
    }
    generate(mrng, _biasFactor) {
        const idx = this.values.length === 1 ? 0 : mrng.nextInt(0, this.values.length - 1);
        const value = this.values[idx];
        if (!(0, _symbolsJs.hasCloneMethod)(value)) return new (0, _valueJs.Value)(value, idx);
        return new (0, _valueJs.Value)(value, idx, ()=>value[0, _symbolsJs.cloneMethod]());
    }
    canShrinkWithoutContext(value) {
        if (this.values.length === 1) return safeObjectIs(this.values[0], value);
        if (this.fastValues === undefined) this.fastValues = new FastConstantValuesLookup(this.values);
        return this.fastValues.has(value);
    }
    shrink(value, context) {
        if (context === 0 || safeObjectIs(value, this.values[0])) return (0, _streamJs.Stream).nil();
        return (0, _streamJs.Stream).of(new (0, _valueJs.Value)(this.values[0], 0));
    }
}
class FastConstantValuesLookup {
    constructor(values){
        this.values = values;
        this.fastValues = new (0, _globalsJs.Set)(this.values);
        let hasMinusZero = false;
        let hasPlusZero = false;
        if ((0, _globalsJs.safeHas)(this.fastValues, 0)) for(let idx = 0; idx !== this.values.length; ++idx){
            const value = this.values[idx];
            hasMinusZero = hasMinusZero || safeObjectIs(value, -0);
            hasPlusZero = hasPlusZero || safeObjectIs(value, 0);
        }
        this.hasMinusZero = hasMinusZero;
        this.hasPlusZero = hasPlusZero;
    }
    has(value) {
        if (value === 0) {
            if (safeObjectIs(value, 0)) return this.hasPlusZero;
            return this.hasMinusZero;
        }
        return (0, _globalsJs.safeHas)(this.fastValues, value);
    }
}

},{"../../stream/Stream.js":"2sjal","../../check/arbitrary/definition/Arbitrary.js":"e6f1K","../../check/arbitrary/definition/Value.js":"8Cf1j","../../check/symbols.js":"2AK80","../../utils/globals.js":"aTuwn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"bbQ9F":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ascii", ()=>ascii);
var _characterArbitraryBuilderJs = require("./_internals/builders/CharacterArbitraryBuilder.js");
var _indexToPrintableIndexJs = require("./_internals/mappers/IndexToPrintableIndex.js");
function ascii() {
    return (0, _characterArbitraryBuilderJs.buildCharacterArbitrary)(0x00, 0x7f, (0, _indexToPrintableIndexJs.indexToPrintableIndexMapper), (0, _indexToPrintableIndexJs.indexToPrintableIndexUnmapper));
}

},{"./_internals/builders/CharacterArbitraryBuilder.js":"b2zBb","./_internals/mappers/IndexToPrintableIndex.js":"1nmW0","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"b2zBb":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "buildCharacterArbitrary", ()=>buildCharacterArbitrary);
var _integerJs = require("../../integer.js");
var _indexToCharStringJs = require("../mappers/IndexToCharString.js");
function buildCharacterArbitrary(min, max, mapToCode, unmapFromCode) {
    return (0, _integerJs.integer)({
        min,
        max
    }).map((n)=>(0, _indexToCharStringJs.indexToCharStringMapper)(mapToCode(n)), (c)=>unmapFromCode((0, _indexToCharStringJs.indexToCharStringUnmapper)(c)));
}

},{"../../integer.js":"embjo","../mappers/IndexToCharString.js":"2lytw","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"2lytw":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "indexToCharStringMapper", ()=>indexToCharStringMapper);
parcelHelpers.export(exports, "indexToCharStringUnmapper", ()=>indexToCharStringUnmapper);
var _globalsJs = require("../../../utils/globals.js");
const indexToCharStringMapper = String.fromCodePoint;
function indexToCharStringUnmapper(c) {
    if (typeof c !== 'string') throw new Error('Cannot unmap non-string');
    if (c.length === 0 || c.length > 2) throw new Error('Cannot unmap string with more or less than one character');
    const c1 = (0, _globalsJs.safeCharCodeAt)(c, 0);
    if (c.length === 1) return c1;
    const c2 = (0, _globalsJs.safeCharCodeAt)(c, 1);
    if (c1 < 0xd800 || c1 > 0xdbff || c2 < 0xdc00 || c2 > 0xdfff) throw new Error('Cannot unmap invalid surrogate pairs');
    return c.codePointAt(0);
}

},{"../../../utils/globals.js":"aTuwn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"1nmW0":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "indexToPrintableIndexMapper", ()=>indexToPrintableIndexMapper);
parcelHelpers.export(exports, "indexToPrintableIndexUnmapper", ()=>indexToPrintableIndexUnmapper);
function indexToPrintableIndexMapper(v) {
    if (v < 95) return v + 0x20;
    if (v <= 0x7e) return v - 95;
    return v;
}
function indexToPrintableIndexUnmapper(v) {
    if (v >= 0x20 && v <= 0x7e) return v - 0x20;
    if (v >= 0 && v <= 0x1f) return v + 95;
    return v;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"jfhtz":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "base64", ()=>base64);
var _characterArbitraryBuilderJs = require("./_internals/builders/CharacterArbitraryBuilder.js");
function base64Mapper(v) {
    if (v < 26) return v + 65;
    if (v < 52) return v + 97 - 26;
    if (v < 62) return v + 48 - 52;
    return v === 62 ? 43 : 47;
}
function base64Unmapper(v) {
    if (v >= 65 && v <= 90) return v - 65;
    if (v >= 97 && v <= 122) return v - 97 + 26;
    if (v >= 48 && v <= 57) return v - 48 + 52;
    return v === 43 ? 62 : v === 47 ? 63 : -1;
}
function base64() {
    return (0, _characterArbitraryBuilderJs.buildCharacterArbitrary)(0, 63, base64Mapper, base64Unmapper);
}

},{"./_internals/builders/CharacterArbitraryBuilder.js":"b2zBb","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"NNpK4":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "char", ()=>char);
var _characterArbitraryBuilderJs = require("./_internals/builders/CharacterArbitraryBuilder.js");
function identity(v) {
    return v;
}
function char() {
    return (0, _characterArbitraryBuilderJs.buildCharacterArbitrary)(0x20, 0x7e, identity, identity);
}

},{"./_internals/builders/CharacterArbitraryBuilder.js":"b2zBb","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"8ydXM":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "char16bits", ()=>char16bits);
var _characterArbitraryBuilderJs = require("./_internals/builders/CharacterArbitraryBuilder.js");
var _indexToPrintableIndexJs = require("./_internals/mappers/IndexToPrintableIndex.js");
function char16bits() {
    return (0, _characterArbitraryBuilderJs.buildCharacterArbitrary)(0x0000, 0xffff, (0, _indexToPrintableIndexJs.indexToPrintableIndexMapper), (0, _indexToPrintableIndexJs.indexToPrintableIndexUnmapper));
}

},{"./_internals/builders/CharacterArbitraryBuilder.js":"b2zBb","./_internals/mappers/IndexToPrintableIndex.js":"1nmW0","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"1lTh1":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fullUnicode", ()=>fullUnicode);
var _characterArbitraryBuilderJs = require("./_internals/builders/CharacterArbitraryBuilder.js");
var _indexToPrintableIndexJs = require("./_internals/mappers/IndexToPrintableIndex.js");
const gapSize = 2048;
function unicodeMapper(v) {
    if (v < 0xd800) return (0, _indexToPrintableIndexJs.indexToPrintableIndexMapper)(v);
    return v + gapSize;
}
function unicodeUnmapper(v) {
    if (v < 0xd800) return (0, _indexToPrintableIndexJs.indexToPrintableIndexUnmapper)(v);
    if (v <= 0xdfff) return -1;
    return v - gapSize;
}
function fullUnicode() {
    return (0, _characterArbitraryBuilderJs.buildCharacterArbitrary)(0x0000, 0x10ffff - gapSize, unicodeMapper, unicodeUnmapper);
}

},{"./_internals/builders/CharacterArbitraryBuilder.js":"b2zBb","./_internals/mappers/IndexToPrintableIndex.js":"1nmW0","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"1PNQs":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "hexa", ()=>hexa);
var _characterArbitraryBuilderJs = require("./_internals/builders/CharacterArbitraryBuilder.js");
function hexaMapper(v) {
    return v < 10 ? v + 48 : v + 97 - 10;
}
function hexaUnmapper(v) {
    return v < 58 ? v - 48 : v >= 97 && v < 103 ? v - 97 + 10 : -1;
}
function hexa() {
    return (0, _characterArbitraryBuilderJs.buildCharacterArbitrary)(0, 15, hexaMapper, hexaUnmapper);
}

},{"./_internals/builders/CharacterArbitraryBuilder.js":"b2zBb","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"2sTN2":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "unicode", ()=>unicode);
var _characterArbitraryBuilderJs = require("./_internals/builders/CharacterArbitraryBuilder.js");
var _indexToPrintableIndexJs = require("./_internals/mappers/IndexToPrintableIndex.js");
const gapSize = 2048;
function unicodeMapper(v) {
    if (v < 0xd800) return (0, _indexToPrintableIndexJs.indexToPrintableIndexMapper)(v);
    return v + gapSize;
}
function unicodeUnmapper(v) {
    if (v < 0xd800) return (0, _indexToPrintableIndexJs.indexToPrintableIndexUnmapper)(v);
    if (v <= 0xdfff) return -1;
    return v - gapSize;
}
function unicode() {
    return (0, _characterArbitraryBuilderJs.buildCharacterArbitrary)(0x0000, 0xffff - gapSize, unicodeMapper, unicodeUnmapper);
}

},{"./_internals/builders/CharacterArbitraryBuilder.js":"b2zBb","./_internals/mappers/IndexToPrintableIndex.js":"1nmW0","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"6Ey5n":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "constant", ()=>constant);
var _constantArbitraryJs = require("./_internals/ConstantArbitrary.js");
function constant(value) {
    return new (0, _constantArbitraryJs.ConstantArbitrary)([
        value
    ]);
}

},{"./_internals/ConstantArbitrary.js":"6ApQt","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"aJsw3":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "context", ()=>context);
var _symbolsJs = require("../check/symbols.js");
var _constantJs = require("./constant.js");
class ContextImplem {
    constructor(){
        this.receivedLogs = [];
    }
    log(data) {
        this.receivedLogs.push(data);
    }
    size() {
        return this.receivedLogs.length;
    }
    toString() {
        return JSON.stringify({
            logs: this.receivedLogs
        });
    }
    [(0, _symbolsJs.cloneMethod)]() {
        return new ContextImplem();
    }
}
function context() {
    return (0, _constantJs.constant)(new ContextImplem());
}

},{"../check/symbols.js":"2AK80","./constant.js":"6Ey5n","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"dhAUk":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "date", ()=>date);
var _globalsJs = require("../utils/globals.js");
var _integerJs = require("./integer.js");
var _timeToDateJs = require("./_internals/mappers/TimeToDate.js");
const safeNumberIsNaN = Number.isNaN;
function date(constraints = {}) {
    const intMin = constraints.min !== undefined ? (0, _globalsJs.safeGetTime)(constraints.min) : -8640000000000000;
    const intMax = constraints.max !== undefined ? (0, _globalsJs.safeGetTime)(constraints.max) : 8640000000000000;
    const noInvalidDate = constraints.noInvalidDate === undefined || constraints.noInvalidDate;
    if (safeNumberIsNaN(intMin)) throw new Error('fc.date min must be valid instance of Date');
    if (safeNumberIsNaN(intMax)) throw new Error('fc.date max must be valid instance of Date');
    if (intMin > intMax) throw new Error('fc.date max must be greater or equal to min');
    if (noInvalidDate) return (0, _integerJs.integer)({
        min: intMin,
        max: intMax
    }).map((0, _timeToDateJs.timeToDateMapper), (0, _timeToDateJs.timeToDateUnmapper));
    const valueForNaN = intMax + 1;
    return (0, _integerJs.integer)({
        min: intMin,
        max: intMax + 1
    }).map((0, _timeToDateJs.timeToDateMapperWithNaN)(valueForNaN), (0, _timeToDateJs.timeToDateUnmapperWithNaN)(valueForNaN));
}

},{"../utils/globals.js":"aTuwn","./integer.js":"embjo","./_internals/mappers/TimeToDate.js":"ag5b0","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"ag5b0":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "timeToDateMapper", ()=>timeToDateMapper);
parcelHelpers.export(exports, "timeToDateUnmapper", ()=>timeToDateUnmapper);
parcelHelpers.export(exports, "timeToDateMapperWithNaN", ()=>timeToDateMapperWithNaN);
parcelHelpers.export(exports, "timeToDateUnmapperWithNaN", ()=>timeToDateUnmapperWithNaN);
var _globalsJs = require("../../../utils/globals.js");
const safeNaN = Number.NaN;
const safeNumberIsNaN = Number.isNaN;
function timeToDateMapper(time) {
    return new (0, _globalsJs.Date)(time);
}
function timeToDateUnmapper(value) {
    if (!(value instanceof (0, _globalsJs.Date)) || value.constructor !== (0, _globalsJs.Date)) throw new (0, _globalsJs.Error)('Not a valid value for date unmapper');
    return (0, _globalsJs.safeGetTime)(value);
}
function timeToDateMapperWithNaN(valueForNaN) {
    return (time)=>{
        return time === valueForNaN ? new (0, _globalsJs.Date)(safeNaN) : timeToDateMapper(time);
    };
}
function timeToDateUnmapperWithNaN(valueForNaN) {
    return (value)=>{
        const time = timeToDateUnmapper(value);
        return safeNumberIsNaN(time) ? valueForNaN : time;
    };
}

},{"../../../utils/globals.js":"aTuwn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"gPSBk":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "clone", ()=>clone);
var _cloneArbitraryJs = require("./_internals/CloneArbitrary.js");
function clone(arb, numValues) {
    return new (0, _cloneArbitraryJs.CloneArbitrary)(arb, numValues);
}

},{"./_internals/CloneArbitrary.js":"iIKkx","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"iIKkx":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CloneArbitrary", ()=>CloneArbitrary);
var _arbitraryJs = require("../../check/arbitrary/definition/Arbitrary.js");
var _valueJs = require("../../check/arbitrary/definition/Value.js");
var _symbolsJs = require("../../check/symbols.js");
var _streamJs = require("../../stream/Stream.js");
var _globalsJs = require("../../utils/globals.js");
const safeSymbolIterator = Symbol.iterator;
const safeIsArray = Array.isArray;
const safeObjectIs = Object.is;
class CloneArbitrary extends (0, _arbitraryJs.Arbitrary) {
    constructor(arb, numValues){
        super();
        this.arb = arb;
        this.numValues = numValues;
    }
    generate(mrng, biasFactor) {
        const items = [];
        if (this.numValues <= 0) return this.wrapper(items);
        for(let idx = 0; idx !== this.numValues - 1; ++idx)(0, _globalsJs.safePush)(items, this.arb.generate(mrng.clone(), biasFactor));
        (0, _globalsJs.safePush)(items, this.arb.generate(mrng, biasFactor));
        return this.wrapper(items);
    }
    canShrinkWithoutContext(value) {
        if (!safeIsArray(value) || value.length !== this.numValues) return false;
        if (value.length === 0) return true;
        for(let index = 1; index < value.length; ++index){
            if (!safeObjectIs(value[0], value[index])) return false;
        }
        return this.arb.canShrinkWithoutContext(value[0]);
    }
    shrink(value, context) {
        if (value.length === 0) return (0, _streamJs.Stream).nil();
        return new (0, _streamJs.Stream)(this.shrinkImpl(value, context !== undefined ? context : [])).map((v)=>this.wrapper(v));
    }
    *shrinkImpl(value, contexts) {
        const its = (0, _globalsJs.safeMap)(value, (v, idx)=>this.arb.shrink(v, contexts[idx])[safeSymbolIterator]());
        let cur = (0, _globalsJs.safeMap)(its, (it)=>it.next());
        while(!cur[0].done){
            yield (0, _globalsJs.safeMap)(cur, (c)=>c.value);
            cur = (0, _globalsJs.safeMap)(its, (it)=>it.next());
        }
    }
    static makeItCloneable(vs, shrinkables) {
        vs[0, _symbolsJs.cloneMethod] = ()=>{
            const cloned = [];
            for(let idx = 0; idx !== shrinkables.length; ++idx)(0, _globalsJs.safePush)(cloned, shrinkables[idx].value);
            this.makeItCloneable(cloned, shrinkables);
            return cloned;
        };
        return vs;
    }
    wrapper(items) {
        let cloneable = false;
        const vs = [];
        const contexts = [];
        for(let idx = 0; idx !== items.length; ++idx){
            const s = items[idx];
            cloneable = cloneable || s.hasToBeCloned;
            (0, _globalsJs.safePush)(vs, s.value);
            (0, _globalsJs.safePush)(contexts, s.context);
        }
        if (cloneable) CloneArbitrary.makeItCloneable(vs, items);
        return new (0, _valueJs.Value)(vs, contexts);
    }
}

},{"../../check/arbitrary/definition/Arbitrary.js":"e6f1K","../../check/arbitrary/definition/Value.js":"8Cf1j","../../check/symbols.js":"2AK80","../../stream/Stream.js":"2sjal","../../utils/globals.js":"aTuwn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"k8d7Y":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "dictionary", ()=>dictionary);
var _tupleJs = require("./tuple.js");
var _uniqueArrayJs = require("./uniqueArray.js");
var _keyValuePairsToObjectJs = require("./_internals/mappers/KeyValuePairsToObject.js");
var _constantJs = require("./constant.js");
var _booleanJs = require("./boolean.js");
function dictionaryKeyExtractor(entry) {
    return entry[0];
}
function dictionary(keyArb, valueArb, constraints = {}) {
    const noNullPrototype = constraints.noNullPrototype !== false;
    return (0, _tupleJs.tuple)((0, _uniqueArrayJs.uniqueArray)((0, _tupleJs.tuple)(keyArb, valueArb), {
        minLength: constraints.minKeys,
        maxLength: constraints.maxKeys,
        size: constraints.size,
        selector: dictionaryKeyExtractor,
        depthIdentifier: constraints.depthIdentifier
    }), noNullPrototype ? (0, _constantJs.constant)(false) : (0, _booleanJs.boolean)()).map((0, _keyValuePairsToObjectJs.keyValuePairsToObjectMapper), (0, _keyValuePairsToObjectJs.keyValuePairsToObjectUnmapper));
}

},{"./tuple.js":"dw0Pn","./uniqueArray.js":"8dSfb","./_internals/mappers/KeyValuePairsToObject.js":"5VrBK","./constant.js":"6Ey5n","./boolean.js":"bazde","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"8dSfb":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "uniqueArray", ()=>uniqueArray);
var _arrayArbitraryJs = require("./_internals/ArrayArbitrary.js");
var _maxLengthFromMinLengthJs = require("./_internals/helpers/MaxLengthFromMinLength.js");
var _customEqualSetJs = require("./_internals/helpers/CustomEqualSet.js");
var _strictlyEqualSetJs = require("./_internals/helpers/StrictlyEqualSet.js");
var _sameValueSetJs = require("./_internals/helpers/SameValueSet.js");
var _sameValueZeroSetJs = require("./_internals/helpers/SameValueZeroSet.js");
function buildUniqueArraySetBuilder(constraints) {
    if (typeof constraints.comparator === 'function') {
        if (constraints.selector === undefined) {
            const comparator = constraints.comparator;
            const isEqualForBuilder = (nextA, nextB)=>comparator(nextA.value_, nextB.value_);
            return ()=>new (0, _customEqualSetJs.CustomEqualSet)(isEqualForBuilder);
        }
        const comparator = constraints.comparator;
        const selector = constraints.selector;
        const refinedSelector = (next)=>selector(next.value_);
        const isEqualForBuilder = (nextA, nextB)=>comparator(refinedSelector(nextA), refinedSelector(nextB));
        return ()=>new (0, _customEqualSetJs.CustomEqualSet)(isEqualForBuilder);
    }
    const selector = constraints.selector || ((v)=>v);
    const refinedSelector = (next)=>selector(next.value_);
    switch(constraints.comparator){
        case 'IsStrictlyEqual':
            return ()=>new (0, _strictlyEqualSetJs.StrictlyEqualSet)(refinedSelector);
        case 'SameValueZero':
            return ()=>new (0, _sameValueZeroSetJs.SameValueZeroSet)(refinedSelector);
        case 'SameValue':
        case undefined:
            return ()=>new (0, _sameValueSetJs.SameValueSet)(refinedSelector);
    }
}
function uniqueArray(arb, constraints = {}) {
    const minLength = constraints.minLength !== undefined ? constraints.minLength : 0;
    const maxLength = constraints.maxLength !== undefined ? constraints.maxLength : (0, _maxLengthFromMinLengthJs.MaxLengthUpperBound);
    const maxGeneratedLength = (0, _maxLengthFromMinLengthJs.maxGeneratedLengthFromSizeForArbitrary)(constraints.size, minLength, maxLength, constraints.maxLength !== undefined);
    const depthIdentifier = constraints.depthIdentifier;
    const setBuilder = buildUniqueArraySetBuilder(constraints);
    const arrayArb = new (0, _arrayArbitraryJs.ArrayArbitrary)(arb, minLength, maxGeneratedLength, maxLength, depthIdentifier, setBuilder, []);
    if (minLength === 0) return arrayArb;
    return arrayArb.filter((tab)=>tab.length >= minLength);
}

},{"./_internals/ArrayArbitrary.js":"9b3Dl","./_internals/helpers/MaxLengthFromMinLength.js":"5ilwx","./_internals/helpers/CustomEqualSet.js":"5OkTh","./_internals/helpers/StrictlyEqualSet.js":"uTFvm","./_internals/helpers/SameValueSet.js":"fEUIs","./_internals/helpers/SameValueZeroSet.js":"j2GH2","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"5OkTh":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CustomEqualSet", ()=>CustomEqualSet);
var _globalsJs = require("../../../utils/globals.js");
class CustomEqualSet {
    constructor(isEqual){
        this.isEqual = isEqual;
        this.data = [];
    }
    tryAdd(value) {
        for(let idx = 0; idx !== this.data.length; ++idx){
            if (this.isEqual(this.data[idx], value)) return false;
        }
        (0, _globalsJs.safePush)(this.data, value);
        return true;
    }
    size() {
        return this.data.length;
    }
    getData() {
        return this.data;
    }
}

},{"../../../utils/globals.js":"aTuwn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"uTFvm":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "StrictlyEqualSet", ()=>StrictlyEqualSet);
var _globalsJs = require("../../../utils/globals.js");
const safeNumberIsNaN = Number.isNaN;
class StrictlyEqualSet {
    constructor(selector){
        this.selector = selector;
        this.selectedItemsExceptNaN = new (0, _globalsJs.Set)();
        this.data = [];
    }
    tryAdd(value) {
        const selected = this.selector(value);
        if (safeNumberIsNaN(selected)) {
            (0, _globalsJs.safePush)(this.data, value);
            return true;
        }
        const sizeBefore = this.selectedItemsExceptNaN.size;
        (0, _globalsJs.safeAdd)(this.selectedItemsExceptNaN, selected);
        if (sizeBefore !== this.selectedItemsExceptNaN.size) {
            (0, _globalsJs.safePush)(this.data, value);
            return true;
        }
        return false;
    }
    size() {
        return this.data.length;
    }
    getData() {
        return this.data;
    }
}

},{"../../../utils/globals.js":"aTuwn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"fEUIs":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SameValueSet", ()=>SameValueSet);
var _globalsJs = require("../../../utils/globals.js");
const safeObjectIs = Object.is;
class SameValueSet {
    constructor(selector){
        this.selector = selector;
        this.selectedItemsExceptMinusZero = new (0, _globalsJs.Set)();
        this.data = [];
        this.hasMinusZero = false;
    }
    tryAdd(value) {
        const selected = this.selector(value);
        if (safeObjectIs(selected, -0)) {
            if (this.hasMinusZero) return false;
            (0, _globalsJs.safePush)(this.data, value);
            this.hasMinusZero = true;
            return true;
        }
        const sizeBefore = this.selectedItemsExceptMinusZero.size;
        (0, _globalsJs.safeAdd)(this.selectedItemsExceptMinusZero, selected);
        if (sizeBefore !== this.selectedItemsExceptMinusZero.size) {
            (0, _globalsJs.safePush)(this.data, value);
            return true;
        }
        return false;
    }
    size() {
        return this.data.length;
    }
    getData() {
        return this.data;
    }
}

},{"../../../utils/globals.js":"aTuwn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"j2GH2":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SameValueZeroSet", ()=>SameValueZeroSet);
var _globalsJs = require("../../../utils/globals.js");
class SameValueZeroSet {
    constructor(selector){
        this.selector = selector;
        this.selectedItems = new (0, _globalsJs.Set)();
        this.data = [];
    }
    tryAdd(value) {
        const selected = this.selector(value);
        const sizeBefore = this.selectedItems.size;
        (0, _globalsJs.safeAdd)(this.selectedItems, selected);
        if (sizeBefore !== this.selectedItems.size) {
            (0, _globalsJs.safePush)(this.data, value);
            return true;
        }
        return false;
    }
    size() {
        return this.data.length;
    }
    getData() {
        return this.data;
    }
}

},{"../../../utils/globals.js":"aTuwn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"5VrBK":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "keyValuePairsToObjectMapper", ()=>keyValuePairsToObjectMapper);
parcelHelpers.export(exports, "keyValuePairsToObjectUnmapper", ()=>keyValuePairsToObjectUnmapper);
var _globalsJs = require("../../../utils/globals.js");
const safeObjectCreate = Object.create;
const safeObjectDefineProperty = Object.defineProperty;
const safeObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
const safeObjectGetPrototypeOf = Object.getPrototypeOf;
const safeObjectGetOwnPropertySymbols = Object.getOwnPropertySymbols;
const safeObjectGetOwnPropertyNames = Object.getOwnPropertyNames;
const safeObjectEntries = Object.entries;
function keyValuePairsToObjectMapper(definition) {
    const obj = definition[1] ? safeObjectCreate(null) : {};
    for (const keyValue of definition[0])safeObjectDefineProperty(obj, keyValue[0], {
        enumerable: true,
        configurable: true,
        writable: true,
        value: keyValue[1]
    });
    return obj;
}
function buildIsValidPropertyNameFilter(obj) {
    return function isValidPropertyNameFilter(key) {
        const descriptor = safeObjectGetOwnPropertyDescriptor(obj, key);
        return descriptor !== undefined && !!descriptor.configurable && !!descriptor.enumerable && !!descriptor.writable && descriptor.get === undefined && descriptor.set === undefined;
    };
}
function keyValuePairsToObjectUnmapper(value) {
    if (typeof value !== 'object' || value === null) throw new (0, _globalsJs.Error)('Incompatible instance received: should be a non-null object');
    const hasNullPrototype = safeObjectGetPrototypeOf(value) === null;
    const hasObjectPrototype = 'constructor' in value && value.constructor === Object;
    if (!hasNullPrototype && !hasObjectPrototype) throw new (0, _globalsJs.Error)('Incompatible instance received: should be of exact type Object');
    if (safeObjectGetOwnPropertySymbols(value).length > 0) throw new (0, _globalsJs.Error)('Incompatible instance received: should contain symbols');
    if (!(0, _globalsJs.safeEvery)(safeObjectGetOwnPropertyNames(value), buildIsValidPropertyNameFilter(value))) throw new (0, _globalsJs.Error)('Incompatible instance received: should contain only c/e/w properties without get/set');
    return [
        safeObjectEntries(value),
        hasNullPrototype
    ];
}

},{"../../../utils/globals.js":"aTuwn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"92bJU":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "emailAddress", ()=>emailAddress);
var _arrayJs = require("./array.js");
var _characterRangeArbitraryBuilderJs = require("./_internals/builders/CharacterRangeArbitraryBuilder.js");
var _domainJs = require("./domain.js");
var _stringJs = require("./string.js");
var _tupleJs = require("./tuple.js");
var _adapterArbitraryJs = require("./_internals/AdapterArbitrary.js");
var _globalsJs = require("../utils/globals.js");
function dotAdapter(a) {
    let currentLength = a[0].length;
    for(let index = 1; index !== a.length; ++index){
        currentLength += 1 + a[index].length;
        if (currentLength > 64) return {
            adapted: true,
            value: (0, _globalsJs.safeSlice)(a, 0, index)
        };
    }
    return {
        adapted: false,
        value: a
    };
}
function dotMapper(a) {
    return (0, _globalsJs.safeJoin)(a, '.');
}
function dotUnmapper(value) {
    if (typeof value !== 'string') throw new Error('Unsupported');
    return (0, _globalsJs.safeSplit)(value, '.');
}
function atMapper(data) {
    return `${data[0]}@${data[1]}`;
}
function atUnmapper(value) {
    if (typeof value !== 'string') throw new Error('Unsupported');
    return (0, _globalsJs.safeSplit)(value, '@', 2);
}
function emailAddress(constraints = {}) {
    const atextArb = (0, _characterRangeArbitraryBuilderJs.getOrCreateLowerAlphaNumericArbitrary)("!#$%&'*+-/=?^_`{|}~");
    const localPartArb = (0, _adapterArbitraryJs.adapter)((0, _arrayJs.array)((0, _stringJs.string)({
        unit: atextArb,
        minLength: 1,
        maxLength: 64,
        size: constraints.size
    }), {
        minLength: 1,
        maxLength: 32,
        size: constraints.size
    }), dotAdapter).map(dotMapper, dotUnmapper);
    return (0, _tupleJs.tuple)(localPartArb, (0, _domainJs.domain)({
        size: constraints.size
    })).map(atMapper, atUnmapper);
}

},{"./array.js":"eZMHg","./_internals/builders/CharacterRangeArbitraryBuilder.js":"gF9Ci","./domain.js":"irrWS","./string.js":"iHGKT","./tuple.js":"dw0Pn","./_internals/AdapterArbitrary.js":"95a4k","../utils/globals.js":"aTuwn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"gF9Ci":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getOrCreateLowerAlphaArbitrary", ()=>getOrCreateLowerAlphaArbitrary);
parcelHelpers.export(exports, "getOrCreateLowerAlphaNumericArbitrary", ()=>getOrCreateLowerAlphaNumericArbitrary);
parcelHelpers.export(exports, "getOrCreateAlphaNumericPercentArbitrary", ()=>getOrCreateAlphaNumericPercentArbitrary);
var _fullUnicodeJs = require("../../fullUnicode.js");
var _oneofJs = require("../../oneof.js");
var _mapToConstantJs = require("../../mapToConstant.js");
var _globalsJs = require("../../../utils/globals.js");
const SMap = Map;
const safeStringFromCharCode = String.fromCharCode;
const lowerCaseMapper = {
    num: 26,
    build: (v)=>safeStringFromCharCode(v + 0x61)
};
const upperCaseMapper = {
    num: 26,
    build: (v)=>safeStringFromCharCode(v + 0x41)
};
const numericMapper = {
    num: 10,
    build: (v)=>safeStringFromCharCode(v + 0x30)
};
function percentCharArbMapper(c) {
    const encoded = (0, _globalsJs.encodeURIComponent)(c);
    return c !== encoded ? encoded : `%${(0, _globalsJs.safeNumberToString)((0, _globalsJs.safeCharCodeAt)(c, 0), 16)}`;
}
function percentCharArbUnmapper(value) {
    if (typeof value !== 'string') throw new Error('Unsupported');
    const decoded = decodeURIComponent(value);
    return decoded;
}
const percentCharArb = (0, _fullUnicodeJs.fullUnicode)().map(percentCharArbMapper, percentCharArbUnmapper);
let lowerAlphaArbitrary = undefined;
function getOrCreateLowerAlphaArbitrary() {
    if (lowerAlphaArbitrary === undefined) lowerAlphaArbitrary = (0, _mapToConstantJs.mapToConstant)(lowerCaseMapper);
    return lowerAlphaArbitrary;
}
let lowerAlphaNumericArbitraries = undefined;
function getOrCreateLowerAlphaNumericArbitrary(others) {
    if (lowerAlphaNumericArbitraries === undefined) lowerAlphaNumericArbitraries = new SMap();
    let match = (0, _globalsJs.safeMapGet)(lowerAlphaNumericArbitraries, others);
    if (match === undefined) {
        match = (0, _mapToConstantJs.mapToConstant)(lowerCaseMapper, numericMapper, {
            num: others.length,
            build: (v)=>others[v]
        });
        (0, _globalsJs.safeMapSet)(lowerAlphaNumericArbitraries, others, match);
    }
    return match;
}
function buildAlphaNumericArbitrary(others) {
    return (0, _mapToConstantJs.mapToConstant)(lowerCaseMapper, upperCaseMapper, numericMapper, {
        num: others.length,
        build: (v)=>others[v]
    });
}
let alphaNumericPercentArbitraries = undefined;
function getOrCreateAlphaNumericPercentArbitrary(others) {
    if (alphaNumericPercentArbitraries === undefined) alphaNumericPercentArbitraries = new SMap();
    let match = (0, _globalsJs.safeMapGet)(alphaNumericPercentArbitraries, others);
    if (match === undefined) {
        match = (0, _oneofJs.oneof)({
            weight: 10,
            arbitrary: buildAlphaNumericArbitrary(others)
        }, {
            weight: 1,
            arbitrary: percentCharArb
        });
        (0, _globalsJs.safeMapSet)(alphaNumericPercentArbitraries, others, match);
    }
    return match;
}

},{"../../fullUnicode.js":"1lTh1","../../oneof.js":"cTys0","../../mapToConstant.js":"QKun9","../../../utils/globals.js":"aTuwn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"cTys0":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "oneof", ()=>oneof);
var _arbitraryJs = require("../check/arbitrary/definition/Arbitrary.js");
var _globalsJs = require("../utils/globals.js");
var _frequencyArbitraryJs = require("./_internals/FrequencyArbitrary.js");
function isOneOfContraints(param) {
    return param != null && typeof param === 'object' && !('generate' in param) && !('arbitrary' in param) && !('weight' in param);
}
function toWeightedArbitrary(maybeWeightedArbitrary) {
    if ((0, _arbitraryJs.isArbitrary)(maybeWeightedArbitrary)) return {
        arbitrary: maybeWeightedArbitrary,
        weight: 1
    };
    return maybeWeightedArbitrary;
}
function oneof(...args) {
    const constraints = args[0];
    if (isOneOfContraints(constraints)) {
        const weightedArbs = (0, _globalsJs.safeMap)((0, _globalsJs.safeSlice)(args, 1), toWeightedArbitrary);
        return (0, _frequencyArbitraryJs.FrequencyArbitrary).from(weightedArbs, constraints, 'fc.oneof');
    }
    const weightedArbs = (0, _globalsJs.safeMap)(args, toWeightedArbitrary);
    return (0, _frequencyArbitraryJs.FrequencyArbitrary).from(weightedArbs, {}, 'fc.oneof');
}

},{"../check/arbitrary/definition/Arbitrary.js":"e6f1K","../utils/globals.js":"aTuwn","./_internals/FrequencyArbitrary.js":"dXFBV","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"dXFBV":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FrequencyArbitrary", ()=>FrequencyArbitrary);
var _streamJs = require("../../stream/Stream.js");
var _arbitraryJs = require("../../check/arbitrary/definition/Arbitrary.js");
var _valueJs = require("../../check/arbitrary/definition/Value.js");
var _depthContextJs = require("./helpers/DepthContext.js");
var _maxLengthFromMinLengthJs = require("./helpers/MaxLengthFromMinLength.js");
var _globalsJs = require("../../utils/globals.js");
const safePositiveInfinity = Number.POSITIVE_INFINITY;
const safeMaxSafeInteger = Number.MAX_SAFE_INTEGER;
const safeNumberIsInteger = Number.isInteger;
const safeMathFloor = Math.floor;
const safeMathPow = Math.pow;
const safeMathMin = Math.min;
class FrequencyArbitrary extends (0, _arbitraryJs.Arbitrary) {
    static from(warbs, constraints, label) {
        if (warbs.length === 0) throw new Error(`${label} expects at least one weighted arbitrary`);
        let totalWeight = 0;
        for(let idx = 0; idx !== warbs.length; ++idx){
            const currentArbitrary = warbs[idx].arbitrary;
            if (currentArbitrary === undefined) throw new Error(`${label} expects arbitraries to be specified`);
            const currentWeight = warbs[idx].weight;
            totalWeight += currentWeight;
            if (!safeNumberIsInteger(currentWeight)) throw new Error(`${label} expects weights to be integer values`);
            if (currentWeight < 0) throw new Error(`${label} expects weights to be superior or equal to 0`);
        }
        if (totalWeight <= 0) throw new Error(`${label} expects the sum of weights to be strictly superior to 0`);
        const sanitizedConstraints = {
            depthBias: (0, _maxLengthFromMinLengthJs.depthBiasFromSizeForArbitrary)(constraints.depthSize, constraints.maxDepth !== undefined),
            maxDepth: constraints.maxDepth != undefined ? constraints.maxDepth : safePositiveInfinity,
            withCrossShrink: !!constraints.withCrossShrink
        };
        return new FrequencyArbitrary(warbs, sanitizedConstraints, (0, _depthContextJs.getDepthContextFor)(constraints.depthIdentifier));
    }
    constructor(warbs, constraints, context){
        super();
        this.warbs = warbs;
        this.constraints = constraints;
        this.context = context;
        let currentWeight = 0;
        this.cumulatedWeights = [];
        for(let idx = 0; idx !== warbs.length; ++idx){
            currentWeight += warbs[idx].weight;
            (0, _globalsJs.safePush)(this.cumulatedWeights, currentWeight);
        }
        this.totalWeight = currentWeight;
    }
    generate(mrng, biasFactor) {
        if (this.mustGenerateFirst()) return this.safeGenerateForIndex(mrng, 0, biasFactor);
        const selected = mrng.nextInt(this.computeNegDepthBenefit(), this.totalWeight - 1);
        for(let idx = 0; idx !== this.cumulatedWeights.length; ++idx){
            if (selected < this.cumulatedWeights[idx]) return this.safeGenerateForIndex(mrng, idx, biasFactor);
        }
        throw new Error(`Unable to generate from fc.frequency`);
    }
    canShrinkWithoutContext(value) {
        return this.canShrinkWithoutContextIndex(value) !== -1;
    }
    shrink(value, context) {
        if (context !== undefined) {
            const safeContext = context;
            const selectedIndex = safeContext.selectedIndex;
            const originalBias = safeContext.originalBias;
            const originalArbitrary = this.warbs[selectedIndex].arbitrary;
            const originalShrinks = originalArbitrary.shrink(value, safeContext.originalContext).map((v)=>this.mapIntoValue(selectedIndex, v, null, originalBias));
            if (safeContext.clonedMrngForFallbackFirst !== null) {
                if (safeContext.cachedGeneratedForFirst === undefined) safeContext.cachedGeneratedForFirst = this.safeGenerateForIndex(safeContext.clonedMrngForFallbackFirst, 0, originalBias);
                const valueFromFirst = safeContext.cachedGeneratedForFirst;
                return (0, _streamJs.Stream).of(valueFromFirst).join(originalShrinks);
            }
            return originalShrinks;
        }
        const potentialSelectedIndex = this.canShrinkWithoutContextIndex(value);
        if (potentialSelectedIndex === -1) return (0, _streamJs.Stream).nil();
        return this.defaultShrinkForFirst(potentialSelectedIndex).join(this.warbs[potentialSelectedIndex].arbitrary.shrink(value, undefined).map((v)=>this.mapIntoValue(potentialSelectedIndex, v, null, undefined)));
    }
    defaultShrinkForFirst(selectedIndex) {
        ++this.context.depth;
        try {
            if (!this.mustFallbackToFirstInShrink(selectedIndex) || this.warbs[0].fallbackValue === undefined) return (0, _streamJs.Stream).nil();
        } finally{
            --this.context.depth;
        }
        const rawShrinkValue = new (0, _valueJs.Value)(this.warbs[0].fallbackValue.default, undefined);
        return (0, _streamJs.Stream).of(this.mapIntoValue(0, rawShrinkValue, null, undefined));
    }
    canShrinkWithoutContextIndex(value) {
        if (this.mustGenerateFirst()) return this.warbs[0].arbitrary.canShrinkWithoutContext(value) ? 0 : -1;
        try {
            ++this.context.depth;
            for(let idx = 0; idx !== this.warbs.length; ++idx){
                const warb = this.warbs[idx];
                if (warb.weight !== 0 && warb.arbitrary.canShrinkWithoutContext(value)) return idx;
            }
            return -1;
        } finally{
            --this.context.depth;
        }
    }
    mapIntoValue(idx, value, clonedMrngForFallbackFirst, biasFactor) {
        const context = {
            selectedIndex: idx,
            originalBias: biasFactor,
            originalContext: value.context,
            clonedMrngForFallbackFirst
        };
        return new (0, _valueJs.Value)(value.value, context);
    }
    safeGenerateForIndex(mrng, idx, biasFactor) {
        ++this.context.depth;
        try {
            const value = this.warbs[idx].arbitrary.generate(mrng, biasFactor);
            const clonedMrngForFallbackFirst = this.mustFallbackToFirstInShrink(idx) ? mrng.clone() : null;
            return this.mapIntoValue(idx, value, clonedMrngForFallbackFirst, biasFactor);
        } finally{
            --this.context.depth;
        }
    }
    mustGenerateFirst() {
        return this.constraints.maxDepth <= this.context.depth;
    }
    mustFallbackToFirstInShrink(idx) {
        return idx !== 0 && this.constraints.withCrossShrink && this.warbs[0].weight !== 0;
    }
    computeNegDepthBenefit() {
        const depthBias = this.constraints.depthBias;
        if (depthBias <= 0 || this.warbs[0].weight === 0) return 0;
        const depthBenefit = safeMathFloor(safeMathPow(1 + depthBias, this.context.depth)) - 1;
        return -safeMathMin(this.totalWeight * depthBenefit, safeMaxSafeInteger) || 0;
    }
}

},{"../../stream/Stream.js":"2sjal","../../check/arbitrary/definition/Arbitrary.js":"e6f1K","../../check/arbitrary/definition/Value.js":"8Cf1j","./helpers/DepthContext.js":"dsS0S","./helpers/MaxLengthFromMinLength.js":"5ilwx","../../utils/globals.js":"aTuwn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"QKun9":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mapToConstant", ()=>mapToConstant);
var _natJs = require("./nat.js");
var _indexToMappedConstantJs = require("./_internals/mappers/IndexToMappedConstant.js");
var _globalsJs = require("../utils/globals.js");
function computeNumChoices(options) {
    if (options.length === 0) throw new (0, _globalsJs.Error)(`fc.mapToConstant expects at least one option`);
    let numChoices = 0;
    for(let idx = 0; idx !== options.length; ++idx){
        if (options[idx].num < 0) throw new (0, _globalsJs.Error)(`fc.mapToConstant expects all options to have a number of entries greater or equal to zero`);
        numChoices += options[idx].num;
    }
    if (numChoices === 0) throw new (0, _globalsJs.Error)(`fc.mapToConstant expects at least one choice among options`);
    return numChoices;
}
function mapToConstant(...entries) {
    const numChoices = computeNumChoices(entries);
    return (0, _natJs.nat)({
        max: numChoices - 1
    }).map((0, _indexToMappedConstantJs.indexToMappedConstantMapperFor)(entries), (0, _indexToMappedConstantJs.indexToMappedConstantUnmapperFor)(entries));
}

},{"./nat.js":"isueS","./_internals/mappers/IndexToMappedConstant.js":"7jFU2","../utils/globals.js":"aTuwn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"isueS":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "nat", ()=>nat);
var _integerArbitraryJs = require("./_internals/IntegerArbitrary.js");
const safeNumberIsInteger = Number.isInteger;
function nat(arg) {
    const max = typeof arg === 'number' ? arg : arg && arg.max !== undefined ? arg.max : 0x7fffffff;
    if (max < 0) throw new Error('fc.nat value should be greater than or equal to 0');
    if (!safeNumberIsInteger(max)) throw new Error('fc.nat maximum value should be an integer');
    return new (0, _integerArbitraryJs.IntegerArbitrary)(0, max);
}

},{"./_internals/IntegerArbitrary.js":"5m6ip","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"7jFU2":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "indexToMappedConstantMapperFor", ()=>indexToMappedConstantMapperFor);
parcelHelpers.export(exports, "indexToMappedConstantUnmapperFor", ()=>indexToMappedConstantUnmapperFor);
var _globalsJs = require("../../../utils/globals.js");
const safeObjectIs = Object.is;
function buildDichotomyEntries(entries) {
    let currentFrom = 0;
    const dichotomyEntries = [];
    for (const entry of entries){
        const from = currentFrom;
        currentFrom = from + entry.num;
        const to = currentFrom - 1;
        dichotomyEntries.push({
            from,
            to,
            entry
        });
    }
    return dichotomyEntries;
}
function findDichotomyEntry(dichotomyEntries, choiceIndex) {
    let min = 0;
    let max = dichotomyEntries.length;
    while(max - min > 1){
        const mid = ~~((min + max) / 2);
        if (choiceIndex < dichotomyEntries[mid].from) max = mid;
        else min = mid;
    }
    return dichotomyEntries[min];
}
function indexToMappedConstantMapperFor(entries) {
    const dichotomyEntries = buildDichotomyEntries(entries);
    return function indexToMappedConstantMapper(choiceIndex) {
        const dichotomyEntry = findDichotomyEntry(dichotomyEntries, choiceIndex);
        return dichotomyEntry.entry.build(choiceIndex - dichotomyEntry.from);
    };
}
function buildReverseMapping(entries) {
    const reverseMapping = {
        mapping: new (0, _globalsJs.Map)(),
        negativeZeroIndex: undefined
    };
    let choiceIndex = 0;
    for(let entryIdx = 0; entryIdx !== entries.length; ++entryIdx){
        const entry = entries[entryIdx];
        for(let idxInEntry = 0; idxInEntry !== entry.num; ++idxInEntry){
            const value = entry.build(idxInEntry);
            if (value === 0 && 1 / value === (0, _globalsJs.Number).NEGATIVE_INFINITY) reverseMapping.negativeZeroIndex = choiceIndex;
            else (0, _globalsJs.safeMapSet)(reverseMapping.mapping, value, choiceIndex);
            ++choiceIndex;
        }
    }
    return reverseMapping;
}
function indexToMappedConstantUnmapperFor(entries) {
    let reverseMapping = null;
    return function indexToMappedConstantUnmapper(value) {
        if (reverseMapping === null) reverseMapping = buildReverseMapping(entries);
        const choiceIndex = safeObjectIs(value, -0) ? reverseMapping.negativeZeroIndex : (0, _globalsJs.safeMapGet)(reverseMapping.mapping, value);
        if (choiceIndex === undefined) throw new (0, _globalsJs.Error)('Unknown value encountered cannot be built using this mapToConstant');
        return choiceIndex;
    };
}

},{"../../../utils/globals.js":"aTuwn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"irrWS":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "domain", ()=>domain);
var _arrayJs = require("./array.js");
var _characterRangeArbitraryBuilderJs = require("./_internals/builders/CharacterRangeArbitraryBuilder.js");
var _optionJs = require("./option.js");
var _stringJs = require("./string.js");
var _tupleJs = require("./tuple.js");
var _invalidSubdomainLabelFiIterJs = require("./_internals/helpers/InvalidSubdomainLabelFiIter.js");
var _maxLengthFromMinLengthJs = require("./_internals/helpers/MaxLengthFromMinLength.js");
var _adapterArbitraryJs = require("./_internals/AdapterArbitrary.js");
var _globalsJs = require("../utils/globals.js");
function toSubdomainLabelMapper([f, d]) {
    return d === null ? f : `${f}${d[0]}${d[1]}`;
}
function toSubdomainLabelUnmapper(value) {
    if (typeof value !== 'string' || value.length === 0) throw new Error('Unsupported');
    if (value.length === 1) return [
        value[0],
        null
    ];
    return [
        value[0],
        [
            (0, _globalsJs.safeSubstring)(value, 1, value.length - 1),
            value[value.length - 1]
        ]
    ];
}
function subdomainLabel(size) {
    const alphaNumericArb = (0, _characterRangeArbitraryBuilderJs.getOrCreateLowerAlphaNumericArbitrary)('');
    const alphaNumericHyphenArb = (0, _characterRangeArbitraryBuilderJs.getOrCreateLowerAlphaNumericArbitrary)('-');
    return (0, _tupleJs.tuple)(alphaNumericArb, (0, _optionJs.option)((0, _tupleJs.tuple)((0, _stringJs.string)({
        unit: alphaNumericHyphenArb,
        size,
        maxLength: 61
    }), alphaNumericArb))).map(toSubdomainLabelMapper, toSubdomainLabelUnmapper).filter((0, _invalidSubdomainLabelFiIterJs.filterInvalidSubdomainLabel));
}
function labelsMapper(elements) {
    return `${(0, _globalsJs.safeJoin)(elements[0], '.')}.${elements[1]}`;
}
function labelsUnmapper(value) {
    if (typeof value !== 'string') throw new Error('Unsupported type');
    const lastDotIndex = value.lastIndexOf('.');
    return [
        (0, _globalsJs.safeSplit)((0, _globalsJs.safeSubstring)(value, 0, lastDotIndex), '.'),
        (0, _globalsJs.safeSubstring)(value, lastDotIndex + 1)
    ];
}
function labelsAdapter(labels) {
    const [subDomains, suffix] = labels;
    let lengthNotIncludingIndex = suffix.length;
    for(let index = 0; index !== subDomains.length; ++index){
        lengthNotIncludingIndex += 1 + subDomains[index].length;
        if (lengthNotIncludingIndex > 255) return {
            adapted: true,
            value: [
                (0, _globalsJs.safeSlice)(subDomains, 0, index),
                suffix
            ]
        };
    }
    return {
        adapted: false,
        value: labels
    };
}
function domain(constraints = {}) {
    const resolvedSize = (0, _maxLengthFromMinLengthJs.resolveSize)(constraints.size);
    const resolvedSizeMinusOne = (0, _maxLengthFromMinLengthJs.relativeSizeToSize)('-1', resolvedSize);
    const lowerAlphaArb = (0, _characterRangeArbitraryBuilderJs.getOrCreateLowerAlphaArbitrary)();
    const publicSuffixArb = (0, _stringJs.string)({
        unit: lowerAlphaArb,
        minLength: 2,
        maxLength: 63,
        size: resolvedSizeMinusOne
    });
    return (0, _adapterArbitraryJs.adapter)((0, _tupleJs.tuple)((0, _arrayJs.array)(subdomainLabel(resolvedSize), {
        size: resolvedSizeMinusOne,
        minLength: 1,
        maxLength: 127
    }), publicSuffixArb), labelsAdapter).map(labelsMapper, labelsUnmapper);
}

},{"./array.js":"eZMHg","./_internals/builders/CharacterRangeArbitraryBuilder.js":"gF9Ci","./option.js":"8sNMn","./string.js":"iHGKT","./tuple.js":"dw0Pn","./_internals/helpers/InvalidSubdomainLabelFiIter.js":"ekMgJ","./_internals/helpers/MaxLengthFromMinLength.js":"5ilwx","./_internals/AdapterArbitrary.js":"95a4k","../utils/globals.js":"aTuwn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"8sNMn":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "option", ()=>option);
var _constantJs = require("./constant.js");
var _frequencyArbitraryJs = require("./_internals/FrequencyArbitrary.js");
var _globalsJs = require("../utils/globals.js");
function option(arb, constraints = {}) {
    const freq = constraints.freq == null ? 5 : constraints.freq;
    const nilValue = (0, _globalsJs.safeHasOwnProperty)(constraints, 'nil') ? constraints.nil : null;
    const nilArb = (0, _constantJs.constant)(nilValue);
    const weightedArbs = [
        {
            arbitrary: nilArb,
            weight: 1,
            fallbackValue: {
                default: nilValue
            }
        },
        {
            arbitrary: arb,
            weight: freq
        }
    ];
    const frequencyConstraints = {
        withCrossShrink: true,
        depthSize: constraints.depthSize,
        maxDepth: constraints.maxDepth,
        depthIdentifier: constraints.depthIdentifier
    };
    return (0, _frequencyArbitraryJs.FrequencyArbitrary).from(weightedArbs, frequencyConstraints, 'fc.option');
}

},{"./constant.js":"6Ey5n","./_internals/FrequencyArbitrary.js":"dXFBV","../utils/globals.js":"aTuwn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"iHGKT":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "string", ()=>string);
var _arrayJs = require("./array.js");
var _slicesForStringBuilderJs = require("./_internals/helpers/SlicesForStringBuilder.js");
var _stringUnitArbitraryJs = require("./_internals/StringUnitArbitrary.js");
var _patternsToStringJs = require("./_internals/mappers/PatternsToString.js");
const safeObjectAssign = Object.assign;
function extractUnitArbitrary(constraints) {
    if (typeof constraints.unit === 'object') return constraints.unit;
    switch(constraints.unit){
        case 'grapheme':
            return (0, _stringUnitArbitraryJs.stringUnit)('grapheme', 'full');
        case 'grapheme-composite':
            return (0, _stringUnitArbitraryJs.stringUnit)('composite', 'full');
        case 'grapheme-ascii':
        case undefined:
            return (0, _stringUnitArbitraryJs.stringUnit)('grapheme', 'ascii');
        case 'binary':
            return (0, _stringUnitArbitraryJs.stringUnit)('binary', 'full');
        case 'binary-ascii':
            return (0, _stringUnitArbitraryJs.stringUnit)('binary', 'ascii');
    }
}
function string(constraints = {}) {
    const charArbitrary = extractUnitArbitrary(constraints);
    const unmapper = (0, _patternsToStringJs.patternsToStringUnmapperFor)(charArbitrary, constraints);
    const experimentalCustomSlices = (0, _slicesForStringBuilderJs.createSlicesForString)(charArbitrary, constraints);
    const enrichedConstraints = safeObjectAssign(safeObjectAssign({}, constraints), {
        experimentalCustomSlices
    });
    return (0, _arrayJs.array)(charArbitrary, enrichedConstraints).map((0, _patternsToStringJs.patternsToStringMapper), unmapper);
}

},{"./array.js":"eZMHg","./_internals/helpers/SlicesForStringBuilder.js":"d3W5S","./_internals/StringUnitArbitrary.js":"dP3go","./_internals/mappers/PatternsToString.js":"frPRE","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"d3W5S":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createSlicesForStringLegacy", ()=>createSlicesForStringLegacy);
parcelHelpers.export(exports, "createSlicesForString", ()=>createSlicesForString);
var _globalsJs = require("../../../utils/globals.js");
var _patternsToStringJs = require("../mappers/PatternsToString.js");
var _maxLengthFromMinLengthJs = require("./MaxLengthFromMinLength.js");
var _tokenizeStringJs = require("./TokenizeString.js");
const dangerousStrings = [
    '__defineGetter__',
    '__defineSetter__',
    '__lookupGetter__',
    '__lookupSetter__',
    '__proto__',
    'constructor',
    'hasOwnProperty',
    'isPrototypeOf',
    'propertyIsEnumerable',
    'toLocaleString',
    'toString',
    'valueOf',
    'apply',
    'arguments',
    'bind',
    'call',
    'caller',
    'length',
    'name',
    'prototype',
    'key',
    'ref'
];
function computeCandidateStringLegacy(dangerous, charArbitrary, stringSplitter) {
    let candidate;
    try {
        candidate = stringSplitter(dangerous);
    } catch (err) {
        return undefined;
    }
    for (const entry of candidate){
        if (!charArbitrary.canShrinkWithoutContext(entry)) return undefined;
    }
    return candidate;
}
function createSlicesForStringLegacy(charArbitrary, stringSplitter) {
    const slicesForString = [];
    for (const dangerous of dangerousStrings){
        const candidate = computeCandidateStringLegacy(dangerous, charArbitrary, stringSplitter);
        if (candidate !== undefined) (0, _globalsJs.safePush)(slicesForString, candidate);
    }
    return slicesForString;
}
const slicesPerArbitrary = new WeakMap();
function createSlicesForStringNoConstraints(charArbitrary) {
    const slicesForString = [];
    for (const dangerous of dangerousStrings){
        const candidate = (0, _tokenizeStringJs.tokenizeString)(charArbitrary, dangerous, 0, (0, _maxLengthFromMinLengthJs.MaxLengthUpperBound));
        if (candidate !== undefined) (0, _globalsJs.safePush)(slicesForString, candidate);
    }
    return slicesForString;
}
function createSlicesForString(charArbitrary, constraints) {
    let slices = (0, _globalsJs.safeGet)(slicesPerArbitrary, charArbitrary);
    if (slices === undefined) {
        slices = createSlicesForStringNoConstraints(charArbitrary);
        (0, _globalsJs.safeSet)(slicesPerArbitrary, charArbitrary, slices);
    }
    const slicesForConstraints = [];
    for (const slice of slices)if ((0, _patternsToStringJs.patternsToStringUnmapperIsValidLength)(slice, constraints)) (0, _globalsJs.safePush)(slicesForConstraints, slice);
    return slicesForConstraints;
}

},{"../../../utils/globals.js":"aTuwn","../mappers/PatternsToString.js":"frPRE","./MaxLengthFromMinLength.js":"5ilwx","./TokenizeString.js":"4bNYw","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"frPRE":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "patternsToStringMapper", ()=>patternsToStringMapper);
parcelHelpers.export(exports, "patternsToStringUnmapperIsValidLength", ()=>patternsToStringUnmapperIsValidLength);
parcelHelpers.export(exports, "patternsToStringUnmapperFor", ()=>patternsToStringUnmapperFor);
var _maxLengthFromMinLengthJs = require("../helpers/MaxLengthFromMinLength.js");
var _globalsJs = require("../../../utils/globals.js");
var _tokenizeStringJs = require("../helpers/TokenizeString.js");
function patternsToStringMapper(tab) {
    return (0, _globalsJs.safeJoin)(tab, '');
}
function minLengthFrom(constraints) {
    return constraints.minLength !== undefined ? constraints.minLength : 0;
}
function maxLengthFrom(constraints) {
    return constraints.maxLength !== undefined ? constraints.maxLength : (0, _maxLengthFromMinLengthJs.MaxLengthUpperBound);
}
function patternsToStringUnmapperIsValidLength(tokens, constraints) {
    return minLengthFrom(constraints) <= tokens.length && tokens.length <= maxLengthFrom(constraints);
}
function patternsToStringUnmapperFor(patternsArb, constraints) {
    return function patternsToStringUnmapper(value) {
        if (typeof value !== 'string') throw new (0, _globalsJs.Error)('Unsupported value');
        const tokens = (0, _tokenizeStringJs.tokenizeString)(patternsArb, value, minLengthFrom(constraints), maxLengthFrom(constraints));
        if (tokens === undefined) throw new (0, _globalsJs.Error)('Unable to unmap received string');
        return tokens;
    };
}

},{"../helpers/MaxLengthFromMinLength.js":"5ilwx","../../../utils/globals.js":"aTuwn","../helpers/TokenizeString.js":"4bNYw","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"4bNYw":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "tokenizeString", ()=>tokenizeString);
var _globalsJs = require("../../../utils/globals.js");
function tokenizeString(patternsArb, value, minLength, maxLength) {
    if (value.length === 0) {
        if (minLength > 0) return undefined;
        return [];
    }
    if (maxLength <= 0) return undefined;
    const stack = [
        {
            endIndexChunks: 0,
            nextStartIndex: 1,
            chunks: []
        }
    ];
    while(stack.length > 0){
        const last = (0, _globalsJs.safePop)(stack);
        for(let index = last.nextStartIndex; index <= value.length; ++index){
            const chunk = (0, _globalsJs.safeSubstring)(value, last.endIndexChunks, index);
            if (patternsArb.canShrinkWithoutContext(chunk)) {
                const newChunks = [
                    ...last.chunks,
                    chunk
                ];
                if (index === value.length) {
                    if (newChunks.length < minLength) break;
                    return newChunks;
                }
                (0, _globalsJs.safePush)(stack, {
                    endIndexChunks: last.endIndexChunks,
                    nextStartIndex: index + 1,
                    chunks: last.chunks
                });
                if (newChunks.length < maxLength) (0, _globalsJs.safePush)(stack, {
                    endIndexChunks: index,
                    nextStartIndex: index + 1,
                    chunks: newChunks
                });
                break;
            }
        }
    }
    return undefined;
}

},{"../../../utils/globals.js":"aTuwn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"dP3go":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "stringUnit", ()=>stringUnit);
var _globalsJs = require("../../utils/globals.js");
var _mapToConstantJs = require("../mapToConstant.js");
var _graphemeRangesJs = require("./data/GraphemeRanges.js");
var _graphemeRangesHelpersJs = require("./helpers/GraphemeRangesHelpers.js");
const registeredStringUnitInstancesMap = Object.create(null);
function getAlphabetRanges(alphabet) {
    switch(alphabet){
        case 'full':
            return 0, _graphemeRangesJs.fullAlphabetRanges;
        case 'ascii':
            return 0, _graphemeRangesJs.asciiAlphabetRanges;
    }
}
function getOrCreateStringUnitInstance(type, alphabet) {
    const key = `${type}:${alphabet}`;
    const registered = registeredStringUnitInstancesMap[key];
    if (registered !== undefined) return registered;
    const alphabetRanges = getAlphabetRanges(alphabet);
    const ranges = type === 'binary' ? alphabetRanges : (0, _graphemeRangesHelpersJs.intersectGraphemeRanges)(alphabetRanges, (0, _graphemeRangesJs.autonomousGraphemeRanges));
    const entries = [];
    for (const range of ranges)(0, _globalsJs.safePush)(entries, (0, _graphemeRangesHelpersJs.convertGraphemeRangeToMapToConstantEntry)(range));
    if (type === 'grapheme') {
        const decomposedRanges = (0, _graphemeRangesHelpersJs.intersectGraphemeRanges)(alphabetRanges, (0, _graphemeRangesJs.autonomousDecomposableGraphemeRanges));
        for (const range of decomposedRanges){
            const rawEntry = (0, _graphemeRangesHelpersJs.convertGraphemeRangeToMapToConstantEntry)(range);
            (0, _globalsJs.safePush)(entries, {
                num: rawEntry.num,
                build: (idInGroup)=>(0, _globalsJs.safeNormalize)(rawEntry.build(idInGroup), 'NFD')
            });
        }
    }
    const stringUnitInstance = (0, _mapToConstantJs.mapToConstant)(...entries);
    registeredStringUnitInstancesMap[key] = stringUnitInstance;
    return stringUnitInstance;
}
function stringUnit(type, alphabet) {
    return getOrCreateStringUnitInstance(type, alphabet);
}

},{"../../utils/globals.js":"aTuwn","../mapToConstant.js":"QKun9","./data/GraphemeRanges.js":"bqBbq","./helpers/GraphemeRangesHelpers.js":"bpTbY","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"bqBbq":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "asciiAlphabetRanges", ()=>asciiAlphabetRanges);
parcelHelpers.export(exports, "fullAlphabetRanges", ()=>fullAlphabetRanges);
parcelHelpers.export(exports, "autonomousGraphemeRanges", ()=>autonomousGraphemeRanges);
parcelHelpers.export(exports, "autonomousDecomposableGraphemeRanges", ()=>autonomousDecomposableGraphemeRanges);
const asciiAlphabetRanges = [
    [
        0x00,
        0x7f
    ]
];
const fullAlphabetRanges = [
    [
        0x0000,
        0xd7ff
    ],
    [
        0xe000,
        0x10ffff
    ]
];
const autonomousGraphemeRanges = [
    [
        0x20,
        0x7e
    ],
    [
        0xa0,
        0xac
    ],
    [
        0xae,
        0x2ff
    ],
    [
        0x370,
        0x377
    ],
    [
        0x37a,
        0x37f
    ],
    [
        0x384,
        0x38a
    ],
    [
        0x38c
    ],
    [
        0x38e,
        0x3a1
    ],
    [
        0x3a3,
        0x482
    ],
    [
        0x48a,
        0x52f
    ],
    [
        0x531,
        0x556
    ],
    [
        0x559,
        0x58a
    ],
    [
        0x58d,
        0x58f
    ],
    [
        0x5be
    ],
    [
        0x5c0
    ],
    [
        0x5c3
    ],
    [
        0x5c6
    ],
    [
        0x5d0,
        0x5ea
    ],
    [
        0x5ef,
        0x5f4
    ],
    [
        0x606,
        0x60f
    ],
    [
        0x61b
    ],
    [
        0x61d,
        0x64a
    ],
    [
        0x660,
        0x66f
    ],
    [
        0x671,
        0x6d5
    ],
    [
        0x6de
    ],
    [
        0x6e5,
        0x6e6
    ],
    [
        0x6e9
    ],
    [
        0x6ee,
        0x70d
    ],
    [
        0x710
    ],
    [
        0x712,
        0x72f
    ],
    [
        0x74d,
        0x7a5
    ],
    [
        0x7b1
    ],
    [
        0x7c0,
        0x7ea
    ],
    [
        0x7f4,
        0x7fa
    ],
    [
        0x7fe,
        0x815
    ],
    [
        0x81a
    ],
    [
        0x824
    ],
    [
        0x828
    ],
    [
        0x830,
        0x83e
    ],
    [
        0x840,
        0x858
    ],
    [
        0x85e
    ],
    [
        0x860,
        0x86a
    ],
    [
        0x870,
        0x88e
    ],
    [
        0x8a0,
        0x8c9
    ],
    [
        0x904,
        0x939
    ],
    [
        0x93d
    ],
    [
        0x950
    ],
    [
        0x958,
        0x961
    ],
    [
        0x964,
        0x980
    ],
    [
        0x985,
        0x98c
    ],
    [
        0x98f,
        0x990
    ],
    [
        0x993,
        0x9a8
    ],
    [
        0x9aa,
        0x9b0
    ],
    [
        0x9b2
    ],
    [
        0x9b6,
        0x9b9
    ],
    [
        0x9bd
    ],
    [
        0x9ce
    ],
    [
        0x9dc,
        0x9dd
    ],
    [
        0x9df,
        0x9e1
    ],
    [
        0x9e6,
        0x9fd
    ],
    [
        0xa05,
        0xa0a
    ],
    [
        0xa0f,
        0xa10
    ],
    [
        0xa13,
        0xa28
    ],
    [
        0xa2a,
        0xa30
    ],
    [
        0xa32,
        0xa33
    ],
    [
        0xa35,
        0xa36
    ],
    [
        0xa38,
        0xa39
    ],
    [
        0xa59,
        0xa5c
    ],
    [
        0xa5e
    ],
    [
        0xa66,
        0xa6f
    ],
    [
        0xa72,
        0xa74
    ],
    [
        0xa76
    ],
    [
        0xa85,
        0xa8d
    ],
    [
        0xa8f,
        0xa91
    ],
    [
        0xa93,
        0xaa8
    ],
    [
        0xaaa,
        0xab0
    ],
    [
        0xab2,
        0xab3
    ],
    [
        0xab5,
        0xab9
    ],
    [
        0xabd
    ],
    [
        0xad0
    ],
    [
        0xae0,
        0xae1
    ],
    [
        0xae6,
        0xaf1
    ],
    [
        0xaf9
    ],
    [
        0xb05,
        0xb0c
    ],
    [
        0xb0f,
        0xb10
    ],
    [
        0xb13,
        0xb28
    ],
    [
        0xb2a,
        0xb30
    ],
    [
        0xb32,
        0xb33
    ],
    [
        0xb35,
        0xb39
    ],
    [
        0xb3d
    ],
    [
        0xb5c,
        0xb5d
    ],
    [
        0xb5f,
        0xb61
    ],
    [
        0xb66,
        0xb77
    ],
    [
        0xb83
    ],
    [
        0xb85,
        0xb8a
    ],
    [
        0xb8e,
        0xb90
    ],
    [
        0xb92,
        0xb95
    ],
    [
        0xb99,
        0xb9a
    ],
    [
        0xb9c
    ],
    [
        0xb9e,
        0xb9f
    ],
    [
        0xba3,
        0xba4
    ],
    [
        0xba8,
        0xbaa
    ],
    [
        0xbae,
        0xbb9
    ],
    [
        0xbd0
    ],
    [
        0xbe6,
        0xbfa
    ],
    [
        0xc05,
        0xc0c
    ],
    [
        0xc0e,
        0xc10
    ],
    [
        0xc12,
        0xc28
    ],
    [
        0xc2a,
        0xc39
    ],
    [
        0xc3d
    ],
    [
        0xc58,
        0xc5a
    ],
    [
        0xc5d
    ],
    [
        0xc60,
        0xc61
    ],
    [
        0xc66,
        0xc6f
    ],
    [
        0xc77,
        0xc80
    ],
    [
        0xc84,
        0xc8c
    ],
    [
        0xc8e,
        0xc90
    ],
    [
        0xc92,
        0xca8
    ],
    [
        0xcaa,
        0xcb3
    ],
    [
        0xcb5,
        0xcb9
    ],
    [
        0xcbd
    ],
    [
        0xcdd,
        0xcde
    ],
    [
        0xce0,
        0xce1
    ],
    [
        0xce6,
        0xcef
    ],
    [
        0xcf1,
        0xcf2
    ],
    [
        0xd04,
        0xd0c
    ],
    [
        0xd0e,
        0xd10
    ],
    [
        0xd12,
        0xd3a
    ],
    [
        0xd3d
    ],
    [
        0xd4f
    ],
    [
        0xd54,
        0xd56
    ],
    [
        0xd58,
        0xd61
    ],
    [
        0xd66,
        0xd7f
    ],
    [
        0xd85,
        0xd96
    ],
    [
        0xd9a,
        0xdb1
    ],
    [
        0xdb3,
        0xdbb
    ],
    [
        0xdbd
    ],
    [
        0xdc0,
        0xdc6
    ],
    [
        0xde6,
        0xdef
    ],
    [
        0xdf4
    ],
    [
        0xe01,
        0xe30
    ],
    [
        0xe32
    ],
    [
        0xe3f,
        0xe46
    ],
    [
        0xe4f,
        0xe5b
    ],
    [
        0xe81,
        0xe82
    ],
    [
        0xe84
    ],
    [
        0xe86,
        0xe8a
    ],
    [
        0xe8c,
        0xea3
    ],
    [
        0xea5
    ],
    [
        0xea7,
        0xeb0
    ],
    [
        0xeb2
    ],
    [
        0xebd
    ],
    [
        0xec0,
        0xec4
    ],
    [
        0xec6
    ],
    [
        0xed0,
        0xed9
    ],
    [
        0xedc,
        0xedf
    ],
    [
        0xf00,
        0xf17
    ],
    [
        0xf1a,
        0xf34
    ],
    [
        0xf36
    ],
    [
        0xf38
    ],
    [
        0xf3a,
        0xf3d
    ],
    [
        0xf40,
        0xf47
    ],
    [
        0xf49,
        0xf6c
    ],
    [
        0xf85
    ],
    [
        0xf88,
        0xf8c
    ],
    [
        0xfbe,
        0xfc5
    ],
    [
        0xfc7,
        0xfcc
    ],
    [
        0xfce,
        0xfda
    ],
    [
        0x1000,
        0x102a
    ],
    [
        0x103f,
        0x1055
    ],
    [
        0x105a,
        0x105d
    ],
    [
        0x1061
    ],
    [
        0x1065,
        0x1066
    ],
    [
        0x106e,
        0x1070
    ],
    [
        0x1075,
        0x1081
    ],
    [
        0x108e
    ],
    [
        0x1090,
        0x1099
    ],
    [
        0x109e,
        0x10c5
    ],
    [
        0x10c7
    ],
    [
        0x10cd
    ],
    [
        0x10d0,
        0x10ff
    ],
    [
        0x1200,
        0x1248
    ],
    [
        0x124a,
        0x124d
    ],
    [
        0x1250,
        0x1256
    ],
    [
        0x1258
    ],
    [
        0x125a,
        0x125d
    ],
    [
        0x1260,
        0x1288
    ],
    [
        0x128a,
        0x128d
    ],
    [
        0x1290,
        0x12b0
    ],
    [
        0x12b2,
        0x12b5
    ],
    [
        0x12b8,
        0x12be
    ],
    [
        0x12c0
    ],
    [
        0x12c2,
        0x12c5
    ],
    [
        0x12c8,
        0x12d6
    ],
    [
        0x12d8,
        0x1310
    ],
    [
        0x1312,
        0x1315
    ],
    [
        0x1318,
        0x135a
    ],
    [
        0x1360,
        0x137c
    ],
    [
        0x1380,
        0x1399
    ],
    [
        0x13a0,
        0x13f5
    ],
    [
        0x13f8,
        0x13fd
    ],
    [
        0x1400,
        0x169c
    ],
    [
        0x16a0,
        0x16f8
    ],
    [
        0x1700,
        0x1711
    ],
    [
        0x171f,
        0x1731
    ],
    [
        0x1735,
        0x1736
    ],
    [
        0x1740,
        0x1751
    ],
    [
        0x1760,
        0x176c
    ],
    [
        0x176e,
        0x1770
    ],
    [
        0x1780,
        0x17b3
    ],
    [
        0x17d4,
        0x17dc
    ],
    [
        0x17e0,
        0x17e9
    ],
    [
        0x17f0,
        0x17f9
    ],
    [
        0x1800,
        0x180a
    ],
    [
        0x1810,
        0x1819
    ],
    [
        0x1820,
        0x1878
    ],
    [
        0x1880,
        0x1884
    ],
    [
        0x1887,
        0x18a8
    ],
    [
        0x18aa
    ],
    [
        0x18b0,
        0x18f5
    ],
    [
        0x1900,
        0x191e
    ],
    [
        0x1940
    ],
    [
        0x1944,
        0x196d
    ],
    [
        0x1970,
        0x1974
    ],
    [
        0x1980,
        0x19ab
    ],
    [
        0x19b0,
        0x19c9
    ],
    [
        0x19d0,
        0x19da
    ],
    [
        0x19de,
        0x1a16
    ],
    [
        0x1a1e,
        0x1a54
    ],
    [
        0x1a80,
        0x1a89
    ],
    [
        0x1a90,
        0x1a99
    ],
    [
        0x1aa0,
        0x1aad
    ],
    [
        0x1b05,
        0x1b33
    ],
    [
        0x1b45,
        0x1b4c
    ],
    [
        0x1b50,
        0x1b6a
    ],
    [
        0x1b74,
        0x1b7e
    ],
    [
        0x1b83,
        0x1ba0
    ],
    [
        0x1bae,
        0x1be5
    ],
    [
        0x1bfc,
        0x1c23
    ],
    [
        0x1c3b,
        0x1c49
    ],
    [
        0x1c4d,
        0x1c88
    ],
    [
        0x1c90,
        0x1cba
    ],
    [
        0x1cbd,
        0x1cc7
    ],
    [
        0x1cd3
    ],
    [
        0x1ce9,
        0x1cec
    ],
    [
        0x1cee,
        0x1cf3
    ],
    [
        0x1cf5,
        0x1cf6
    ],
    [
        0x1cfa
    ],
    [
        0x1d00,
        0x1dbf
    ],
    [
        0x1e00,
        0x1f15
    ],
    [
        0x1f18,
        0x1f1d
    ],
    [
        0x1f20,
        0x1f45
    ],
    [
        0x1f48,
        0x1f4d
    ],
    [
        0x1f50,
        0x1f57
    ],
    [
        0x1f59
    ],
    [
        0x1f5b
    ],
    [
        0x1f5d
    ],
    [
        0x1f5f,
        0x1f7d
    ],
    [
        0x1f80,
        0x1fb4
    ],
    [
        0x1fb6,
        0x1fc4
    ],
    [
        0x1fc6,
        0x1fd3
    ],
    [
        0x1fd6,
        0x1fdb
    ],
    [
        0x1fdd,
        0x1fef
    ],
    [
        0x1ff2,
        0x1ff4
    ],
    [
        0x1ff6,
        0x1ffe
    ],
    [
        0x2000,
        0x200a
    ],
    [
        0x2010,
        0x2029
    ],
    [
        0x202f,
        0x205f
    ],
    [
        0x2070,
        0x2071
    ],
    [
        0x2074,
        0x208e
    ],
    [
        0x2090,
        0x209c
    ],
    [
        0x20a0,
        0x20c0
    ],
    [
        0x2100,
        0x218b
    ],
    [
        0x2190,
        0x2426
    ],
    [
        0x2440,
        0x244a
    ],
    [
        0x2460,
        0x2b73
    ],
    [
        0x2b76,
        0x2b95
    ],
    [
        0x2b97,
        0x2cee
    ],
    [
        0x2cf2,
        0x2cf3
    ],
    [
        0x2cf9,
        0x2d25
    ],
    [
        0x2d27
    ],
    [
        0x2d2d
    ],
    [
        0x2d30,
        0x2d67
    ],
    [
        0x2d6f,
        0x2d70
    ],
    [
        0x2d80,
        0x2d96
    ],
    [
        0x2da0,
        0x2da6
    ],
    [
        0x2da8,
        0x2dae
    ],
    [
        0x2db0,
        0x2db6
    ],
    [
        0x2db8,
        0x2dbe
    ],
    [
        0x2dc0,
        0x2dc6
    ],
    [
        0x2dc8,
        0x2dce
    ],
    [
        0x2dd0,
        0x2dd6
    ],
    [
        0x2dd8,
        0x2dde
    ],
    [
        0x2e00,
        0x2e5d
    ],
    [
        0x2e80,
        0x2e99
    ],
    [
        0x2e9b,
        0x2ef3
    ],
    [
        0x2f00,
        0x2fd5
    ],
    [
        0x2ff0,
        0x3029
    ],
    [
        0x3030,
        0x303f
    ],
    [
        0x3041,
        0x3096
    ],
    [
        0x309b,
        0x30ff
    ],
    [
        0x3105,
        0x312f
    ],
    [
        0x3131,
        0x318e
    ],
    [
        0x3190,
        0x31e3
    ],
    [
        0x31ef,
        0x321e
    ],
    [
        0x3220,
        0x3400
    ],
    [
        0x4dbf,
        0x4e00
    ],
    [
        0x9fff,
        0xa48c
    ],
    [
        0xa490,
        0xa4c6
    ],
    [
        0xa4d0,
        0xa62b
    ],
    [
        0xa640,
        0xa66e
    ],
    [
        0xa673
    ],
    [
        0xa67e,
        0xa69d
    ],
    [
        0xa6a0,
        0xa6ef
    ],
    [
        0xa6f2,
        0xa6f7
    ],
    [
        0xa700,
        0xa7ca
    ],
    [
        0xa7d0,
        0xa7d1
    ],
    [
        0xa7d3
    ],
    [
        0xa7d5,
        0xa7d9
    ],
    [
        0xa7f2,
        0xa801
    ],
    [
        0xa803,
        0xa805
    ],
    [
        0xa807,
        0xa80a
    ],
    [
        0xa80c,
        0xa822
    ],
    [
        0xa828,
        0xa82b
    ],
    [
        0xa830,
        0xa839
    ],
    [
        0xa840,
        0xa877
    ],
    [
        0xa882,
        0xa8b3
    ],
    [
        0xa8ce,
        0xa8d9
    ],
    [
        0xa8f2,
        0xa8fe
    ],
    [
        0xa900,
        0xa925
    ],
    [
        0xa92e,
        0xa946
    ],
    [
        0xa95f
    ],
    [
        0xa984,
        0xa9b2
    ],
    [
        0xa9c1,
        0xa9cd
    ],
    [
        0xa9cf,
        0xa9d9
    ],
    [
        0xa9de,
        0xa9e4
    ],
    [
        0xa9e6,
        0xa9fe
    ],
    [
        0xaa00,
        0xaa28
    ],
    [
        0xaa40,
        0xaa42
    ],
    [
        0xaa44,
        0xaa4b
    ],
    [
        0xaa50,
        0xaa59
    ],
    [
        0xaa5c,
        0xaa7a
    ],
    [
        0xaa7e,
        0xaaaf
    ],
    [
        0xaab1
    ],
    [
        0xaab5,
        0xaab6
    ],
    [
        0xaab9,
        0xaabd
    ],
    [
        0xaac0
    ],
    [
        0xaac2
    ],
    [
        0xaadb,
        0xaaea
    ],
    [
        0xaaf0,
        0xaaf4
    ],
    [
        0xab01,
        0xab06
    ],
    [
        0xab09,
        0xab0e
    ],
    [
        0xab11,
        0xab16
    ],
    [
        0xab20,
        0xab26
    ],
    [
        0xab28,
        0xab2e
    ],
    [
        0xab30,
        0xab6b
    ],
    [
        0xab70,
        0xabe2
    ],
    [
        0xabeb
    ],
    [
        0xabf0,
        0xabf9
    ],
    [
        0xac00
    ],
    [
        0xd7a3
    ],
    [
        0xf900,
        0xfa6d
    ],
    [
        0xfa70,
        0xfad9
    ],
    [
        0xfb00,
        0xfb06
    ],
    [
        0xfb13,
        0xfb17
    ],
    [
        0xfb1d
    ],
    [
        0xfb1f,
        0xfb36
    ],
    [
        0xfb38,
        0xfb3c
    ],
    [
        0xfb3e
    ],
    [
        0xfb40,
        0xfb41
    ],
    [
        0xfb43,
        0xfb44
    ],
    [
        0xfb46,
        0xfbc2
    ],
    [
        0xfbd3,
        0xfd8f
    ],
    [
        0xfd92,
        0xfdc7
    ],
    [
        0xfdcf
    ],
    [
        0xfdf0,
        0xfdff
    ],
    [
        0xfe10,
        0xfe19
    ],
    [
        0xfe30,
        0xfe52
    ],
    [
        0xfe54,
        0xfe66
    ],
    [
        0xfe68,
        0xfe6b
    ],
    [
        0xfe70,
        0xfe74
    ],
    [
        0xfe76,
        0xfefc
    ],
    [
        0xff01,
        0xff9d
    ],
    [
        0xffa0,
        0xffbe
    ],
    [
        0xffc2,
        0xffc7
    ],
    [
        0xffca,
        0xffcf
    ],
    [
        0xffd2,
        0xffd7
    ],
    [
        0xffda,
        0xffdc
    ],
    [
        0xffe0,
        0xffe6
    ],
    [
        0xffe8,
        0xffee
    ],
    [
        0xfffc,
        0xfffd
    ],
    [
        0x10000,
        0x1000b
    ],
    [
        0x1000d,
        0x10026
    ],
    [
        0x10028,
        0x1003a
    ],
    [
        0x1003c,
        0x1003d
    ],
    [
        0x1003f,
        0x1004d
    ],
    [
        0x10050,
        0x1005d
    ],
    [
        0x10080,
        0x100fa
    ],
    [
        0x10100,
        0x10102
    ],
    [
        0x10107,
        0x10133
    ],
    [
        0x10137,
        0x1018e
    ],
    [
        0x10190,
        0x1019c
    ],
    [
        0x101a0
    ],
    [
        0x101d0,
        0x101fc
    ],
    [
        0x10280,
        0x1029c
    ],
    [
        0x102a0,
        0x102d0
    ],
    [
        0x102e1,
        0x102fb
    ],
    [
        0x10300,
        0x10323
    ],
    [
        0x1032d,
        0x1034a
    ],
    [
        0x10350,
        0x10375
    ],
    [
        0x10380,
        0x1039d
    ],
    [
        0x1039f,
        0x103c3
    ],
    [
        0x103c8,
        0x103d5
    ],
    [
        0x10400,
        0x1049d
    ],
    [
        0x104a0,
        0x104a9
    ],
    [
        0x104b0,
        0x104d3
    ],
    [
        0x104d8,
        0x104fb
    ],
    [
        0x10500,
        0x10527
    ],
    [
        0x10530,
        0x10563
    ],
    [
        0x1056f,
        0x1057a
    ],
    [
        0x1057c,
        0x1058a
    ],
    [
        0x1058c,
        0x10592
    ],
    [
        0x10594,
        0x10595
    ],
    [
        0x10597,
        0x105a1
    ],
    [
        0x105a3,
        0x105b1
    ],
    [
        0x105b3,
        0x105b9
    ],
    [
        0x105bb,
        0x105bc
    ],
    [
        0x10600,
        0x10736
    ],
    [
        0x10740,
        0x10755
    ],
    [
        0x10760,
        0x10767
    ],
    [
        0x10780,
        0x10785
    ],
    [
        0x10787,
        0x107b0
    ],
    [
        0x107b2,
        0x107ba
    ],
    [
        0x10800,
        0x10805
    ],
    [
        0x10808
    ],
    [
        0x1080a,
        0x10835
    ],
    [
        0x10837,
        0x10838
    ],
    [
        0x1083c
    ],
    [
        0x1083f,
        0x10855
    ],
    [
        0x10857,
        0x1089e
    ],
    [
        0x108a7,
        0x108af
    ],
    [
        0x108e0,
        0x108f2
    ],
    [
        0x108f4,
        0x108f5
    ],
    [
        0x108fb,
        0x1091b
    ],
    [
        0x1091f,
        0x10939
    ],
    [
        0x1093f
    ],
    [
        0x10980,
        0x109b7
    ],
    [
        0x109bc,
        0x109cf
    ],
    [
        0x109d2,
        0x10a00
    ],
    [
        0x10a10,
        0x10a13
    ],
    [
        0x10a15,
        0x10a17
    ],
    [
        0x10a19,
        0x10a35
    ],
    [
        0x10a40,
        0x10a48
    ],
    [
        0x10a50,
        0x10a58
    ],
    [
        0x10a60,
        0x10a9f
    ],
    [
        0x10ac0,
        0x10ae4
    ],
    [
        0x10aeb,
        0x10af6
    ],
    [
        0x10b00,
        0x10b35
    ],
    [
        0x10b39,
        0x10b55
    ],
    [
        0x10b58,
        0x10b72
    ],
    [
        0x10b78,
        0x10b91
    ],
    [
        0x10b99,
        0x10b9c
    ],
    [
        0x10ba9,
        0x10baf
    ],
    [
        0x10c00,
        0x10c48
    ],
    [
        0x10c80,
        0x10cb2
    ],
    [
        0x10cc0,
        0x10cf2
    ],
    [
        0x10cfa,
        0x10d23
    ],
    [
        0x10d30,
        0x10d39
    ],
    [
        0x10e60,
        0x10e7e
    ],
    [
        0x10e80,
        0x10ea9
    ],
    [
        0x10ead
    ],
    [
        0x10eb0,
        0x10eb1
    ],
    [
        0x10f00,
        0x10f27
    ],
    [
        0x10f30,
        0x10f45
    ],
    [
        0x10f51,
        0x10f59
    ],
    [
        0x10f70,
        0x10f81
    ],
    [
        0x10f86,
        0x10f89
    ],
    [
        0x10fb0,
        0x10fcb
    ],
    [
        0x10fe0,
        0x10ff6
    ],
    [
        0x11003,
        0x11037
    ],
    [
        0x11047,
        0x1104d
    ],
    [
        0x11052,
        0x1106f
    ],
    [
        0x11071,
        0x11072
    ],
    [
        0x11075
    ],
    [
        0x11083,
        0x110af
    ],
    [
        0x110bb,
        0x110bc
    ],
    [
        0x110be,
        0x110c1
    ],
    [
        0x110d0,
        0x110e8
    ],
    [
        0x110f0,
        0x110f9
    ],
    [
        0x11103,
        0x11126
    ],
    [
        0x11136,
        0x11144
    ],
    [
        0x11147
    ],
    [
        0x11150,
        0x11172
    ],
    [
        0x11174,
        0x11176
    ],
    [
        0x11183,
        0x111b2
    ],
    [
        0x111c1
    ],
    [
        0x111c4,
        0x111c8
    ],
    [
        0x111cd
    ],
    [
        0x111d0,
        0x111df
    ],
    [
        0x111e1,
        0x111f4
    ],
    [
        0x11200,
        0x11211
    ],
    [
        0x11213,
        0x1122b
    ],
    [
        0x11238,
        0x1123d
    ],
    [
        0x1123f,
        0x11240
    ],
    [
        0x11280,
        0x11286
    ],
    [
        0x11288
    ],
    [
        0x1128a,
        0x1128d
    ],
    [
        0x1128f,
        0x1129d
    ],
    [
        0x1129f,
        0x112a9
    ],
    [
        0x112b0,
        0x112de
    ],
    [
        0x112f0,
        0x112f9
    ],
    [
        0x11305,
        0x1130c
    ],
    [
        0x1130f,
        0x11310
    ],
    [
        0x11313,
        0x11328
    ],
    [
        0x1132a,
        0x11330
    ],
    [
        0x11332,
        0x11333
    ],
    [
        0x11335,
        0x11339
    ],
    [
        0x1133d
    ],
    [
        0x11350
    ],
    [
        0x1135d,
        0x11361
    ],
    [
        0x11400,
        0x11434
    ],
    [
        0x11447,
        0x1145b
    ],
    [
        0x1145d
    ],
    [
        0x1145f,
        0x11461
    ],
    [
        0x11480,
        0x114af
    ],
    [
        0x114c4,
        0x114c7
    ],
    [
        0x114d0,
        0x114d9
    ],
    [
        0x11580,
        0x115ae
    ],
    [
        0x115c1,
        0x115db
    ],
    [
        0x11600,
        0x1162f
    ],
    [
        0x11641,
        0x11644
    ],
    [
        0x11650,
        0x11659
    ],
    [
        0x11660,
        0x1166c
    ],
    [
        0x11680,
        0x116aa
    ],
    [
        0x116b8,
        0x116b9
    ],
    [
        0x116c0,
        0x116c9
    ],
    [
        0x11700,
        0x1171a
    ],
    [
        0x11730,
        0x11746
    ],
    [
        0x11800,
        0x1182b
    ],
    [
        0x1183b
    ],
    [
        0x118a0,
        0x118f2
    ],
    [
        0x118ff,
        0x11906
    ],
    [
        0x11909
    ],
    [
        0x1190c,
        0x11913
    ],
    [
        0x11915,
        0x11916
    ],
    [
        0x11918,
        0x1192f
    ],
    [
        0x11944,
        0x11946
    ],
    [
        0x11950,
        0x11959
    ],
    [
        0x119a0,
        0x119a7
    ],
    [
        0x119aa,
        0x119d0
    ],
    [
        0x119e1,
        0x119e3
    ],
    [
        0x11a00
    ],
    [
        0x11a0b,
        0x11a32
    ],
    [
        0x11a3f,
        0x11a46
    ],
    [
        0x11a50
    ],
    [
        0x11a5c,
        0x11a83
    ],
    [
        0x11a9a,
        0x11aa2
    ],
    [
        0x11ab0,
        0x11af8
    ],
    [
        0x11b00,
        0x11b09
    ],
    [
        0x11c00,
        0x11c08
    ],
    [
        0x11c0a,
        0x11c2e
    ],
    [
        0x11c40,
        0x11c45
    ],
    [
        0x11c50,
        0x11c6c
    ],
    [
        0x11c70,
        0x11c8f
    ],
    [
        0x11d00,
        0x11d06
    ],
    [
        0x11d08,
        0x11d09
    ],
    [
        0x11d0b,
        0x11d30
    ],
    [
        0x11d50,
        0x11d59
    ],
    [
        0x11d60,
        0x11d65
    ],
    [
        0x11d67,
        0x11d68
    ],
    [
        0x11d6a,
        0x11d89
    ],
    [
        0x11d98
    ],
    [
        0x11da0,
        0x11da9
    ],
    [
        0x11ee0,
        0x11ef2
    ],
    [
        0x11ef7,
        0x11ef8
    ],
    [
        0x11f04,
        0x11f10
    ],
    [
        0x11f12,
        0x11f33
    ],
    [
        0x11f43,
        0x11f59
    ],
    [
        0x11fb0
    ],
    [
        0x11fc0,
        0x11ff1
    ],
    [
        0x11fff,
        0x12399
    ],
    [
        0x12400,
        0x1246e
    ],
    [
        0x12470,
        0x12474
    ],
    [
        0x12480,
        0x12543
    ],
    [
        0x12f90,
        0x12ff2
    ],
    [
        0x13000,
        0x1342f
    ],
    [
        0x13441,
        0x13446
    ],
    [
        0x14400,
        0x14646
    ],
    [
        0x16800,
        0x16a38
    ],
    [
        0x16a40,
        0x16a5e
    ],
    [
        0x16a60,
        0x16a69
    ],
    [
        0x16a6e,
        0x16abe
    ],
    [
        0x16ac0,
        0x16ac9
    ],
    [
        0x16ad0,
        0x16aed
    ],
    [
        0x16af5
    ],
    [
        0x16b00,
        0x16b2f
    ],
    [
        0x16b37,
        0x16b45
    ],
    [
        0x16b50,
        0x16b59
    ],
    [
        0x16b5b,
        0x16b61
    ],
    [
        0x16b63,
        0x16b77
    ],
    [
        0x16b7d,
        0x16b8f
    ],
    [
        0x16e40,
        0x16e9a
    ],
    [
        0x16f00,
        0x16f4a
    ],
    [
        0x16f50
    ],
    [
        0x16f93,
        0x16f9f
    ],
    [
        0x16fe0,
        0x16fe3
    ],
    [
        0x17000
    ],
    [
        0x187f7
    ],
    [
        0x18800,
        0x18cd5
    ],
    [
        0x18d00
    ],
    [
        0x18d08
    ],
    [
        0x1aff0,
        0x1aff3
    ],
    [
        0x1aff5,
        0x1affb
    ],
    [
        0x1affd,
        0x1affe
    ],
    [
        0x1b000,
        0x1b122
    ],
    [
        0x1b132
    ],
    [
        0x1b150,
        0x1b152
    ],
    [
        0x1b155
    ],
    [
        0x1b164,
        0x1b167
    ],
    [
        0x1b170,
        0x1b2fb
    ],
    [
        0x1bc00,
        0x1bc6a
    ],
    [
        0x1bc70,
        0x1bc7c
    ],
    [
        0x1bc80,
        0x1bc88
    ],
    [
        0x1bc90,
        0x1bc99
    ],
    [
        0x1bc9c
    ],
    [
        0x1bc9f
    ],
    [
        0x1cf50,
        0x1cfc3
    ],
    [
        0x1d000,
        0x1d0f5
    ],
    [
        0x1d100,
        0x1d126
    ],
    [
        0x1d129,
        0x1d164
    ],
    [
        0x1d16a,
        0x1d16c
    ],
    [
        0x1d183,
        0x1d184
    ],
    [
        0x1d18c,
        0x1d1a9
    ],
    [
        0x1d1ae,
        0x1d1ea
    ],
    [
        0x1d200,
        0x1d241
    ],
    [
        0x1d245
    ],
    [
        0x1d2c0,
        0x1d2d3
    ],
    [
        0x1d2e0,
        0x1d2f3
    ],
    [
        0x1d300,
        0x1d356
    ],
    [
        0x1d360,
        0x1d378
    ],
    [
        0x1d400,
        0x1d454
    ],
    [
        0x1d456,
        0x1d49c
    ],
    [
        0x1d49e,
        0x1d49f
    ],
    [
        0x1d4a2
    ],
    [
        0x1d4a5,
        0x1d4a6
    ],
    [
        0x1d4a9,
        0x1d4ac
    ],
    [
        0x1d4ae,
        0x1d4b9
    ],
    [
        0x1d4bb
    ],
    [
        0x1d4bd,
        0x1d4c3
    ],
    [
        0x1d4c5,
        0x1d505
    ],
    [
        0x1d507,
        0x1d50a
    ],
    [
        0x1d50d,
        0x1d514
    ],
    [
        0x1d516,
        0x1d51c
    ],
    [
        0x1d51e,
        0x1d539
    ],
    [
        0x1d53b,
        0x1d53e
    ],
    [
        0x1d540,
        0x1d544
    ],
    [
        0x1d546
    ],
    [
        0x1d54a,
        0x1d550
    ],
    [
        0x1d552,
        0x1d6a5
    ],
    [
        0x1d6a8,
        0x1d7cb
    ],
    [
        0x1d7ce,
        0x1d9ff
    ],
    [
        0x1da37,
        0x1da3a
    ],
    [
        0x1da6d,
        0x1da74
    ],
    [
        0x1da76,
        0x1da83
    ],
    [
        0x1da85,
        0x1da8b
    ],
    [
        0x1df00,
        0x1df1e
    ],
    [
        0x1df25,
        0x1df2a
    ],
    [
        0x1e030,
        0x1e06d
    ],
    [
        0x1e100,
        0x1e12c
    ],
    [
        0x1e137,
        0x1e13d
    ],
    [
        0x1e140,
        0x1e149
    ],
    [
        0x1e14e,
        0x1e14f
    ],
    [
        0x1e290,
        0x1e2ad
    ],
    [
        0x1e2c0,
        0x1e2eb
    ],
    [
        0x1e2f0,
        0x1e2f9
    ],
    [
        0x1e2ff
    ],
    [
        0x1e4d0,
        0x1e4eb
    ],
    [
        0x1e4f0,
        0x1e4f9
    ],
    [
        0x1e7e0,
        0x1e7e6
    ],
    [
        0x1e7e8,
        0x1e7eb
    ],
    [
        0x1e7ed,
        0x1e7ee
    ],
    [
        0x1e7f0,
        0x1e7fe
    ],
    [
        0x1e800,
        0x1e8c4
    ],
    [
        0x1e8c7,
        0x1e8cf
    ],
    [
        0x1e900,
        0x1e943
    ],
    [
        0x1e94b
    ],
    [
        0x1e950,
        0x1e959
    ],
    [
        0x1e95e,
        0x1e95f
    ],
    [
        0x1ec71,
        0x1ecb4
    ],
    [
        0x1ed01,
        0x1ed3d
    ],
    [
        0x1ee00,
        0x1ee03
    ],
    [
        0x1ee05,
        0x1ee1f
    ],
    [
        0x1ee21,
        0x1ee22
    ],
    [
        0x1ee24
    ],
    [
        0x1ee27
    ],
    [
        0x1ee29,
        0x1ee32
    ],
    [
        0x1ee34,
        0x1ee37
    ],
    [
        0x1ee39
    ],
    [
        0x1ee3b
    ],
    [
        0x1ee42
    ],
    [
        0x1ee47
    ],
    [
        0x1ee49
    ],
    [
        0x1ee4b
    ],
    [
        0x1ee4d,
        0x1ee4f
    ],
    [
        0x1ee51,
        0x1ee52
    ],
    [
        0x1ee54
    ],
    [
        0x1ee57
    ],
    [
        0x1ee59
    ],
    [
        0x1ee5b
    ],
    [
        0x1ee5d
    ],
    [
        0x1ee5f
    ],
    [
        0x1ee61,
        0x1ee62
    ],
    [
        0x1ee64
    ],
    [
        0x1ee67,
        0x1ee6a
    ],
    [
        0x1ee6c,
        0x1ee72
    ],
    [
        0x1ee74,
        0x1ee77
    ],
    [
        0x1ee79,
        0x1ee7c
    ],
    [
        0x1ee7e
    ],
    [
        0x1ee80,
        0x1ee89
    ],
    [
        0x1ee8b,
        0x1ee9b
    ],
    [
        0x1eea1,
        0x1eea3
    ],
    [
        0x1eea5,
        0x1eea9
    ],
    [
        0x1eeab,
        0x1eebb
    ],
    [
        0x1eef0,
        0x1eef1
    ],
    [
        0x1f000,
        0x1f02b
    ],
    [
        0x1f030,
        0x1f093
    ],
    [
        0x1f0a0,
        0x1f0ae
    ],
    [
        0x1f0b1,
        0x1f0bf
    ],
    [
        0x1f0c1,
        0x1f0cf
    ],
    [
        0x1f0d1,
        0x1f0f5
    ],
    [
        0x1f100,
        0x1f1ad
    ],
    [
        0x1f200,
        0x1f202
    ],
    [
        0x1f210,
        0x1f23b
    ],
    [
        0x1f240,
        0x1f248
    ],
    [
        0x1f250,
        0x1f251
    ],
    [
        0x1f260,
        0x1f265
    ],
    [
        0x1f300,
        0x1f3fa
    ],
    [
        0x1f400,
        0x1f6d7
    ],
    [
        0x1f6dc,
        0x1f6ec
    ],
    [
        0x1f6f0,
        0x1f6fc
    ],
    [
        0x1f700,
        0x1f776
    ],
    [
        0x1f77b,
        0x1f7d9
    ],
    [
        0x1f7e0,
        0x1f7eb
    ],
    [
        0x1f7f0
    ],
    [
        0x1f800,
        0x1f80b
    ],
    [
        0x1f810,
        0x1f847
    ],
    [
        0x1f850,
        0x1f859
    ],
    [
        0x1f860,
        0x1f887
    ],
    [
        0x1f890,
        0x1f8ad
    ],
    [
        0x1f8b0,
        0x1f8b1
    ],
    [
        0x1f900,
        0x1fa53
    ],
    [
        0x1fa60,
        0x1fa6d
    ],
    [
        0x1fa70,
        0x1fa7c
    ],
    [
        0x1fa80,
        0x1fa88
    ],
    [
        0x1fa90,
        0x1fabd
    ],
    [
        0x1fabf,
        0x1fac5
    ],
    [
        0x1face,
        0x1fadb
    ],
    [
        0x1fae0,
        0x1fae8
    ],
    [
        0x1faf0,
        0x1faf8
    ],
    [
        0x1fb00,
        0x1fb92
    ],
    [
        0x1fb94,
        0x1fbca
    ],
    [
        0x1fbf0,
        0x1fbf9
    ],
    [
        0x20000
    ],
    [
        0x2a6df
    ],
    [
        0x2a700
    ],
    [
        0x2b739
    ],
    [
        0x2b740
    ],
    [
        0x2b81d
    ],
    [
        0x2b820
    ],
    [
        0x2cea1
    ],
    [
        0x2ceb0
    ],
    [
        0x2ebe0
    ],
    [
        0x2ebf0
    ],
    [
        0x2ee5d
    ],
    [
        0x2f800,
        0x2fa1d
    ],
    [
        0x30000
    ],
    [
        0x3134a
    ],
    [
        0x31350
    ],
    [
        0x323af
    ]
];
const autonomousDecomposableGraphemeRanges = [
    [
        0xc0,
        0xc5
    ],
    [
        0xc7,
        0xcf
    ],
    [
        0xd1,
        0xd6
    ],
    [
        0xd9,
        0xdd
    ],
    [
        0xe0,
        0xe5
    ],
    [
        0xe7,
        0xef
    ],
    [
        0xf1,
        0xf6
    ],
    [
        0xf9,
        0xfd
    ],
    [
        0xff,
        0x10f
    ],
    [
        0x112,
        0x125
    ],
    [
        0x128,
        0x130
    ],
    [
        0x134,
        0x137
    ],
    [
        0x139,
        0x13e
    ],
    [
        0x143,
        0x148
    ],
    [
        0x14c,
        0x151
    ],
    [
        0x154,
        0x165
    ],
    [
        0x168,
        0x17e
    ],
    [
        0x1a0,
        0x1a1
    ],
    [
        0x1af,
        0x1b0
    ],
    [
        0x1cd,
        0x1dc
    ],
    [
        0x1de,
        0x1e3
    ],
    [
        0x1e6,
        0x1f0
    ],
    [
        0x1f4,
        0x1f5
    ],
    [
        0x1f8,
        0x21b
    ],
    [
        0x21e,
        0x21f
    ],
    [
        0x226,
        0x233
    ],
    [
        0x385,
        0x386
    ],
    [
        0x388,
        0x38a
    ],
    [
        0x38c
    ],
    [
        0x38e,
        0x390
    ],
    [
        0x3aa,
        0x3b0
    ],
    [
        0x3ca,
        0x3ce
    ],
    [
        0x3d3,
        0x3d4
    ],
    [
        0x400,
        0x401
    ],
    [
        0x403
    ],
    [
        0x407
    ],
    [
        0x40c,
        0x40e
    ],
    [
        0x419
    ],
    [
        0x439
    ],
    [
        0x450,
        0x451
    ],
    [
        0x453
    ],
    [
        0x457
    ],
    [
        0x45c,
        0x45e
    ],
    [
        0x476,
        0x477
    ],
    [
        0x4c1,
        0x4c2
    ],
    [
        0x4d0,
        0x4d3
    ],
    [
        0x4d6,
        0x4d7
    ],
    [
        0x4da,
        0x4df
    ],
    [
        0x4e2,
        0x4e7
    ],
    [
        0x4ea,
        0x4f5
    ],
    [
        0x4f8,
        0x4f9
    ],
    [
        0x622,
        0x626
    ],
    [
        0x6c0
    ],
    [
        0x6c2
    ],
    [
        0x6d3
    ],
    [
        0x929
    ],
    [
        0x931
    ],
    [
        0x934
    ],
    [
        0x958,
        0x95f
    ],
    [
        0x9dc,
        0x9dd
    ],
    [
        0x9df
    ],
    [
        0xa33
    ],
    [
        0xa36
    ],
    [
        0xa59,
        0xa5b
    ],
    [
        0xa5e
    ],
    [
        0xb5c,
        0xb5d
    ],
    [
        0xb94
    ],
    [
        0xf43
    ],
    [
        0xf4d
    ],
    [
        0xf52
    ],
    [
        0xf57
    ],
    [
        0xf5c
    ],
    [
        0xf69
    ],
    [
        0x1026
    ],
    [
        0x1b06
    ],
    [
        0x1b08
    ],
    [
        0x1b0a
    ],
    [
        0x1b0c
    ],
    [
        0x1b0e
    ],
    [
        0x1b12
    ],
    [
        0x1e00,
        0x1e99
    ],
    [
        0x1e9b
    ],
    [
        0x1ea0,
        0x1ef9
    ],
    [
        0x1f00,
        0x1f15
    ],
    [
        0x1f18,
        0x1f1d
    ],
    [
        0x1f20,
        0x1f45
    ],
    [
        0x1f48,
        0x1f4d
    ],
    [
        0x1f50,
        0x1f57
    ],
    [
        0x1f59
    ],
    [
        0x1f5b
    ],
    [
        0x1f5d
    ],
    [
        0x1f5f,
        0x1f70
    ],
    [
        0x1f72
    ],
    [
        0x1f74
    ],
    [
        0x1f76
    ],
    [
        0x1f78
    ],
    [
        0x1f7a
    ],
    [
        0x1f7c
    ],
    [
        0x1f80,
        0x1fb4
    ],
    [
        0x1fb6,
        0x1fba
    ],
    [
        0x1fbc
    ],
    [
        0x1fc1,
        0x1fc4
    ],
    [
        0x1fc6,
        0x1fc8
    ],
    [
        0x1fca
    ],
    [
        0x1fcc,
        0x1fd2
    ],
    [
        0x1fd6,
        0x1fda
    ],
    [
        0x1fdd,
        0x1fe2
    ],
    [
        0x1fe4,
        0x1fea
    ],
    [
        0x1fec,
        0x1fed
    ],
    [
        0x1ff2,
        0x1ff4
    ],
    [
        0x1ff6,
        0x1ff8
    ],
    [
        0x1ffa
    ],
    [
        0x1ffc
    ],
    [
        0x219a,
        0x219b
    ],
    [
        0x21ae
    ],
    [
        0x21cd,
        0x21cf
    ],
    [
        0x2204
    ],
    [
        0x2209
    ],
    [
        0x220c
    ],
    [
        0x2224
    ],
    [
        0x2226
    ],
    [
        0x2241
    ],
    [
        0x2244
    ],
    [
        0x2247
    ],
    [
        0x2249
    ],
    [
        0x2260
    ],
    [
        0x2262
    ],
    [
        0x226d,
        0x2271
    ],
    [
        0x2274,
        0x2275
    ],
    [
        0x2278,
        0x2279
    ],
    [
        0x2280,
        0x2281
    ],
    [
        0x2284,
        0x2285
    ],
    [
        0x2288,
        0x2289
    ],
    [
        0x22ac,
        0x22af
    ],
    [
        0x22e0,
        0x22e3
    ],
    [
        0x22ea,
        0x22ed
    ],
    [
        0x2adc
    ],
    [
        0x304c
    ],
    [
        0x304e
    ],
    [
        0x3050
    ],
    [
        0x3052
    ],
    [
        0x3054
    ],
    [
        0x3056
    ],
    [
        0x3058
    ],
    [
        0x305a
    ],
    [
        0x305c
    ],
    [
        0x305e
    ],
    [
        0x3060
    ],
    [
        0x3062
    ],
    [
        0x3065
    ],
    [
        0x3067
    ],
    [
        0x3069
    ],
    [
        0x3070,
        0x3071
    ],
    [
        0x3073,
        0x3074
    ],
    [
        0x3076,
        0x3077
    ],
    [
        0x3079,
        0x307a
    ],
    [
        0x307c,
        0x307d
    ],
    [
        0x3094
    ],
    [
        0x309e
    ],
    [
        0x30ac
    ],
    [
        0x30ae
    ],
    [
        0x30b0
    ],
    [
        0x30b2
    ],
    [
        0x30b4
    ],
    [
        0x30b6
    ],
    [
        0x30b8
    ],
    [
        0x30ba
    ],
    [
        0x30bc
    ],
    [
        0x30be
    ],
    [
        0x30c0
    ],
    [
        0x30c2
    ],
    [
        0x30c5
    ],
    [
        0x30c7
    ],
    [
        0x30c9
    ],
    [
        0x30d0,
        0x30d1
    ],
    [
        0x30d3,
        0x30d4
    ],
    [
        0x30d6,
        0x30d7
    ],
    [
        0x30d9,
        0x30da
    ],
    [
        0x30dc,
        0x30dd
    ],
    [
        0x30f4
    ],
    [
        0x30f7,
        0x30fa
    ],
    [
        0x30fe
    ],
    [
        0xac00
    ],
    [
        0xd7a3
    ],
    [
        0xfb1d
    ],
    [
        0xfb1f
    ],
    [
        0xfb2a,
        0xfb36
    ],
    [
        0xfb38,
        0xfb3c
    ],
    [
        0xfb3e
    ],
    [
        0xfb40,
        0xfb41
    ],
    [
        0xfb43,
        0xfb44
    ],
    [
        0xfb46,
        0xfb4e
    ],
    [
        0x1109a
    ],
    [
        0x1109c
    ],
    [
        0x110ab
    ],
    [
        0x1d15e,
        0x1d164
    ],
    [
        0x1d1bb,
        0x1d1c0
    ]
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"bpTbY":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "convertGraphemeRangeToMapToConstantEntry", ()=>convertGraphemeRangeToMapToConstantEntry);
parcelHelpers.export(exports, "intersectGraphemeRanges", ()=>intersectGraphemeRanges);
var _globalsJs = require("../../../utils/globals.js");
const safeStringFromCodePoint = String.fromCodePoint;
const safeMathMin = Math.min;
const safeMathMax = Math.max;
function convertGraphemeRangeToMapToConstantEntry(range) {
    if (range.length === 1) {
        const codePointString = safeStringFromCodePoint(range[0]);
        return {
            num: 1,
            build: ()=>codePointString
        };
    }
    const rangeStart = range[0];
    return {
        num: range[1] - range[0] + 1,
        build: (idInGroup)=>safeStringFromCodePoint(rangeStart + idInGroup)
    };
}
function intersectGraphemeRanges(rangesA, rangesB) {
    const mergedRanges = [];
    let cursorA = 0;
    let cursorB = 0;
    while(cursorA < rangesA.length && cursorB < rangesB.length){
        const rangeA = rangesA[cursorA];
        const rangeAMin = rangeA[0];
        const rangeAMax = rangeA.length === 1 ? rangeA[0] : rangeA[1];
        const rangeB = rangesB[cursorB];
        const rangeBMin = rangeB[0];
        const rangeBMax = rangeB.length === 1 ? rangeB[0] : rangeB[1];
        if (rangeAMax < rangeBMin) cursorA += 1;
        else if (rangeBMax < rangeAMin) cursorB += 1;
        else {
            let min = safeMathMax(rangeAMin, rangeBMin);
            const max = safeMathMin(rangeAMax, rangeBMax);
            if (mergedRanges.length >= 1) {
                const lastMergedRange = mergedRanges[mergedRanges.length - 1];
                const lastMergedRangeMax = lastMergedRange.length === 1 ? lastMergedRange[0] : lastMergedRange[1];
                if (lastMergedRangeMax + 1 === min) {
                    min = lastMergedRange[0];
                    (0, _globalsJs.safePop)(mergedRanges);
                }
            }
            (0, _globalsJs.safePush)(mergedRanges, min === max ? [
                min
            ] : [
                min,
                max
            ]);
            if (rangeAMax <= max) cursorA += 1;
            if (rangeBMax <= max) cursorB += 1;
        }
    }
    return mergedRanges;
}

},{"../../../utils/globals.js":"aTuwn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"ekMgJ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterInvalidSubdomainLabel", ()=>filterInvalidSubdomainLabel);
function filterInvalidSubdomainLabel(subdomainLabel) {
    if (subdomainLabel.length > 63) return false;
    return subdomainLabel.length < 4 || subdomainLabel[0] !== 'x' || subdomainLabel[1] !== 'n' || subdomainLabel[2] !== '-' || subdomainLabel[3] !== '-';
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"95a4k":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "adapter", ()=>adapter);
var _arbitraryJs = require("../../check/arbitrary/definition/Arbitrary.js");
var _valueJs = require("../../check/arbitrary/definition/Value.js");
var _streamJs = require("../../stream/Stream.js");
const AdaptedValue = Symbol('adapted-value');
function toAdapterValue(rawValue, adapter) {
    const adapted = adapter(rawValue.value_);
    if (!adapted.adapted) return rawValue;
    return new (0, _valueJs.Value)(adapted.value, AdaptedValue);
}
class AdapterArbitrary extends (0, _arbitraryJs.Arbitrary) {
    constructor(sourceArb, adapter){
        super();
        this.sourceArb = sourceArb;
        this.adapter = adapter;
        this.adaptValue = (rawValue)=>toAdapterValue(rawValue, adapter);
    }
    generate(mrng, biasFactor) {
        const rawValue = this.sourceArb.generate(mrng, biasFactor);
        return this.adaptValue(rawValue);
    }
    canShrinkWithoutContext(value) {
        return this.sourceArb.canShrinkWithoutContext(value) && !this.adapter(value).adapted;
    }
    shrink(value, context) {
        if (context === AdaptedValue) {
            if (!this.sourceArb.canShrinkWithoutContext(value)) return (0, _streamJs.Stream).nil();
            return this.sourceArb.shrink(value, undefined).map(this.adaptValue);
        }
        return this.sourceArb.shrink(value, context).map(this.adaptValue);
    }
}
function adapter(sourceArb, adapter) {
    return new AdapterArbitrary(sourceArb, adapter);
}

},{"../../check/arbitrary/definition/Arbitrary.js":"e6f1K","../../check/arbitrary/definition/Value.js":"8Cf1j","../../stream/Stream.js":"2sjal","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"8I26L":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "double", ()=>double);
var _arrayInt64Js = require("./_internals/helpers/ArrayInt64.js");
var _arrayInt64ArbitraryJs = require("./_internals/ArrayInt64Arbitrary.js");
var _doubleHelpersJs = require("./_internals/helpers/DoubleHelpers.js");
var _doubleOnlyHelpersJs = require("./_internals/helpers/DoubleOnlyHelpers.js");
const safeNumberIsInteger = Number.isInteger;
const safeNumberIsNaN = Number.isNaN;
const safeNegativeInfinity = Number.NEGATIVE_INFINITY;
const safePositiveInfinity = Number.POSITIVE_INFINITY;
const safeMaxValue = Number.MAX_VALUE;
const safeNaN = Number.NaN;
function safeDoubleToIndex(d, constraintsLabel) {
    if (safeNumberIsNaN(d)) throw new Error('fc.double constraints.' + constraintsLabel + ' must be a 64-bit float');
    return (0, _doubleHelpersJs.doubleToIndex)(d);
}
function unmapperDoubleToIndex(value) {
    if (typeof value !== 'number') throw new Error('Unsupported type');
    return (0, _doubleHelpersJs.doubleToIndex)(value);
}
function numberIsNotInteger(value) {
    return !safeNumberIsInteger(value);
}
function anyDouble(constraints) {
    const { noDefaultInfinity = false, noNaN = false, minExcluded = false, maxExcluded = false, min = noDefaultInfinity ? -safeMaxValue : safeNegativeInfinity, max = noDefaultInfinity ? safeMaxValue : safePositiveInfinity } = constraints;
    const minIndexRaw = safeDoubleToIndex(min, 'min');
    const minIndex = minExcluded ? (0, _arrayInt64Js.add64)(minIndexRaw, (0, _arrayInt64Js.Unit64)) : minIndexRaw;
    const maxIndexRaw = safeDoubleToIndex(max, 'max');
    const maxIndex = maxExcluded ? (0, _arrayInt64Js.substract64)(maxIndexRaw, (0, _arrayInt64Js.Unit64)) : maxIndexRaw;
    if ((0, _arrayInt64Js.isStrictlySmaller64)(maxIndex, minIndex)) throw new Error('fc.double constraints.min must be smaller or equal to constraints.max');
    if (noNaN) return (0, _arrayInt64ArbitraryJs.arrayInt64)(minIndex, maxIndex).map((0, _doubleHelpersJs.indexToDouble), unmapperDoubleToIndex);
    const positiveMaxIdx = (0, _arrayInt64Js.isStrictlyPositive64)(maxIndex);
    const minIndexWithNaN = positiveMaxIdx ? minIndex : (0, _arrayInt64Js.substract64)(minIndex, (0, _arrayInt64Js.Unit64));
    const maxIndexWithNaN = positiveMaxIdx ? (0, _arrayInt64Js.add64)(maxIndex, (0, _arrayInt64Js.Unit64)) : maxIndex;
    return (0, _arrayInt64ArbitraryJs.arrayInt64)(minIndexWithNaN, maxIndexWithNaN).map((index)=>{
        if ((0, _arrayInt64Js.isStrictlySmaller64)(maxIndex, index) || (0, _arrayInt64Js.isStrictlySmaller64)(index, minIndex)) return safeNaN;
        else return (0, _doubleHelpersJs.indexToDouble)(index);
    }, (value)=>{
        if (typeof value !== 'number') throw new Error('Unsupported type');
        if (safeNumberIsNaN(value)) return !(0, _arrayInt64Js.isEqual64)(maxIndex, maxIndexWithNaN) ? maxIndexWithNaN : minIndexWithNaN;
        return (0, _doubleHelpersJs.doubleToIndex)(value);
    });
}
function double(constraints = {}) {
    if (!constraints.noInteger) return anyDouble(constraints);
    return anyDouble((0, _doubleOnlyHelpersJs.refineConstraintsForDoubleOnly)(constraints)).map((0, _doubleOnlyHelpersJs.doubleOnlyMapper), (0, _doubleOnlyHelpersJs.doubleOnlyUnmapper)).filter(numberIsNotInteger);
}

},{"./_internals/helpers/ArrayInt64.js":"av2DX","./_internals/ArrayInt64Arbitrary.js":"lBdQ9","./_internals/helpers/DoubleHelpers.js":"aQUsO","./_internals/helpers/DoubleOnlyHelpers.js":"6BZRS","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"av2DX":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Zero64", ()=>Zero64);
parcelHelpers.export(exports, "Unit64", ()=>Unit64);
parcelHelpers.export(exports, "isZero64", ()=>isZero64);
parcelHelpers.export(exports, "isStrictlyNegative64", ()=>isStrictlyNegative64);
parcelHelpers.export(exports, "isStrictlyPositive64", ()=>isStrictlyPositive64);
parcelHelpers.export(exports, "isEqual64", ()=>isEqual64);
parcelHelpers.export(exports, "isStrictlySmaller64", ()=>isStrictlySmaller64);
parcelHelpers.export(exports, "clone64", ()=>clone64);
parcelHelpers.export(exports, "substract64", ()=>substract64);
parcelHelpers.export(exports, "negative64", ()=>negative64);
parcelHelpers.export(exports, "add64", ()=>add64);
parcelHelpers.export(exports, "halve64", ()=>halve64);
parcelHelpers.export(exports, "logLike64", ()=>logLike64);
const Zero64 = {
    sign: 1,
    data: [
        0,
        0
    ]
};
const Unit64 = {
    sign: 1,
    data: [
        0,
        1
    ]
};
function isZero64(a) {
    return a.data[0] === 0 && a.data[1] === 0;
}
function isStrictlyNegative64(a) {
    return a.sign === -1 && !isZero64(a);
}
function isStrictlyPositive64(a) {
    return a.sign === 1 && !isZero64(a);
}
function isEqual64(a, b) {
    if (a.data[0] === b.data[0] && a.data[1] === b.data[1]) return a.sign === b.sign || a.data[0] === 0 && a.data[1] === 0;
    return false;
}
function isStrictlySmaller64Internal(a, b) {
    return a[0] < b[0] || a[0] === b[0] && a[1] < b[1];
}
function isStrictlySmaller64(a, b) {
    if (a.sign === b.sign) return a.sign === 1 ? isStrictlySmaller64Internal(a.data, b.data) : isStrictlySmaller64Internal(b.data, a.data);
    return a.sign === -1 && (!isZero64(a) || !isZero64(b));
}
function clone64(a) {
    return {
        sign: a.sign,
        data: [
            a.data[0],
            a.data[1]
        ]
    };
}
function substract64DataInternal(a, b) {
    let reminderLow = 0;
    let low = a[1] - b[1];
    if (low < 0) {
        reminderLow = 1;
        low = low >>> 0;
    }
    return [
        a[0] - b[0] - reminderLow,
        low
    ];
}
function substract64Internal(a, b) {
    if (a.sign === 1 && b.sign === -1) {
        const low = a.data[1] + b.data[1];
        const high = a.data[0] + b.data[0] + (low > 0xffffffff ? 1 : 0);
        return {
            sign: 1,
            data: [
                high >>> 0,
                low >>> 0
            ]
        };
    }
    return {
        sign: 1,
        data: a.sign === 1 ? substract64DataInternal(a.data, b.data) : substract64DataInternal(b.data, a.data)
    };
}
function substract64(arrayIntA, arrayIntB) {
    if (isStrictlySmaller64(arrayIntA, arrayIntB)) {
        const out = substract64Internal(arrayIntB, arrayIntA);
        out.sign = -1;
        return out;
    }
    return substract64Internal(arrayIntA, arrayIntB);
}
function negative64(arrayIntA) {
    return {
        sign: -arrayIntA.sign,
        data: [
            arrayIntA.data[0],
            arrayIntA.data[1]
        ]
    };
}
function add64(arrayIntA, arrayIntB) {
    if (isZero64(arrayIntB)) {
        if (isZero64(arrayIntA)) return clone64(Zero64);
        return clone64(arrayIntA);
    }
    return substract64(arrayIntA, negative64(arrayIntB));
}
function halve64(a) {
    return {
        sign: a.sign,
        data: [
            Math.floor(a.data[0] / 2),
            (a.data[0] % 2 === 1 ? 0x80000000 : 0) + Math.floor(a.data[1] / 2)
        ]
    };
}
function logLike64(a) {
    return {
        sign: a.sign,
        data: [
            0,
            Math.floor(Math.log(a.data[0] * 0x100000000 + a.data[1]) / Math.log(2))
        ]
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"lBdQ9":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "arrayInt64", ()=>arrayInt64);
var _streamJs = require("../../stream/Stream.js");
var _arbitraryJs = require("../../check/arbitrary/definition/Arbitrary.js");
var _valueJs = require("../../check/arbitrary/definition/Value.js");
var _arrayInt64Js = require("./helpers/ArrayInt64.js");
class ArrayInt64Arbitrary extends (0, _arbitraryJs.Arbitrary) {
    constructor(min, max){
        super();
        this.min = min;
        this.max = max;
        this.biasedRanges = null;
    }
    generate(mrng, biasFactor) {
        const range = this.computeGenerateRange(mrng, biasFactor);
        const uncheckedValue = mrng.nextArrayInt(range.min, range.max);
        if (uncheckedValue.data.length === 1) uncheckedValue.data.unshift(0);
        return new (0, _valueJs.Value)(uncheckedValue, undefined);
    }
    computeGenerateRange(mrng, biasFactor) {
        if (biasFactor === undefined || mrng.nextInt(1, biasFactor) !== 1) return {
            min: this.min,
            max: this.max
        };
        const ranges = this.retrieveBiasedRanges();
        if (ranges.length === 1) return ranges[0];
        const id = mrng.nextInt(-2 * (ranges.length - 1), ranges.length - 2);
        return id < 0 ? ranges[0] : ranges[id + 1];
    }
    canShrinkWithoutContext(value) {
        const unsafeValue = value;
        return typeof value === 'object' && value !== null && (unsafeValue.sign === -1 || unsafeValue.sign === 1) && Array.isArray(unsafeValue.data) && unsafeValue.data.length === 2 && ((0, _arrayInt64Js.isStrictlySmaller64)(this.min, unsafeValue) && (0, _arrayInt64Js.isStrictlySmaller64)(unsafeValue, this.max) || (0, _arrayInt64Js.isEqual64)(this.min, unsafeValue) || (0, _arrayInt64Js.isEqual64)(this.max, unsafeValue));
    }
    shrinkArrayInt64(value, target, tryTargetAsap) {
        const realGap = (0, _arrayInt64Js.substract64)(value, target);
        function* shrinkGen() {
            let previous = tryTargetAsap ? undefined : target;
            const gap = tryTargetAsap ? realGap : (0, _arrayInt64Js.halve64)(realGap);
            for(let toremove = gap; !(0, _arrayInt64Js.isZero64)(toremove); toremove = (0, _arrayInt64Js.halve64)(toremove)){
                const next = (0, _arrayInt64Js.substract64)(value, toremove);
                yield new (0, _valueJs.Value)(next, previous);
                previous = next;
            }
        }
        return (0, _streamJs.stream)(shrinkGen());
    }
    shrink(current, context) {
        if (!ArrayInt64Arbitrary.isValidContext(current, context)) {
            const target = this.defaultTarget();
            return this.shrinkArrayInt64(current, target, true);
        }
        if (this.isLastChanceTry(current, context)) return (0, _streamJs.Stream).of(new (0, _valueJs.Value)(context, undefined));
        return this.shrinkArrayInt64(current, context, false);
    }
    defaultTarget() {
        if (!(0, _arrayInt64Js.isStrictlyPositive64)(this.min) && !(0, _arrayInt64Js.isStrictlyNegative64)(this.max)) return 0, _arrayInt64Js.Zero64;
        return (0, _arrayInt64Js.isStrictlyNegative64)(this.min) ? this.max : this.min;
    }
    isLastChanceTry(current, context) {
        if ((0, _arrayInt64Js.isZero64)(current)) return false;
        if (current.sign === 1) return (0, _arrayInt64Js.isEqual64)(current, (0, _arrayInt64Js.add64)(context, (0, _arrayInt64Js.Unit64))) && (0, _arrayInt64Js.isStrictlyPositive64)((0, _arrayInt64Js.substract64)(current, this.min));
        else return (0, _arrayInt64Js.isEqual64)(current, (0, _arrayInt64Js.substract64)(context, (0, _arrayInt64Js.Unit64))) && (0, _arrayInt64Js.isStrictlyNegative64)((0, _arrayInt64Js.substract64)(current, this.max));
    }
    static isValidContext(_current, context) {
        if (context === undefined) return false;
        if (typeof context !== 'object' || context === null || !('sign' in context) || !('data' in context)) throw new Error(`Invalid context type passed to ArrayInt64Arbitrary (#1)`);
        return true;
    }
    retrieveBiasedRanges() {
        if (this.biasedRanges != null) return this.biasedRanges;
        if ((0, _arrayInt64Js.isEqual64)(this.min, this.max)) {
            this.biasedRanges = [
                {
                    min: this.min,
                    max: this.max
                }
            ];
            return this.biasedRanges;
        }
        const minStrictlySmallerZero = (0, _arrayInt64Js.isStrictlyNegative64)(this.min);
        const maxStrictlyGreaterZero = (0, _arrayInt64Js.isStrictlyPositive64)(this.max);
        if (minStrictlySmallerZero && maxStrictlyGreaterZero) {
            const logMin = (0, _arrayInt64Js.logLike64)(this.min);
            const logMax = (0, _arrayInt64Js.logLike64)(this.max);
            this.biasedRanges = [
                {
                    min: logMin,
                    max: logMax
                },
                {
                    min: (0, _arrayInt64Js.substract64)(this.max, logMax),
                    max: this.max
                },
                {
                    min: this.min,
                    max: (0, _arrayInt64Js.substract64)(this.min, logMin)
                }
            ];
        } else {
            const logGap = (0, _arrayInt64Js.logLike64)((0, _arrayInt64Js.substract64)(this.max, this.min));
            const arbCloseToMin = {
                min: this.min,
                max: (0, _arrayInt64Js.add64)(this.min, logGap)
            };
            const arbCloseToMax = {
                min: (0, _arrayInt64Js.substract64)(this.max, logGap),
                max: this.max
            };
            this.biasedRanges = minStrictlySmallerZero ? [
                arbCloseToMax,
                arbCloseToMin
            ] : [
                arbCloseToMin,
                arbCloseToMax
            ];
        }
        return this.biasedRanges;
    }
}
function arrayInt64(min, max) {
    const arb = new ArrayInt64Arbitrary(min, max);
    return arb;
}

},{"../../stream/Stream.js":"2sjal","../../check/arbitrary/definition/Arbitrary.js":"e6f1K","../../check/arbitrary/definition/Value.js":"8Cf1j","./helpers/ArrayInt64.js":"av2DX","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"aQUsO":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "decomposeDouble", ()=>decomposeDouble);
parcelHelpers.export(exports, "doubleToIndex", ()=>doubleToIndex);
parcelHelpers.export(exports, "indexToDouble", ()=>indexToDouble);
var _arrayInt64Js = require("./ArrayInt64.js");
const safeNegativeInfinity = Number.NEGATIVE_INFINITY;
const safePositiveInfinity = Number.POSITIVE_INFINITY;
const safeEpsilon = Number.EPSILON;
const INDEX_POSITIVE_INFINITY = {
    sign: 1,
    data: [
        2146435072,
        0
    ]
};
const INDEX_NEGATIVE_INFINITY = {
    sign: -1,
    data: [
        2146435072,
        1
    ]
};
const f64 = new Float64Array(1);
const u32 = new Uint32Array(f64.buffer, f64.byteOffset);
function bitCastDoubleToUInt64(f) {
    f64[0] = f;
    return [
        u32[1],
        u32[0]
    ];
}
function decomposeDouble(d) {
    const { 0: hi, 1: lo } = bitCastDoubleToUInt64(d);
    const signBit = hi >>> 31;
    const exponentBits = hi >>> 20 & 0x7ff;
    const significandBits = (hi & 0xfffff) * 0x100000000 + lo;
    const exponent = exponentBits === 0 ? -1022 : exponentBits - 1023;
    let significand = exponentBits === 0 ? 0 : 1;
    significand += significandBits / 2 ** 52;
    significand *= signBit === 0 ? 1 : -1;
    return {
        exponent,
        significand
    };
}
function positiveNumberToInt64(n) {
    return [
        ~~(n / 0x100000000),
        n >>> 0
    ];
}
function indexInDoubleFromDecomp(exponent, significand) {
    if (exponent === -1022) {
        const rescaledSignificand = significand * 2 ** 52;
        return positiveNumberToInt64(rescaledSignificand);
    }
    const rescaledSignificand = (significand - 1) * 2 ** 52;
    const exponentOnlyHigh = (exponent + 1023) * 2 ** 20;
    const index = positiveNumberToInt64(rescaledSignificand);
    index[0] += exponentOnlyHigh;
    return index;
}
function doubleToIndex(d) {
    if (d === safePositiveInfinity) return (0, _arrayInt64Js.clone64)(INDEX_POSITIVE_INFINITY);
    if (d === safeNegativeInfinity) return (0, _arrayInt64Js.clone64)(INDEX_NEGATIVE_INFINITY);
    const decomp = decomposeDouble(d);
    const exponent = decomp.exponent;
    const significand = decomp.significand;
    if (d > 0 || d === 0 && 1 / d === safePositiveInfinity) return {
        sign: 1,
        data: indexInDoubleFromDecomp(exponent, significand)
    };
    else {
        const indexOpposite = indexInDoubleFromDecomp(exponent, -significand);
        if (indexOpposite[1] === 0xffffffff) {
            indexOpposite[0] += 1;
            indexOpposite[1] = 0;
        } else indexOpposite[1] += 1;
        return {
            sign: -1,
            data: indexOpposite
        };
    }
}
function indexToDouble(index) {
    if (index.sign === -1) {
        const indexOpposite = {
            sign: 1,
            data: [
                index.data[0],
                index.data[1]
            ]
        };
        if (indexOpposite.data[1] === 0) {
            indexOpposite.data[0] -= 1;
            indexOpposite.data[1] = 0xffffffff;
        } else indexOpposite.data[1] -= 1;
        return -indexToDouble(indexOpposite);
    }
    if ((0, _arrayInt64Js.isEqual64)(index, INDEX_POSITIVE_INFINITY)) return safePositiveInfinity;
    if (index.data[0] < 0x200000) return (index.data[0] * 0x100000000 + index.data[1]) * 2 ** -1074;
    const postIndexHigh = index.data[0] - 0x200000;
    const exponent = -1021 + (postIndexHigh >> 20);
    const significand = 1 + ((postIndexHigh & 0xfffff) * 2 ** 32 + index.data[1]) * safeEpsilon;
    return significand * 2 ** exponent;
}

},{"./ArrayInt64.js":"av2DX","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"6BZRS":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "maxNonIntegerValue", ()=>maxNonIntegerValue);
parcelHelpers.export(exports, "onlyIntegersAfterThisValue", ()=>onlyIntegersAfterThisValue);
parcelHelpers.export(exports, "refineConstraintsForDoubleOnly", ()=>refineConstraintsForDoubleOnly);
parcelHelpers.export(exports, "doubleOnlyMapper", ()=>doubleOnlyMapper);
parcelHelpers.export(exports, "doubleOnlyUnmapper", ()=>doubleOnlyUnmapper);
var _floatingOnlyHelpersJs = require("./FloatingOnlyHelpers.js");
const safeNegativeInfinity = Number.NEGATIVE_INFINITY;
const safePositiveInfinity = Number.POSITIVE_INFINITY;
const safeMaxValue = Number.MAX_VALUE;
const maxNonIntegerValue = 4503599627370495.5;
const onlyIntegersAfterThisValue = 4503599627370496;
function refineConstraintsForDoubleOnly(constraints) {
    return (0, _floatingOnlyHelpersJs.refineConstraintsForFloatingOnly)(constraints, safeMaxValue, maxNonIntegerValue, onlyIntegersAfterThisValue);
}
function doubleOnlyMapper(value) {
    return value === onlyIntegersAfterThisValue ? safePositiveInfinity : value === -onlyIntegersAfterThisValue ? safeNegativeInfinity : value;
}
function doubleOnlyUnmapper(value) {
    if (typeof value !== 'number') throw new Error('Unsupported type');
    return value === safePositiveInfinity ? onlyIntegersAfterThisValue : value === safeNegativeInfinity ? -onlyIntegersAfterThisValue : value;
}

},{"./FloatingOnlyHelpers.js":"8HpJn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"8HpJn":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "refineConstraintsForFloatingOnly", ()=>refineConstraintsForFloatingOnly);
const safeNumberIsInteger = Number.isInteger;
const safeObjectIs = Object.is;
const safeNegativeInfinity = Number.NEGATIVE_INFINITY;
const safePositiveInfinity = Number.POSITIVE_INFINITY;
function refineConstraintsForFloatingOnly(constraints, maxValue, maxNonIntegerValue, onlyIntegersAfterThisValue) {
    const { noDefaultInfinity = false, minExcluded = false, maxExcluded = false, min = noDefaultInfinity ? -maxValue : safeNegativeInfinity, max = noDefaultInfinity ? maxValue : safePositiveInfinity } = constraints;
    const effectiveMin = minExcluded ? min < -maxNonIntegerValue ? -onlyIntegersAfterThisValue : Math.max(min, -maxNonIntegerValue) : min === safeNegativeInfinity ? Math.max(min, -onlyIntegersAfterThisValue) : Math.max(min, -maxNonIntegerValue);
    const effectiveMax = maxExcluded ? max > maxNonIntegerValue ? onlyIntegersAfterThisValue : Math.min(max, maxNonIntegerValue) : max === safePositiveInfinity ? Math.min(max, onlyIntegersAfterThisValue) : Math.min(max, maxNonIntegerValue);
    const fullConstraints = {
        noDefaultInfinity: false,
        minExcluded: minExcluded || (min !== safeNegativeInfinity || minExcluded) && safeNumberIsInteger(effectiveMin),
        maxExcluded: maxExcluded || (max !== safePositiveInfinity || maxExcluded) && safeNumberIsInteger(effectiveMax),
        min: safeObjectIs(effectiveMin, -0) ? 0 : effectiveMin,
        max: safeObjectIs(effectiveMax, 0) ? -0 : effectiveMax,
        noNaN: constraints.noNaN || false
    };
    return fullConstraints;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"4Tn1Y":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "float", ()=>float);
var _integerJs = require("./integer.js");
var _floatHelpersJs = require("./_internals/helpers/FloatHelpers.js");
var _floatOnlyHelpersJs = require("./_internals/helpers/FloatOnlyHelpers.js");
const safeNumberIsInteger = Number.isInteger;
const safeNumberIsNaN = Number.isNaN;
const safeMathFround = Math.fround;
const safeNegativeInfinity = Number.NEGATIVE_INFINITY;
const safePositiveInfinity = Number.POSITIVE_INFINITY;
const safeNaN = Number.NaN;
function safeFloatToIndex(f, constraintsLabel) {
    const conversionTrick = 'you can convert any double to a 32-bit float by using `Math.fround(myDouble)`';
    const errorMessage = 'fc.float constraints.' + constraintsLabel + ' must be a 32-bit float - ' + conversionTrick;
    if (safeNumberIsNaN(f) || safeMathFround(f) !== f) throw new Error(errorMessage);
    return (0, _floatHelpersJs.floatToIndex)(f);
}
function unmapperFloatToIndex(value) {
    if (typeof value !== 'number') throw new Error('Unsupported type');
    return (0, _floatHelpersJs.floatToIndex)(value);
}
function numberIsNotInteger(value) {
    return !safeNumberIsInteger(value);
}
function anyFloat(constraints) {
    const { noDefaultInfinity = false, noNaN = false, minExcluded = false, maxExcluded = false, min = noDefaultInfinity ? -(0, _floatHelpersJs.MAX_VALUE_32) : safeNegativeInfinity, max = noDefaultInfinity ? (0, _floatHelpersJs.MAX_VALUE_32) : safePositiveInfinity } = constraints;
    const minIndexRaw = safeFloatToIndex(min, 'min');
    const minIndex = minExcluded ? minIndexRaw + 1 : minIndexRaw;
    const maxIndexRaw = safeFloatToIndex(max, 'max');
    const maxIndex = maxExcluded ? maxIndexRaw - 1 : maxIndexRaw;
    if (minIndex > maxIndex) throw new Error('fc.float constraints.min must be smaller or equal to constraints.max');
    if (noNaN) return (0, _integerJs.integer)({
        min: minIndex,
        max: maxIndex
    }).map((0, _floatHelpersJs.indexToFloat), unmapperFloatToIndex);
    const minIndexWithNaN = maxIndex > 0 ? minIndex : minIndex - 1;
    const maxIndexWithNaN = maxIndex > 0 ? maxIndex + 1 : maxIndex;
    return (0, _integerJs.integer)({
        min: minIndexWithNaN,
        max: maxIndexWithNaN
    }).map((index)=>{
        if (index > maxIndex || index < minIndex) return safeNaN;
        else return (0, _floatHelpersJs.indexToFloat)(index);
    }, (value)=>{
        if (typeof value !== 'number') throw new Error('Unsupported type');
        if (safeNumberIsNaN(value)) return maxIndex !== maxIndexWithNaN ? maxIndexWithNaN : minIndexWithNaN;
        return (0, _floatHelpersJs.floatToIndex)(value);
    });
}
function float(constraints = {}) {
    if (!constraints.noInteger) return anyFloat(constraints);
    return anyFloat((0, _floatOnlyHelpersJs.refineConstraintsForFloatOnly)(constraints)).map((0, _floatOnlyHelpersJs.floatOnlyMapper), (0, _floatOnlyHelpersJs.floatOnlyUnmapper)).filter(numberIsNotInteger);
}

},{"./integer.js":"embjo","./_internals/helpers/FloatHelpers.js":"dON2o","./_internals/helpers/FloatOnlyHelpers.js":"cYqDZ","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"dON2o":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MIN_VALUE_32", ()=>MIN_VALUE_32);
parcelHelpers.export(exports, "MAX_VALUE_32", ()=>MAX_VALUE_32);
parcelHelpers.export(exports, "EPSILON_32", ()=>EPSILON_32);
parcelHelpers.export(exports, "decomposeFloat", ()=>decomposeFloat);
parcelHelpers.export(exports, "floatToIndex", ()=>floatToIndex);
parcelHelpers.export(exports, "indexToFloat", ()=>indexToFloat);
const safeNegativeInfinity = Number.NEGATIVE_INFINITY;
const safePositiveInfinity = Number.POSITIVE_INFINITY;
const MIN_VALUE_32 = 2 ** -126 * 2 ** -23;
const MAX_VALUE_32 = 2 ** 127 * (1 + (2 ** 23 - 1) / 2 ** 23);
const EPSILON_32 = 2 ** -23;
const INDEX_POSITIVE_INFINITY = 2139095040;
const INDEX_NEGATIVE_INFINITY = -2139095041;
const f32 = new Float32Array(1);
const u32 = new Uint32Array(f32.buffer, f32.byteOffset);
function bitCastFloatToUInt32(f) {
    f32[0] = f;
    return u32[0];
}
function decomposeFloat(f) {
    const bits = bitCastFloatToUInt32(f);
    const signBit = bits >>> 31;
    const exponentBits = bits >>> 23 & 0xff;
    const significandBits = bits & 0x7fffff;
    const exponent = exponentBits === 0 ? -126 : exponentBits - 127;
    let significand = exponentBits === 0 ? 0 : 1;
    significand += significandBits / 2 ** 23;
    significand *= signBit === 0 ? 1 : -1;
    return {
        exponent,
        significand
    };
}
function indexInFloatFromDecomp(exponent, significand) {
    if (exponent === -126) return significand * 0x800000;
    return (exponent + 127) * 0x800000 + (significand - 1) * 0x800000;
}
function floatToIndex(f) {
    if (f === safePositiveInfinity) return INDEX_POSITIVE_INFINITY;
    if (f === safeNegativeInfinity) return INDEX_NEGATIVE_INFINITY;
    const decomp = decomposeFloat(f);
    const exponent = decomp.exponent;
    const significand = decomp.significand;
    if (f > 0 || f === 0 && 1 / f === safePositiveInfinity) return indexInFloatFromDecomp(exponent, significand);
    else return -indexInFloatFromDecomp(exponent, -significand) - 1;
}
function indexToFloat(index) {
    if (index < 0) return -indexToFloat(-index - 1);
    if (index === INDEX_POSITIVE_INFINITY) return safePositiveInfinity;
    if (index < 0x1000000) return index * 2 ** -149;
    const postIndex = index - 0x1000000;
    const exponent = -125 + (postIndex >> 23);
    const significand = 1 + (postIndex & 0x7fffff) / 0x800000;
    return significand * 2 ** exponent;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"cYqDZ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "maxNonIntegerValue", ()=>maxNonIntegerValue);
parcelHelpers.export(exports, "onlyIntegersAfterThisValue", ()=>onlyIntegersAfterThisValue);
parcelHelpers.export(exports, "refineConstraintsForFloatOnly", ()=>refineConstraintsForFloatOnly);
parcelHelpers.export(exports, "floatOnlyMapper", ()=>floatOnlyMapper);
parcelHelpers.export(exports, "floatOnlyUnmapper", ()=>floatOnlyUnmapper);
var _floatHelpersJs = require("./FloatHelpers.js");
var _floatingOnlyHelpersJs = require("./FloatingOnlyHelpers.js");
const safeNegativeInfinity = Number.NEGATIVE_INFINITY;
const safePositiveInfinity = Number.POSITIVE_INFINITY;
const safeMaxValue = (0, _floatHelpersJs.MAX_VALUE_32);
const maxNonIntegerValue = 8388607.5;
const onlyIntegersAfterThisValue = 8388608;
function refineConstraintsForFloatOnly(constraints) {
    return (0, _floatingOnlyHelpersJs.refineConstraintsForFloatingOnly)(constraints, safeMaxValue, maxNonIntegerValue, onlyIntegersAfterThisValue);
}
function floatOnlyMapper(value) {
    return value === onlyIntegersAfterThisValue ? safePositiveInfinity : value === -onlyIntegersAfterThisValue ? safeNegativeInfinity : value;
}
function floatOnlyUnmapper(value) {
    if (typeof value !== 'number') throw new Error('Unsupported type');
    return value === safePositiveInfinity ? onlyIntegersAfterThisValue : value === safeNegativeInfinity ? -onlyIntegersAfterThisValue : value;
}

},{"./FloatHelpers.js":"dON2o","./FloatingOnlyHelpers.js":"8HpJn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"iuKCt":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "compareBooleanFunc", ()=>compareBooleanFunc);
var _compareFunctionArbitraryBuilderJs = require("./_internals/builders/CompareFunctionArbitraryBuilder.js");
const safeObjectAssign = Object.assign;
function compareBooleanFunc() {
    return (0, _compareFunctionArbitraryBuilderJs.buildCompareFunctionArbitrary)(safeObjectAssign((hA, hB)=>hA < hB, {
        toString () {
            return '(hA, hB) => hA < hB';
        }
    }));
}

},{"./_internals/builders/CompareFunctionArbitraryBuilder.js":"bgPn1","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"bgPn1":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "buildCompareFunctionArbitrary", ()=>buildCompareFunctionArbitrary);
var _textEscaperJs = require("../helpers/TextEscaper.js");
var _symbolsJs = require("../../../check/symbols.js");
var _hashJs = require("../../../utils/hash.js");
var _stringifyJs = require("../../../utils/stringify.js");
var _integerJs = require("../../integer.js");
var _noShrinkJs = require("../../noShrink.js");
var _tupleJs = require("../../tuple.js");
var _globalsJs = require("../../../utils/globals.js");
const safeObjectAssign = Object.assign;
const safeObjectKeys = Object.keys;
function buildCompareFunctionArbitrary(cmp) {
    return (0, _tupleJs.tuple)((0, _noShrinkJs.noShrink)((0, _integerJs.integer)()), (0, _noShrinkJs.noShrink)((0, _integerJs.integer)({
        min: 1,
        max: 0xffffffff
    }))).map(([seed, hashEnvSize])=>{
        const producer = ()=>{
            const recorded = {};
            const f = (a, b)=>{
                const reprA = (0, _stringifyJs.stringify)(a);
                const reprB = (0, _stringifyJs.stringify)(b);
                const hA = (0, _hashJs.hash)(`${seed}${reprA}`) % hashEnvSize;
                const hB = (0, _hashJs.hash)(`${seed}${reprB}`) % hashEnvSize;
                const val = cmp(hA, hB);
                recorded[`[${reprA},${reprB}]`] = val;
                return val;
            };
            return safeObjectAssign(f, {
                toString: ()=>{
                    const seenValues = safeObjectKeys(recorded).sort().map((k)=>`${k} => ${(0, _stringifyJs.stringify)(recorded[k])}`).map((line)=>`/* ${(0, _textEscaperJs.escapeForMultilineComments)(line)} */`);
                    return `function(a, b) {
  // With hash and stringify coming from fast-check${seenValues.length !== 0 ? `\n  ${(0, _globalsJs.safeJoin)(seenValues, '\n  ')}` : ''}
  const cmp = ${cmp};
  const hA = hash('${seed}' + stringify(a)) % ${hashEnvSize};
  const hB = hash('${seed}' + stringify(b)) % ${hashEnvSize};
  return cmp(hA, hB);
}`;
                },
                [(0, _symbolsJs.cloneMethod)]: producer
            });
        };
        return producer();
    });
}

},{"../helpers/TextEscaper.js":"fSa3V","../../../check/symbols.js":"2AK80","../../../utils/hash.js":"6kEiE","../../../utils/stringify.js":"gOa8u","../../integer.js":"embjo","../../noShrink.js":"iaGEG","../../tuple.js":"dw0Pn","../../../utils/globals.js":"aTuwn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"fSa3V":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "escapeForTemplateString", ()=>escapeForTemplateString);
parcelHelpers.export(exports, "escapeForMultilineComments", ()=>escapeForMultilineComments);
function escapeForTemplateString(originalText) {
    return originalText.replace(/([$`\\])/g, '\\$1').replace(/\r/g, '\\r');
}
function escapeForMultilineComments(originalText) {
    return originalText.replace(/\*\//g, '*\\/');
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"6kEiE":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "hash", ()=>hash);
var _globalsJs = require("./globals.js");
const crc32Table = [
    0x00000000,
    0x77073096,
    0xee0e612c,
    0x990951ba,
    0x076dc419,
    0x706af48f,
    0xe963a535,
    0x9e6495a3,
    0x0edb8832,
    0x79dcb8a4,
    0xe0d5e91e,
    0x97d2d988,
    0x09b64c2b,
    0x7eb17cbd,
    0xe7b82d07,
    0x90bf1d91,
    0x1db71064,
    0x6ab020f2,
    0xf3b97148,
    0x84be41de,
    0x1adad47d,
    0x6ddde4eb,
    0xf4d4b551,
    0x83d385c7,
    0x136c9856,
    0x646ba8c0,
    0xfd62f97a,
    0x8a65c9ec,
    0x14015c4f,
    0x63066cd9,
    0xfa0f3d63,
    0x8d080df5,
    0x3b6e20c8,
    0x4c69105e,
    0xd56041e4,
    0xa2677172,
    0x3c03e4d1,
    0x4b04d447,
    0xd20d85fd,
    0xa50ab56b,
    0x35b5a8fa,
    0x42b2986c,
    0xdbbbc9d6,
    0xacbcf940,
    0x32d86ce3,
    0x45df5c75,
    0xdcd60dcf,
    0xabd13d59,
    0x26d930ac,
    0x51de003a,
    0xc8d75180,
    0xbfd06116,
    0x21b4f4b5,
    0x56b3c423,
    0xcfba9599,
    0xb8bda50f,
    0x2802b89e,
    0x5f058808,
    0xc60cd9b2,
    0xb10be924,
    0x2f6f7c87,
    0x58684c11,
    0xc1611dab,
    0xb6662d3d,
    0x76dc4190,
    0x01db7106,
    0x98d220bc,
    0xefd5102a,
    0x71b18589,
    0x06b6b51f,
    0x9fbfe4a5,
    0xe8b8d433,
    0x7807c9a2,
    0x0f00f934,
    0x9609a88e,
    0xe10e9818,
    0x7f6a0dbb,
    0x086d3d2d,
    0x91646c97,
    0xe6635c01,
    0x6b6b51f4,
    0x1c6c6162,
    0x856530d8,
    0xf262004e,
    0x6c0695ed,
    0x1b01a57b,
    0x8208f4c1,
    0xf50fc457,
    0x65b0d9c6,
    0x12b7e950,
    0x8bbeb8ea,
    0xfcb9887c,
    0x62dd1ddf,
    0x15da2d49,
    0x8cd37cf3,
    0xfbd44c65,
    0x4db26158,
    0x3ab551ce,
    0xa3bc0074,
    0xd4bb30e2,
    0x4adfa541,
    0x3dd895d7,
    0xa4d1c46d,
    0xd3d6f4fb,
    0x4369e96a,
    0x346ed9fc,
    0xad678846,
    0xda60b8d0,
    0x44042d73,
    0x33031de5,
    0xaa0a4c5f,
    0xdd0d7cc9,
    0x5005713c,
    0x270241aa,
    0xbe0b1010,
    0xc90c2086,
    0x5768b525,
    0x206f85b3,
    0xb966d409,
    0xce61e49f,
    0x5edef90e,
    0x29d9c998,
    0xb0d09822,
    0xc7d7a8b4,
    0x59b33d17,
    0x2eb40d81,
    0xb7bd5c3b,
    0xc0ba6cad,
    0xedb88320,
    0x9abfb3b6,
    0x03b6e20c,
    0x74b1d29a,
    0xead54739,
    0x9dd277af,
    0x04db2615,
    0x73dc1683,
    0xe3630b12,
    0x94643b84,
    0x0d6d6a3e,
    0x7a6a5aa8,
    0xe40ecf0b,
    0x9309ff9d,
    0x0a00ae27,
    0x7d079eb1,
    0xf00f9344,
    0x8708a3d2,
    0x1e01f268,
    0x6906c2fe,
    0xf762575d,
    0x806567cb,
    0x196c3671,
    0x6e6b06e7,
    0xfed41b76,
    0x89d32be0,
    0x10da7a5a,
    0x67dd4acc,
    0xf9b9df6f,
    0x8ebeeff9,
    0x17b7be43,
    0x60b08ed5,
    0xd6d6a3e8,
    0xa1d1937e,
    0x38d8c2c4,
    0x4fdff252,
    0xd1bb67f1,
    0xa6bc5767,
    0x3fb506dd,
    0x48b2364b,
    0xd80d2bda,
    0xaf0a1b4c,
    0x36034af6,
    0x41047a60,
    0xdf60efc3,
    0xa867df55,
    0x316e8eef,
    0x4669be79,
    0xcb61b38c,
    0xbc66831a,
    0x256fd2a0,
    0x5268e236,
    0xcc0c7795,
    0xbb0b4703,
    0x220216b9,
    0x5505262f,
    0xc5ba3bbe,
    0xb2bd0b28,
    0x2bb45a92,
    0x5cb36a04,
    0xc2d7ffa7,
    0xb5d0cf31,
    0x2cd99e8b,
    0x5bdeae1d,
    0x9b64c2b0,
    0xec63f226,
    0x756aa39c,
    0x026d930a,
    0x9c0906a9,
    0xeb0e363f,
    0x72076785,
    0x05005713,
    0x95bf4a82,
    0xe2b87a14,
    0x7bb12bae,
    0x0cb61b38,
    0x92d28e9b,
    0xe5d5be0d,
    0x7cdcefb7,
    0x0bdbdf21,
    0x86d3d2d4,
    0xf1d4e242,
    0x68ddb3f8,
    0x1fda836e,
    0x81be16cd,
    0xf6b9265b,
    0x6fb077e1,
    0x18b74777,
    0x88085ae6,
    0xff0f6a70,
    0x66063bca,
    0x11010b5c,
    0x8f659eff,
    0xf862ae69,
    0x616bffd3,
    0x166ccf45,
    0xa00ae278,
    0xd70dd2ee,
    0x4e048354,
    0x3903b3c2,
    0xa7672661,
    0xd06016f7,
    0x4969474d,
    0x3e6e77db,
    0xaed16a4a,
    0xd9d65adc,
    0x40df0b66,
    0x37d83bf0,
    0xa9bcae53,
    0xdebb9ec5,
    0x47b2cf7f,
    0x30b5ffe9,
    0xbdbdf21c,
    0xcabac28a,
    0x53b39330,
    0x24b4a3a6,
    0xbad03605,
    0xcdd70693,
    0x54de5729,
    0x23d967bf,
    0xb3667a2e,
    0xc4614ab8,
    0x5d681b02,
    0x2a6f2b94,
    0xb40bbe37,
    0xc30c8ea1,
    0x5a05df1b,
    0x2d02ef8d
];
function hash(repr) {
    let crc = 0xffffffff;
    for(let idx = 0; idx < repr.length; ++idx){
        const c = (0, _globalsJs.safeCharCodeAt)(repr, idx);
        if (c < 0x80) crc = crc32Table[crc & 0xff ^ c] ^ crc >> 8;
        else if (c < 0x800) {
            crc = crc32Table[crc & 0xff ^ (192 | c >> 6 & 31)] ^ crc >> 8;
            crc = crc32Table[crc & 0xff ^ (128 | c & 63)] ^ crc >> 8;
        } else if (c >= 0xd800 && c < 0xe000) {
            const cNext = (0, _globalsJs.safeCharCodeAt)(repr, ++idx);
            if (c >= 0xdc00 || cNext < 0xdc00 || cNext > 0xdfff || Number.isNaN(cNext)) {
                idx -= 1;
                crc = crc32Table[crc & 0xff ^ 0xef] ^ crc >> 8;
                crc = crc32Table[crc & 0xff ^ 0xbf] ^ crc >> 8;
                crc = crc32Table[crc & 0xff ^ 0xbd] ^ crc >> 8;
            } else {
                const c1 = (c & 1023) + 64;
                const c2 = cNext & 1023;
                crc = crc32Table[crc & 0xff ^ (240 | c1 >> 8 & 7)] ^ crc >> 8;
                crc = crc32Table[crc & 0xff ^ (128 | c1 >> 2 & 63)] ^ crc >> 8;
                crc = crc32Table[crc & 0xff ^ (128 | c2 >> 6 & 15 | (c1 & 3) << 4)] ^ crc >> 8;
                crc = crc32Table[crc & 0xff ^ (128 | c2 & 63)] ^ crc >> 8;
            }
        } else {
            crc = crc32Table[crc & 0xff ^ (224 | c >> 12 & 15)] ^ crc >> 8;
            crc = crc32Table[crc & 0xff ^ (128 | c >> 6 & 63)] ^ crc >> 8;
            crc = crc32Table[crc & 0xff ^ (128 | c & 63)] ^ crc >> 8;
        }
    }
    return (crc | 0) + 0x80000000;
}

},{"./globals.js":"aTuwn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"iaGEG":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "noShrink", ()=>noShrink);
function noShrink(arb) {
    return arb.noShrink();
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"4xJOs":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "compareFunc", ()=>compareFunc);
var _compareFunctionArbitraryBuilderJs = require("./_internals/builders/CompareFunctionArbitraryBuilder.js");
const safeObjectAssign = Object.assign;
function compareFunc() {
    return (0, _compareFunctionArbitraryBuilderJs.buildCompareFunctionArbitrary)(safeObjectAssign((hA, hB)=>hA - hB, {
        toString () {
            return '(hA, hB) => hA - hB';
        }
    }));
}

},{"./_internals/builders/CompareFunctionArbitraryBuilder.js":"bgPn1","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"iiwYq":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "func", ()=>func);
var _hashJs = require("../utils/hash.js");
var _stringifyJs = require("../utils/stringify.js");
var _symbolsJs = require("../check/symbols.js");
var _arrayJs = require("./array.js");
var _integerJs = require("./integer.js");
var _noShrinkJs = require("./noShrink.js");
var _tupleJs = require("./tuple.js");
var _textEscaperJs = require("./_internals/helpers/TextEscaper.js");
var _globalsJs = require("../utils/globals.js");
const safeObjectDefineProperties = Object.defineProperties;
const safeObjectKeys = Object.keys;
function func(arb) {
    return (0, _tupleJs.tuple)((0, _arrayJs.array)(arb, {
        minLength: 1
    }), (0, _noShrinkJs.noShrink)((0, _integerJs.integer)())).map(([outs, seed])=>{
        const producer = ()=>{
            const recorded = {};
            const f = (...args)=>{
                const repr = (0, _stringifyJs.stringify)(args);
                const val = outs[(0, _hashJs.hash)(`${seed}${repr}`) % outs.length];
                recorded[repr] = val;
                return (0, _symbolsJs.hasCloneMethod)(val) ? val[0, _symbolsJs.cloneMethod]() : val;
            };
            function prettyPrint(stringifiedOuts) {
                const seenValues = (0, _globalsJs.safeMap)((0, _globalsJs.safeMap)((0, _globalsJs.safeSort)(safeObjectKeys(recorded)), (k)=>`${k} => ${(0, _stringifyJs.stringify)(recorded[k])}`), (line)=>`/* ${(0, _textEscaperJs.escapeForMultilineComments)(line)} */`);
                return `function(...args) {
  // With hash and stringify coming from fast-check${seenValues.length !== 0 ? `\n  ${seenValues.join('\n  ')}` : ''}
  const outs = ${stringifiedOuts};
  return outs[hash('${seed}' + stringify(args)) % outs.length];
}`;
            }
            return safeObjectDefineProperties(f, {
                toString: {
                    value: ()=>prettyPrint((0, _stringifyJs.stringify)(outs))
                },
                [(0, _stringifyJs.toStringMethod)]: {
                    value: ()=>prettyPrint((0, _stringifyJs.stringify)(outs))
                },
                [(0, _stringifyJs.asyncToStringMethod)]: {
                    value: async ()=>prettyPrint(await (0, _stringifyJs.asyncStringify)(outs))
                },
                [(0, _symbolsJs.cloneMethod)]: {
                    value: producer,
                    configurable: true
                }
            });
        };
        return producer();
    });
}

},{"../utils/hash.js":"6kEiE","../utils/stringify.js":"gOa8u","../check/symbols.js":"2AK80","./array.js":"eZMHg","./integer.js":"embjo","./noShrink.js":"iaGEG","./tuple.js":"dw0Pn","./_internals/helpers/TextEscaper.js":"fSa3V","../utils/globals.js":"aTuwn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"auNd7":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "maxSafeInteger", ()=>maxSafeInteger);
var _integerArbitraryJs = require("./_internals/IntegerArbitrary.js");
const safeMinSafeInteger = Number.MIN_SAFE_INTEGER;
const safeMaxSafeInteger = Number.MAX_SAFE_INTEGER;
function maxSafeInteger() {
    return new (0, _integerArbitraryJs.IntegerArbitrary)(safeMinSafeInteger, safeMaxSafeInteger);
}

},{"./_internals/IntegerArbitrary.js":"5m6ip","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"fw31I":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "maxSafeNat", ()=>maxSafeNat);
var _integerArbitraryJs = require("./_internals/IntegerArbitrary.js");
const safeMaxSafeInteger = Number.MAX_SAFE_INTEGER;
function maxSafeNat() {
    return new (0, _integerArbitraryJs.IntegerArbitrary)(0, safeMaxSafeInteger);
}

},{"./_internals/IntegerArbitrary.js":"5m6ip","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"lIWCt":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ipV4", ()=>ipV4);
var _globalsJs = require("../utils/globals.js");
var _natJs = require("./nat.js");
var _tupleJs = require("./tuple.js");
var _natToStringifiedNatJs = require("./_internals/mappers/NatToStringifiedNat.js");
function dotJoinerMapper(data) {
    return (0, _globalsJs.safeJoin)(data, '.');
}
function dotJoinerUnmapper(value) {
    if (typeof value !== 'string') throw new Error('Invalid type');
    return (0, _globalsJs.safeMap)((0, _globalsJs.safeSplit)(value, '.'), (v)=>(0, _natToStringifiedNatJs.tryParseStringifiedNat)(v, 10));
}
function ipV4() {
    return (0, _tupleJs.tuple)((0, _natJs.nat)(255), (0, _natJs.nat)(255), (0, _natJs.nat)(255), (0, _natJs.nat)(255)).map(dotJoinerMapper, dotJoinerUnmapper);
}

},{"../utils/globals.js":"aTuwn","./nat.js":"isueS","./tuple.js":"dw0Pn","./_internals/mappers/NatToStringifiedNat.js":"3W6Vw","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"3W6Vw":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "natToStringifiedNatMapper", ()=>natToStringifiedNatMapper);
parcelHelpers.export(exports, "tryParseStringifiedNat", ()=>tryParseStringifiedNat);
parcelHelpers.export(exports, "natToStringifiedNatUnmapper", ()=>natToStringifiedNatUnmapper);
var _globalsJs = require("../../../utils/globals.js");
const safeNumberParseInt = Number.parseInt;
function natToStringifiedNatMapper(options) {
    const [style, v] = options;
    switch(style){
        case 'oct':
            return `0${(0, _globalsJs.safeNumberToString)(v, 8)}`;
        case 'hex':
            return `0x${(0, _globalsJs.safeNumberToString)(v, 16)}`;
        case 'dec':
        default:
            return `${v}`;
    }
}
function tryParseStringifiedNat(stringValue, radix) {
    const parsedNat = safeNumberParseInt(stringValue, radix);
    if ((0, _globalsJs.safeNumberToString)(parsedNat, radix) !== stringValue) throw new Error('Invalid value');
    return parsedNat;
}
function natToStringifiedNatUnmapper(value) {
    if (typeof value !== 'string') throw new Error('Invalid type');
    if (value.length >= 2 && value[0] === '0') {
        if (value[1] === 'x') return [
            'hex',
            tryParseStringifiedNat((0, _globalsJs.safeSubstring)(value, 2), 16)
        ];
        return [
            'oct',
            tryParseStringifiedNat((0, _globalsJs.safeSubstring)(value, 1), 8)
        ];
    }
    return [
        'dec',
        tryParseStringifiedNat(value, 10)
    ];
}

},{"../../../utils/globals.js":"aTuwn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"d0QLr":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ipV4Extended", ()=>ipV4Extended);
var _globalsJs = require("../utils/globals.js");
var _oneofJs = require("./oneof.js");
var _tupleJs = require("./tuple.js");
var _stringifiedNatArbitraryBuilderJs = require("./_internals/builders/StringifiedNatArbitraryBuilder.js");
function dotJoinerMapper(data) {
    return (0, _globalsJs.safeJoin)(data, '.');
}
function dotJoinerUnmapper(value) {
    if (typeof value !== 'string') throw new Error('Invalid type');
    return (0, _globalsJs.safeSplit)(value, '.');
}
function ipV4Extended() {
    return (0, _oneofJs.oneof)((0, _tupleJs.tuple)((0, _stringifiedNatArbitraryBuilderJs.buildStringifiedNatArbitrary)(255), (0, _stringifiedNatArbitraryBuilderJs.buildStringifiedNatArbitrary)(255), (0, _stringifiedNatArbitraryBuilderJs.buildStringifiedNatArbitrary)(255), (0, _stringifiedNatArbitraryBuilderJs.buildStringifiedNatArbitrary)(255)).map(dotJoinerMapper, dotJoinerUnmapper), (0, _tupleJs.tuple)((0, _stringifiedNatArbitraryBuilderJs.buildStringifiedNatArbitrary)(255), (0, _stringifiedNatArbitraryBuilderJs.buildStringifiedNatArbitrary)(255), (0, _stringifiedNatArbitraryBuilderJs.buildStringifiedNatArbitrary)(65535)).map(dotJoinerMapper, dotJoinerUnmapper), (0, _tupleJs.tuple)((0, _stringifiedNatArbitraryBuilderJs.buildStringifiedNatArbitrary)(255), (0, _stringifiedNatArbitraryBuilderJs.buildStringifiedNatArbitrary)(16777215)).map(dotJoinerMapper, dotJoinerUnmapper), (0, _stringifiedNatArbitraryBuilderJs.buildStringifiedNatArbitrary)(4294967295));
}

},{"../utils/globals.js":"aTuwn","./oneof.js":"cTys0","./tuple.js":"dw0Pn","./_internals/builders/StringifiedNatArbitraryBuilder.js":"ddPum","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"ddPum":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "buildStringifiedNatArbitrary", ()=>buildStringifiedNatArbitrary);
var _constantFromJs = require("../../constantFrom.js");
var _natJs = require("../../nat.js");
var _tupleJs = require("../../tuple.js");
var _natToStringifiedNatJs = require("../mappers/NatToStringifiedNat.js");
function buildStringifiedNatArbitrary(maxValue) {
    return (0, _tupleJs.tuple)((0, _constantFromJs.constantFrom)('dec', 'oct', 'hex'), (0, _natJs.nat)(maxValue)).map((0, _natToStringifiedNatJs.natToStringifiedNatMapper), (0, _natToStringifiedNatJs.natToStringifiedNatUnmapper));
}

},{"../../constantFrom.js":"bZWfh","../../nat.js":"isueS","../../tuple.js":"dw0Pn","../mappers/NatToStringifiedNat.js":"3W6Vw","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"gHrQA":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ipV6", ()=>ipV6);
var _arrayJs = require("./array.js");
var _oneofJs = require("./oneof.js");
var _hexaStringJs = require("./hexaString.js");
var _tupleJs = require("./tuple.js");
var _ipV4Js = require("./ipV4.js");
var _entitiesToIPv6Js = require("./_internals/mappers/EntitiesToIPv6.js");
function h16sTol32Mapper([a, b]) {
    return `${a}:${b}`;
}
function h16sTol32Unmapper(value) {
    if (typeof value !== 'string') throw new Error('Invalid type');
    if (!value.includes(':')) throw new Error('Invalid value');
    return value.split(':', 2);
}
function ipV6() {
    const h16Arb = (0, _hexaStringJs.hexaString)({
        minLength: 1,
        maxLength: 4,
        size: 'max'
    });
    const ls32Arb = (0, _oneofJs.oneof)((0, _tupleJs.tuple)(h16Arb, h16Arb).map(h16sTol32Mapper, h16sTol32Unmapper), (0, _ipV4Js.ipV4)());
    return (0, _oneofJs.oneof)((0, _tupleJs.tuple)((0, _arrayJs.array)(h16Arb, {
        minLength: 6,
        maxLength: 6,
        size: 'max'
    }), ls32Arb).map((0, _entitiesToIPv6Js.fullySpecifiedMapper), (0, _entitiesToIPv6Js.fullySpecifiedUnmapper)), (0, _tupleJs.tuple)((0, _arrayJs.array)(h16Arb, {
        minLength: 5,
        maxLength: 5,
        size: 'max'
    }), ls32Arb).map((0, _entitiesToIPv6Js.onlyTrailingMapper), (0, _entitiesToIPv6Js.onlyTrailingUnmapper)), (0, _tupleJs.tuple)((0, _arrayJs.array)(h16Arb, {
        minLength: 0,
        maxLength: 1,
        size: 'max'
    }), (0, _arrayJs.array)(h16Arb, {
        minLength: 4,
        maxLength: 4,
        size: 'max'
    }), ls32Arb).map((0, _entitiesToIPv6Js.multiTrailingMapper), (0, _entitiesToIPv6Js.multiTrailingUnmapper)), (0, _tupleJs.tuple)((0, _arrayJs.array)(h16Arb, {
        minLength: 0,
        maxLength: 2,
        size: 'max'
    }), (0, _arrayJs.array)(h16Arb, {
        minLength: 3,
        maxLength: 3,
        size: 'max'
    }), ls32Arb).map((0, _entitiesToIPv6Js.multiTrailingMapper), (0, _entitiesToIPv6Js.multiTrailingUnmapper)), (0, _tupleJs.tuple)((0, _arrayJs.array)(h16Arb, {
        minLength: 0,
        maxLength: 3,
        size: 'max'
    }), (0, _arrayJs.array)(h16Arb, {
        minLength: 2,
        maxLength: 2,
        size: 'max'
    }), ls32Arb).map((0, _entitiesToIPv6Js.multiTrailingMapper), (0, _entitiesToIPv6Js.multiTrailingUnmapper)), (0, _tupleJs.tuple)((0, _arrayJs.array)(h16Arb, {
        minLength: 0,
        maxLength: 4,
        size: 'max'
    }), h16Arb, ls32Arb).map((0, _entitiesToIPv6Js.multiTrailingMapperOne), (0, _entitiesToIPv6Js.multiTrailingUnmapperOne)), (0, _tupleJs.tuple)((0, _arrayJs.array)(h16Arb, {
        minLength: 0,
        maxLength: 5,
        size: 'max'
    }), ls32Arb).map((0, _entitiesToIPv6Js.singleTrailingMapper), (0, _entitiesToIPv6Js.singleTrailingUnmapper)), (0, _tupleJs.tuple)((0, _arrayJs.array)(h16Arb, {
        minLength: 0,
        maxLength: 6,
        size: 'max'
    }), h16Arb).map((0, _entitiesToIPv6Js.singleTrailingMapper), (0, _entitiesToIPv6Js.singleTrailingUnmapper)), (0, _tupleJs.tuple)((0, _arrayJs.array)(h16Arb, {
        minLength: 0,
        maxLength: 7,
        size: 'max'
    })).map((0, _entitiesToIPv6Js.noTrailingMapper), (0, _entitiesToIPv6Js.noTrailingUnmapper)));
}

},{"./array.js":"eZMHg","./oneof.js":"cTys0","./hexaString.js":"iMh3o","./tuple.js":"dw0Pn","./ipV4.js":"lIWCt","./_internals/mappers/EntitiesToIPv6.js":"41OKT","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"iMh3o":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "hexaString", ()=>hexaString);
var _arrayJs = require("./array.js");
var _hexaJs = require("./hexa.js");
var _codePointsToStringJs = require("./_internals/mappers/CodePointsToString.js");
var _slicesForStringBuilderJs = require("./_internals/helpers/SlicesForStringBuilder.js");
const safeObjectAssign = Object.assign;
function hexaString(constraints = {}) {
    const charArbitrary = (0, _hexaJs.hexa)();
    const experimentalCustomSlices = (0, _slicesForStringBuilderJs.createSlicesForStringLegacy)(charArbitrary, (0, _codePointsToStringJs.codePointsToStringUnmapper));
    const enrichedConstraints = safeObjectAssign(safeObjectAssign({}, constraints), {
        experimentalCustomSlices
    });
    return (0, _arrayJs.array)(charArbitrary, enrichedConstraints).map((0, _codePointsToStringJs.codePointsToStringMapper), (0, _codePointsToStringJs.codePointsToStringUnmapper));
}

},{"./array.js":"eZMHg","./hexa.js":"1PNQs","./_internals/mappers/CodePointsToString.js":"887co","./_internals/helpers/SlicesForStringBuilder.js":"d3W5S","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"887co":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "codePointsToStringMapper", ()=>codePointsToStringMapper);
parcelHelpers.export(exports, "codePointsToStringUnmapper", ()=>codePointsToStringUnmapper);
var _globalsJs = require("../../../utils/globals.js");
function codePointsToStringMapper(tab) {
    return (0, _globalsJs.safeJoin)(tab, '');
}
function codePointsToStringUnmapper(value) {
    if (typeof value !== 'string') throw new Error('Cannot unmap the passed value');
    return [
        ...value
    ];
}

},{"../../../utils/globals.js":"aTuwn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"41OKT":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fullySpecifiedMapper", ()=>fullySpecifiedMapper);
parcelHelpers.export(exports, "fullySpecifiedUnmapper", ()=>fullySpecifiedUnmapper);
parcelHelpers.export(exports, "onlyTrailingMapper", ()=>onlyTrailingMapper);
parcelHelpers.export(exports, "onlyTrailingUnmapper", ()=>onlyTrailingUnmapper);
parcelHelpers.export(exports, "multiTrailingMapper", ()=>multiTrailingMapper);
parcelHelpers.export(exports, "multiTrailingUnmapper", ()=>multiTrailingUnmapper);
parcelHelpers.export(exports, "multiTrailingMapperOne", ()=>multiTrailingMapperOne);
parcelHelpers.export(exports, "multiTrailingUnmapperOne", ()=>multiTrailingUnmapperOne);
parcelHelpers.export(exports, "singleTrailingMapper", ()=>singleTrailingMapper);
parcelHelpers.export(exports, "singleTrailingUnmapper", ()=>singleTrailingUnmapper);
parcelHelpers.export(exports, "noTrailingMapper", ()=>noTrailingMapper);
parcelHelpers.export(exports, "noTrailingUnmapper", ()=>noTrailingUnmapper);
var _globalsJs = require("../../../utils/globals.js");
function readBh(value) {
    if (value.length === 0) return [];
    else return (0, _globalsJs.safeSplit)(value, ':');
}
function extractEhAndL(value) {
    const valueSplits = (0, _globalsJs.safeSplit)(value, ':');
    if (valueSplits.length >= 2 && valueSplits[valueSplits.length - 1].length <= 4) return [
        (0, _globalsJs.safeSlice)(valueSplits, 0, valueSplits.length - 2),
        `${valueSplits[valueSplits.length - 2]}:${valueSplits[valueSplits.length - 1]}`
    ];
    return [
        (0, _globalsJs.safeSlice)(valueSplits, 0, valueSplits.length - 1),
        valueSplits[valueSplits.length - 1]
    ];
}
function fullySpecifiedMapper(data) {
    return `${(0, _globalsJs.safeJoin)(data[0], ':')}:${data[1]}`;
}
function fullySpecifiedUnmapper(value) {
    if (typeof value !== 'string') throw new Error('Invalid type');
    return extractEhAndL(value);
}
function onlyTrailingMapper(data) {
    return `::${(0, _globalsJs.safeJoin)(data[0], ':')}:${data[1]}`;
}
function onlyTrailingUnmapper(value) {
    if (typeof value !== 'string') throw new Error('Invalid type');
    if (!(0, _globalsJs.safeStartsWith)(value, '::')) throw new Error('Invalid value');
    return extractEhAndL((0, _globalsJs.safeSubstring)(value, 2));
}
function multiTrailingMapper(data) {
    return `${(0, _globalsJs.safeJoin)(data[0], ':')}::${(0, _globalsJs.safeJoin)(data[1], ':')}:${data[2]}`;
}
function multiTrailingUnmapper(value) {
    if (typeof value !== 'string') throw new Error('Invalid type');
    const [bhString, trailingString] = (0, _globalsJs.safeSplit)(value, '::', 2);
    const [eh, l] = extractEhAndL(trailingString);
    return [
        readBh(bhString),
        eh,
        l
    ];
}
function multiTrailingMapperOne(data) {
    return multiTrailingMapper([
        data[0],
        [
            data[1]
        ],
        data[2]
    ]);
}
function multiTrailingUnmapperOne(value) {
    const out = multiTrailingUnmapper(value);
    return [
        out[0],
        (0, _globalsJs.safeJoin)(out[1], ':'),
        out[2]
    ];
}
function singleTrailingMapper(data) {
    return `${(0, _globalsJs.safeJoin)(data[0], ':')}::${data[1]}`;
}
function singleTrailingUnmapper(value) {
    if (typeof value !== 'string') throw new Error('Invalid type');
    const [bhString, trailing] = (0, _globalsJs.safeSplit)(value, '::', 2);
    return [
        readBh(bhString),
        trailing
    ];
}
function noTrailingMapper(data) {
    return `${(0, _globalsJs.safeJoin)(data[0], ':')}::`;
}
function noTrailingUnmapper(value) {
    if (typeof value !== 'string') throw new Error('Invalid type');
    if (!(0, _globalsJs.safeEndsWith)(value, '::')) throw new Error('Invalid value');
    return [
        readBh((0, _globalsJs.safeSubstring)(value, 0, value.length - 2))
    ];
}

},{"../../../utils/globals.js":"aTuwn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"1mp3E":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "letrec", ()=>letrec);
var _lazyArbitraryJs = require("./_internals/LazyArbitrary.js");
var _globalsJs = require("../utils/globals.js");
const safeObjectCreate = Object.create;
function letrec(builder) {
    const lazyArbs = safeObjectCreate(null);
    const tie = (key)=>{
        if (!(0, _globalsJs.safeHasOwnProperty)(lazyArbs, key)) lazyArbs[key] = new (0, _lazyArbitraryJs.LazyArbitrary)(String(key));
        return lazyArbs[key];
    };
    const strictArbs = builder(tie);
    for(const key in strictArbs){
        if (!(0, _globalsJs.safeHasOwnProperty)(strictArbs, key)) continue;
        const lazyAtKey = lazyArbs[key];
        const lazyArb = lazyAtKey !== undefined ? lazyAtKey : new (0, _lazyArbitraryJs.LazyArbitrary)(key);
        lazyArb.underlying = strictArbs[key];
        lazyArbs[key] = lazyArb;
    }
    return strictArbs;
}

},{"./_internals/LazyArbitrary.js":"5ZFcn","../utils/globals.js":"aTuwn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"5ZFcn":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "LazyArbitrary", ()=>LazyArbitrary);
var _arbitraryJs = require("../../check/arbitrary/definition/Arbitrary.js");
class LazyArbitrary extends (0, _arbitraryJs.Arbitrary) {
    constructor(name){
        super();
        this.name = name;
        this.underlying = null;
    }
    generate(mrng, biasFactor) {
        if (!this.underlying) throw new Error(`Lazy arbitrary ${JSON.stringify(this.name)} not correctly initialized`);
        return this.underlying.generate(mrng, biasFactor);
    }
    canShrinkWithoutContext(value) {
        if (!this.underlying) throw new Error(`Lazy arbitrary ${JSON.stringify(this.name)} not correctly initialized`);
        return this.underlying.canShrinkWithoutContext(value);
    }
    shrink(value, context) {
        if (!this.underlying) throw new Error(`Lazy arbitrary ${JSON.stringify(this.name)} not correctly initialized`);
        return this.underlying.shrink(value, context);
    }
}

},{"../../check/arbitrary/definition/Arbitrary.js":"e6f1K","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"iqGts":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "lorem", ()=>lorem);
var _arrayJs = require("./array.js");
var _constantJs = require("./constant.js");
var _oneofJs = require("./oneof.js");
var _wordsToLoremJs = require("./_internals/mappers/WordsToLorem.js");
const h = (v, w)=>{
    return {
        arbitrary: (0, _constantJs.constant)(v),
        weight: w
    };
};
function loremWord() {
    return (0, _oneofJs.oneof)(h('non', 6), h('adipiscing', 5), h('ligula', 5), h('enim', 5), h('pellentesque', 5), h('in', 5), h('augue', 5), h('et', 5), h('nulla', 5), h('lorem', 4), h('sit', 4), h('sed', 4), h('diam', 4), h('fermentum', 4), h('ut', 4), h('eu', 4), h('aliquam', 4), h('mauris', 4), h('vitae', 4), h('felis', 4), h('ipsum', 3), h('dolor', 3), h('amet,', 3), h('elit', 3), h('euismod', 3), h('mi', 3), h('orci', 3), h('erat', 3), h('praesent', 3), h('egestas', 3), h('leo', 3), h('vel', 3), h('sapien', 3), h('integer', 3), h('curabitur', 3), h('convallis', 3), h('purus', 3), h('risus', 2), h('suspendisse', 2), h('lectus', 2), h('nec,', 2), h('ultricies', 2), h('sed,', 2), h('cras', 2), h('elementum', 2), h('ultrices', 2), h('maecenas', 2), h('massa,', 2), h('varius', 2), h('a,', 2), h('semper', 2), h('proin', 2), h('nec', 2), h('nisl', 2), h('amet', 2), h('duis', 2), h('congue', 2), h('libero', 2), h('vestibulum', 2), h('pede', 2), h('blandit', 2), h('sodales', 2), h('ante', 2), h('nibh', 2), h('ac', 2), h('aenean', 2), h('massa', 2), h('suscipit', 2), h('sollicitudin', 2), h('fusce', 2), h('tempus', 2), h('aliquam,', 2), h('nunc', 2), h('ullamcorper', 2), h('rhoncus', 2), h('metus', 2), h('faucibus,', 2), h('justo', 2), h('magna', 2), h('at', 2), h('tincidunt', 2), h('consectetur', 1), h('tortor,', 1), h('dignissim', 1), h('congue,', 1), h('non,', 1), h('porttitor,', 1), h('nonummy', 1), h('molestie,', 1), h('est', 1), h('eleifend', 1), h('mi,', 1), h('arcu', 1), h('scelerisque', 1), h('vitae,', 1), h('consequat', 1), h('in,', 1), h('pretium', 1), h('volutpat', 1), h('pharetra', 1), h('tempor', 1), h('bibendum', 1), h('odio', 1), h('dui', 1), h('primis', 1), h('faucibus', 1), h('luctus', 1), h('posuere', 1), h('cubilia', 1), h('curae,', 1), h('hendrerit', 1), h('velit', 1), h('mauris,', 1), h('gravida', 1), h('ornare', 1), h('ut,', 1), h('pulvinar', 1), h('varius,', 1), h('turpis', 1), h('nibh,', 1), h('eros', 1), h('id', 1), h('aliquet', 1), h('quis', 1), h('lobortis', 1), h('consectetuer', 1), h('morbi', 1), h('vehicula', 1), h('tortor', 1), h('tellus,', 1), h('id,', 1), h('eu,', 1), h('quam', 1), h('feugiat,', 1), h('posuere,', 1), h('iaculis', 1), h('lectus,', 1), h('tristique', 1), h('mollis,', 1), h('nisl,', 1), h('vulputate', 1), h('sem', 1), h('vivamus', 1), h('placerat', 1), h('imperdiet', 1), h('cursus', 1), h('rutrum', 1), h('iaculis,', 1), h('augue,', 1), h('lacus', 1));
}
function lorem(constraints = {}) {
    const { maxCount, mode = 'words', size } = constraints;
    if (maxCount !== undefined && maxCount < 1) throw new Error(`lorem has to produce at least one word/sentence`);
    const wordArbitrary = loremWord();
    if (mode === 'sentences') {
        const sentence = (0, _arrayJs.array)(wordArbitrary, {
            minLength: 1,
            size: 'small'
        }).map((0, _wordsToLoremJs.wordsToSentenceMapper), (0, _wordsToLoremJs.wordsToSentenceUnmapperFor)(wordArbitrary));
        return (0, _arrayJs.array)(sentence, {
            minLength: 1,
            maxLength: maxCount,
            size
        }).map((0, _wordsToLoremJs.sentencesToParagraphMapper), (0, _wordsToLoremJs.sentencesToParagraphUnmapper));
    } else return (0, _arrayJs.array)(wordArbitrary, {
        minLength: 1,
        maxLength: maxCount,
        size
    }).map((0, _wordsToLoremJs.wordsToJoinedStringMapper), (0, _wordsToLoremJs.wordsToJoinedStringUnmapperFor)(wordArbitrary));
}

},{"./array.js":"eZMHg","./constant.js":"6Ey5n","./oneof.js":"cTys0","./_internals/mappers/WordsToLorem.js":"cXAJ0","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"cXAJ0":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "wordsToJoinedStringMapper", ()=>wordsToJoinedStringMapper);
parcelHelpers.export(exports, "wordsToJoinedStringUnmapperFor", ()=>wordsToJoinedStringUnmapperFor);
parcelHelpers.export(exports, "wordsToSentenceMapper", ()=>wordsToSentenceMapper);
parcelHelpers.export(exports, "wordsToSentenceUnmapperFor", ()=>wordsToSentenceUnmapperFor);
parcelHelpers.export(exports, "sentencesToParagraphMapper", ()=>sentencesToParagraphMapper);
parcelHelpers.export(exports, "sentencesToParagraphUnmapper", ()=>sentencesToParagraphUnmapper);
var _globalsJs = require("../../../utils/globals.js");
function wordsToJoinedStringMapper(words) {
    return (0, _globalsJs.safeJoin)((0, _globalsJs.safeMap)(words, (w)=>w[w.length - 1] === ',' ? (0, _globalsJs.safeSubstring)(w, 0, w.length - 1) : w), ' ');
}
function wordsToJoinedStringUnmapperFor(wordsArbitrary) {
    return function wordsToJoinedStringUnmapper(value) {
        if (typeof value !== 'string') throw new Error('Unsupported type');
        const words = [];
        for (const candidate of (0, _globalsJs.safeSplit)(value, ' ')){
            if (wordsArbitrary.canShrinkWithoutContext(candidate)) (0, _globalsJs.safePush)(words, candidate);
            else if (wordsArbitrary.canShrinkWithoutContext(candidate + ',')) (0, _globalsJs.safePush)(words, candidate + ',');
            else throw new Error('Unsupported word');
        }
        return words;
    };
}
function wordsToSentenceMapper(words) {
    let sentence = (0, _globalsJs.safeJoin)(words, ' ');
    if (sentence[sentence.length - 1] === ',') sentence = (0, _globalsJs.safeSubstring)(sentence, 0, sentence.length - 1);
    return (0, _globalsJs.safeToUpperCase)(sentence[0]) + (0, _globalsJs.safeSubstring)(sentence, 1) + '.';
}
function wordsToSentenceUnmapperFor(wordsArbitrary) {
    return function wordsToSentenceUnmapper(value) {
        if (typeof value !== 'string') throw new Error('Unsupported type');
        if (value.length < 2 || value[value.length - 1] !== '.' || value[value.length - 2] === ',' || (0, _globalsJs.safeToUpperCase)((0, _globalsJs.safeToLowerCase)(value[0])) !== value[0]) throw new Error('Unsupported value');
        const adaptedValue = (0, _globalsJs.safeToLowerCase)(value[0]) + (0, _globalsJs.safeSubstring)(value, 1, value.length - 1);
        const words = [];
        const candidates = (0, _globalsJs.safeSplit)(adaptedValue, ' ');
        for(let idx = 0; idx !== candidates.length; ++idx){
            const candidate = candidates[idx];
            if (wordsArbitrary.canShrinkWithoutContext(candidate)) (0, _globalsJs.safePush)(words, candidate);
            else if (idx === candidates.length - 1 && wordsArbitrary.canShrinkWithoutContext(candidate + ',')) (0, _globalsJs.safePush)(words, candidate + ',');
            else throw new Error('Unsupported word');
        }
        return words;
    };
}
function sentencesToParagraphMapper(sentences) {
    return (0, _globalsJs.safeJoin)(sentences, ' ');
}
function sentencesToParagraphUnmapper(value) {
    if (typeof value !== 'string') throw new Error('Unsupported type');
    const sentences = (0, _globalsJs.safeSplit)(value, '. ');
    for(let idx = 0; idx < sentences.length - 1; ++idx)sentences[idx] += '.';
    return sentences;
}

},{"../../../utils/globals.js":"aTuwn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"1qE8M":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "memo", ()=>memo);
var _globalsJs = require("../utils/globals.js");
let contextRemainingDepth = 10;
function memo(builder) {
    const previous = {};
    return (maxDepth)=>{
        const n = maxDepth !== undefined ? maxDepth : contextRemainingDepth;
        if (!(0, _globalsJs.safeHasOwnProperty)(previous, n)) {
            const prev = contextRemainingDepth;
            contextRemainingDepth = n - 1;
            previous[n] = builder(n);
            contextRemainingDepth = prev;
        }
        return previous[n];
    };
}

},{"../utils/globals.js":"aTuwn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"55a0V":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mixedCase", ()=>mixedCase);
var _globalsJs = require("../utils/globals.js");
var _mixedCaseArbitraryJs = require("./_internals/MixedCaseArbitrary.js");
function defaultToggleCase(rawChar) {
    const upper = (0, _globalsJs.safeToUpperCase)(rawChar);
    if (upper !== rawChar) return upper;
    return (0, _globalsJs.safeToLowerCase)(rawChar);
}
function mixedCase(stringArb, constraints) {
    if (typeof (0, _globalsJs.BigInt) === 'undefined') throw new (0, _globalsJs.Error)(`mixedCase requires BigInt support`);
    const toggleCase = constraints && constraints.toggleCase || defaultToggleCase;
    const untoggleAll = constraints && constraints.untoggleAll;
    return new (0, _mixedCaseArbitraryJs.MixedCaseArbitrary)(stringArb, toggleCase, untoggleAll);
}

},{"../utils/globals.js":"aTuwn","./_internals/MixedCaseArbitrary.js":"2xGjG","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"2xGjG":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MixedCaseArbitrary", ()=>MixedCaseArbitrary);
var _bigUintNJs = require("../bigUintN.js");
var _arbitraryJs = require("../../check/arbitrary/definition/Arbitrary.js");
var _valueJs = require("../../check/arbitrary/definition/Value.js");
var _lazyIterableIteratorJs = require("../../stream/LazyIterableIterator.js");
var _toggleFlagsJs = require("./helpers/ToggleFlags.js");
var _globalsJs = require("../../utils/globals.js");
class MixedCaseArbitrary extends (0, _arbitraryJs.Arbitrary) {
    constructor(stringArb, toggleCase, untoggleAll){
        super();
        this.stringArb = stringArb;
        this.toggleCase = toggleCase;
        this.untoggleAll = untoggleAll;
    }
    buildContextFor(rawStringValue, flagsValue) {
        return {
            rawString: rawStringValue.value,
            rawStringContext: rawStringValue.context,
            flags: flagsValue.value,
            flagsContext: flagsValue.context
        };
    }
    generate(mrng, biasFactor) {
        const rawStringValue = this.stringArb.generate(mrng, biasFactor);
        const chars = [
            ...rawStringValue.value
        ];
        const togglePositions = (0, _toggleFlagsJs.computeTogglePositions)(chars, this.toggleCase);
        const flagsArb = (0, _bigUintNJs.bigUintN)(togglePositions.length);
        const flagsValue = flagsArb.generate(mrng, undefined);
        (0, _toggleFlagsJs.applyFlagsOnChars)(chars, flagsValue.value, togglePositions, this.toggleCase);
        return new (0, _valueJs.Value)((0, _globalsJs.safeJoin)(chars, ''), this.buildContextFor(rawStringValue, flagsValue));
    }
    canShrinkWithoutContext(value) {
        if (typeof value !== 'string') return false;
        return this.untoggleAll !== undefined ? this.stringArb.canShrinkWithoutContext(this.untoggleAll(value)) : this.stringArb.canShrinkWithoutContext(value);
    }
    shrink(value, context) {
        let contextSafe;
        if (context !== undefined) contextSafe = context;
        else if (this.untoggleAll !== undefined) {
            const untoggledValue = this.untoggleAll(value);
            const valueChars = [
                ...value
            ];
            const untoggledValueChars = [
                ...untoggledValue
            ];
            const togglePositions = (0, _toggleFlagsJs.computeTogglePositions)(untoggledValueChars, this.toggleCase);
            contextSafe = {
                rawString: untoggledValue,
                rawStringContext: undefined,
                flags: (0, _toggleFlagsJs.computeFlagsFromChars)(untoggledValueChars, valueChars, togglePositions),
                flagsContext: undefined
            };
        } else contextSafe = {
            rawString: value,
            rawStringContext: undefined,
            flags: (0, _globalsJs.BigInt)(0),
            flagsContext: undefined
        };
        const rawString = contextSafe.rawString;
        const flags = contextSafe.flags;
        return this.stringArb.shrink(rawString, contextSafe.rawStringContext).map((nRawStringValue)=>{
            const nChars = [
                ...nRawStringValue.value
            ];
            const nTogglePositions = (0, _toggleFlagsJs.computeTogglePositions)(nChars, this.toggleCase);
            const nFlags = (0, _toggleFlagsJs.computeNextFlags)(flags, nTogglePositions.length);
            (0, _toggleFlagsJs.applyFlagsOnChars)(nChars, nFlags, nTogglePositions, this.toggleCase);
            return new (0, _valueJs.Value)((0, _globalsJs.safeJoin)(nChars, ''), this.buildContextFor(nRawStringValue, new (0, _valueJs.Value)(nFlags, undefined)));
        }).join((0, _lazyIterableIteratorJs.makeLazy)(()=>{
            const chars = [
                ...rawString
            ];
            const togglePositions = (0, _toggleFlagsJs.computeTogglePositions)(chars, this.toggleCase);
            return (0, _bigUintNJs.bigUintN)(togglePositions.length).shrink(flags, contextSafe.flagsContext).map((nFlagsValue)=>{
                const nChars = (0, _globalsJs.safeSlice)(chars);
                (0, _toggleFlagsJs.applyFlagsOnChars)(nChars, nFlagsValue.value, togglePositions, this.toggleCase);
                return new (0, _valueJs.Value)((0, _globalsJs.safeJoin)(nChars, ''), this.buildContextFor(new (0, _valueJs.Value)(rawString, contextSafe.rawStringContext), nFlagsValue));
            });
        }));
    }
}

},{"../bigUintN.js":"7ttyT","../../check/arbitrary/definition/Arbitrary.js":"e6f1K","../../check/arbitrary/definition/Value.js":"8Cf1j","../../stream/LazyIterableIterator.js":"bnj2K","./helpers/ToggleFlags.js":"e57xG","../../utils/globals.js":"aTuwn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"e57xG":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "countToggledBits", ()=>countToggledBits);
parcelHelpers.export(exports, "computeNextFlags", ()=>computeNextFlags);
parcelHelpers.export(exports, "computeTogglePositions", ()=>computeTogglePositions);
parcelHelpers.export(exports, "computeFlagsFromChars", ()=>computeFlagsFromChars);
parcelHelpers.export(exports, "applyFlagsOnChars", ()=>applyFlagsOnChars);
var _globalsJs = require("../../../utils/globals.js");
function countToggledBits(n) {
    let count = 0;
    while(n > (0, _globalsJs.BigInt)(0)){
        if (n & (0, _globalsJs.BigInt)(1)) ++count;
        n >>= (0, _globalsJs.BigInt)(1);
    }
    return count;
}
function computeNextFlags(flags, nextSize) {
    const allowedMask = ((0, _globalsJs.BigInt)(1) << (0, _globalsJs.BigInt)(nextSize)) - (0, _globalsJs.BigInt)(1);
    const preservedFlags = flags & allowedMask;
    let numMissingFlags = countToggledBits(flags - preservedFlags);
    let nFlags = preservedFlags;
    for(let mask = (0, _globalsJs.BigInt)(1); mask <= allowedMask && numMissingFlags !== 0; mask <<= (0, _globalsJs.BigInt)(1))if (!(nFlags & mask)) {
        nFlags |= mask;
        --numMissingFlags;
    }
    return nFlags;
}
function computeTogglePositions(chars, toggleCase) {
    const positions = [];
    for(let idx = chars.length - 1; idx !== -1; --idx)if (toggleCase(chars[idx]) !== chars[idx]) (0, _globalsJs.safePush)(positions, idx);
    return positions;
}
function computeFlagsFromChars(untoggledChars, toggledChars, togglePositions) {
    let flags = (0, _globalsJs.BigInt)(0);
    for(let idx = 0, mask = (0, _globalsJs.BigInt)(1); idx !== togglePositions.length; ++idx, mask <<= (0, _globalsJs.BigInt)(1))if (untoggledChars[togglePositions[idx]] !== toggledChars[togglePositions[idx]]) flags |= mask;
    return flags;
}
function applyFlagsOnChars(chars, flags, togglePositions, toggleCase) {
    for(let idx = 0, mask = (0, _globalsJs.BigInt)(1); idx !== togglePositions.length; ++idx, mask <<= (0, _globalsJs.BigInt)(1))if (flags & mask) chars[togglePositions[idx]] = toggleCase(chars[togglePositions[idx]]);
}

},{"../../../utils/globals.js":"aTuwn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"aQQuy":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "object", ()=>object);
var _dictionaryJs = require("./dictionary.js");
var _anyArbitraryBuilderJs = require("./_internals/builders/AnyArbitraryBuilder.js");
var _qualifiedObjectConstraintsJs = require("./_internals/helpers/QualifiedObjectConstraints.js");
function objectInternal(constraints) {
    return (0, _dictionaryJs.dictionary)(constraints.key, (0, _anyArbitraryBuilderJs.anyArbitraryBuilder)(constraints), {
        maxKeys: constraints.maxKeys,
        noNullPrototype: !constraints.withNullPrototype,
        size: constraints.size
    });
}
function object(constraints) {
    return objectInternal((0, _qualifiedObjectConstraintsJs.toQualifiedObjectConstraints)(constraints));
}

},{"./dictionary.js":"k8d7Y","./_internals/builders/AnyArbitraryBuilder.js":"kTWWq","./_internals/helpers/QualifiedObjectConstraints.js":"5Q05P","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"kTWWq":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "anyArbitraryBuilder", ()=>anyArbitraryBuilder);
var _stringifyJs = require("../../../utils/stringify.js");
var _arrayJs = require("../../array.js");
var _oneofJs = require("../../oneof.js");
var _tupleJs = require("../../tuple.js");
var _bigIntJs = require("../../bigInt.js");
var _dateJs = require("../../date.js");
var _float32ArrayJs = require("../../float32Array.js");
var _float64ArrayJs = require("../../float64Array.js");
var _int16ArrayJs = require("../../int16Array.js");
var _int32ArrayJs = require("../../int32Array.js");
var _int8ArrayJs = require("../../int8Array.js");
var _uint16ArrayJs = require("../../uint16Array.js");
var _uint32ArrayJs = require("../../uint32Array.js");
var _uint8ArrayJs = require("../../uint8Array.js");
var _uint8ClampedArrayJs = require("../../uint8ClampedArray.js");
var _sparseArrayJs = require("../../sparseArray.js");
var _arrayToMapJs = require("../mappers/ArrayToMap.js");
var _arrayToSetJs = require("../mappers/ArrayToSet.js");
var _letrecJs = require("../../letrec.js");
var _uniqueArrayJs = require("../../uniqueArray.js");
var _depthContextJs = require("../helpers/DepthContext.js");
var _dictionaryJs = require("../../dictionary.js");
function mapOf(ka, va, maxKeys, size, depthIdentifier) {
    return (0, _uniqueArrayJs.uniqueArray)((0, _tupleJs.tuple)(ka, va), {
        maxLength: maxKeys,
        size,
        comparator: 'SameValueZero',
        selector: (t)=>t[0],
        depthIdentifier
    }).map((0, _arrayToMapJs.arrayToMapMapper), (0, _arrayToMapJs.arrayToMapUnmapper));
}
function dictOf(ka, va, maxKeys, size, depthIdentifier, withNullPrototype) {
    return (0, _dictionaryJs.dictionary)(ka, va, {
        maxKeys,
        noNullPrototype: !withNullPrototype,
        size,
        depthIdentifier
    });
}
function setOf(va, maxKeys, size, depthIdentifier) {
    return (0, _uniqueArrayJs.uniqueArray)(va, {
        maxLength: maxKeys,
        size,
        comparator: 'SameValueZero',
        depthIdentifier
    }).map((0, _arrayToSetJs.arrayToSetMapper), (0, _arrayToSetJs.arrayToSetUnmapper));
}
function typedArray(constraints) {
    return (0, _oneofJs.oneof)((0, _int8ArrayJs.int8Array)(constraints), (0, _uint8ArrayJs.uint8Array)(constraints), (0, _uint8ClampedArrayJs.uint8ClampedArray)(constraints), (0, _int16ArrayJs.int16Array)(constraints), (0, _uint16ArrayJs.uint16Array)(constraints), (0, _int32ArrayJs.int32Array)(constraints), (0, _uint32ArrayJs.uint32Array)(constraints), (0, _float32ArrayJs.float32Array)(constraints), (0, _float64ArrayJs.float64Array)(constraints));
}
function anyArbitraryBuilder(constraints) {
    const arbitrariesForBase = constraints.values;
    const depthSize = constraints.depthSize;
    const depthIdentifier = (0, _depthContextJs.createDepthIdentifier)();
    const maxDepth = constraints.maxDepth;
    const maxKeys = constraints.maxKeys;
    const size = constraints.size;
    const baseArb = (0, _oneofJs.oneof)(...arbitrariesForBase, ...constraints.withBigInt ? [
        (0, _bigIntJs.bigInt)()
    ] : [], ...constraints.withDate ? [
        (0, _dateJs.date)()
    ] : []);
    return (0, _letrecJs.letrec)((tie)=>({
            anything: (0, _oneofJs.oneof)({
                maxDepth,
                depthSize,
                depthIdentifier
            }, baseArb, tie('array'), tie('object'), ...constraints.withMap ? [
                tie('map')
            ] : [], ...constraints.withSet ? [
                tie('set')
            ] : [], ...constraints.withObjectString ? [
                tie('anything').map((o)=>(0, _stringifyJs.stringify)(o))
            ] : [], ...constraints.withTypedArray ? [
                typedArray({
                    maxLength: maxKeys,
                    size
                })
            ] : [], ...constraints.withSparseArray ? [
                (0, _sparseArrayJs.sparseArray)(tie('anything'), {
                    maxNumElements: maxKeys,
                    size,
                    depthIdentifier
                })
            ] : []),
            keys: constraints.withObjectString ? (0, _oneofJs.oneof)({
                arbitrary: constraints.key,
                weight: 10
            }, {
                arbitrary: tie('anything').map((o)=>(0, _stringifyJs.stringify)(o)),
                weight: 1
            }) : constraints.key,
            array: (0, _arrayJs.array)(tie('anything'), {
                maxLength: maxKeys,
                size,
                depthIdentifier
            }),
            set: setOf(tie('anything'), maxKeys, size, depthIdentifier),
            map: (0, _oneofJs.oneof)(mapOf(tie('keys'), tie('anything'), maxKeys, size, depthIdentifier), mapOf(tie('anything'), tie('anything'), maxKeys, size, depthIdentifier)),
            object: dictOf(tie('keys'), tie('anything'), maxKeys, size, depthIdentifier, constraints.withNullPrototype)
        })).anything;
}

},{"../../../utils/stringify.js":"gOa8u","../../array.js":"eZMHg","../../oneof.js":"cTys0","../../tuple.js":"dw0Pn","../../bigInt.js":"ffHa9","../../date.js":"dhAUk","../../float32Array.js":"bDHOa","../../float64Array.js":"NC4jW","../../int16Array.js":"8x0zl","../../int32Array.js":"6wLbr","../../int8Array.js":"7QGjS","../../uint16Array.js":"58AkQ","../../uint32Array.js":"5UMvJ","../../uint8Array.js":"qWlHB","../../uint8ClampedArray.js":"7X0R7","../../sparseArray.js":"atKfO","../mappers/ArrayToMap.js":"iYqOz","../mappers/ArrayToSet.js":"aa7C0","../../letrec.js":"1mp3E","../../uniqueArray.js":"8dSfb","../helpers/DepthContext.js":"dsS0S","../../dictionary.js":"k8d7Y","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"bDHOa":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "float32Array", ()=>float32Array);
var _floatJs = require("./float.js");
var _arrayJs = require("./array.js");
var _globalsJs = require("../utils/globals.js");
function toTypedMapper(data) {
    return (0, _globalsJs.Float32Array).from(data);
}
function fromTypedUnmapper(value) {
    if (!(value instanceof (0, _globalsJs.Float32Array))) throw new Error('Unexpected type');
    return [
        ...value
    ];
}
function float32Array(constraints = {}) {
    return (0, _arrayJs.array)((0, _floatJs.float)(constraints), constraints).map(toTypedMapper, fromTypedUnmapper);
}

},{"./float.js":"4Tn1Y","./array.js":"eZMHg","../utils/globals.js":"aTuwn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"NC4jW":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "float64Array", ()=>float64Array);
var _doubleJs = require("./double.js");
var _arrayJs = require("./array.js");
var _globalsJs = require("../utils/globals.js");
function toTypedMapper(data) {
    return (0, _globalsJs.Float64Array).from(data);
}
function fromTypedUnmapper(value) {
    if (!(value instanceof (0, _globalsJs.Float64Array))) throw new Error('Unexpected type');
    return [
        ...value
    ];
}
function float64Array(constraints = {}) {
    return (0, _arrayJs.array)((0, _doubleJs.double)(constraints), constraints).map(toTypedMapper, fromTypedUnmapper);
}

},{"./double.js":"8I26L","./array.js":"eZMHg","../utils/globals.js":"aTuwn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"8x0zl":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "int16Array", ()=>int16Array);
var _globalsJs = require("../utils/globals.js");
var _integerJs = require("./integer.js");
var _typedIntArrayArbitraryBuilderJs = require("./_internals/builders/TypedIntArrayArbitraryBuilder.js");
function int16Array(constraints = {}) {
    return (0, _typedIntArrayArbitraryBuilderJs.typedIntArrayArbitraryArbitraryBuilder)(constraints, -32768, 32767, (0, _globalsJs.Int16Array), (0, _integerJs.integer));
}

},{"../utils/globals.js":"aTuwn","./integer.js":"embjo","./_internals/builders/TypedIntArrayArbitraryBuilder.js":"hXkYu","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"hXkYu":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "typedIntArrayArbitraryArbitraryBuilder", ()=>typedIntArrayArbitraryArbitraryBuilder);
var _arrayJs = require("../../array.js");
var __rest = undefined && undefined.__rest || function(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") {
        for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
};
function typedIntArrayArbitraryArbitraryBuilder(constraints, defaultMin, defaultMax, TypedArrayClass, arbitraryBuilder) {
    const generatorName = TypedArrayClass.name;
    const { min = defaultMin, max = defaultMax } = constraints, arrayConstraints = __rest(constraints, [
        "min",
        "max"
    ]);
    if (min > max) throw new Error(`Invalid range passed to ${generatorName}: min must be lower than or equal to max`);
    if (min < defaultMin) throw new Error(`Invalid min value passed to ${generatorName}: min must be greater than or equal to ${defaultMin}`);
    if (max > defaultMax) throw new Error(`Invalid max value passed to ${generatorName}: max must be lower than or equal to ${defaultMax}`);
    return (0, _arrayJs.array)(arbitraryBuilder({
        min,
        max
    }), arrayConstraints).map((data)=>TypedArrayClass.from(data), (value)=>{
        if (!(value instanceof TypedArrayClass)) throw new Error('Invalid type');
        return [
            ...value
        ];
    });
}

},{"../../array.js":"eZMHg","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"6wLbr":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "int32Array", ()=>int32Array);
var _globalsJs = require("../utils/globals.js");
var _integerJs = require("./integer.js");
var _typedIntArrayArbitraryBuilderJs = require("./_internals/builders/TypedIntArrayArbitraryBuilder.js");
function int32Array(constraints = {}) {
    return (0, _typedIntArrayArbitraryBuilderJs.typedIntArrayArbitraryArbitraryBuilder)(constraints, -2147483648, 0x7fffffff, (0, _globalsJs.Int32Array), (0, _integerJs.integer));
}

},{"../utils/globals.js":"aTuwn","./integer.js":"embjo","./_internals/builders/TypedIntArrayArbitraryBuilder.js":"hXkYu","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"7QGjS":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "int8Array", ()=>int8Array);
var _globalsJs = require("../utils/globals.js");
var _integerJs = require("./integer.js");
var _typedIntArrayArbitraryBuilderJs = require("./_internals/builders/TypedIntArrayArbitraryBuilder.js");
function int8Array(constraints = {}) {
    return (0, _typedIntArrayArbitraryBuilderJs.typedIntArrayArbitraryArbitraryBuilder)(constraints, -128, 127, (0, _globalsJs.Int8Array), (0, _integerJs.integer));
}

},{"../utils/globals.js":"aTuwn","./integer.js":"embjo","./_internals/builders/TypedIntArrayArbitraryBuilder.js":"hXkYu","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"58AkQ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "uint16Array", ()=>uint16Array);
var _globalsJs = require("../utils/globals.js");
var _integerJs = require("./integer.js");
var _typedIntArrayArbitraryBuilderJs = require("./_internals/builders/TypedIntArrayArbitraryBuilder.js");
function uint16Array(constraints = {}) {
    return (0, _typedIntArrayArbitraryBuilderJs.typedIntArrayArbitraryArbitraryBuilder)(constraints, 0, 65535, (0, _globalsJs.Uint16Array), (0, _integerJs.integer));
}

},{"../utils/globals.js":"aTuwn","./integer.js":"embjo","./_internals/builders/TypedIntArrayArbitraryBuilder.js":"hXkYu","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"5UMvJ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "uint32Array", ()=>uint32Array);
var _globalsJs = require("../utils/globals.js");
var _integerJs = require("./integer.js");
var _typedIntArrayArbitraryBuilderJs = require("./_internals/builders/TypedIntArrayArbitraryBuilder.js");
function uint32Array(constraints = {}) {
    return (0, _typedIntArrayArbitraryBuilderJs.typedIntArrayArbitraryArbitraryBuilder)(constraints, 0, 0xffffffff, (0, _globalsJs.Uint32Array), (0, _integerJs.integer));
}

},{"../utils/globals.js":"aTuwn","./integer.js":"embjo","./_internals/builders/TypedIntArrayArbitraryBuilder.js":"hXkYu","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"qWlHB":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "uint8Array", ()=>uint8Array);
var _globalsJs = require("../utils/globals.js");
var _integerJs = require("./integer.js");
var _typedIntArrayArbitraryBuilderJs = require("./_internals/builders/TypedIntArrayArbitraryBuilder.js");
function uint8Array(constraints = {}) {
    return (0, _typedIntArrayArbitraryBuilderJs.typedIntArrayArbitraryArbitraryBuilder)(constraints, 0, 255, (0, _globalsJs.Uint8Array), (0, _integerJs.integer));
}

},{"../utils/globals.js":"aTuwn","./integer.js":"embjo","./_internals/builders/TypedIntArrayArbitraryBuilder.js":"hXkYu","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"7X0R7":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "uint8ClampedArray", ()=>uint8ClampedArray);
var _globalsJs = require("../utils/globals.js");
var _integerJs = require("./integer.js");
var _typedIntArrayArbitraryBuilderJs = require("./_internals/builders/TypedIntArrayArbitraryBuilder.js");
function uint8ClampedArray(constraints = {}) {
    return (0, _typedIntArrayArbitraryBuilderJs.typedIntArrayArbitraryArbitraryBuilder)(constraints, 0, 255, (0, _globalsJs.Uint8ClampedArray), (0, _integerJs.integer));
}

},{"../utils/globals.js":"aTuwn","./integer.js":"embjo","./_internals/builders/TypedIntArrayArbitraryBuilder.js":"hXkYu","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"atKfO":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "sparseArray", ()=>sparseArray);
var _globalsJs = require("../utils/globals.js");
var _tupleJs = require("./tuple.js");
var _uniqueArrayJs = require("./uniqueArray.js");
var _restrictedIntegerArbitraryBuilderJs = require("./_internals/builders/RestrictedIntegerArbitraryBuilder.js");
var _maxLengthFromMinLengthJs = require("./_internals/helpers/MaxLengthFromMinLength.js");
const safeMathMin = Math.min;
const safeMathMax = Math.max;
const safeArrayIsArray = (0, _globalsJs.Array).isArray;
const safeObjectEntries = Object.entries;
function extractMaxIndex(indexesAndValues) {
    let maxIndex = -1;
    for(let index = 0; index !== indexesAndValues.length; ++index)maxIndex = safeMathMax(maxIndex, indexesAndValues[index][0]);
    return maxIndex;
}
function arrayFromItems(length, indexesAndValues) {
    const array = (0, _globalsJs.Array)(length);
    for(let index = 0; index !== indexesAndValues.length; ++index){
        const it = indexesAndValues[index];
        if (it[0] < length) array[it[0]] = it[1];
    }
    return array;
}
function sparseArray(arb, constraints = {}) {
    const { size, minNumElements = 0, maxLength = (0, _maxLengthFromMinLengthJs.MaxLengthUpperBound), maxNumElements = maxLength, noTrailingHole, depthIdentifier } = constraints;
    const maxGeneratedNumElements = (0, _maxLengthFromMinLengthJs.maxGeneratedLengthFromSizeForArbitrary)(size, minNumElements, maxNumElements, constraints.maxNumElements !== undefined);
    const maxGeneratedLength = (0, _maxLengthFromMinLengthJs.maxGeneratedLengthFromSizeForArbitrary)(size, maxGeneratedNumElements, maxLength, constraints.maxLength !== undefined);
    if (minNumElements > maxLength) throw new Error(`The minimal number of non-hole elements cannot be higher than the maximal length of the array`);
    if (minNumElements > maxNumElements) throw new Error(`The minimal number of non-hole elements cannot be higher than the maximal number of non-holes`);
    const resultedMaxNumElements = safeMathMin(maxNumElements, maxLength);
    const resultedSizeMaxNumElements = constraints.maxNumElements !== undefined || size !== undefined ? size : '=';
    const maxGeneratedIndexAuthorized = safeMathMax(maxGeneratedLength - 1, 0);
    const maxIndexAuthorized = safeMathMax(maxLength - 1, 0);
    const sparseArrayNoTrailingHole = (0, _uniqueArrayJs.uniqueArray)((0, _tupleJs.tuple)((0, _restrictedIntegerArbitraryBuilderJs.restrictedIntegerArbitraryBuilder)(0, maxGeneratedIndexAuthorized, maxIndexAuthorized), arb), {
        size: resultedSizeMaxNumElements,
        minLength: minNumElements,
        maxLength: resultedMaxNumElements,
        selector: (item)=>item[0],
        depthIdentifier
    }).map((items)=>{
        const lastIndex = extractMaxIndex(items);
        return arrayFromItems(lastIndex + 1, items);
    }, (value)=>{
        if (!safeArrayIsArray(value)) throw new Error('Not supported entry type');
        if (noTrailingHole && value.length !== 0 && !(value.length - 1 in value)) throw new Error('No trailing hole');
        return (0, _globalsJs.safeMap)(safeObjectEntries(value), (entry)=>[
                Number(entry[0]),
                entry[1]
            ]);
    });
    if (noTrailingHole || maxLength === minNumElements) return sparseArrayNoTrailingHole;
    return (0, _tupleJs.tuple)(sparseArrayNoTrailingHole, (0, _restrictedIntegerArbitraryBuilderJs.restrictedIntegerArbitraryBuilder)(minNumElements, maxGeneratedLength, maxLength)).map((data)=>{
        const sparse = data[0];
        const targetLength = data[1];
        if (sparse.length >= targetLength) return sparse;
        const longerSparse = (0, _globalsJs.safeSlice)(sparse);
        longerSparse.length = targetLength;
        return longerSparse;
    }, (value)=>{
        if (!safeArrayIsArray(value)) throw new Error('Not supported entry type');
        return [
            value,
            value.length
        ];
    });
}

},{"../utils/globals.js":"aTuwn","./tuple.js":"dw0Pn","./uniqueArray.js":"8dSfb","./_internals/builders/RestrictedIntegerArbitraryBuilder.js":"1IMef","./_internals/helpers/MaxLengthFromMinLength.js":"5ilwx","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"1IMef":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "restrictedIntegerArbitraryBuilder", ()=>restrictedIntegerArbitraryBuilder);
var _integerJs = require("../../integer.js");
var _withShrinkFromOtherArbitraryJs = require("../WithShrinkFromOtherArbitrary.js");
function restrictedIntegerArbitraryBuilder(min, maxGenerated, max) {
    const generatorArbitrary = (0, _integerJs.integer)({
        min,
        max: maxGenerated
    });
    if (maxGenerated === max) return generatorArbitrary;
    const shrinkerArbitrary = (0, _integerJs.integer)({
        min,
        max
    });
    return new (0, _withShrinkFromOtherArbitraryJs.WithShrinkFromOtherArbitrary)(generatorArbitrary, shrinkerArbitrary);
}

},{"../../integer.js":"embjo","../WithShrinkFromOtherArbitrary.js":"bZ49w","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"bZ49w":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "WithShrinkFromOtherArbitrary", ()=>WithShrinkFromOtherArbitrary);
var _arbitraryJs = require("../../check/arbitrary/definition/Arbitrary.js");
var _valueJs = require("../../check/arbitrary/definition/Value.js");
function isSafeContext(context) {
    return context !== undefined;
}
function toGeneratorValue(value) {
    if (value.hasToBeCloned) return new (0, _valueJs.Value)(value.value_, {
        generatorContext: value.context
    }, ()=>value.value);
    return new (0, _valueJs.Value)(value.value_, {
        generatorContext: value.context
    });
}
function toShrinkerValue(value) {
    if (value.hasToBeCloned) return new (0, _valueJs.Value)(value.value_, {
        shrinkerContext: value.context
    }, ()=>value.value);
    return new (0, _valueJs.Value)(value.value_, {
        shrinkerContext: value.context
    });
}
class WithShrinkFromOtherArbitrary extends (0, _arbitraryJs.Arbitrary) {
    constructor(generatorArbitrary, shrinkerArbitrary){
        super();
        this.generatorArbitrary = generatorArbitrary;
        this.shrinkerArbitrary = shrinkerArbitrary;
    }
    generate(mrng, biasFactor) {
        return toGeneratorValue(this.generatorArbitrary.generate(mrng, biasFactor));
    }
    canShrinkWithoutContext(value) {
        return this.shrinkerArbitrary.canShrinkWithoutContext(value);
    }
    shrink(value, context) {
        if (!isSafeContext(context)) return this.shrinkerArbitrary.shrink(value, undefined).map(toShrinkerValue);
        if ('generatorContext' in context) return this.generatorArbitrary.shrink(value, context.generatorContext).map(toGeneratorValue);
        return this.shrinkerArbitrary.shrink(value, context.shrinkerContext).map(toShrinkerValue);
    }
}

},{"../../check/arbitrary/definition/Arbitrary.js":"e6f1K","../../check/arbitrary/definition/Value.js":"8Cf1j","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"iYqOz":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "arrayToMapMapper", ()=>arrayToMapMapper);
parcelHelpers.export(exports, "arrayToMapUnmapper", ()=>arrayToMapUnmapper);
function arrayToMapMapper(data) {
    return new Map(data);
}
function arrayToMapUnmapper(value) {
    if (typeof value !== 'object' || value === null) throw new Error('Incompatible instance received: should be a non-null object');
    if (!('constructor' in value) || value.constructor !== Map) throw new Error('Incompatible instance received: should be of exact type Map');
    return Array.from(value);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"aa7C0":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "arrayToSetMapper", ()=>arrayToSetMapper);
parcelHelpers.export(exports, "arrayToSetUnmapper", ()=>arrayToSetUnmapper);
function arrayToSetMapper(data) {
    return new Set(data);
}
function arrayToSetUnmapper(value) {
    if (typeof value !== 'object' || value === null) throw new Error('Incompatible instance received: should be a non-null object');
    if (!('constructor' in value) || value.constructor !== Set) throw new Error('Incompatible instance received: should be of exact type Set');
    return Array.from(value);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"5Q05P":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "toQualifiedObjectConstraints", ()=>toQualifiedObjectConstraints);
var _booleanJs = require("../../boolean.js");
var _constantJs = require("../../constant.js");
var _doubleJs = require("../../double.js");
var _fullUnicodeStringJs = require("../../fullUnicodeString.js");
var _maxSafeIntegerJs = require("../../maxSafeInteger.js");
var _oneofJs = require("../../oneof.js");
var _stringJs = require("../../string.js");
var _boxedArbitraryBuilderJs = require("../builders/BoxedArbitraryBuilder.js");
function defaultValues(constraints, stringArbitrary) {
    return [
        (0, _booleanJs.boolean)(),
        (0, _maxSafeIntegerJs.maxSafeInteger)(),
        (0, _doubleJs.double)(),
        stringArbitrary(constraints),
        (0, _oneofJs.oneof)(stringArbitrary(constraints), (0, _constantJs.constant)(null), (0, _constantJs.constant)(undefined))
    ];
}
function boxArbitraries(arbs) {
    return arbs.map((arb)=>(0, _boxedArbitraryBuilderJs.boxedArbitraryBuilder)(arb));
}
function boxArbitrariesIfNeeded(arbs, boxEnabled) {
    return boxEnabled ? boxArbitraries(arbs).concat(arbs) : arbs;
}
function toQualifiedObjectConstraints(settings = {}) {
    function orDefault(optionalValue, defaultValue) {
        return optionalValue !== undefined ? optionalValue : defaultValue;
    }
    const stringArbitrary = 'stringUnit' in settings ? (0, _stringJs.string) : settings.withUnicodeString ? (0, _fullUnicodeStringJs.fullUnicodeString) : (0, _stringJs.string);
    const valueConstraints = {
        size: settings.size,
        unit: settings.stringUnit
    };
    return {
        key: orDefault(settings.key, stringArbitrary(valueConstraints)),
        values: boxArbitrariesIfNeeded(orDefault(settings.values, defaultValues(valueConstraints, stringArbitrary)), orDefault(settings.withBoxedValues, false)),
        depthSize: settings.depthSize,
        maxDepth: settings.maxDepth,
        maxKeys: settings.maxKeys,
        size: settings.size,
        withSet: orDefault(settings.withSet, false),
        withMap: orDefault(settings.withMap, false),
        withObjectString: orDefault(settings.withObjectString, false),
        withNullPrototype: orDefault(settings.withNullPrototype, false),
        withBigInt: orDefault(settings.withBigInt, false),
        withDate: orDefault(settings.withDate, false),
        withTypedArray: orDefault(settings.withTypedArray, false),
        withSparseArray: orDefault(settings.withSparseArray, false)
    };
}

},{"../../boolean.js":"bazde","../../constant.js":"6Ey5n","../../double.js":"8I26L","../../fullUnicodeString.js":"9AgbI","../../maxSafeInteger.js":"auNd7","../../oneof.js":"cTys0","../../string.js":"iHGKT","../builders/BoxedArbitraryBuilder.js":"j9uy1","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"9AgbI":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fullUnicodeString", ()=>fullUnicodeString);
var _arrayJs = require("./array.js");
var _fullUnicodeJs = require("./fullUnicode.js");
var _codePointsToStringJs = require("./_internals/mappers/CodePointsToString.js");
var _slicesForStringBuilderJs = require("./_internals/helpers/SlicesForStringBuilder.js");
const safeObjectAssign = Object.assign;
function fullUnicodeString(constraints = {}) {
    const charArbitrary = (0, _fullUnicodeJs.fullUnicode)();
    const experimentalCustomSlices = (0, _slicesForStringBuilderJs.createSlicesForStringLegacy)(charArbitrary, (0, _codePointsToStringJs.codePointsToStringUnmapper));
    const enrichedConstraints = safeObjectAssign(safeObjectAssign({}, constraints), {
        experimentalCustomSlices
    });
    return (0, _arrayJs.array)(charArbitrary, enrichedConstraints).map((0, _codePointsToStringJs.codePointsToStringMapper), (0, _codePointsToStringJs.codePointsToStringUnmapper));
}

},{"./array.js":"eZMHg","./fullUnicode.js":"1lTh1","./_internals/mappers/CodePointsToString.js":"887co","./_internals/helpers/SlicesForStringBuilder.js":"d3W5S","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"j9uy1":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "boxedArbitraryBuilder", ()=>boxedArbitraryBuilder);
var _unboxedToBoxedJs = require("../mappers/UnboxedToBoxed.js");
function boxedArbitraryBuilder(arb) {
    return arb.map((0, _unboxedToBoxedJs.unboxedToBoxedMapper), (0, _unboxedToBoxedJs.unboxedToBoxedUnmapper));
}

},{"../mappers/UnboxedToBoxed.js":"lVqGP","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"lVqGP":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "unboxedToBoxedMapper", ()=>unboxedToBoxedMapper);
parcelHelpers.export(exports, "unboxedToBoxedUnmapper", ()=>unboxedToBoxedUnmapper);
var _globalsJs = require("../../../utils/globals.js");
function unboxedToBoxedMapper(value) {
    switch(typeof value){
        case 'boolean':
            return new (0, _globalsJs.Boolean)(value);
        case 'number':
            return new (0, _globalsJs.Number)(value);
        case 'string':
            return new (0, _globalsJs.String)(value);
        default:
            return value;
    }
}
function unboxedToBoxedUnmapper(value) {
    if (typeof value !== 'object' || value === null || !('constructor' in value)) return value;
    return value.constructor === (0, _globalsJs.Boolean) || value.constructor === (0, _globalsJs.Number) || value.constructor === (0, _globalsJs.String) ? value.valueOf() : value;
}

},{"../../../utils/globals.js":"aTuwn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"gH44o":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "json", ()=>json);
var _jsonValueJs = require("./jsonValue.js");
function json(constraints = {}) {
    const arb = (0, _jsonValueJs.jsonValue)(constraints);
    return arb.map(JSON.stringify);
}

},{"./jsonValue.js":"jQpeh","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"jQpeh":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "jsonValue", ()=>jsonValue);
var _stringJs = require("./string.js");
var _jsonConstraintsBuilderJs = require("./_internals/helpers/JsonConstraintsBuilder.js");
var _anythingJs = require("./anything.js");
var _fullUnicodeStringJs = require("./fullUnicodeString.js");
function jsonValue(constraints = {}) {
    const noUnicodeString = constraints.noUnicodeString === undefined || constraints.noUnicodeString === true;
    const stringArbitrary = 'stringUnit' in constraints ? (0, _stringJs.string)({
        unit: constraints.stringUnit
    }) : noUnicodeString ? (0, _stringJs.string)() : (0, _fullUnicodeStringJs.fullUnicodeString)();
    return (0, _anythingJs.anything)((0, _jsonConstraintsBuilderJs.jsonConstraintsBuilder)(stringArbitrary, constraints));
}

},{"./string.js":"iHGKT","./_internals/helpers/JsonConstraintsBuilder.js":"i1ZlJ","./anything.js":"843Dd","./fullUnicodeString.js":"9AgbI","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"i1ZlJ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "jsonConstraintsBuilder", ()=>jsonConstraintsBuilder);
var _booleanJs = require("../../boolean.js");
var _constantJs = require("../../constant.js");
var _doubleJs = require("../../double.js");
function jsonConstraintsBuilder(stringArbitrary, constraints) {
    const { depthSize, maxDepth } = constraints;
    const key = stringArbitrary;
    const values = [
        (0, _booleanJs.boolean)(),
        (0, _doubleJs.double)({
            noDefaultInfinity: true,
            noNaN: true
        }),
        stringArbitrary,
        (0, _constantJs.constant)(null)
    ];
    return {
        key,
        values,
        depthSize,
        maxDepth
    };
}

},{"../../boolean.js":"bazde","../../constant.js":"6Ey5n","../../double.js":"8I26L","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"843Dd":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "anything", ()=>anything);
var _anyArbitraryBuilderJs = require("./_internals/builders/AnyArbitraryBuilder.js");
var _qualifiedObjectConstraintsJs = require("./_internals/helpers/QualifiedObjectConstraints.js");
function anything(constraints) {
    return (0, _anyArbitraryBuilderJs.anyArbitraryBuilder)((0, _qualifiedObjectConstraintsJs.toQualifiedObjectConstraints)(constraints));
}

},{"./_internals/builders/AnyArbitraryBuilder.js":"kTWWq","./_internals/helpers/QualifiedObjectConstraints.js":"5Q05P","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"6IvVE":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "unicodeJsonValue", ()=>unicodeJsonValue);
var _unicodeStringJs = require("./unicodeString.js");
var _jsonConstraintsBuilderJs = require("./_internals/helpers/JsonConstraintsBuilder.js");
var _anythingJs = require("./anything.js");
function unicodeJsonValue(constraints = {}) {
    return (0, _anythingJs.anything)((0, _jsonConstraintsBuilderJs.jsonConstraintsBuilder)((0, _unicodeStringJs.unicodeString)(), constraints));
}

},{"./unicodeString.js":"16ziD","./_internals/helpers/JsonConstraintsBuilder.js":"i1ZlJ","./anything.js":"843Dd","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"16ziD":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "unicodeString", ()=>unicodeString);
var _arrayJs = require("./array.js");
var _unicodeJs = require("./unicode.js");
var _codePointsToStringJs = require("./_internals/mappers/CodePointsToString.js");
var _slicesForStringBuilderJs = require("./_internals/helpers/SlicesForStringBuilder.js");
const safeObjectAssign = Object.assign;
function unicodeString(constraints = {}) {
    const charArbitrary = (0, _unicodeJs.unicode)();
    const experimentalCustomSlices = (0, _slicesForStringBuilderJs.createSlicesForStringLegacy)(charArbitrary, (0, _codePointsToStringJs.codePointsToStringUnmapper));
    const enrichedConstraints = safeObjectAssign(safeObjectAssign({}, constraints), {
        experimentalCustomSlices
    });
    return (0, _arrayJs.array)(charArbitrary, enrichedConstraints).map((0, _codePointsToStringJs.codePointsToStringMapper), (0, _codePointsToStringJs.codePointsToStringUnmapper));
}

},{"./array.js":"eZMHg","./unicode.js":"2sTN2","./_internals/mappers/CodePointsToString.js":"887co","./_internals/helpers/SlicesForStringBuilder.js":"d3W5S","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"2meNn":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "unicodeJson", ()=>unicodeJson);
var _unicodeJsonValueJs = require("./unicodeJsonValue.js");
function unicodeJson(constraints = {}) {
    const arb = (0, _unicodeJsonValueJs.unicodeJsonValue)(constraints);
    return arb.map(JSON.stringify);
}

},{"./unicodeJsonValue.js":"6IvVE","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"ct0c7":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "record", ()=>record);
var _partialRecordArbitraryBuilderJs = require("./_internals/builders/PartialRecordArbitraryBuilder.js");
function record(recordModel, constraints) {
    const noNullPrototype = constraints === undefined || constraints.noNullPrototype === undefined || constraints.noNullPrototype;
    if (constraints == null) return (0, _partialRecordArbitraryBuilderJs.buildPartialRecordArbitrary)(recordModel, undefined, noNullPrototype);
    if ('withDeletedKeys' in constraints && 'requiredKeys' in constraints) throw new Error(`requiredKeys and withDeletedKeys cannot be used together in fc.record`);
    const requireDeletedKeys = 'requiredKeys' in constraints && constraints.requiredKeys !== undefined || 'withDeletedKeys' in constraints && !!constraints.withDeletedKeys;
    if (!requireDeletedKeys) return (0, _partialRecordArbitraryBuilderJs.buildPartialRecordArbitrary)(recordModel, undefined, noNullPrototype);
    const requiredKeys = ('requiredKeys' in constraints ? constraints.requiredKeys : undefined) || [];
    for(let idx = 0; idx !== requiredKeys.length; ++idx){
        const descriptor = Object.getOwnPropertyDescriptor(recordModel, requiredKeys[idx]);
        if (descriptor === undefined) throw new Error(`requiredKeys cannot reference keys that have not been defined in recordModel`);
        if (!descriptor.enumerable) throw new Error(`requiredKeys cannot reference keys that have are enumerable in recordModel`);
    }
    return (0, _partialRecordArbitraryBuilderJs.buildPartialRecordArbitrary)(recordModel, requiredKeys, noNullPrototype);
}

},{"./_internals/builders/PartialRecordArbitraryBuilder.js":"gzNZ4","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"gzNZ4":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "buildPartialRecordArbitrary", ()=>buildPartialRecordArbitrary);
var _globalsJs = require("../../../utils/globals.js");
var _booleanJs = require("../../boolean.js");
var _constantJs = require("../../constant.js");
var _optionJs = require("../../option.js");
var _tupleJs = require("../../tuple.js");
var _enumerableKeysExtractorJs = require("../helpers/EnumerableKeysExtractor.js");
var _valuesAndSeparateKeysToObjectJs = require("../mappers/ValuesAndSeparateKeysToObject.js");
const noKeyValue = Symbol('no-key');
function buildPartialRecordArbitrary(recordModel, requiredKeys, noNullPrototype) {
    const keys = (0, _enumerableKeysExtractorJs.extractEnumerableKeys)(recordModel);
    const arbs = [];
    for(let index = 0; index !== keys.length; ++index){
        const k = keys[index];
        const requiredArbitrary = recordModel[k];
        if (requiredKeys === undefined || (0, _globalsJs.safeIndexOf)(requiredKeys, k) !== -1) (0, _globalsJs.safePush)(arbs, requiredArbitrary);
        else (0, _globalsJs.safePush)(arbs, (0, _optionJs.option)(requiredArbitrary, {
            nil: noKeyValue
        }));
    }
    return (0, _tupleJs.tuple)((0, _tupleJs.tuple)(...arbs), noNullPrototype ? (0, _constantJs.constant)(false) : (0, _booleanJs.boolean)()).map((0, _valuesAndSeparateKeysToObjectJs.buildValuesAndSeparateKeysToObjectMapper)(keys, noKeyValue), (0, _valuesAndSeparateKeysToObjectJs.buildValuesAndSeparateKeysToObjectUnmapper)(keys, noKeyValue));
}

},{"../../../utils/globals.js":"aTuwn","../../boolean.js":"bazde","../../constant.js":"6Ey5n","../../option.js":"8sNMn","../../tuple.js":"dw0Pn","../helpers/EnumerableKeysExtractor.js":"7DgkA","../mappers/ValuesAndSeparateKeysToObject.js":"lKGrT","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"7DgkA":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "extractEnumerableKeys", ()=>extractEnumerableKeys);
const safeObjectKeys = Object.keys;
const safeObjectGetOwnPropertySymbols = Object.getOwnPropertySymbols;
const safeObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
function extractEnumerableKeys(instance) {
    const keys = safeObjectKeys(instance);
    const symbols = safeObjectGetOwnPropertySymbols(instance);
    for(let index = 0; index !== symbols.length; ++index){
        const symbol = symbols[index];
        const descriptor = safeObjectGetOwnPropertyDescriptor(instance, symbol);
        if (descriptor && descriptor.enumerable) keys.push(symbol);
    }
    return keys;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"lKGrT":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "buildValuesAndSeparateKeysToObjectMapper", ()=>buildValuesAndSeparateKeysToObjectMapper);
parcelHelpers.export(exports, "buildValuesAndSeparateKeysToObjectUnmapper", ()=>buildValuesAndSeparateKeysToObjectUnmapper);
var _globalsJs = require("../../../utils/globals.js");
const safeObjectCreate = Object.create;
const safeObjectDefineProperty = Object.defineProperty;
const safeObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
const safeObjectGetOwnPropertyNames = Object.getOwnPropertyNames;
const safeObjectGetOwnPropertySymbols = Object.getOwnPropertySymbols;
function buildValuesAndSeparateKeysToObjectMapper(keys, noKeyValue) {
    return function valuesAndSeparateKeysToObjectMapper(definition) {
        const obj = definition[1] ? safeObjectCreate(null) : {};
        for(let idx = 0; idx !== keys.length; ++idx){
            const valueWrapper = definition[0][idx];
            if (valueWrapper !== noKeyValue) safeObjectDefineProperty(obj, keys[idx], {
                value: valueWrapper,
                configurable: true,
                enumerable: true,
                writable: true
            });
        }
        return obj;
    };
}
function buildValuesAndSeparateKeysToObjectUnmapper(keys, noKeyValue) {
    return function valuesAndSeparateKeysToObjectUnmapper(value) {
        if (typeof value !== 'object' || value === null) throw new Error('Incompatible instance received: should be a non-null object');
        const hasNullPrototype = Object.getPrototypeOf(value) === null;
        const hasObjectPrototype = 'constructor' in value && value.constructor === Object;
        if (!hasNullPrototype && !hasObjectPrototype) throw new Error('Incompatible instance received: should be of exact type Object');
        let extractedPropertiesCount = 0;
        const extractedValues = [];
        for(let idx = 0; idx !== keys.length; ++idx){
            const descriptor = safeObjectGetOwnPropertyDescriptor(value, keys[idx]);
            if (descriptor !== undefined) {
                if (!descriptor.configurable || !descriptor.enumerable || !descriptor.writable) throw new Error('Incompatible instance received: should contain only c/e/w properties');
                if (descriptor.get !== undefined || descriptor.set !== undefined) throw new Error('Incompatible instance received: should contain only no get/set properties');
                ++extractedPropertiesCount;
                (0, _globalsJs.safePush)(extractedValues, descriptor.value);
            } else (0, _globalsJs.safePush)(extractedValues, noKeyValue);
        }
        const namePropertiesCount = safeObjectGetOwnPropertyNames(value).length;
        const symbolPropertiesCount = safeObjectGetOwnPropertySymbols(value).length;
        if (extractedPropertiesCount !== namePropertiesCount + symbolPropertiesCount) throw new Error('Incompatible instance received: should not contain extra properties');
        return [
            extractedValues,
            hasNullPrototype
        ];
    };
}

},{"../../../utils/globals.js":"aTuwn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"7HEQI":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "infiniteStream", ()=>infiniteStream);
var _streamArbitraryJs = require("./_internals/StreamArbitrary.js");
function infiniteStream(arb) {
    return new (0, _streamArbitraryJs.StreamArbitrary)(arb);
}

},{"./_internals/StreamArbitrary.js":"d6fwW","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"d6fwW":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "StreamArbitrary", ()=>StreamArbitrary);
var _arbitraryJs = require("../../check/arbitrary/definition/Arbitrary.js");
var _valueJs = require("../../check/arbitrary/definition/Value.js");
var _symbolsJs = require("../../check/symbols.js");
var _streamJs = require("../../stream/Stream.js");
var _globalsJs = require("../../utils/globals.js");
var _stringifyJs = require("../../utils/stringify.js");
const safeObjectDefineProperties = Object.defineProperties;
function prettyPrint(seenValuesStrings) {
    return `Stream(${(0, _globalsJs.safeJoin)(seenValuesStrings, ',')}\u{2026})`;
}
class StreamArbitrary extends (0, _arbitraryJs.Arbitrary) {
    constructor(arb){
        super();
        this.arb = arb;
    }
    generate(mrng, biasFactor) {
        const appliedBiasFactor = biasFactor !== undefined && mrng.nextInt(1, biasFactor) === 1 ? biasFactor : undefined;
        const enrichedProducer = ()=>{
            const seenValues = [];
            const g = function*(arb, clonedMrng) {
                while(true){
                    const value = arb.generate(clonedMrng, appliedBiasFactor).value;
                    (0, _globalsJs.safePush)(seenValues, value);
                    yield value;
                }
            };
            const s = new (0, _streamJs.Stream)(g(this.arb, mrng.clone()));
            return safeObjectDefineProperties(s, {
                toString: {
                    value: ()=>prettyPrint(seenValues.map((0, _stringifyJs.stringify)))
                },
                [(0, _stringifyJs.toStringMethod)]: {
                    value: ()=>prettyPrint(seenValues.map((0, _stringifyJs.stringify)))
                },
                [(0, _stringifyJs.asyncToStringMethod)]: {
                    value: async ()=>prettyPrint(await Promise.all(seenValues.map((0, _stringifyJs.asyncStringify))))
                },
                [(0, _symbolsJs.cloneMethod)]: {
                    value: enrichedProducer,
                    enumerable: true
                }
            });
        };
        return new (0, _valueJs.Value)(enrichedProducer(), undefined);
    }
    canShrinkWithoutContext(value) {
        return false;
    }
    shrink(_value, _context) {
        return (0, _streamJs.Stream).nil();
    }
}

},{"../../check/arbitrary/definition/Arbitrary.js":"e6f1K","../../check/arbitrary/definition/Value.js":"8Cf1j","../../check/symbols.js":"2AK80","../../stream/Stream.js":"2sjal","../../utils/globals.js":"aTuwn","../../utils/stringify.js":"gOa8u","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"fxuVr":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "asciiString", ()=>asciiString);
var _arrayJs = require("./array.js");
var _asciiJs = require("./ascii.js");
var _codePointsToStringJs = require("./_internals/mappers/CodePointsToString.js");
var _slicesForStringBuilderJs = require("./_internals/helpers/SlicesForStringBuilder.js");
const safeObjectAssign = Object.assign;
function asciiString(constraints = {}) {
    const charArbitrary = (0, _asciiJs.ascii)();
    const experimentalCustomSlices = (0, _slicesForStringBuilderJs.createSlicesForStringLegacy)(charArbitrary, (0, _codePointsToStringJs.codePointsToStringUnmapper));
    const enrichedConstraints = safeObjectAssign(safeObjectAssign({}, constraints), {
        experimentalCustomSlices
    });
    return (0, _arrayJs.array)(charArbitrary, enrichedConstraints).map((0, _codePointsToStringJs.codePointsToStringMapper), (0, _codePointsToStringJs.codePointsToStringUnmapper));
}

},{"./array.js":"eZMHg","./ascii.js":"bbQ9F","./_internals/mappers/CodePointsToString.js":"887co","./_internals/helpers/SlicesForStringBuilder.js":"d3W5S","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"gohPH":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "base64String", ()=>base64String);
var _arrayJs = require("./array.js");
var _base64Js = require("./base64.js");
var _maxLengthFromMinLengthJs = require("./_internals/helpers/MaxLengthFromMinLength.js");
var _codePointsToStringJs = require("./_internals/mappers/CodePointsToString.js");
var _stringToBase64Js = require("./_internals/mappers/StringToBase64.js");
var _slicesForStringBuilderJs = require("./_internals/helpers/SlicesForStringBuilder.js");
function base64String(constraints = {}) {
    const { minLength: unscaledMinLength = 0, maxLength: unscaledMaxLength = (0, _maxLengthFromMinLengthJs.MaxLengthUpperBound), size } = constraints;
    const minLength = unscaledMinLength + 3 - (unscaledMinLength + 3) % 4;
    const maxLength = unscaledMaxLength - unscaledMaxLength % 4;
    const requestedSize = constraints.maxLength === undefined && size === undefined ? '=' : size;
    if (minLength > maxLength) throw new Error('Minimal length should be inferior or equal to maximal length');
    if (minLength % 4 !== 0) throw new Error('Minimal length of base64 strings must be a multiple of 4');
    if (maxLength % 4 !== 0) throw new Error('Maximal length of base64 strings must be a multiple of 4');
    const charArbitrary = (0, _base64Js.base64)();
    const experimentalCustomSlices = (0, _slicesForStringBuilderJs.createSlicesForStringLegacy)(charArbitrary, (0, _codePointsToStringJs.codePointsToStringUnmapper));
    const enrichedConstraints = {
        minLength,
        maxLength,
        size: requestedSize,
        experimentalCustomSlices
    };
    return (0, _arrayJs.array)(charArbitrary, enrichedConstraints).map((0, _codePointsToStringJs.codePointsToStringMapper), (0, _codePointsToStringJs.codePointsToStringUnmapper)).map((0, _stringToBase64Js.stringToBase64Mapper), (0, _stringToBase64Js.stringToBase64Unmapper));
}

},{"./array.js":"eZMHg","./base64.js":"jfhtz","./_internals/helpers/MaxLengthFromMinLength.js":"5ilwx","./_internals/mappers/CodePointsToString.js":"887co","./_internals/mappers/StringToBase64.js":"8LkJu","./_internals/helpers/SlicesForStringBuilder.js":"d3W5S","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"8LkJu":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "stringToBase64Mapper", ()=>stringToBase64Mapper);
parcelHelpers.export(exports, "stringToBase64Unmapper", ()=>stringToBase64Unmapper);
var _globalsJs = require("../../../utils/globals.js");
function stringToBase64Mapper(s) {
    switch(s.length % 4){
        case 0:
            return s;
        case 3:
            return `${s}=`;
        case 2:
            return `${s}==`;
        default:
            return (0, _globalsJs.safeSubstring)(s, 1);
    }
}
function stringToBase64Unmapper(value) {
    if (typeof value !== 'string' || value.length % 4 !== 0) throw new Error('Invalid string received');
    const lastTrailingIndex = value.indexOf('=');
    if (lastTrailingIndex === -1) return value;
    const numTrailings = value.length - lastTrailingIndex;
    if (numTrailings > 2) throw new Error('Cannot unmap the passed value');
    return (0, _globalsJs.safeSubstring)(value, 0, lastTrailingIndex);
}

},{"../../../utils/globals.js":"aTuwn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"bmjQM":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "string16bits", ()=>string16bits);
var _arrayJs = require("./array.js");
var _char16BitsJs = require("./char16bits.js");
var _charsToStringJs = require("./_internals/mappers/CharsToString.js");
var _slicesForStringBuilderJs = require("./_internals/helpers/SlicesForStringBuilder.js");
const safeObjectAssign = Object.assign;
function string16bits(constraints = {}) {
    const charArbitrary = (0, _char16BitsJs.char16bits)();
    const experimentalCustomSlices = (0, _slicesForStringBuilderJs.createSlicesForStringLegacy)(charArbitrary, (0, _charsToStringJs.charsToStringUnmapper));
    const enrichedConstraints = safeObjectAssign(safeObjectAssign({}, constraints), {
        experimentalCustomSlices
    });
    return (0, _arrayJs.array)(charArbitrary, enrichedConstraints).map((0, _charsToStringJs.charsToStringMapper), (0, _charsToStringJs.charsToStringUnmapper));
}

},{"./array.js":"eZMHg","./char16bits.js":"8ydXM","./_internals/mappers/CharsToString.js":"lu2Jy","./_internals/helpers/SlicesForStringBuilder.js":"d3W5S","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"lu2Jy":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "charsToStringMapper", ()=>charsToStringMapper);
parcelHelpers.export(exports, "charsToStringUnmapper", ()=>charsToStringUnmapper);
var _globalsJs = require("../../../utils/globals.js");
function charsToStringMapper(tab) {
    return (0, _globalsJs.safeJoin)(tab, '');
}
function charsToStringUnmapper(value) {
    if (typeof value !== 'string') throw new Error('Cannot unmap the passed value');
    return (0, _globalsJs.safeSplit)(value, '');
}

},{"../../../utils/globals.js":"aTuwn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"5vl42":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "stringOf", ()=>stringOf);
var _arrayJs = require("./array.js");
var _patternsToStringJs = require("./_internals/mappers/PatternsToString.js");
var _slicesForStringBuilderJs = require("./_internals/helpers/SlicesForStringBuilder.js");
const safeObjectAssign = Object.assign;
function stringOf(charArb, constraints = {}) {
    const unmapper = (0, _patternsToStringJs.patternsToStringUnmapperFor)(charArb, constraints);
    const experimentalCustomSlices = (0, _slicesForStringBuilderJs.createSlicesForStringLegacy)(charArb, unmapper);
    const enrichedConstraints = safeObjectAssign(safeObjectAssign({}, constraints), {
        experimentalCustomSlices
    });
    return (0, _arrayJs.array)(charArb, enrichedConstraints).map((0, _patternsToStringJs.patternsToStringMapper), unmapper);
}

},{"./array.js":"eZMHg","./_internals/mappers/PatternsToString.js":"frPRE","./_internals/helpers/SlicesForStringBuilder.js":"d3W5S","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"kgeWD":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "subarray", ()=>subarray);
var _subarrayArbitraryJs = require("./_internals/SubarrayArbitrary.js");
function subarray(originalArray, constraints = {}) {
    const { minLength = 0, maxLength = originalArray.length } = constraints;
    return new (0, _subarrayArbitraryJs.SubarrayArbitrary)(originalArray, true, minLength, maxLength);
}

},{"./_internals/SubarrayArbitrary.js":"h40MH","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"h40MH":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SubarrayArbitrary", ()=>SubarrayArbitrary);
var _arbitraryJs = require("../../check/arbitrary/definition/Arbitrary.js");
var _valueJs = require("../../check/arbitrary/definition/Value.js");
var _lazyIterableIteratorJs = require("../../stream/LazyIterableIterator.js");
var _streamJs = require("../../stream/Stream.js");
var _globalsJs = require("../../utils/globals.js");
var _isSubarrayOfJs = require("./helpers/IsSubarrayOf.js");
var _integerArbitraryJs = require("./IntegerArbitrary.js");
const safeMathFloor = Math.floor;
const safeMathLog = Math.log;
const safeArrayIsArray = Array.isArray;
class SubarrayArbitrary extends (0, _arbitraryJs.Arbitrary) {
    constructor(originalArray, isOrdered, minLength, maxLength){
        super();
        this.originalArray = originalArray;
        this.isOrdered = isOrdered;
        this.minLength = minLength;
        this.maxLength = maxLength;
        if (minLength < 0 || minLength > originalArray.length) throw new Error('fc.*{s|S}ubarrayOf expects the minimal length to be between 0 and the size of the original array');
        if (maxLength < 0 || maxLength > originalArray.length) throw new Error('fc.*{s|S}ubarrayOf expects the maximal length to be between 0 and the size of the original array');
        if (minLength > maxLength) throw new Error('fc.*{s|S}ubarrayOf expects the minimal length to be inferior or equal to the maximal length');
        this.lengthArb = new (0, _integerArbitraryJs.IntegerArbitrary)(minLength, maxLength);
        this.biasedLengthArb = minLength !== maxLength ? new (0, _integerArbitraryJs.IntegerArbitrary)(minLength, minLength + safeMathFloor(safeMathLog(maxLength - minLength) / safeMathLog(2))) : this.lengthArb;
    }
    generate(mrng, biasFactor) {
        const lengthArb = biasFactor !== undefined && mrng.nextInt(1, biasFactor) === 1 ? this.biasedLengthArb : this.lengthArb;
        const size = lengthArb.generate(mrng, undefined);
        const sizeValue = size.value;
        const remainingElements = (0, _globalsJs.safeMap)(this.originalArray, (_v, idx)=>idx);
        const ids = [];
        for(let index = 0; index !== sizeValue; ++index){
            const selectedIdIndex = mrng.nextInt(0, remainingElements.length - 1);
            (0, _globalsJs.safePush)(ids, remainingElements[selectedIdIndex]);
            (0, _globalsJs.safeSplice)(remainingElements, selectedIdIndex, 1);
        }
        if (this.isOrdered) (0, _globalsJs.safeSort)(ids, (a, b)=>a - b);
        return new (0, _valueJs.Value)((0, _globalsJs.safeMap)(ids, (i)=>this.originalArray[i]), size.context);
    }
    canShrinkWithoutContext(value) {
        if (!safeArrayIsArray(value)) return false;
        if (!this.lengthArb.canShrinkWithoutContext(value.length)) return false;
        return (0, _isSubarrayOfJs.isSubarrayOf)(this.originalArray, value);
    }
    shrink(value, context) {
        if (value.length === 0) return (0, _streamJs.Stream).nil();
        return this.lengthArb.shrink(value.length, context).map((newSize)=>{
            return new (0, _valueJs.Value)((0, _globalsJs.safeSlice)(value, value.length - newSize.value), newSize.context);
        }).join(value.length > this.minLength ? (0, _lazyIterableIteratorJs.makeLazy)(()=>this.shrink((0, _globalsJs.safeSlice)(value, 1), undefined).filter((newValue)=>this.minLength <= newValue.value.length + 1).map((newValue)=>new (0, _valueJs.Value)([
                    value[0],
                    ...newValue.value
                ], undefined))) : (0, _streamJs.Stream).nil());
    }
}

},{"../../check/arbitrary/definition/Arbitrary.js":"e6f1K","../../check/arbitrary/definition/Value.js":"8Cf1j","../../stream/LazyIterableIterator.js":"bnj2K","../../stream/Stream.js":"2sjal","../../utils/globals.js":"aTuwn","./helpers/IsSubarrayOf.js":"b7YYQ","./IntegerArbitrary.js":"5m6ip","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"b7YYQ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isSubarrayOf", ()=>isSubarrayOf);
var _globalsJs = require("../../../utils/globals.js");
const safeObjectIs = Object.is;
function isSubarrayOf(source, small) {
    const countMap = new (0, _globalsJs.Map)();
    let countMinusZero = 0;
    for (const sourceEntry of source)if (safeObjectIs(sourceEntry, -0)) ++countMinusZero;
    else {
        const oldCount = (0, _globalsJs.safeMapGet)(countMap, sourceEntry) || 0;
        (0, _globalsJs.safeMapSet)(countMap, sourceEntry, oldCount + 1);
    }
    for(let index = 0; index !== small.length; ++index){
        if (!(index in small)) return false;
        const smallEntry = small[index];
        if (safeObjectIs(smallEntry, -0)) {
            if (countMinusZero === 0) return false;
            --countMinusZero;
        } else {
            const oldCount = (0, _globalsJs.safeMapGet)(countMap, smallEntry) || 0;
            if (oldCount === 0) return false;
            (0, _globalsJs.safeMapSet)(countMap, smallEntry, oldCount - 1);
        }
    }
    return true;
}

},{"../../../utils/globals.js":"aTuwn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"61HTX":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "shuffledSubarray", ()=>shuffledSubarray);
var _subarrayArbitraryJs = require("./_internals/SubarrayArbitrary.js");
function shuffledSubarray(originalArray, constraints = {}) {
    const { minLength = 0, maxLength = originalArray.length } = constraints;
    return new (0, _subarrayArbitraryJs.SubarrayArbitrary)(originalArray, false, minLength, maxLength);
}

},{"./_internals/SubarrayArbitrary.js":"h40MH","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"aBd18":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ulid", ()=>ulid);
var _tupleJs = require("./tuple.js");
var _integerJs = require("./integer.js");
var _uintToBase32StringJs = require("./_internals/mappers/UintToBase32String.js");
const padded10Mapper = (0, _uintToBase32StringJs.paddedUintToBase32StringMapper)(10);
const padded8Mapper = (0, _uintToBase32StringJs.paddedUintToBase32StringMapper)(8);
function ulidMapper(parts) {
    return padded10Mapper(parts[0]) + padded8Mapper(parts[1]) + padded8Mapper(parts[2]);
}
function ulidUnmapper(value) {
    if (typeof value !== 'string' || value.length !== 26) throw new Error('Unsupported type');
    return [
        (0, _uintToBase32StringJs.uintToBase32StringUnmapper)(value.slice(0, 10)),
        (0, _uintToBase32StringJs.uintToBase32StringUnmapper)(value.slice(10, 18)),
        (0, _uintToBase32StringJs.uintToBase32StringUnmapper)(value.slice(18))
    ];
}
function ulid() {
    const timestampPartArbitrary = (0, _integerJs.integer)({
        min: 0,
        max: 0xffffffffffff
    });
    const randomnessPartOneArbitrary = (0, _integerJs.integer)({
        min: 0,
        max: 0xffffffffff
    });
    const randomnessPartTwoArbitrary = (0, _integerJs.integer)({
        min: 0,
        max: 0xffffffffff
    });
    return (0, _tupleJs.tuple)(timestampPartArbitrary, randomnessPartOneArbitrary, randomnessPartTwoArbitrary).map(ulidMapper, ulidUnmapper);
}

},{"./tuple.js":"dw0Pn","./integer.js":"embjo","./_internals/mappers/UintToBase32String.js":"6KQ4Y","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"6KQ4Y":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "uintToBase32StringMapper", ()=>uintToBase32StringMapper);
parcelHelpers.export(exports, "paddedUintToBase32StringMapper", ()=>paddedUintToBase32StringMapper);
parcelHelpers.export(exports, "uintToBase32StringUnmapper", ()=>uintToBase32StringUnmapper);
var _globalsJs = require("../../../utils/globals.js");
const encodeSymbolLookupTable = {
    10: 'A',
    11: 'B',
    12: 'C',
    13: 'D',
    14: 'E',
    15: 'F',
    16: 'G',
    17: 'H',
    18: 'J',
    19: 'K',
    20: 'M',
    21: 'N',
    22: 'P',
    23: 'Q',
    24: 'R',
    25: 'S',
    26: 'T',
    27: 'V',
    28: 'W',
    29: 'X',
    30: 'Y',
    31: 'Z'
};
const decodeSymbolLookupTable = {
    '0': 0,
    '1': 1,
    '2': 2,
    '3': 3,
    '4': 4,
    '5': 5,
    '6': 6,
    '7': 7,
    '8': 8,
    '9': 9,
    A: 10,
    B: 11,
    C: 12,
    D: 13,
    E: 14,
    F: 15,
    G: 16,
    H: 17,
    J: 18,
    K: 19,
    M: 20,
    N: 21,
    P: 22,
    Q: 23,
    R: 24,
    S: 25,
    T: 26,
    V: 27,
    W: 28,
    X: 29,
    Y: 30,
    Z: 31
};
function encodeSymbol(symbol) {
    return symbol < 10 ? (0, _globalsJs.String)(symbol) : encodeSymbolLookupTable[symbol];
}
function pad(value, paddingLength) {
    let extraPadding = '';
    while(value.length + extraPadding.length < paddingLength)extraPadding += '0';
    return extraPadding + value;
}
function smallUintToBase32StringMapper(num) {
    let base32Str = '';
    for(let remaining = num; remaining !== 0;){
        const next = remaining >> 5;
        const current = remaining - (next << 5);
        base32Str = encodeSymbol(current) + base32Str;
        remaining = next;
    }
    return base32Str;
}
function uintToBase32StringMapper(num, paddingLength) {
    const head = ~~(num / 0x40000000);
    const tail = num & 0x3fffffff;
    return pad(smallUintToBase32StringMapper(head), paddingLength - 6) + pad(smallUintToBase32StringMapper(tail), 6);
}
function paddedUintToBase32StringMapper(paddingLength) {
    return function padded(num) {
        return uintToBase32StringMapper(num, paddingLength);
    };
}
function uintToBase32StringUnmapper(value) {
    if (typeof value !== 'string') throw new (0, _globalsJs.Error)('Unsupported type');
    let accumulated = 0;
    let power = 1;
    for(let index = value.length - 1; index >= 0; --index){
        const char = value[index];
        const numericForChar = decodeSymbolLookupTable[char];
        if (numericForChar === undefined) throw new (0, _globalsJs.Error)('Unsupported type');
        accumulated += numericForChar * power;
        power *= 32;
    }
    return accumulated;
}

},{"../../../utils/globals.js":"aTuwn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"b5hPH":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "uuid", ()=>uuid);
var _tupleJs = require("./tuple.js");
var _paddedNumberArbitraryBuilderJs = require("./_internals/builders/PaddedNumberArbitraryBuilder.js");
var _paddedEightsToUuidJs = require("./_internals/mappers/PaddedEightsToUuid.js");
var _globalsJs = require("../utils/globals.js");
var _versionsApplierForUuidJs = require("./_internals/mappers/VersionsApplierForUuid.js");
function assertValidVersions(versions) {
    const found = {};
    for (const version of versions){
        if (found[version]) throw new (0, _globalsJs.Error)(`Version ${version} has been requested at least twice for uuid`);
        found[version] = true;
        if (version < 1 || version > 15) throw new (0, _globalsJs.Error)(`Version must be a value in [1-15] for uuid, but received ${version}`);
        if (~~version !== version) throw new (0, _globalsJs.Error)(`Version must be an integer value for uuid, but received ${version}`);
    }
    if (versions.length === 0) throw new (0, _globalsJs.Error)(`Must provide at least one version for uuid`);
}
function uuid(constraints = {}) {
    const padded = (0, _paddedNumberArbitraryBuilderJs.buildPaddedNumberArbitrary)(0, 0xffffffff);
    const version = constraints.version !== undefined ? typeof constraints.version === 'number' ? [
        constraints.version
    ] : constraints.version : [
        1,
        2,
        3,
        4,
        5
    ];
    assertValidVersions(version);
    const { versionsApplierMapper, versionsApplierUnmapper } = (0, _versionsApplierForUuidJs.buildVersionsAppliersForUuid)(version);
    const secondPadded = (0, _paddedNumberArbitraryBuilderJs.buildPaddedNumberArbitrary)(0, 0x10000000 * version.length - 1).map(versionsApplierMapper, versionsApplierUnmapper);
    const thirdPadded = (0, _paddedNumberArbitraryBuilderJs.buildPaddedNumberArbitrary)(0x80000000, 0xbfffffff);
    return (0, _tupleJs.tuple)(padded, secondPadded, thirdPadded, padded).map((0, _paddedEightsToUuidJs.paddedEightsToUuidMapper), (0, _paddedEightsToUuidJs.paddedEightsToUuidUnmapper));
}

},{"./tuple.js":"dw0Pn","./_internals/builders/PaddedNumberArbitraryBuilder.js":"lzfLj","./_internals/mappers/PaddedEightsToUuid.js":"41QS4","../utils/globals.js":"aTuwn","./_internals/mappers/VersionsApplierForUuid.js":"eB2SV","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"lzfLj":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "buildPaddedNumberArbitrary", ()=>buildPaddedNumberArbitrary);
var _integerJs = require("../../integer.js");
var _numberToPaddedEightJs = require("../mappers/NumberToPaddedEight.js");
function buildPaddedNumberArbitrary(min, max) {
    return (0, _integerJs.integer)({
        min,
        max
    }).map((0, _numberToPaddedEightJs.numberToPaddedEightMapper), (0, _numberToPaddedEightJs.numberToPaddedEightUnmapper));
}

},{"../../integer.js":"embjo","../mappers/NumberToPaddedEight.js":"cmulO","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"cmulO":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "numberToPaddedEightMapper", ()=>numberToPaddedEightMapper);
parcelHelpers.export(exports, "numberToPaddedEightUnmapper", ()=>numberToPaddedEightUnmapper);
var _globalsJs = require("../../../utils/globals.js");
function numberToPaddedEightMapper(n) {
    return (0, _globalsJs.safePadStart)((0, _globalsJs.safeNumberToString)(n, 16), 8, '0');
}
function numberToPaddedEightUnmapper(value) {
    if (typeof value !== 'string') throw new Error('Unsupported type');
    if (value.length !== 8) throw new Error('Unsupported value: invalid length');
    const n = parseInt(value, 16);
    if (value !== numberToPaddedEightMapper(n)) throw new Error('Unsupported value: invalid content');
    return n;
}

},{"../../../utils/globals.js":"aTuwn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"41QS4":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "paddedEightsToUuidMapper", ()=>paddedEightsToUuidMapper);
parcelHelpers.export(exports, "paddedEightsToUuidUnmapper", ()=>paddedEightsToUuidUnmapper);
var _globalsJs = require("../../../utils/globals.js");
function paddedEightsToUuidMapper(t) {
    return `${t[0]}-${(0, _globalsJs.safeSubstring)(t[1], 4)}-${(0, _globalsJs.safeSubstring)(t[1], 0, 4)}-${(0, _globalsJs.safeSubstring)(t[2], 0, 4)}-${(0, _globalsJs.safeSubstring)(t[2], 4)}${t[3]}`;
}
const UuidRegex = /^([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})$/;
function paddedEightsToUuidUnmapper(value) {
    if (typeof value !== 'string') throw new Error('Unsupported type');
    const m = UuidRegex.exec(value);
    if (m === null) throw new Error('Unsupported type');
    return [
        m[1],
        m[3] + m[2],
        m[4] + (0, _globalsJs.safeSubstring)(m[5], 0, 4),
        (0, _globalsJs.safeSubstring)(m[5], 4)
    ];
}

},{"../../../utils/globals.js":"aTuwn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"eB2SV":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "buildVersionsAppliersForUuid", ()=>buildVersionsAppliersForUuid);
var _globalsJs = require("../../../utils/globals.js");
const quickNumberToHexaString = '0123456789abcdef';
function buildVersionsAppliersForUuid(versions) {
    const mapping = {};
    const reversedMapping = {};
    for(let index = 0; index !== versions.length; ++index){
        const from = quickNumberToHexaString[index];
        const to = quickNumberToHexaString[versions[index]];
        mapping[from] = to;
        reversedMapping[to] = from;
    }
    function versionsApplierMapper(value) {
        return mapping[value[0]] + (0, _globalsJs.safeSubstring)(value, 1);
    }
    function versionsApplierUnmapper(value) {
        if (typeof value !== 'string') throw new (0, _globalsJs.Error)('Cannot produce non-string values');
        const rev = reversedMapping[value[0]];
        if (rev === undefined) throw new (0, _globalsJs.Error)('Cannot produce strings not starting by the version in hexa code');
        return rev + (0, _globalsJs.safeSubstring)(value, 1);
    }
    return {
        versionsApplierMapper,
        versionsApplierUnmapper
    };
}

},{"../../../utils/globals.js":"aTuwn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"6Ocm7":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "uuidV", ()=>uuidV);
var _tupleJs = require("./tuple.js");
var _paddedNumberArbitraryBuilderJs = require("./_internals/builders/PaddedNumberArbitraryBuilder.js");
var _paddedEightsToUuidJs = require("./_internals/mappers/PaddedEightsToUuid.js");
function uuidV(versionNumber) {
    const padded = (0, _paddedNumberArbitraryBuilderJs.buildPaddedNumberArbitrary)(0, 0xffffffff);
    const offsetSecond = versionNumber * 0x10000000;
    const secondPadded = (0, _paddedNumberArbitraryBuilderJs.buildPaddedNumberArbitrary)(offsetSecond, offsetSecond + 0x0fffffff);
    const thirdPadded = (0, _paddedNumberArbitraryBuilderJs.buildPaddedNumberArbitrary)(0x80000000, 0xbfffffff);
    return (0, _tupleJs.tuple)(padded, secondPadded, thirdPadded, padded).map((0, _paddedEightsToUuidJs.paddedEightsToUuidMapper), (0, _paddedEightsToUuidJs.paddedEightsToUuidUnmapper));
}

},{"./tuple.js":"dw0Pn","./_internals/builders/PaddedNumberArbitraryBuilder.js":"lzfLj","./_internals/mappers/PaddedEightsToUuid.js":"41QS4","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"5rYqd":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "webAuthority", ()=>webAuthority);
var _characterRangeArbitraryBuilderJs = require("./_internals/builders/CharacterRangeArbitraryBuilder.js");
var _constantJs = require("./constant.js");
var _domainJs = require("./domain.js");
var _ipV4Js = require("./ipV4.js");
var _ipV4ExtendedJs = require("./ipV4Extended.js");
var _ipV6Js = require("./ipV6.js");
var _natJs = require("./nat.js");
var _oneofJs = require("./oneof.js");
var _optionJs = require("./option.js");
var _stringJs = require("./string.js");
var _tupleJs = require("./tuple.js");
function hostUserInfo(size) {
    return (0, _stringJs.string)({
        unit: (0, _characterRangeArbitraryBuilderJs.getOrCreateAlphaNumericPercentArbitrary)("-._~!$&'()*+,;=:"),
        size
    });
}
function userHostPortMapper([u, h, p]) {
    return (u === null ? '' : `${u}@`) + h + (p === null ? '' : `:${p}`);
}
function userHostPortUnmapper(value) {
    if (typeof value !== 'string') throw new Error('Unsupported');
    const atPosition = value.indexOf('@');
    const user = atPosition !== -1 ? value.substring(0, atPosition) : null;
    const portRegex = /:(\d+)$/;
    const m = portRegex.exec(value);
    const port = m !== null ? Number(m[1]) : null;
    const host = m !== null ? value.substring(atPosition + 1, value.length - m[1].length - 1) : value.substring(atPosition + 1);
    return [
        user,
        host,
        port
    ];
}
function bracketedMapper(s) {
    return `[${s}]`;
}
function bracketedUnmapper(value) {
    if (typeof value !== 'string' || value[0] !== '[' || value[value.length - 1] !== ']') throw new Error('Unsupported');
    return value.substring(1, value.length - 1);
}
function webAuthority(constraints) {
    const c = constraints || {};
    const size = c.size;
    const hostnameArbs = [
        (0, _domainJs.domain)({
            size
        }),
        ...c.withIPv4 === true ? [
            (0, _ipV4Js.ipV4)()
        ] : [],
        ...c.withIPv6 === true ? [
            (0, _ipV6Js.ipV6)().map(bracketedMapper, bracketedUnmapper)
        ] : [],
        ...c.withIPv4Extended === true ? [
            (0, _ipV4ExtendedJs.ipV4Extended)()
        ] : []
    ];
    return (0, _tupleJs.tuple)(c.withUserInfo === true ? (0, _optionJs.option)(hostUserInfo(size)) : (0, _constantJs.constant)(null), (0, _oneofJs.oneof)(...hostnameArbs), c.withPort === true ? (0, _optionJs.option)((0, _natJs.nat)(65535)) : (0, _constantJs.constant)(null)).map(userHostPortMapper, userHostPortUnmapper);
}

},{"./_internals/builders/CharacterRangeArbitraryBuilder.js":"gF9Ci","./constant.js":"6Ey5n","./domain.js":"irrWS","./ipV4.js":"lIWCt","./ipV4Extended.js":"d0QLr","./ipV6.js":"gHrQA","./nat.js":"isueS","./oneof.js":"cTys0","./option.js":"8sNMn","./string.js":"iHGKT","./tuple.js":"dw0Pn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"32wkl":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "webFragments", ()=>webFragments);
var _uriQueryOrFragmentArbitraryBuilderJs = require("./_internals/builders/UriQueryOrFragmentArbitraryBuilder.js");
function webFragments(constraints = {}) {
    return (0, _uriQueryOrFragmentArbitraryBuilderJs.buildUriQueryOrFragmentArbitrary)(constraints.size);
}

},{"./_internals/builders/UriQueryOrFragmentArbitraryBuilder.js":"1ziQ9","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"1ziQ9":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "buildUriQueryOrFragmentArbitrary", ()=>buildUriQueryOrFragmentArbitrary);
var _characterRangeArbitraryBuilderJs = require("./CharacterRangeArbitraryBuilder.js");
var _stringJs = require("../../string.js");
function buildUriQueryOrFragmentArbitrary(size) {
    return (0, _stringJs.string)({
        unit: (0, _characterRangeArbitraryBuilderJs.getOrCreateAlphaNumericPercentArbitrary)("-._~!$&'()*+,;=:@/?"),
        size
    });
}

},{"./CharacterRangeArbitraryBuilder.js":"gF9Ci","../../string.js":"iHGKT","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"5YO6L":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "webPath", ()=>webPath);
var _maxLengthFromMinLengthJs = require("./_internals/helpers/MaxLengthFromMinLength.js");
var _uriPathArbitraryBuilderJs = require("./_internals/builders/UriPathArbitraryBuilder.js");
function webPath(constraints) {
    const c = constraints || {};
    const resolvedSize = (0, _maxLengthFromMinLengthJs.resolveSize)(c.size);
    return (0, _uriPathArbitraryBuilderJs.buildUriPathArbitrary)(resolvedSize);
}

},{"./_internals/helpers/MaxLengthFromMinLength.js":"5ilwx","./_internals/builders/UriPathArbitraryBuilder.js":"8vPmx","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"8vPmx":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "buildUriPathArbitrary", ()=>buildUriPathArbitrary);
var _webSegmentJs = require("../../webSegment.js");
var _arrayJs = require("../../array.js");
var _segmentsToPathJs = require("../mappers/SegmentsToPath.js");
var _oneofJs = require("../../oneof.js");
function sqrtSize(size) {
    switch(size){
        case 'xsmall':
            return [
                'xsmall',
                'xsmall'
            ];
        case 'small':
            return [
                'small',
                'xsmall'
            ];
        case 'medium':
            return [
                'small',
                'small'
            ];
        case 'large':
            return [
                'medium',
                'small'
            ];
        case 'xlarge':
            return [
                'medium',
                'medium'
            ];
    }
}
function buildUriPathArbitraryInternal(segmentSize, numSegmentSize) {
    return (0, _arrayJs.array)((0, _webSegmentJs.webSegment)({
        size: segmentSize
    }), {
        size: numSegmentSize
    }).map((0, _segmentsToPathJs.segmentsToPathMapper), (0, _segmentsToPathJs.segmentsToPathUnmapper));
}
function buildUriPathArbitrary(resolvedSize) {
    const [segmentSize, numSegmentSize] = sqrtSize(resolvedSize);
    if (segmentSize === numSegmentSize) return buildUriPathArbitraryInternal(segmentSize, numSegmentSize);
    return (0, _oneofJs.oneof)(buildUriPathArbitraryInternal(segmentSize, numSegmentSize), buildUriPathArbitraryInternal(numSegmentSize, segmentSize));
}

},{"../../webSegment.js":"8Xxs3","../../array.js":"eZMHg","../mappers/SegmentsToPath.js":"fycNy","../../oneof.js":"cTys0","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"8Xxs3":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "webSegment", ()=>webSegment);
var _characterRangeArbitraryBuilderJs = require("./_internals/builders/CharacterRangeArbitraryBuilder.js");
var _stringJs = require("./string.js");
function webSegment(constraints = {}) {
    return (0, _stringJs.string)({
        unit: (0, _characterRangeArbitraryBuilderJs.getOrCreateAlphaNumericPercentArbitrary)("-._~!$&'()*+,;=:@"),
        size: constraints.size
    });
}

},{"./_internals/builders/CharacterRangeArbitraryBuilder.js":"gF9Ci","./string.js":"iHGKT","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"fycNy":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "segmentsToPathMapper", ()=>segmentsToPathMapper);
parcelHelpers.export(exports, "segmentsToPathUnmapper", ()=>segmentsToPathUnmapper);
var _globalsJs = require("../../../utils/globals.js");
function segmentsToPathMapper(segments) {
    return (0, _globalsJs.safeJoin)((0, _globalsJs.safeMap)(segments, (v)=>`/${v}`), '');
}
function segmentsToPathUnmapper(value) {
    if (typeof value !== 'string') throw new Error('Incompatible value received: type');
    if (value.length !== 0 && value[0] !== '/') throw new Error('Incompatible value received: start');
    return (0, _globalsJs.safeSplice)((0, _globalsJs.safeSplit)(value, '/'), 1);
}

},{"../../../utils/globals.js":"aTuwn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"cHcCa":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "webQueryParameters", ()=>webQueryParameters);
var _uriQueryOrFragmentArbitraryBuilderJs = require("./_internals/builders/UriQueryOrFragmentArbitraryBuilder.js");
function webQueryParameters(constraints = {}) {
    return (0, _uriQueryOrFragmentArbitraryBuilderJs.buildUriQueryOrFragmentArbitrary)(constraints.size);
}

},{"./_internals/builders/UriQueryOrFragmentArbitraryBuilder.js":"1ziQ9","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"2v3ev":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "webUrl", ()=>webUrl);
var _constantFromJs = require("./constantFrom.js");
var _constantJs = require("./constant.js");
var _optionJs = require("./option.js");
var _tupleJs = require("./tuple.js");
var _webQueryParametersJs = require("./webQueryParameters.js");
var _webFragmentsJs = require("./webFragments.js");
var _webAuthorityJs = require("./webAuthority.js");
var _partsToUrlJs = require("./_internals/mappers/PartsToUrl.js");
var _maxLengthFromMinLengthJs = require("./_internals/helpers/MaxLengthFromMinLength.js");
var _webPathJs = require("./webPath.js");
const safeObjectAssign = Object.assign;
function webUrl(constraints) {
    const c = constraints || {};
    const resolvedSize = (0, _maxLengthFromMinLengthJs.resolveSize)(c.size);
    const resolvedAuthoritySettingsSize = c.authoritySettings !== undefined && c.authoritySettings.size !== undefined ? (0, _maxLengthFromMinLengthJs.relativeSizeToSize)(c.authoritySettings.size, resolvedSize) : resolvedSize;
    const resolvedAuthoritySettings = safeObjectAssign(safeObjectAssign({}, c.authoritySettings), {
        size: resolvedAuthoritySettingsSize
    });
    const validSchemes = c.validSchemes || [
        'http',
        'https'
    ];
    const schemeArb = (0, _constantFromJs.constantFrom)(...validSchemes);
    const authorityArb = (0, _webAuthorityJs.webAuthority)(resolvedAuthoritySettings);
    return (0, _tupleJs.tuple)(schemeArb, authorityArb, (0, _webPathJs.webPath)({
        size: resolvedSize
    }), c.withQueryParameters === true ? (0, _optionJs.option)((0, _webQueryParametersJs.webQueryParameters)({
        size: resolvedSize
    })) : (0, _constantJs.constant)(null), c.withFragments === true ? (0, _optionJs.option)((0, _webFragmentsJs.webFragments)({
        size: resolvedSize
    })) : (0, _constantJs.constant)(null)).map((0, _partsToUrlJs.partsToUrlMapper), (0, _partsToUrlJs.partsToUrlUnmapper));
}

},{"./constantFrom.js":"bZWfh","./constant.js":"6Ey5n","./option.js":"8sNMn","./tuple.js":"dw0Pn","./webQueryParameters.js":"cHcCa","./webFragments.js":"32wkl","./webAuthority.js":"5rYqd","./_internals/mappers/PartsToUrl.js":"jsnsv","./_internals/helpers/MaxLengthFromMinLength.js":"5ilwx","./webPath.js":"5YO6L","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"jsnsv":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "partsToUrlMapper", ()=>partsToUrlMapper);
parcelHelpers.export(exports, "partsToUrlUnmapper", ()=>partsToUrlUnmapper);
function partsToUrlMapper(data) {
    const [scheme, authority, path] = data;
    const query = data[3] === null ? '' : `?${data[3]}`;
    const fragments = data[4] === null ? '' : `#${data[4]}`;
    return `${scheme}://${authority}${path}${query}${fragments}`;
}
const UrlSplitRegex = /^([[A-Za-z][A-Za-z0-9+.-]*):\/\/([^/?#]*)([^?#]*)(\?[A-Za-z0-9\-._~!$&'()*+,;=:@/?%]*)?(#[A-Za-z0-9\-._~!$&'()*+,;=:@/?%]*)?$/;
function partsToUrlUnmapper(value) {
    if (typeof value !== 'string') throw new Error('Incompatible value received: type');
    const m = UrlSplitRegex.exec(value);
    if (m === null) throw new Error('Incompatible value received');
    const scheme = m[1];
    const authority = m[2];
    const path = m[3];
    const query = m[4];
    const fragments = m[5];
    return [
        scheme,
        authority,
        path,
        query !== undefined ? query.substring(1) : null,
        fragments !== undefined ? fragments.substring(1) : null
    ];
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"cER6c":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "commands", ()=>commands);
var _commandsArbitraryJs = require("./_internals/CommandsArbitrary.js");
var _maxLengthFromMinLengthJs = require("./_internals/helpers/MaxLengthFromMinLength.js");
function commands(commandArbs, constraints = {}) {
    const { size, maxCommands = (0, _maxLengthFromMinLengthJs.MaxLengthUpperBound), disableReplayLog = false, replayPath = null } = constraints;
    const specifiedMaxCommands = constraints.maxCommands !== undefined;
    const maxGeneratedCommands = (0, _maxLengthFromMinLengthJs.maxGeneratedLengthFromSizeForArbitrary)(size, 0, maxCommands, specifiedMaxCommands);
    return new (0, _commandsArbitraryJs.CommandsArbitrary)(commandArbs, maxGeneratedCommands, maxCommands, replayPath, disableReplayLog);
}

},{"./_internals/CommandsArbitrary.js":"lUo6t","./_internals/helpers/MaxLengthFromMinLength.js":"5ilwx","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"lUo6t":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CommandsArbitrary", ()=>CommandsArbitrary);
var _arbitraryJs = require("../../check/arbitrary/definition/Arbitrary.js");
var _valueJs = require("../../check/arbitrary/definition/Value.js");
var _commandsIterableJs = require("../../check/model/commands/CommandsIterable.js");
var _commandWrapperJs = require("../../check/model/commands/CommandWrapper.js");
var _replayPathJs = require("../../check/model/ReplayPath.js");
var _lazyIterableIteratorJs = require("../../stream/LazyIterableIterator.js");
var _streamJs = require("../../stream/Stream.js");
var _oneofJs = require("../oneof.js");
var _restrictedIntegerArbitraryBuilderJs = require("./builders/RestrictedIntegerArbitraryBuilder.js");
class CommandsArbitrary extends (0, _arbitraryJs.Arbitrary) {
    constructor(commandArbs, maxGeneratedCommands, maxCommands, sourceReplayPath, disableReplayLog){
        super();
        this.sourceReplayPath = sourceReplayPath;
        this.disableReplayLog = disableReplayLog;
        this.oneCommandArb = (0, _oneofJs.oneof)(...commandArbs).map((c)=>new (0, _commandWrapperJs.CommandWrapper)(c));
        this.lengthArb = (0, _restrictedIntegerArbitraryBuilderJs.restrictedIntegerArbitraryBuilder)(0, maxGeneratedCommands, maxCommands);
        this.replayPath = [];
        this.replayPathPosition = 0;
    }
    metadataForReplay() {
        return this.disableReplayLog ? '' : `replayPath=${JSON.stringify((0, _replayPathJs.ReplayPath).stringify(this.replayPath))}`;
    }
    buildValueFor(items, shrunkOnce) {
        const commands = items.map((item)=>item.value_);
        const context = {
            shrunkOnce,
            items
        };
        return new (0, _valueJs.Value)(new (0, _commandsIterableJs.CommandsIterable)(commands, ()=>this.metadataForReplay()), context);
    }
    generate(mrng) {
        const size = this.lengthArb.generate(mrng, undefined);
        const sizeValue = size.value;
        const items = Array(sizeValue);
        for(let idx = 0; idx !== sizeValue; ++idx){
            const item = this.oneCommandArb.generate(mrng, undefined);
            items[idx] = item;
        }
        this.replayPathPosition = 0;
        return this.buildValueFor(items, false);
    }
    canShrinkWithoutContext(value) {
        return false;
    }
    filterOnExecution(itemsRaw) {
        const items = [];
        for (const c of itemsRaw)if (c.value_.hasRan) {
            this.replayPath.push(true);
            items.push(c);
        } else this.replayPath.push(false);
        return items;
    }
    filterOnReplay(itemsRaw) {
        return itemsRaw.filter((c, idx)=>{
            const state = this.replayPath[this.replayPathPosition + idx];
            if (state === undefined) throw new Error(`Too short replayPath`);
            if (!state && c.value_.hasRan) throw new Error(`Mismatch between replayPath and real execution`);
            return state;
        });
    }
    filterForShrinkImpl(itemsRaw) {
        if (this.replayPathPosition === 0) this.replayPath = this.sourceReplayPath !== null ? (0, _replayPathJs.ReplayPath).parse(this.sourceReplayPath) : [];
        const items = this.replayPathPosition < this.replayPath.length ? this.filterOnReplay(itemsRaw) : this.filterOnExecution(itemsRaw);
        this.replayPathPosition += itemsRaw.length;
        return items;
    }
    shrink(_value, context) {
        if (context === undefined) return (0, _streamJs.Stream).nil();
        const safeContext = context;
        const shrunkOnce = safeContext.shrunkOnce;
        const itemsRaw = safeContext.items;
        const items = this.filterForShrinkImpl(itemsRaw);
        if (items.length === 0) return (0, _streamJs.Stream).nil();
        const rootShrink = shrunkOnce ? (0, _streamJs.Stream).nil() : new (0, _streamJs.Stream)([
            []
        ][Symbol.iterator]());
        const nextShrinks = [];
        for(let numToKeep = 0; numToKeep !== items.length; ++numToKeep)nextShrinks.push((0, _lazyIterableIteratorJs.makeLazy)(()=>{
            const fixedStart = items.slice(0, numToKeep);
            return this.lengthArb.shrink(items.length - 1 - numToKeep, undefined).map((l)=>fixedStart.concat(items.slice(items.length - (l.value + 1))));
        }));
        for(let itemAt = 0; itemAt !== items.length; ++itemAt)nextShrinks.push((0, _lazyIterableIteratorJs.makeLazy)(()=>this.oneCommandArb.shrink(items[itemAt].value_, items[itemAt].context).map((v)=>items.slice(0, itemAt).concat([
                    v
                ], items.slice(itemAt + 1)))));
        return rootShrink.join(...nextShrinks).map((shrinkables)=>{
            return this.buildValueFor(shrinkables.map((c)=>new (0, _valueJs.Value)(c.value_.clone(), c.context)), true);
        });
    }
}

},{"../../check/arbitrary/definition/Arbitrary.js":"e6f1K","../../check/arbitrary/definition/Value.js":"8Cf1j","../../check/model/commands/CommandsIterable.js":"iKDlH","../../check/model/commands/CommandWrapper.js":"bDpnn","../../check/model/ReplayPath.js":"lCFIP","../../stream/LazyIterableIterator.js":"bnj2K","../../stream/Stream.js":"2sjal","../oneof.js":"cTys0","./builders/RestrictedIntegerArbitraryBuilder.js":"1IMef","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"iKDlH":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CommandsIterable", ()=>CommandsIterable);
var _symbolsJs = require("../../symbols.js");
class CommandsIterable {
    constructor(commands, metadataForReplay){
        this.commands = commands;
        this.metadataForReplay = metadataForReplay;
    }
    [Symbol.iterator]() {
        return this.commands[Symbol.iterator]();
    }
    [(0, _symbolsJs.cloneMethod)]() {
        return new CommandsIterable(this.commands.map((c)=>c.clone()), this.metadataForReplay);
    }
    toString() {
        const serializedCommands = this.commands.filter((c)=>c.hasRan).map((c)=>c.toString()).join(',');
        const metadata = this.metadataForReplay();
        return metadata.length !== 0 ? `${serializedCommands} /*${metadata}*/` : serializedCommands;
    }
}

},{"../../symbols.js":"2AK80","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"bDpnn":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CommandWrapper", ()=>CommandWrapper);
var _stringifyJs = require("../../../utils/stringify.js");
var _symbolsJs = require("../../symbols.js");
class CommandWrapper {
    constructor(cmd){
        this.cmd = cmd;
        this.hasRan = false;
        if ((0, _stringifyJs.hasToStringMethod)(cmd)) {
            const method = cmd[0, _stringifyJs.toStringMethod];
            this[0, _stringifyJs.toStringMethod] = function toStringMethod() {
                return method.call(cmd);
            };
        }
        if ((0, _stringifyJs.hasAsyncToStringMethod)(cmd)) {
            const method = cmd[0, _stringifyJs.asyncToStringMethod];
            this[0, _stringifyJs.asyncToStringMethod] = function asyncToStringMethod() {
                return method.call(cmd);
            };
        }
    }
    check(m) {
        return this.cmd.check(m);
    }
    run(m, r) {
        this.hasRan = true;
        return this.cmd.run(m, r);
    }
    clone() {
        if ((0, _symbolsJs.hasCloneMethod)(this.cmd)) return new CommandWrapper(this.cmd[0, _symbolsJs.cloneMethod]());
        return new CommandWrapper(this.cmd);
    }
    toString() {
        return this.cmd.toString();
    }
}

},{"../../../utils/stringify.js":"gOa8u","../../symbols.js":"2AK80","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"lCFIP":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ReplayPath", ()=>ReplayPath);
class ReplayPath {
    static parse(replayPathStr) {
        const [serializedCount, serializedChanges] = replayPathStr.split(':');
        const counts = this.parseCounts(serializedCount);
        const changes = this.parseChanges(serializedChanges);
        return this.parseOccurences(counts, changes);
    }
    static stringify(replayPath) {
        const occurences = this.countOccurences(replayPath);
        const serializedCount = this.stringifyCounts(occurences);
        const serializedChanges = this.stringifyChanges(occurences);
        return `${serializedCount}:${serializedChanges}`;
    }
    static intToB64(n) {
        if (n < 26) return String.fromCharCode(n + 65);
        if (n < 52) return String.fromCharCode(n + 97 - 26);
        if (n < 62) return String.fromCharCode(n + 48 - 52);
        return String.fromCharCode(n === 62 ? 43 : 47);
    }
    static b64ToInt(c) {
        if (c >= 'a') return c.charCodeAt(0) - 97 + 26;
        if (c >= 'A') return c.charCodeAt(0) - 65;
        if (c >= '0') return c.charCodeAt(0) - 48 + 52;
        return c === '+' ? 62 : 63;
    }
    static countOccurences(replayPath) {
        return replayPath.reduce((counts, cur)=>{
            if (counts.length === 0 || counts[counts.length - 1].count === 64 || counts[counts.length - 1].value !== cur) counts.push({
                value: cur,
                count: 1
            });
            else counts[counts.length - 1].count += 1;
            return counts;
        }, []);
    }
    static parseOccurences(counts, changes) {
        const replayPath = [];
        for(let idx = 0; idx !== counts.length; ++idx){
            const count = counts[idx];
            const value = changes[idx];
            for(let num = 0; num !== count; ++num)replayPath.push(value);
        }
        return replayPath;
    }
    static stringifyChanges(occurences) {
        let serializedChanges = '';
        for(let idx = 0; idx < occurences.length; idx += 6){
            const changesInt = occurences.slice(idx, idx + 6).reduceRight((prev, cur)=>prev * 2 + (cur.value ? 1 : 0), 0);
            serializedChanges += this.intToB64(changesInt);
        }
        return serializedChanges;
    }
    static parseChanges(serializedChanges) {
        const changesInt = serializedChanges.split('').map((c)=>this.b64ToInt(c));
        const changes = [];
        for(let idx = 0; idx !== changesInt.length; ++idx){
            let current = changesInt[idx];
            for(let n = 0; n !== 6; ++n, current >>= 1)changes.push(current % 2 === 1);
        }
        return changes;
    }
    static stringifyCounts(occurences) {
        return occurences.map(({ count })=>this.intToB64(count - 1)).join('');
    }
    static parseCounts(serializedCount) {
        return serializedCount.split('').map((c)=>this.b64ToInt(c) + 1);
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"jj37H":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "modelRun", ()=>modelRun);
parcelHelpers.export(exports, "asyncModelRun", ()=>asyncModelRun);
parcelHelpers.export(exports, "scheduledModelRun", ()=>scheduledModelRun);
var _scheduledCommandJs = require("./commands/ScheduledCommand.js");
const genericModelRun = (s, cmds, initialValue, runCmd, then)=>{
    return s.then((o)=>{
        const { model, real } = o;
        let state = initialValue;
        for (const c of cmds)state = then(state, ()=>{
            return runCmd(c, model, real);
        });
        return state;
    });
};
const internalModelRun = (s, cmds)=>{
    const then = (_p, c)=>c();
    const setupProducer = {
        then: (fun)=>{
            fun(s());
            return undefined;
        }
    };
    const runSync = (cmd, m, r)=>{
        if (cmd.check(m)) cmd.run(m, r);
        return undefined;
    };
    return genericModelRun(setupProducer, cmds, undefined, runSync, then);
};
const isAsyncSetup = (s)=>{
    return typeof s.then === 'function';
};
const internalAsyncModelRun = async (s, cmds, defaultPromise = Promise.resolve())=>{
    const then = (p, c)=>p.then(c);
    const setupProducer = {
        then: (fun)=>{
            const out = s();
            if (isAsyncSetup(out)) return out.then(fun);
            else return fun(out);
        }
    };
    const runAsync = async (cmd, m, r)=>{
        if (await cmd.check(m)) await cmd.run(m, r);
    };
    return await genericModelRun(setupProducer, cmds, defaultPromise, runAsync, then);
};
function modelRun(s, cmds) {
    internalModelRun(s, cmds);
}
async function asyncModelRun(s, cmds) {
    await internalAsyncModelRun(s, cmds);
}
async function scheduledModelRun(scheduler, s, cmds) {
    const scheduledCommands = (0, _scheduledCommandJs.scheduleCommands)(scheduler, cmds);
    const out = internalAsyncModelRun(s, scheduledCommands, scheduler.schedule(Promise.resolve(), 'startModel'));
    await scheduler.waitFor(out);
    await scheduler.waitAll();
}

},{"./commands/ScheduledCommand.js":"6FXrU","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"6FXrU":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ScheduledCommand", ()=>ScheduledCommand);
parcelHelpers.export(exports, "scheduleCommands", ()=>scheduleCommands);
class ScheduledCommand {
    constructor(s, cmd){
        this.s = s;
        this.cmd = cmd;
    }
    async check(m) {
        let error = null;
        let checkPassed = false;
        const status = await this.s.scheduleSequence([
            {
                label: `check@${this.cmd.toString()}`,
                builder: async ()=>{
                    try {
                        checkPassed = await Promise.resolve(this.cmd.check(m));
                    } catch (err) {
                        error = err;
                        throw err;
                    }
                }
            }
        ]).task;
        if (status.faulty) throw error;
        return checkPassed;
    }
    async run(m, r) {
        let error = null;
        const status = await this.s.scheduleSequence([
            {
                label: `run@${this.cmd.toString()}`,
                builder: async ()=>{
                    try {
                        await this.cmd.run(m, r);
                    } catch (err) {
                        error = err;
                        throw err;
                    }
                }
            }
        ]).task;
        if (status.faulty) throw error;
    }
}
const scheduleCommands = function*(s, cmds) {
    for (const cmd of cmds)yield new ScheduledCommand(s, cmd);
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"S5kCw":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "scheduler", ()=>scheduler);
parcelHelpers.export(exports, "schedulerFor", ()=>schedulerFor);
var _buildSchedulerForJs = require("./_internals/helpers/BuildSchedulerFor.js");
var _schedulerArbitraryJs = require("./_internals/SchedulerArbitrary.js");
function scheduler(constraints) {
    const { act = (f)=>f() } = constraints || {};
    return new (0, _schedulerArbitraryJs.SchedulerArbitrary)(act);
}
function schedulerFor(customOrderingOrConstraints, constraintsOrUndefined) {
    const { act = (f)=>f() } = Array.isArray(customOrderingOrConstraints) ? constraintsOrUndefined || {} : customOrderingOrConstraints || {};
    if (Array.isArray(customOrderingOrConstraints)) return (0, _buildSchedulerForJs.buildSchedulerFor)(act, customOrderingOrConstraints);
    return function(_strs, ...ordering) {
        return (0, _buildSchedulerForJs.buildSchedulerFor)(act, ordering);
    };
}

},{"./_internals/helpers/BuildSchedulerFor.js":"4reGo","./_internals/SchedulerArbitrary.js":"jL7f5","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"4reGo":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "buildSchedulerFor", ()=>buildSchedulerFor);
var _schedulerImplemJs = require("../implementations/SchedulerImplem.js");
function buildNextTaskIndex(ordering) {
    let numTasks = 0;
    return {
        clone: ()=>buildNextTaskIndex(ordering),
        nextTaskIndex: (scheduledTasks)=>{
            if (ordering.length <= numTasks) throw new Error(`Invalid schedulerFor defined: too many tasks have been scheduled`);
            const taskIndex = scheduledTasks.findIndex((t)=>t.taskId === ordering[numTasks]);
            if (taskIndex === -1) throw new Error(`Invalid schedulerFor defined: unable to find next task`);
            ++numTasks;
            return taskIndex;
        }
    };
}
function buildSchedulerFor(act, ordering) {
    return new (0, _schedulerImplemJs.SchedulerImplem)(act, buildNextTaskIndex(ordering));
}

},{"../implementations/SchedulerImplem.js":"4mUJ2","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"4mUJ2":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SchedulerImplem", ()=>SchedulerImplem);
var _textEscaperJs = require("../helpers/TextEscaper.js");
var _symbolsJs = require("../../../check/symbols.js");
var _stringifyJs = require("../../../utils/stringify.js");
const defaultSchedulerAct = (f)=>f();
class SchedulerImplem {
    constructor(act, taskSelector){
        this.act = act;
        this.taskSelector = taskSelector;
        this.lastTaskId = 0;
        this.sourceTaskSelector = taskSelector.clone();
        this.scheduledTasks = [];
        this.triggeredTasks = [];
        this.scheduledWatchers = [];
    }
    static buildLog(reportItem) {
        return `[task\${${reportItem.taskId}}] ${reportItem.label.length !== 0 ? `${reportItem.schedulingType}::${reportItem.label}` : reportItem.schedulingType} ${reportItem.status}${reportItem.outputValue !== undefined ? ` with value ${(0, _textEscaperJs.escapeForTemplateString)(reportItem.outputValue)}` : ''}`;
    }
    log(schedulingType, taskId, label, metadata, status, data) {
        this.triggeredTasks.push({
            status,
            schedulingType,
            taskId,
            label,
            metadata,
            outputValue: data !== undefined ? (0, _stringifyJs.stringify)(data) : undefined
        });
    }
    scheduleInternal(schedulingType, label, task, metadata, customAct, thenTaskToBeAwaited) {
        let trigger = null;
        const taskId = ++this.lastTaskId;
        const scheduledPromise = new Promise((resolve, reject)=>{
            trigger = ()=>{
                (thenTaskToBeAwaited ? task.then(()=>thenTaskToBeAwaited()) : task).then((data)=>{
                    this.log(schedulingType, taskId, label, metadata, 'resolved', data);
                    return resolve(data);
                }, (err)=>{
                    this.log(schedulingType, taskId, label, metadata, 'rejected', err);
                    return reject(err);
                });
            };
        });
        this.scheduledTasks.push({
            original: task,
            scheduled: scheduledPromise,
            trigger: trigger,
            schedulingType,
            taskId,
            label,
            metadata,
            customAct
        });
        if (this.scheduledWatchers.length !== 0) this.scheduledWatchers[0]();
        return scheduledPromise;
    }
    schedule(task, label, metadata, customAct) {
        return this.scheduleInternal('promise', label || '', task, metadata, customAct || defaultSchedulerAct);
    }
    scheduleFunction(asyncFunction, customAct) {
        return (...args)=>this.scheduleInternal('function', `${asyncFunction.name}(${args.map((0, _stringifyJs.stringify)).join(',')})`, asyncFunction(...args), undefined, customAct || defaultSchedulerAct);
    }
    scheduleSequence(sequenceBuilders, customAct) {
        const status = {
            done: false,
            faulty: false
        };
        const dummyResolvedPromise = {
            then: (f)=>f()
        };
        let resolveSequenceTask = ()=>{};
        const sequenceTask = new Promise((resolve)=>resolveSequenceTask = resolve);
        sequenceBuilders.reduce((previouslyScheduled, item)=>{
            const [builder, label, metadata] = typeof item === 'function' ? [
                item,
                item.name,
                undefined
            ] : [
                item.builder,
                item.label,
                item.metadata
            ];
            return previouslyScheduled.then(()=>{
                const scheduled = this.scheduleInternal('sequence', label, dummyResolvedPromise, metadata, customAct || defaultSchedulerAct, ()=>builder());
                scheduled.catch(()=>{
                    status.faulty = true;
                    resolveSequenceTask();
                });
                return scheduled;
            });
        }, dummyResolvedPromise).then(()=>{
            status.done = true;
            resolveSequenceTask();
        }, ()=>{});
        return Object.assign(status, {
            task: Promise.resolve(sequenceTask).then(()=>{
                return {
                    done: status.done,
                    faulty: status.faulty
                };
            })
        });
    }
    count() {
        return this.scheduledTasks.length;
    }
    internalWaitOne() {
        if (this.scheduledTasks.length === 0) throw new Error('No task scheduled');
        const taskIndex = this.taskSelector.nextTaskIndex(this.scheduledTasks);
        const [scheduledTask] = this.scheduledTasks.splice(taskIndex, 1);
        return scheduledTask.customAct(async ()=>{
            scheduledTask.trigger();
            try {
                await scheduledTask.scheduled;
            } catch (_err) {}
        });
    }
    async waitOne(customAct) {
        const waitAct = customAct || defaultSchedulerAct;
        await this.act(()=>waitAct(async ()=>await this.internalWaitOne()));
    }
    async waitAll(customAct) {
        while(this.scheduledTasks.length > 0)await this.waitOne(customAct);
    }
    async waitFor(unscheduledTask, customAct) {
        let taskResolved = false;
        let awaiterPromise = null;
        const awaiter = async ()=>{
            while(!taskResolved && this.scheduledTasks.length > 0)await this.waitOne(customAct);
            awaiterPromise = null;
        };
        const handleNotified = ()=>{
            if (awaiterPromise !== null) return;
            awaiterPromise = Promise.resolve().then(awaiter);
        };
        const clearAndReplaceWatcher = ()=>{
            const handleNotifiedIndex = this.scheduledWatchers.indexOf(handleNotified);
            if (handleNotifiedIndex !== -1) this.scheduledWatchers.splice(handleNotifiedIndex, 1);
            if (handleNotifiedIndex === 0 && this.scheduledWatchers.length !== 0) this.scheduledWatchers[0]();
        };
        const rewrappedTask = unscheduledTask.then((ret)=>{
            taskResolved = true;
            if (awaiterPromise === null) {
                clearAndReplaceWatcher();
                return ret;
            }
            return awaiterPromise.then(()=>{
                clearAndReplaceWatcher();
                return ret;
            });
        }, (err)=>{
            taskResolved = true;
            if (awaiterPromise === null) {
                clearAndReplaceWatcher();
                throw err;
            }
            return awaiterPromise.then(()=>{
                clearAndReplaceWatcher();
                throw err;
            });
        });
        if (this.scheduledTasks.length > 0 && this.scheduledWatchers.length === 0) handleNotified();
        this.scheduledWatchers.push(handleNotified);
        return rewrappedTask;
    }
    report() {
        return [
            ...this.triggeredTasks,
            ...this.scheduledTasks.map((t)=>({
                    status: 'pending',
                    schedulingType: t.schedulingType,
                    taskId: t.taskId,
                    label: t.label,
                    metadata: t.metadata
                }))
        ];
    }
    toString() {
        return 'schedulerFor()`\n' + this.report().map(SchedulerImplem.buildLog).map((log)=>`-> ${log}`).join('\n') + '`';
    }
    [(0, _symbolsJs.cloneMethod)]() {
        return new SchedulerImplem(this.act, this.sourceTaskSelector);
    }
}

},{"../helpers/TextEscaper.js":"fSa3V","../../../check/symbols.js":"2AK80","../../../utils/stringify.js":"gOa8u","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"jL7f5":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SchedulerArbitrary", ()=>SchedulerArbitrary);
var _arbitraryJs = require("../../check/arbitrary/definition/Arbitrary.js");
var _valueJs = require("../../check/arbitrary/definition/Value.js");
var _streamJs = require("../../stream/Stream.js");
var _schedulerImplemJs = require("./implementations/SchedulerImplem.js");
function buildNextTaskIndex(mrng) {
    const clonedMrng = mrng.clone();
    return {
        clone: ()=>buildNextTaskIndex(clonedMrng),
        nextTaskIndex: (scheduledTasks)=>{
            return mrng.nextInt(0, scheduledTasks.length - 1);
        }
    };
}
class SchedulerArbitrary extends (0, _arbitraryJs.Arbitrary) {
    constructor(act){
        super();
        this.act = act;
    }
    generate(mrng, _biasFactor) {
        return new (0, _valueJs.Value)(new (0, _schedulerImplemJs.SchedulerImplem)(this.act, buildNextTaskIndex(mrng.clone())), undefined);
    }
    canShrinkWithoutContext(value) {
        return false;
    }
    shrink(_value, _context) {
        return (0, _streamJs.Stream).nil();
    }
}

},{"../../check/arbitrary/definition/Arbitrary.js":"e6f1K","../../check/arbitrary/definition/Value.js":"8Cf1j","../../stream/Stream.js":"2sjal","./implementations/SchedulerImplem.js":"4mUJ2","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"8uZyS":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "bigInt64Array", ()=>bigInt64Array);
var _globalsJs = require("../utils/globals.js");
var _bigIntJs = require("./bigInt.js");
var _typedIntArrayArbitraryBuilderJs = require("./_internals/builders/TypedIntArrayArbitraryBuilder.js");
function bigInt64Array(constraints = {}) {
    return (0, _typedIntArrayArbitraryBuilderJs.typedIntArrayArbitraryArbitraryBuilder)(constraints, (0, _globalsJs.BigInt)('-9223372036854775808'), (0, _globalsJs.BigInt)('9223372036854775807'), (0, _globalsJs.BigInt64Array), (0, _bigIntJs.bigInt));
}

},{"../utils/globals.js":"aTuwn","./bigInt.js":"ffHa9","./_internals/builders/TypedIntArrayArbitraryBuilder.js":"hXkYu","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"eu8NS":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "bigUint64Array", ()=>bigUint64Array);
var _globalsJs = require("../utils/globals.js");
var _bigIntJs = require("./bigInt.js");
var _typedIntArrayArbitraryBuilderJs = require("./_internals/builders/TypedIntArrayArbitraryBuilder.js");
function bigUint64Array(constraints = {}) {
    return (0, _typedIntArrayArbitraryBuilderJs.typedIntArrayArbitraryArbitraryBuilder)(constraints, (0, _globalsJs.BigInt)(0), (0, _globalsJs.BigInt)('18446744073709551615'), (0, _globalsJs.BigUint64Array), (0, _bigIntJs.bigInt));
}

},{"../utils/globals.js":"aTuwn","./bigInt.js":"ffHa9","./_internals/builders/TypedIntArrayArbitraryBuilder.js":"hXkYu","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"cfmkC":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "stringMatching", ()=>stringMatching);
var _globalsJs = require("../utils/globals.js");
var _stringifyJs = require("../utils/stringify.js");
var _sanitizeRegexAstJs = require("./_internals/helpers/SanitizeRegexAst.js");
var _tokenizeRegexJs = require("./_internals/helpers/TokenizeRegex.js");
var _charJs = require("./char.js");
var _constantJs = require("./constant.js");
var _constantFromJs = require("./constantFrom.js");
var _integerJs = require("./integer.js");
var _oneofJs = require("./oneof.js");
var _stringOfJs = require("./stringOf.js");
var _tupleJs = require("./tuple.js");
const safeStringFromCodePoint = String.fromCodePoint;
const wordChars = [
    ...'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_'
];
const digitChars = [
    ...'0123456789'
];
const spaceChars = [
    ...' \t\r\n\v\f'
];
const newLineChars = [
    ...'\r\n'
];
const terminatorChars = [
    ...'\x1E\x15'
];
const newLineAndTerminatorChars = [
    ...newLineChars,
    ...terminatorChars
];
const defaultChar = (0, _charJs.char)();
function raiseUnsupportedASTNode(astNode) {
    return new (0, _globalsJs.Error)(`Unsupported AST node! Received: ${(0, _stringifyJs.stringify)(astNode)}`);
}
function toMatchingArbitrary(astNode, constraints, flags) {
    switch(astNode.type){
        case 'Char':
            if (astNode.kind === 'meta') switch(astNode.value){
                case '\\w':
                    return (0, _constantFromJs.constantFrom)(...wordChars);
                case '\\W':
                    return defaultChar.filter((c)=>(0, _globalsJs.safeIndexOf)(wordChars, c) === -1);
                case '\\d':
                    return (0, _constantFromJs.constantFrom)(...digitChars);
                case '\\D':
                    return defaultChar.filter((c)=>(0, _globalsJs.safeIndexOf)(digitChars, c) === -1);
                case '\\s':
                    return (0, _constantFromJs.constantFrom)(...spaceChars);
                case '\\S':
                    return defaultChar.filter((c)=>(0, _globalsJs.safeIndexOf)(spaceChars, c) === -1);
                case '\\b':
                case '\\B':
                    throw new (0, _globalsJs.Error)(`Meta character ${astNode.value} not implemented yet!`);
                case '.':
                    {
                        const forbiddenChars = flags.dotAll ? terminatorChars : newLineAndTerminatorChars;
                        return defaultChar.filter((c)=>(0, _globalsJs.safeIndexOf)(forbiddenChars, c) === -1);
                    }
            }
            if (astNode.symbol === undefined) throw new (0, _globalsJs.Error)(`Unexpected undefined symbol received for non-meta Char! Received: ${(0, _stringifyJs.stringify)(astNode)}`);
            return (0, _constantJs.constant)(astNode.symbol);
        case 'Repetition':
            {
                const node = toMatchingArbitrary(astNode.expression, constraints, flags);
                switch(astNode.quantifier.kind){
                    case '*':
                        return (0, _stringOfJs.stringOf)(node, constraints);
                    case '+':
                        return (0, _stringOfJs.stringOf)(node, Object.assign(Object.assign({}, constraints), {
                            minLength: 1
                        }));
                    case '?':
                        return (0, _stringOfJs.stringOf)(node, Object.assign(Object.assign({}, constraints), {
                            minLength: 0,
                            maxLength: 1
                        }));
                    case 'Range':
                        return (0, _stringOfJs.stringOf)(node, Object.assign(Object.assign({}, constraints), {
                            minLength: astNode.quantifier.from,
                            maxLength: astNode.quantifier.to
                        }));
                    default:
                        throw raiseUnsupportedASTNode(astNode.quantifier);
                }
            }
        case 'Quantifier':
            throw new (0, _globalsJs.Error)(`Wrongly defined AST tree, Quantifier nodes not supposed to be scanned!`);
        case 'Alternative':
            return (0, _tupleJs.tuple)(...(0, _globalsJs.safeMap)(astNode.expressions, (n)=>toMatchingArbitrary(n, constraints, flags))).map((vs)=>(0, _globalsJs.safeJoin)(vs, ''));
        case 'CharacterClass':
            if (astNode.negative) {
                const childrenArbitraries = (0, _globalsJs.safeMap)(astNode.expressions, (n)=>toMatchingArbitrary(n, constraints, flags));
                return defaultChar.filter((c)=>(0, _globalsJs.safeEvery)(childrenArbitraries, (arb)=>!arb.canShrinkWithoutContext(c)));
            }
            return (0, _oneofJs.oneof)(...(0, _globalsJs.safeMap)(astNode.expressions, (n)=>toMatchingArbitrary(n, constraints, flags)));
        case 'ClassRange':
            {
                const min = astNode.from.codePoint;
                const max = astNode.to.codePoint;
                return (0, _integerJs.integer)({
                    min,
                    max
                }).map((n)=>safeStringFromCodePoint(n), (c)=>{
                    if (typeof c !== 'string') throw new (0, _globalsJs.Error)('Invalid type');
                    if ([
                        ...c
                    ].length !== 1) throw new (0, _globalsJs.Error)('Invalid length');
                    return (0, _globalsJs.safeCharCodeAt)(c, 0);
                });
            }
        case 'Group':
            return toMatchingArbitrary(astNode.expression, constraints, flags);
        case 'Disjunction':
            {
                const left = astNode.left !== null ? toMatchingArbitrary(astNode.left, constraints, flags) : (0, _constantJs.constant)('');
                const right = astNode.right !== null ? toMatchingArbitrary(astNode.right, constraints, flags) : (0, _constantJs.constant)('');
                return (0, _oneofJs.oneof)(left, right);
            }
        case 'Assertion':
            if (astNode.kind === '^' || astNode.kind === '$') {
                if (flags.multiline) {
                    if (astNode.kind === '^') return (0, _oneofJs.oneof)((0, _constantJs.constant)(''), (0, _tupleJs.tuple)((0, _stringOfJs.stringOf)(defaultChar), (0, _constantFromJs.constantFrom)(...newLineChars)).map((t)=>`${t[0]}${t[1]}`, (value)=>{
                        if (typeof value !== 'string' || value.length === 0) throw new (0, _globalsJs.Error)('Invalid type');
                        return [
                            (0, _globalsJs.safeSubstring)(value, 0, value.length - 1),
                            value[value.length - 1]
                        ];
                    }));
                    else return (0, _oneofJs.oneof)((0, _constantJs.constant)(''), (0, _tupleJs.tuple)((0, _constantFromJs.constantFrom)(...newLineChars), (0, _stringOfJs.stringOf)(defaultChar)).map((t)=>`${t[0]}${t[1]}`, (value)=>{
                        if (typeof value !== 'string' || value.length === 0) throw new (0, _globalsJs.Error)('Invalid type');
                        return [
                            value[0],
                            (0, _globalsJs.safeSubstring)(value, 1)
                        ];
                    }));
                }
                return (0, _constantJs.constant)('');
            }
            throw new (0, _globalsJs.Error)(`Assertions of kind ${astNode.kind} not implemented yet!`);
        case 'Backreference':
            throw new (0, _globalsJs.Error)(`Backreference nodes not implemented yet!`);
        default:
            throw raiseUnsupportedASTNode(astNode);
    }
}
function stringMatching(regex, constraints = {}) {
    for (const flag of regex.flags){
        if (flag !== 'd' && flag !== 'g' && flag !== 'm' && flag !== 's' && flag !== 'u') throw new (0, _globalsJs.Error)(`Unable to use "stringMatching" against a regex using the flag ${flag}`);
    }
    const sanitizedConstraints = {
        size: constraints.size
    };
    const flags = {
        multiline: regex.multiline,
        dotAll: regex.dotAll
    };
    const regexRootToken = (0, _sanitizeRegexAstJs.addMissingDotStar)((0, _tokenizeRegexJs.tokenizeRegex)(regex));
    return toMatchingArbitrary(regexRootToken, sanitizedConstraints, flags);
}

},{"../utils/globals.js":"aTuwn","../utils/stringify.js":"gOa8u","./_internals/helpers/SanitizeRegexAst.js":"7zkRK","./_internals/helpers/TokenizeRegex.js":"9Nd7Z","./char.js":"NNpK4","./constant.js":"6Ey5n","./constantFrom.js":"bZWfh","./integer.js":"embjo","./oneof.js":"cTys0","./stringOf.js":"5vl42","./tuple.js":"dw0Pn","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"7zkRK":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "addMissingDotStar", ()=>addMissingDotStar);
var _stringifyJs = require("../../../utils/stringify.js");
function raiseUnsupportedASTNode(astNode) {
    return new Error(`Unsupported AST node! Received: ${(0, _stringifyJs.stringify)(astNode)}`);
}
function addMissingDotStarTraversalAddMissing(astNode, isFirst, isLast) {
    if (!isFirst && !isLast) return astNode;
    const traversalResults = {
        hasStart: false,
        hasEnd: false
    };
    const revampedNode = addMissingDotStarTraversal(astNode, isFirst, isLast, traversalResults);
    const missingStart = isFirst && !traversalResults.hasStart;
    const missingEnd = isLast && !traversalResults.hasEnd;
    if (!missingStart && !missingEnd) return revampedNode;
    const expressions = [];
    if (missingStart) {
        expressions.push({
            type: 'Assertion',
            kind: '^'
        });
        expressions.push({
            type: 'Repetition',
            quantifier: {
                type: 'Quantifier',
                kind: '*',
                greedy: true
            },
            expression: {
                type: 'Char',
                kind: 'meta',
                symbol: '.',
                value: '.',
                codePoint: Number.NaN
            }
        });
    }
    expressions.push(revampedNode);
    if (missingEnd) {
        expressions.push({
            type: 'Repetition',
            quantifier: {
                type: 'Quantifier',
                kind: '*',
                greedy: true
            },
            expression: {
                type: 'Char',
                kind: 'meta',
                symbol: '.',
                value: '.',
                codePoint: Number.NaN
            }
        });
        expressions.push({
            type: 'Assertion',
            kind: '$'
        });
    }
    return {
        type: 'Group',
        capturing: false,
        expression: {
            type: 'Alternative',
            expressions
        }
    };
}
function addMissingDotStarTraversal(astNode, isFirst, isLast, traversalResults) {
    switch(astNode.type){
        case 'Char':
            return astNode;
        case 'Repetition':
            return astNode;
        case 'Quantifier':
            throw new Error(`Wrongly defined AST tree, Quantifier nodes not supposed to be scanned!`);
        case 'Alternative':
            traversalResults.hasStart = true;
            traversalResults.hasEnd = true;
            return Object.assign(Object.assign({}, astNode), {
                expressions: astNode.expressions.map((node, index)=>addMissingDotStarTraversalAddMissing(node, isFirst && index === 0, isLast && index === astNode.expressions.length - 1))
            });
        case 'CharacterClass':
            return astNode;
        case 'ClassRange':
            return astNode;
        case 'Group':
            return Object.assign(Object.assign({}, astNode), {
                expression: addMissingDotStarTraversal(astNode.expression, isFirst, isLast, traversalResults)
            });
        case 'Disjunction':
            traversalResults.hasStart = true;
            traversalResults.hasEnd = true;
            return Object.assign(Object.assign({}, astNode), {
                left: astNode.left !== null ? addMissingDotStarTraversalAddMissing(astNode.left, isFirst, isLast) : null,
                right: astNode.right !== null ? addMissingDotStarTraversalAddMissing(astNode.right, isFirst, isLast) : null
            });
        case 'Assertion':
            if (astNode.kind === '^' || astNode.kind === 'Lookahead') {
                traversalResults.hasStart = true;
                return astNode;
            } else if (astNode.kind === '$' || astNode.kind === 'Lookbehind') {
                traversalResults.hasEnd = true;
                return astNode;
            } else throw new Error(`Assertions of kind ${astNode.kind} not implemented yet!`);
        case 'Backreference':
            return astNode;
        default:
            throw raiseUnsupportedASTNode(astNode);
    }
}
function addMissingDotStar(astNode) {
    return addMissingDotStarTraversalAddMissing(astNode, true, true);
}

},{"../../../utils/stringify.js":"gOa8u","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"9Nd7Z":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "tokenizeRegex", ()=>tokenizeRegex);
var _globalsJs = require("../../../utils/globals.js");
var _readRegexJs = require("./ReadRegex.js");
const safeStringFromCodePoint = String.fromCodePoint;
function safePop(tokens) {
    const previous = tokens.pop();
    if (previous === undefined) throw new Error('Unable to extract token preceeding the currently parsed one');
    return previous;
}
function isDigit(char) {
    return char >= '0' && char <= '9';
}
function simpleChar(char, escaped) {
    return {
        type: 'Char',
        kind: 'simple',
        symbol: char,
        value: char,
        codePoint: char.codePointAt(0) || -1,
        escaped
    };
}
function metaEscapedChar(block, symbol) {
    return {
        type: 'Char',
        kind: 'meta',
        symbol,
        value: block,
        codePoint: symbol.codePointAt(0) || -1
    };
}
function toSingleToken(tokens, allowEmpty) {
    if (tokens.length > 1) return {
        type: 'Alternative',
        expressions: tokens
    };
    if (!allowEmpty && tokens.length === 0) throw new Error(`Unsupported no token`);
    return tokens[0];
}
function blockToCharToken(block) {
    if (block[0] === '\\') {
        const next = block[1];
        switch(next){
            case 'x':
                {
                    const allDigits = block.substring(2);
                    const codePoint = Number.parseInt(allDigits, 16);
                    const symbol = safeStringFromCodePoint(codePoint);
                    return {
                        type: 'Char',
                        kind: 'hex',
                        symbol,
                        value: block,
                        codePoint
                    };
                }
            case 'u':
                {
                    if (block === '\\u') return simpleChar('u', true);
                    const allDigits = block[2] === '{' ? block.substring(3, block.length - 1) : block.substring(2);
                    const codePoint = Number.parseInt(allDigits, 16);
                    const symbol = safeStringFromCodePoint(codePoint);
                    return {
                        type: 'Char',
                        kind: 'unicode',
                        symbol,
                        value: block,
                        codePoint
                    };
                }
            case '0':
                return metaEscapedChar(block, '\0');
            case 'n':
                return metaEscapedChar(block, '\n');
            case 'f':
                return metaEscapedChar(block, '\f');
            case 'r':
                return metaEscapedChar(block, '\r');
            case 't':
                return metaEscapedChar(block, '\t');
            case 'v':
                return metaEscapedChar(block, '\v');
            case 'w':
            case 'W':
            case 'd':
            case 'D':
            case 's':
            case 'S':
            case 'b':
            case 'B':
                return {
                    type: 'Char',
                    kind: 'meta',
                    symbol: undefined,
                    value: block,
                    codePoint: Number.NaN
                };
            default:
                {
                    if (isDigit(next)) {
                        const allDigits = block.substring(1);
                        const codePoint = Number(allDigits);
                        const symbol = safeStringFromCodePoint(codePoint);
                        return {
                            type: 'Char',
                            kind: 'decimal',
                            symbol,
                            value: block,
                            codePoint
                        };
                    }
                    if (block.length > 2 && (next === 'p' || next === 'P')) throw new Error(`UnicodeProperty not implemented yet!`);
                    const char = block.substring(1);
                    return simpleChar(char, true);
                }
        }
    }
    return simpleChar(block);
}
function pushTokens(tokens, regexSource, unicodeMode, groups) {
    let disjunctions = null;
    for(let index = 0, block = (0, _readRegexJs.readFrom)(regexSource, index, unicodeMode, (0, _readRegexJs.TokenizerBlockMode).Full); index !== regexSource.length; index += block.length, block = (0, _readRegexJs.readFrom)(regexSource, index, unicodeMode, (0, _readRegexJs.TokenizerBlockMode).Full)){
        const firstInBlock = block[0];
        switch(firstInBlock){
            case '|':
                if (disjunctions === null) disjunctions = [];
                disjunctions.push(toSingleToken(tokens.splice(0), true) || null);
                break;
            case '.':
                tokens.push({
                    type: 'Char',
                    kind: 'meta',
                    symbol: block,
                    value: block,
                    codePoint: Number.NaN
                });
                break;
            case '*':
            case '+':
                {
                    const previous = safePop(tokens);
                    tokens.push({
                        type: 'Repetition',
                        expression: previous,
                        quantifier: {
                            type: 'Quantifier',
                            kind: firstInBlock,
                            greedy: true
                        }
                    });
                    break;
                }
            case '?':
                {
                    const previous = safePop(tokens);
                    if (previous.type === 'Repetition') {
                        previous.quantifier.greedy = false;
                        tokens.push(previous);
                    } else tokens.push({
                        type: 'Repetition',
                        expression: previous,
                        quantifier: {
                            type: 'Quantifier',
                            kind: firstInBlock,
                            greedy: true
                        }
                    });
                    break;
                }
            case '{':
                {
                    if (block === '{') {
                        tokens.push(simpleChar(block));
                        break;
                    }
                    const previous = safePop(tokens);
                    const quantifierText = block.substring(1, block.length - 1);
                    const quantifierTokens = quantifierText.split(',');
                    const from = Number(quantifierTokens[0]);
                    const to = quantifierTokens.length === 1 ? from : quantifierTokens[1].length !== 0 ? Number(quantifierTokens[1]) : undefined;
                    tokens.push({
                        type: 'Repetition',
                        expression: previous,
                        quantifier: {
                            type: 'Quantifier',
                            kind: 'Range',
                            greedy: true,
                            from,
                            to
                        }
                    });
                    break;
                }
            case '[':
                {
                    const blockContent = block.substring(1, block.length - 1);
                    const subTokens = [];
                    let negative = undefined;
                    let previousWasSimpleDash = false;
                    for(let subIndex = 0, subBlock = (0, _readRegexJs.readFrom)(blockContent, subIndex, unicodeMode, (0, _readRegexJs.TokenizerBlockMode).Character); subIndex !== blockContent.length; subIndex += subBlock.length, subBlock = (0, _readRegexJs.readFrom)(blockContent, subIndex, unicodeMode, (0, _readRegexJs.TokenizerBlockMode).Character)){
                        if (subIndex === 0 && subBlock === '^') {
                            negative = true;
                            continue;
                        }
                        const newToken = blockToCharToken(subBlock);
                        if (subBlock === '-') {
                            subTokens.push(newToken);
                            previousWasSimpleDash = true;
                        } else {
                            const operand1Token = subTokens.length >= 2 ? subTokens[subTokens.length - 2] : undefined;
                            if (previousWasSimpleDash && operand1Token !== undefined && operand1Token.type === 'Char') {
                                subTokens.pop();
                                subTokens.pop();
                                subTokens.push({
                                    type: 'ClassRange',
                                    from: operand1Token,
                                    to: newToken
                                });
                            } else subTokens.push(newToken);
                            previousWasSimpleDash = false;
                        }
                    }
                    tokens.push({
                        type: 'CharacterClass',
                        expressions: subTokens,
                        negative
                    });
                    break;
                }
            case '(':
                {
                    const blockContent = block.substring(1, block.length - 1);
                    const subTokens = [];
                    if (blockContent[0] === '?') {
                        if (blockContent[1] === ':') {
                            pushTokens(subTokens, blockContent.substring(2), unicodeMode, groups);
                            tokens.push({
                                type: 'Group',
                                capturing: false,
                                expression: toSingleToken(subTokens)
                            });
                        } else if (blockContent[1] === '=' || blockContent[1] === '!') {
                            pushTokens(subTokens, blockContent.substring(2), unicodeMode, groups);
                            tokens.push({
                                type: 'Assertion',
                                kind: 'Lookahead',
                                negative: blockContent[1] === '!' ? true : undefined,
                                assertion: toSingleToken(subTokens)
                            });
                        } else if (blockContent[1] === '<' && (blockContent[2] === '=' || blockContent[2] === '!')) {
                            pushTokens(subTokens, blockContent.substring(3), unicodeMode, groups);
                            tokens.push({
                                type: 'Assertion',
                                kind: 'Lookbehind',
                                negative: blockContent[2] === '!' ? true : undefined,
                                assertion: toSingleToken(subTokens)
                            });
                        } else {
                            const chunks = blockContent.split('>');
                            if (chunks.length < 2 || chunks[0][1] !== '<') throw new Error(`Unsupported regex content found at ${JSON.stringify(block)}`);
                            const groupIndex = ++groups.lastIndex;
                            const nameRaw = chunks[0].substring(2);
                            groups.named.set(nameRaw, groupIndex);
                            pushTokens(subTokens, chunks.slice(1).join('>'), unicodeMode, groups);
                            tokens.push({
                                type: 'Group',
                                capturing: true,
                                nameRaw,
                                name: nameRaw,
                                number: groupIndex,
                                expression: toSingleToken(subTokens)
                            });
                        }
                    } else {
                        const groupIndex = ++groups.lastIndex;
                        pushTokens(subTokens, blockContent, unicodeMode, groups);
                        tokens.push({
                            type: 'Group',
                            capturing: true,
                            number: groupIndex,
                            expression: toSingleToken(subTokens)
                        });
                    }
                    break;
                }
            default:
                if (block === '^') tokens.push({
                    type: 'Assertion',
                    kind: block
                });
                else if (block === '$') tokens.push({
                    type: 'Assertion',
                    kind: block
                });
                else if (block[0] === '\\' && isDigit(block[1])) {
                    const reference = Number(block.substring(1));
                    if (unicodeMode || reference <= groups.lastIndex) tokens.push({
                        type: 'Backreference',
                        kind: 'number',
                        number: reference,
                        reference
                    });
                    else tokens.push(blockToCharToken(block));
                } else if (block[0] === '\\' && block[1] === 'k' && block.length !== 2) {
                    const referenceRaw = block.substring(3, block.length - 1);
                    tokens.push({
                        type: 'Backreference',
                        kind: 'name',
                        number: groups.named.get(referenceRaw) || 0,
                        referenceRaw,
                        reference: referenceRaw
                    });
                } else tokens.push(blockToCharToken(block));
                break;
        }
    }
    if (disjunctions !== null) {
        disjunctions.push(toSingleToken(tokens.splice(0), true) || null);
        let currentDisjunction = {
            type: 'Disjunction',
            left: disjunctions[0],
            right: disjunctions[1]
        };
        for(let index = 2; index < disjunctions.length; ++index)currentDisjunction = {
            type: 'Disjunction',
            left: currentDisjunction,
            right: disjunctions[index]
        };
        tokens.push(currentDisjunction);
    }
}
function tokenizeRegex(regex) {
    const unicodeMode = (0, _globalsJs.safeIndexOf)([
        ...regex.flags
    ], 'u') !== -1;
    const regexSource = regex.source;
    const tokens = [];
    pushTokens(tokens, regexSource, unicodeMode, {
        lastIndex: 0,
        named: new Map()
    });
    return toSingleToken(tokens);
}

},{"../../../utils/globals.js":"aTuwn","./ReadRegex.js":"5vtex","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"5vtex":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TokenizerBlockMode", ()=>TokenizerBlockMode);
parcelHelpers.export(exports, "readFrom", ()=>readFrom);
function charSizeAt(text, pos) {
    return text[pos] >= '\uD800' && text[pos] <= '\uDBFF' && text[pos + 1] >= '\uDC00' && text[pos + 1] <= '\uDFFF' ? 2 : 1;
}
function isHexaDigit(char) {
    return char >= '0' && char <= '9' || char >= 'a' && char <= 'f' || char >= 'A' && char <= 'F';
}
function isDigit(char) {
    return char >= '0' && char <= '9';
}
function squaredBracketBlockContentEndFrom(text, from) {
    for(let index = from; index !== text.length; ++index){
        const char = text[index];
        if (char === '\\') index += 1;
        else if (char === ']') return index;
    }
    throw new Error(`Missing closing ']'`);
}
function parenthesisBlockContentEndFrom(text, from) {
    let numExtraOpened = 0;
    for(let index = from; index !== text.length; ++index){
        const char = text[index];
        if (char === '\\') index += 1;
        else if (char === ')') {
            if (numExtraOpened === 0) return index;
            numExtraOpened -= 1;
        } else if (char === '[') index = squaredBracketBlockContentEndFrom(text, index);
        else if (char === '(') numExtraOpened += 1;
    }
    throw new Error(`Missing closing ')'`);
}
function curlyBracketBlockContentEndFrom(text, from) {
    let foundComma = false;
    for(let index = from; index !== text.length; ++index){
        const char = text[index];
        if (isDigit(char)) ;
        else if (from === index) return -1;
        else if (char === ',') {
            if (foundComma) return -1;
            foundComma = true;
        } else if (char === '}') return index;
        else return -1;
    }
    return -1;
}
var TokenizerBlockMode;
(function(TokenizerBlockMode) {
    TokenizerBlockMode[TokenizerBlockMode["Full"] = 0] = "Full";
    TokenizerBlockMode[TokenizerBlockMode["Character"] = 1] = "Character";
})(TokenizerBlockMode || (TokenizerBlockMode = {}));
function blockEndFrom(text, from, unicodeMode, mode) {
    switch(text[from]){
        case '[':
            if (mode === TokenizerBlockMode.Character) return from + 1;
            return squaredBracketBlockContentEndFrom(text, from + 1) + 1;
        case '{':
            {
                if (mode === TokenizerBlockMode.Character) return from + 1;
                const foundEnd = curlyBracketBlockContentEndFrom(text, from + 1);
                if (foundEnd === -1) return from + 1;
                return foundEnd + 1;
            }
        case '(':
            if (mode === TokenizerBlockMode.Character) return from + 1;
            return parenthesisBlockContentEndFrom(text, from + 1) + 1;
        case ']':
        case '}':
        case ')':
            return from + 1;
        case '\\':
            {
                const next1 = text[from + 1];
                switch(next1){
                    case 'x':
                        if (isHexaDigit(text[from + 2]) && isHexaDigit(text[from + 3])) return from + 4;
                        throw new Error(`Unexpected token '${text.substring(from, from + 4)}' found`);
                    case 'u':
                        if (text[from + 2] === '{') {
                            if (!unicodeMode) return from + 2;
                            if (text[from + 4] === '}') {
                                if (isHexaDigit(text[from + 3])) return from + 5;
                                throw new Error(`Unexpected token '${text.substring(from, from + 5)}' found`);
                            }
                            if (text[from + 5] === '}') {
                                if (isHexaDigit(text[from + 3]) && isHexaDigit(text[from + 4])) return from + 6;
                                throw new Error(`Unexpected token '${text.substring(from, from + 6)}' found`);
                            }
                            if (text[from + 6] === '}') {
                                if (isHexaDigit(text[from + 3]) && isHexaDigit(text[from + 4]) && isHexaDigit(text[from + 5])) return from + 7;
                                throw new Error(`Unexpected token '${text.substring(from, from + 7)}' found`);
                            }
                            if (text[from + 7] === '}') {
                                if (isHexaDigit(text[from + 3]) && isHexaDigit(text[from + 4]) && isHexaDigit(text[from + 5]) && isHexaDigit(text[from + 6])) return from + 8;
                                throw new Error(`Unexpected token '${text.substring(from, from + 8)}' found`);
                            }
                            if (text[from + 8] === '}' && isHexaDigit(text[from + 3]) && isHexaDigit(text[from + 4]) && isHexaDigit(text[from + 5]) && isHexaDigit(text[from + 6]) && isHexaDigit(text[from + 7])) return from + 9;
                            throw new Error(`Unexpected token '${text.substring(from, from + 9)}' found`);
                        }
                        if (isHexaDigit(text[from + 2]) && isHexaDigit(text[from + 3]) && isHexaDigit(text[from + 4]) && isHexaDigit(text[from + 5])) return from + 6;
                        throw new Error(`Unexpected token '${text.substring(from, from + 6)}' found`);
                    case 'p':
                    case 'P':
                        {
                            if (!unicodeMode) return from + 2;
                            let subIndex = from + 2;
                            for(; subIndex < text.length && text[subIndex] !== '}'; subIndex += text[subIndex] === '\\' ? 2 : 1);
                            if (text[subIndex] !== '}') throw new Error(`Invalid \\P definition`);
                            return subIndex + 1;
                        }
                    case 'k':
                        {
                            let subIndex = from + 2;
                            for(; subIndex < text.length && text[subIndex] !== '>'; ++subIndex);
                            if (text[subIndex] !== '>') {
                                if (!unicodeMode) return from + 2;
                                throw new Error(`Invalid \\k definition`);
                            }
                            return subIndex + 1;
                        }
                    default:
                        {
                            if (isDigit(next1)) {
                                const maxIndex = unicodeMode ? text.length : Math.min(from + 4, text.length);
                                let subIndex = from + 2;
                                for(; subIndex < maxIndex && isDigit(text[subIndex]); ++subIndex);
                                return subIndex;
                            }
                            const charSize = unicodeMode ? charSizeAt(text, from + 1) : 1;
                            return from + charSize + 1;
                        }
                }
            }
        default:
            {
                const charSize = unicodeMode ? charSizeAt(text, from) : 1;
                return from + charSize;
            }
    }
}
function readFrom(text, from, unicodeMode, mode) {
    const to = blockEndFrom(text, from, unicodeMode, mode);
    return text.substring(from, to);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"jmGf1":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "limitShrink", ()=>limitShrink);
var _limitedShrinkArbitraryJs = require("./_internals/LimitedShrinkArbitrary.js");
function limitShrink(arbitrary, maxShrinks) {
    return new (0, _limitedShrinkArbitraryJs.LimitedShrinkArbitrary)(arbitrary, maxShrinks);
}

},{"./_internals/LimitedShrinkArbitrary.js":"6MR43","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"6MR43":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "LimitedShrinkArbitrary", ()=>LimitedShrinkArbitrary);
var _arbitraryJs = require("../../check/arbitrary/definition/Arbitrary.js");
var _valueJs = require("../../check/arbitrary/definition/Value.js");
var _streamJs = require("../../stream/Stream.js");
var _zipIterableIteratorsJs = require("./helpers/ZipIterableIterators.js");
function* iotaFrom(startValue) {
    let value = startValue;
    while(true){
        yield value;
        ++value;
    }
}
class LimitedShrinkArbitrary extends (0, _arbitraryJs.Arbitrary) {
    constructor(arb, maxShrinks){
        super();
        this.arb = arb;
        this.maxShrinks = maxShrinks;
    }
    generate(mrng, biasFactor) {
        const value = this.arb.generate(mrng, biasFactor);
        return this.valueMapper(value, 0);
    }
    canShrinkWithoutContext(value) {
        return this.arb.canShrinkWithoutContext(value);
    }
    shrink(value, context) {
        if (this.isSafeContext(context)) return this.safeShrink(value, context.originalContext, context.length);
        return this.safeShrink(value, undefined, 0);
    }
    safeShrink(value, originalContext, currentLength) {
        const remaining = this.maxShrinks - currentLength;
        if (remaining <= 0) return (0, _streamJs.Stream).nil();
        return new (0, _streamJs.Stream)((0, _zipIterableIteratorsJs.zipIterableIterators)(this.arb.shrink(value, originalContext), iotaFrom(currentLength + 1))).take(remaining).map((valueAndLength)=>this.valueMapper(valueAndLength[0], valueAndLength[1]));
    }
    valueMapper(v, newLength) {
        const context = {
            originalContext: v.context,
            length: newLength
        };
        return new (0, _valueJs.Value)(v.value, context);
    }
    isSafeContext(context) {
        return context != null && typeof context === 'object' && 'originalContext' in context && 'length' in context;
    }
}

},{"../../check/arbitrary/definition/Arbitrary.js":"e6f1K","../../check/arbitrary/definition/Value.js":"8Cf1j","../../stream/Stream.js":"2sjal","./helpers/ZipIterableIterators.js":"kHr31","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"kHr31":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "zipIterableIterators", ()=>zipIterableIterators);
function initZippedValues(its) {
    const vs = [];
    for(let index = 0; index !== its.length; ++index)vs.push(its[index].next());
    return vs;
}
function nextZippedValues(its, vs) {
    for(let index = 0; index !== its.length; ++index)vs[index] = its[index].next();
}
function isDoneZippedValues(vs) {
    for(let index = 0; index !== vs.length; ++index){
        if (vs[index].done) return true;
    }
    return false;
}
function* zipIterableIterators(...its) {
    const vs = initZippedValues(its);
    while(!isDoneZippedValues(vs)){
        yield vs.map((v)=>v.value);
        nextZippedValues(its, vs);
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"4Kq0F":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MatcherTypeId", ()=>MatcherTypeId);
parcelHelpers.export(exports, "type", ()=>type);
parcelHelpers.export(exports, "value", ()=>value);
parcelHelpers.export(exports, "valueTags", ()=>valueTags);
parcelHelpers.export(exports, "typeTags", ()=>typeTags);
parcelHelpers.export(exports, "withReturnType", ()=>withReturnType);
parcelHelpers.export(exports, "when", ()=>when);
parcelHelpers.export(exports, "whenOr", ()=>whenOr);
parcelHelpers.export(exports, "whenAnd", ()=>whenAnd);
parcelHelpers.export(exports, "discriminator", ()=>discriminator);
parcelHelpers.export(exports, "discriminatorStartsWith", ()=>discriminatorStartsWith);
parcelHelpers.export(exports, "discriminators", ()=>discriminators);
parcelHelpers.export(exports, "discriminatorsExhaustive", ()=>discriminatorsExhaustive);
parcelHelpers.export(exports, "tag", ()=>tag);
parcelHelpers.export(exports, "tagStartsWith", ()=>tagStartsWith);
parcelHelpers.export(exports, "tags", ()=>tags);
parcelHelpers.export(exports, "tagsExhaustive", ()=>tagsExhaustive);
parcelHelpers.export(exports, "not", ()=>not);
parcelHelpers.export(exports, "nonEmptyString", ()=>nonEmptyString);
parcelHelpers.export(exports, "is", ()=>is);
parcelHelpers.export(exports, "string", ()=>string);
parcelHelpers.export(exports, "number", ()=>number);
parcelHelpers.export(exports, "any", ()=>any);
parcelHelpers.export(exports, "defined", ()=>defined);
parcelHelpers.export(exports, "boolean", ()=>boolean);
parcelHelpers.export(exports, "undefined", ()=>/**
 * Matches the value `undefined`.
 *
 * @category Predicates
 * @since 1.0.0
 */ _undefined);
parcelHelpers.export(exports, "null", ()=>/**
 * Matches the value `null`.
 *
 * @category Predicates
 * @since 1.0.0
 */ _null);
parcelHelpers.export(exports, "bigint", ()=>bigint);
parcelHelpers.export(exports, "symbol", ()=>symbol);
parcelHelpers.export(exports, "date", ()=>date);
parcelHelpers.export(exports, "record", ()=>record);
parcelHelpers.export(exports, "instanceOf", ()=>instanceOf);
parcelHelpers.export(exports, "instanceOfUnsafe", ()=>instanceOfUnsafe);
parcelHelpers.export(exports, "orElse", ()=>orElse);
parcelHelpers.export(exports, "orElseAbsurd", ()=>orElseAbsurd);
parcelHelpers.export(exports, "either", ()=>either);
parcelHelpers.export(exports, "option", ()=>option);
parcelHelpers.export(exports, "exhaustive", ()=>exhaustive);
parcelHelpers.export(exports, "SafeRefinementId", ()=>SafeRefinementId);
var _matcherJs = require("./internal/matcher.js");
var _predicateJs = require("./Predicate.js");
const MatcherTypeId = _matcherJs.TypeId;
const type = _matcherJs.type;
const value = _matcherJs.value;
const valueTags = _matcherJs.valueTags;
const typeTags = _matcherJs.typeTags;
const withReturnType = _matcherJs.withReturnType;
const when = _matcherJs.when;
const whenOr = _matcherJs.whenOr;
const whenAnd = _matcherJs.whenAnd;
const discriminator = _matcherJs.discriminator;
const discriminatorStartsWith = _matcherJs.discriminatorStartsWith;
const discriminators = _matcherJs.discriminators;
const discriminatorsExhaustive = _matcherJs.discriminatorsExhaustive;
const tag = _matcherJs.tag;
const tagStartsWith = _matcherJs.tagStartsWith;
const tags = _matcherJs.tags;
const tagsExhaustive = _matcherJs.tagsExhaustive;
const not = _matcherJs.not;
const nonEmptyString = _matcherJs.nonEmptyString;
const is = _matcherJs.is;
const string = _predicateJs.isString;
const number = _predicateJs.isNumber;
const any = _matcherJs.any;
const defined = _matcherJs.defined;
const boolean = _predicateJs.isBoolean;
const _undefined = _predicateJs.isUndefined;
const _null = _predicateJs.isNull;
const bigint = _predicateJs.isBigInt;
const symbol = _predicateJs.isSymbol;
const date = _predicateJs.isDate;
const record = _predicateJs.isRecord;
const instanceOf = _matcherJs.instanceOf;
const instanceOfUnsafe = _matcherJs.instanceOf;
const orElse = _matcherJs.orElse;
const orElseAbsurd = _matcherJs.orElseAbsurd;
const either = _matcherJs.either;
const option = _matcherJs.option;
const exhaustive = _matcherJs.exhaustive;
const SafeRefinementId = /*#__PURE__*/ Symbol.for("effect/SafeRefinement");
const Fail = /*#__PURE__*/ Symbol.for("effect/Fail");

},{"./internal/matcher.js":"gpvH4","./Predicate.js":"gW5pd","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"gpvH4":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TypeId", ()=>TypeId);
parcelHelpers.export(exports, "type", ()=>type);
parcelHelpers.export(exports, "value", ()=>value);
parcelHelpers.export(exports, "valueTags", ()=>valueTags);
parcelHelpers.export(exports, "typeTags", ()=>typeTags);
parcelHelpers.export(exports, "withReturnType", ()=>withReturnType);
parcelHelpers.export(exports, "when", ()=>when);
parcelHelpers.export(exports, "whenOr", ()=>whenOr);
parcelHelpers.export(exports, "whenAnd", ()=>whenAnd);
parcelHelpers.export(exports, "discriminator", ()=>discriminator);
parcelHelpers.export(exports, "discriminatorStartsWith", ()=>discriminatorStartsWith);
parcelHelpers.export(exports, "discriminators", ()=>discriminators);
parcelHelpers.export(exports, "discriminatorsExhaustive", ()=>discriminatorsExhaustive);
parcelHelpers.export(exports, "tag", ()=>tag);
parcelHelpers.export(exports, "tagStartsWith", ()=>tagStartsWith);
parcelHelpers.export(exports, "tags", ()=>tags);
parcelHelpers.export(exports, "tagsExhaustive", ()=>tagsExhaustive);
parcelHelpers.export(exports, "not", ()=>not);
parcelHelpers.export(exports, "nonEmptyString", ()=>nonEmptyString);
parcelHelpers.export(exports, "is", ()=>is);
parcelHelpers.export(exports, "any", ()=>any);
parcelHelpers.export(exports, "defined", ()=>defined);
parcelHelpers.export(exports, "instanceOf", ()=>instanceOf);
parcelHelpers.export(exports, "instanceOfUnsafe", ()=>instanceOfUnsafe);
parcelHelpers.export(exports, "orElse", ()=>orElse);
parcelHelpers.export(exports, "orElseAbsurd", ()=>orElseAbsurd);
parcelHelpers.export(exports, "either", ()=>either);
parcelHelpers.export(exports, "option", ()=>option);
parcelHelpers.export(exports, "exhaustive", ()=>exhaustive);
var _eitherJs = require("../Either.js");
var _functionJs = require("../Function.js");
var _optionJs = require("../Option.js");
var _pipeableJs = require("../Pipeable.js");
const TypeId = /*#__PURE__*/ Symbol.for("@effect/matcher/Matcher");
const TypeMatcherProto = {
    [TypeId]: {
        _input: (0, _functionJs.identity),
        _filters: (0, _functionJs.identity),
        _remaining: (0, _functionJs.identity),
        _result: (0, _functionJs.identity),
        _return: (0, _functionJs.identity)
    },
    _tag: "TypeMatcher",
    add (_case) {
        return makeTypeMatcher([
            ...this.cases,
            _case
        ]);
    },
    pipe () {
        return (0, _pipeableJs.pipeArguments)(this, arguments);
    }
};
function makeTypeMatcher(cases) {
    const matcher = Object.create(TypeMatcherProto);
    matcher.cases = cases;
    return matcher;
}
const ValueMatcherProto = {
    [TypeId]: {
        _input: (0, _functionJs.identity),
        _filters: (0, _functionJs.identity),
        _result: (0, _functionJs.identity),
        _return: (0, _functionJs.identity)
    },
    _tag: "ValueMatcher",
    add (_case) {
        if (this.value._tag === "Right") return this;
        if (_case._tag === "When" && _case.guard(this.provided) === true) return makeValueMatcher(this.provided, _eitherJs.right(_case.evaluate(this.provided)));
        else if (_case._tag === "Not" && _case.guard(this.provided) === false) return makeValueMatcher(this.provided, _eitherJs.right(_case.evaluate(this.provided)));
        return this;
    },
    pipe () {
        return (0, _pipeableJs.pipeArguments)(this, arguments);
    }
};
function makeValueMatcher(provided, value) {
    const matcher = Object.create(ValueMatcherProto);
    matcher.provided = provided;
    matcher.value = value;
    return matcher;
}
const makeWhen = (guard, evaluate)=>({
        _tag: "When",
        guard,
        evaluate
    });
const makeNot = (guard, evaluate)=>({
        _tag: "Not",
        guard,
        evaluate
    });
const makePredicate = (pattern)=>{
    if (typeof pattern === "function") return pattern;
    else if (Array.isArray(pattern)) {
        const predicates = pattern.map(makePredicate);
        const len = predicates.length;
        return (u)=>{
            if (!Array.isArray(u)) return false;
            for(let i = 0; i < len; i++){
                if (predicates[i](u[i]) === false) return false;
            }
            return true;
        };
    } else if (pattern !== null && typeof pattern === "object") {
        const keysAndPredicates = Object.entries(pattern).map(([k, p])=>[
                k,
                makePredicate(p)
            ]);
        const len = keysAndPredicates.length;
        return (u)=>{
            if (typeof u !== "object" || u === null) return false;
            for(let i = 0; i < len; i++){
                const [key, predicate] = keysAndPredicates[i];
                if (!(key in u) || predicate(u[key]) === false) return false;
            }
            return true;
        };
    }
    return (u)=>u === pattern;
};
const makeOrPredicate = (patterns)=>{
    const predicates = patterns.map(makePredicate);
    const len = predicates.length;
    return (u)=>{
        for(let i = 0; i < len; i++){
            if (predicates[i](u) === true) return true;
        }
        return false;
    };
};
const makeAndPredicate = (patterns)=>{
    const predicates = patterns.map(makePredicate);
    const len = predicates.length;
    return (u)=>{
        for(let i = 0; i < len; i++){
            if (predicates[i](u) === false) return false;
        }
        return true;
    };
};
const type = ()=>makeTypeMatcher([]);
const value = (i)=>makeValueMatcher(i, _eitherJs.left(i));
const valueTags = /*#__PURE__*/ (0, _functionJs.dual)(2, (input, fields)=>{
    const match = tagsExhaustive(fields)(makeTypeMatcher([]));
    return match(input);
});
const typeTags = ()=>(fields)=>{
        const match = tagsExhaustive(fields)(makeTypeMatcher([]));
        return (input)=>match(input);
    };
const withReturnType = ()=>(self)=>self;
const when = (pattern, f)=>(self)=>self.add(makeWhen(makePredicate(pattern), f));
const whenOr = (...args)=>(self)=>{
        const onMatch = args[args.length - 1];
        const patterns = args.slice(0, -1);
        return self.add(makeWhen(makeOrPredicate(patterns), onMatch));
    };
const whenAnd = (...args)=>(self)=>{
        const onMatch = args[args.length - 1];
        const patterns = args.slice(0, -1);
        return self.add(makeWhen(makeAndPredicate(patterns), onMatch));
    };
const discriminator = (field)=>(...pattern)=>{
        const f = pattern[pattern.length - 1];
        const values = pattern.slice(0, -1);
        const pred = values.length === 1 ? (_)=>_[field] === values[0] : (_)=>values.includes(_[field]);
        return (self)=>self.add(makeWhen(pred, f));
    };
const discriminatorStartsWith = (field)=>(pattern, f)=>{
        const pred = (_)=>typeof _[field] === "string" && _[field].startsWith(pattern);
        return (self)=>self.add(makeWhen(pred, f));
    };
const discriminators = (field)=>(fields)=>{
        const predicate = makeWhen((arg)=>arg != null && arg[field] in fields, (data)=>fields[data[field]](data));
        return (self)=>self.add(predicate);
    };
const discriminatorsExhaustive = (field)=>(fields)=>{
        const addCases = discriminators(field)(fields);
        return (matcher)=>exhaustive(addCases(matcher));
    };
const tag = /*#__PURE__*/ discriminator("_tag");
const tagStartsWith = /*#__PURE__*/ discriminatorStartsWith("_tag");
const tags = /*#__PURE__*/ discriminators("_tag");
const tagsExhaustive = /*#__PURE__*/ discriminatorsExhaustive("_tag");
const not = (pattern, f)=>(self)=>self.add(makeNot(makePredicate(pattern), f));
const nonEmptyString = (u)=>typeof u === "string" && u.length > 0;
const is = (...literals)=>{
    const len = literals.length;
    return (u)=>{
        for(let i = 0; i < len; i++){
            if (u === literals[i]) return true;
        }
        return false;
    };
};
const any = ()=>true;
const defined = (u)=>u !== undefined && u !== null;
const instanceOf = (constructor)=>(u)=>u instanceof constructor;
const instanceOfUnsafe = instanceOf;
const orElse = (f)=>(self)=>{
        const result = either(self);
        if (_eitherJs.isEither(result)) // @ts-expect-error
        return result._tag === "Right" ? result.right : f(result.left);
        // @ts-expect-error
        return (input)=>{
            const a = result(input);
            return a._tag === "Right" ? a.right : f(a.left);
        };
    };
const orElseAbsurd = (self)=>orElse(()=>{
        throw new Error("effect/Match/orElseAbsurd: absurd");
    })(self);
const either = (self)=>{
    if (self._tag === "ValueMatcher") return self.value;
    const len = self.cases.length;
    if (len === 1) {
        const _case = self.cases[0];
        return (input)=>{
            if (_case._tag === "When" && _case.guard(input) === true) return _eitherJs.right(_case.evaluate(input));
            else if (_case._tag === "Not" && _case.guard(input) === false) return _eitherJs.right(_case.evaluate(input));
            return _eitherJs.left(input);
        };
    }
    return (input)=>{
        for(let i = 0; i < len; i++){
            const _case = self.cases[i];
            if (_case._tag === "When" && _case.guard(input) === true) return _eitherJs.right(_case.evaluate(input));
            else if (_case._tag === "Not" && _case.guard(input) === false) return _eitherJs.right(_case.evaluate(input));
        }
        return _eitherJs.left(input);
    };
};
const option = (self)=>{
    const toEither = either(self);
    if (_eitherJs.isEither(toEither)) return _eitherJs.match(toEither, {
        onLeft: ()=>_optionJs.none(),
        onRight: _optionJs.some
    });
    return (input)=>_eitherJs.match(toEither(input), {
            onLeft: ()=>_optionJs.none(),
            onRight: _optionJs.some
        });
};
const getExhaustiveAbsurdErrorMessage = "effect/Match/exhaustive: absurd";
const exhaustive = (self)=>{
    const toEither = either(self);
    if (_eitherJs.isEither(toEither)) {
        if (toEither._tag === "Right") return toEither.right;
        throw new Error(getExhaustiveAbsurdErrorMessage);
    }
    return (u)=>{
        // @ts-expect-error
        const result = toEither(u);
        if (result._tag === "Right") return result.right;
        throw new Error(getExhaustiveAbsurdErrorMessage);
    };
};

},{"../Either.js":"4amnT","../Function.js":"21gOL","../Option.js":"6sHA7","../Pipeable.js":"b5RU2","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"74X79":[function(require,module,exports,__globalThis) {
/**
 * @since 3.10.0
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @category model
 * @since 3.10.0
 */ parcelHelpers.export(exports, "Pointer", ()=>Pointer);
/**
 * Error that occurs when an unexpected key or index is present.
 *
 * @category model
 * @since 3.10.0
 */ parcelHelpers.export(exports, "Unexpected", ()=>Unexpected);
/**
 * Error that occurs when a required key or index is missing.
 *
 * @category model
 * @since 3.10.0
 */ parcelHelpers.export(exports, "Missing", ()=>Missing);
/**
 * Error that contains multiple issues.
 *
 * @category model
 * @since 3.10.0
 */ parcelHelpers.export(exports, "Composite", ()=>Composite);
/**
 * Error that occurs when a refinement has an error.
 *
 * @category model
 * @since 3.10.0
 */ parcelHelpers.export(exports, "Refinement", ()=>Refinement);
/**
 * Error that occurs when a transformation has an error.
 *
 * @category model
 * @since 3.10.0
 */ parcelHelpers.export(exports, "Transformation", ()=>Transformation);
/**
 * The `Type` variant of the `ParseIssue` type represents an error that occurs when the `actual` value is not of the expected type.
 * The `ast` field specifies the expected type, and the `actual` field contains the value that caused the error.
 *
 * @category model
 * @since 3.10.0
 */ parcelHelpers.export(exports, "Type", ()=>Type);
/**
 * The `Forbidden` variant of the `ParseIssue` type represents a forbidden operation, such as when encountering an Effect that is not allowed to execute (e.g., using `runSync`).
 *
 * @category model
 * @since 3.10.0
 */ parcelHelpers.export(exports, "Forbidden", ()=>Forbidden);
parcelHelpers.export(exports, "ParseErrorTypeId", ()=>ParseErrorTypeId);
parcelHelpers.export(exports, "isParseError", ()=>isParseError);
/**
 * @since 3.10.0
 */ parcelHelpers.export(exports, "ParseError", ()=>ParseError);
parcelHelpers.export(exports, "parseError", ()=>parseError);
parcelHelpers.export(exports, "succeed", ()=>succeed);
parcelHelpers.export(exports, "fail", ()=>fail);
parcelHelpers.export(exports, "try", ()=>/**
 * @category constructors
 * @since 3.10.0
 */ _try);
parcelHelpers.export(exports, "fromOption", ()=>fromOption);
parcelHelpers.export(exports, "flatMap", ()=>flatMap);
parcelHelpers.export(exports, "map", ()=>map);
parcelHelpers.export(exports, "mapError", ()=>mapError);
parcelHelpers.export(exports, "eitherOrUndefined", ()=>eitherOrUndefined);
parcelHelpers.export(exports, "mapBoth", ()=>mapBoth);
parcelHelpers.export(exports, "orElse", ()=>orElse);
parcelHelpers.export(exports, "mergeInternalOptions", ()=>mergeInternalOptions);
parcelHelpers.export(exports, "getOption", ()=>getOption);
parcelHelpers.export(exports, "decodeUnknownSync", ()=>decodeUnknownSync);
parcelHelpers.export(exports, "decodeUnknownOption", ()=>decodeUnknownOption);
parcelHelpers.export(exports, "decodeUnknownEither", ()=>decodeUnknownEither);
parcelHelpers.export(exports, "decodeUnknownPromise", ()=>decodeUnknownPromise);
parcelHelpers.export(exports, "decodeUnknown", ()=>decodeUnknown);
parcelHelpers.export(exports, "encodeUnknownSync", ()=>encodeUnknownSync);
parcelHelpers.export(exports, "encodeUnknownOption", ()=>encodeUnknownOption);
parcelHelpers.export(exports, "encodeUnknownEither", ()=>encodeUnknownEither);
parcelHelpers.export(exports, "encodeUnknownPromise", ()=>encodeUnknownPromise);
parcelHelpers.export(exports, "encodeUnknown", ()=>encodeUnknown);
parcelHelpers.export(exports, "decodeSync", ()=>decodeSync);
parcelHelpers.export(exports, "decodeOption", ()=>decodeOption);
parcelHelpers.export(exports, "decodeEither", ()=>decodeEither);
parcelHelpers.export(exports, "decodePromise", ()=>decodePromise);
parcelHelpers.export(exports, "decode", ()=>decode);
parcelHelpers.export(exports, "validateSync", ()=>validateSync);
parcelHelpers.export(exports, "validateOption", ()=>validateOption);
parcelHelpers.export(exports, "validateEither", ()=>validateEither);
parcelHelpers.export(exports, "validatePromise", ()=>validatePromise);
parcelHelpers.export(exports, "validate", ()=>validate);
parcelHelpers.export(exports, "is", ()=>is);
parcelHelpers.export(exports, "asserts", ()=>asserts);
parcelHelpers.export(exports, "encodeSync", ()=>encodeSync);
parcelHelpers.export(exports, "encodeOption", ()=>encodeOption);
parcelHelpers.export(exports, "encodeEither", ()=>encodeEither);
parcelHelpers.export(exports, "encodePromise", ()=>encodePromise);
parcelHelpers.export(exports, "encode", ()=>encode);
parcelHelpers.export(exports, "getLiterals", ()=>getLiterals);
parcelHelpers.export(exports, "getSearchTree", ()=>getSearchTree);
parcelHelpers.export(exports, "getFinalTransformation", ()=>getFinalTransformation);
parcelHelpers.export(exports, "TreeFormatter", ()=>TreeFormatter);
parcelHelpers.export(exports, "isComposite", ()=>isComposite);
/** @internal */ parcelHelpers.export(exports, "getRefinementExpected", ()=>getRefinementExpected);
parcelHelpers.export(exports, "ArrayFormatter", ()=>ArrayFormatter);
var _arrayJs = require("./Array.js");
var _causeJs = require("./Cause.js");
var _dataJs = require("./Data.js");
var _effectJs = require("./Effect.js");
var _eitherJs = require("./Either.js");
var _exitJs = require("./Exit.js");
var _functionJs = require("./Function.js");
var _globalValueJs = require("./GlobalValue.js");
var _inspectableJs = require("./Inspectable.js");
var _utilJs = require("./internal/schema/util.js");
var _optionJs = require("./Option.js");
var _predicateJs = require("./Predicate.js");
var _schedulerJs = require("./Scheduler.js");
var _schemaASTJs = require("./SchemaAST.js");
class Pointer {
    path;
    actual;
    issue;
    /**
   * @since 3.10.0
   */ _tag = "Pointer";
    constructor(path, actual, issue){
        this.path = path;
        this.actual = actual;
        this.issue = issue;
    }
}
class Unexpected {
    actual;
    message;
    /**
   * @since 3.10.0
   */ _tag = "Unexpected";
    constructor(actual, /**
   * @since 3.10.0
   */ message){
        this.actual = actual;
        this.message = message;
    }
}
class Missing {
    ast;
    message;
    /**
   * @since 3.10.0
   */ _tag = "Missing";
    /**
   * @since 3.10.0
   */ actual = undefined;
    constructor(/**
   * @since 3.10.0
   */ ast, /**
   * @since 3.10.0
   */ message){
        this.ast = ast;
        this.message = message;
    }
}
class Composite {
    ast;
    actual;
    issues;
    output;
    /**
   * @since 3.10.0
   */ _tag = "Composite";
    constructor(ast, actual, issues, output){
        this.ast = ast;
        this.actual = actual;
        this.issues = issues;
        this.output = output;
    }
}
class Refinement {
    ast;
    actual;
    kind;
    issue;
    /**
   * @since 3.10.0
   */ _tag = "Refinement";
    constructor(ast, actual, kind, issue){
        this.ast = ast;
        this.actual = actual;
        this.kind = kind;
        this.issue = issue;
    }
}
class Transformation {
    ast;
    actual;
    kind;
    issue;
    /**
   * @since 3.10.0
   */ _tag = "Transformation";
    constructor(ast, actual, kind, issue){
        this.ast = ast;
        this.actual = actual;
        this.kind = kind;
        this.issue = issue;
    }
}
class Type {
    ast;
    actual;
    message;
    /**
   * @since 3.10.0
   */ _tag = "Type";
    constructor(ast, actual, message){
        this.ast = ast;
        this.actual = actual;
        this.message = message;
    }
}
class Forbidden {
    ast;
    actual;
    message;
    /**
   * @since 3.10.0
   */ _tag = "Forbidden";
    constructor(ast, actual, message){
        this.ast = ast;
        this.actual = actual;
        this.message = message;
    }
}
const ParseErrorTypeId = /*#__PURE__*/ Symbol.for("effect/Schema/ParseErrorTypeId");
const isParseError = (u)=>_predicateJs.hasProperty(u, ParseErrorTypeId);
class ParseError extends /*#__PURE__*/ (0, _dataJs.TaggedError)("ParseError") {
    /**
   * @since 3.10.0
   */ [ParseErrorTypeId] = ParseErrorTypeId;
    get message() {
        return this.toString();
    }
    /**
   * @since 3.10.0
   */ toString() {
        return TreeFormatter.formatIssueSync(this.issue);
    }
    /**
   * @since 3.10.0
   */ toJSON() {
        return {
            _id: "ParseError",
            message: this.toString()
        };
    }
    /**
   * @since 3.10.0
   */ [_inspectableJs.NodeInspectSymbol]() {
        return this.toJSON();
    }
}
const parseError = (issue)=>new ParseError({
        issue
    });
const succeed = _eitherJs.right;
const fail = _eitherJs.left;
const _try = _eitherJs.try;
const fromOption = _eitherJs.fromOption;
const isEither = _eitherJs.isEither;
const flatMap = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>{
    return isEither(self) ? _eitherJs.match(self, {
        onLeft: _eitherJs.left,
        onRight: f
    }) : _effectJs.flatMap(self, f);
});
const map = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>{
    return isEither(self) ? _eitherJs.map(self, f) : _effectJs.map(self, f);
});
const mapError = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>{
    return isEither(self) ? _eitherJs.mapLeft(self, f) : _effectJs.mapError(self, f);
});
const eitherOrUndefined = (self)=>{
    if (isEither(self)) return self;
};
const mapBoth = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, options)=>{
    return isEither(self) ? _eitherJs.mapBoth(self, {
        onLeft: options.onFailure,
        onRight: options.onSuccess
    }) : _effectJs.mapBoth(self, options);
});
const orElse = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>{
    return isEither(self) ? _eitherJs.match(self, {
        onLeft: f,
        onRight: _eitherJs.right
    }) : _effectJs.catchAll(self, f);
});
const mergeInternalOptions = (options, overrideOptions)=>{
    if (overrideOptions === undefined || _predicateJs.isNumber(overrideOptions)) return options;
    if (options === undefined) return overrideOptions;
    return {
        ...options,
        ...overrideOptions
    };
};
const getEither = (ast, isDecoding, options)=>{
    const parser = goMemo(ast, isDecoding);
    return (u, overrideOptions)=>parser(u, mergeInternalOptions(options, overrideOptions));
};
const getSync = (ast, isDecoding, options)=>{
    const parser = getEither(ast, isDecoding, options);
    return (input, overrideOptions)=>_eitherJs.getOrThrowWith(parser(input, overrideOptions), parseError);
};
const getOption = (ast, isDecoding, options)=>{
    const parser = getEither(ast, isDecoding, options);
    return (input, overrideOptions)=>_optionJs.getRight(parser(input, overrideOptions));
};
const getEffect = (ast, isDecoding, options)=>{
    const parser = goMemo(ast, isDecoding);
    return (input, overrideOptions)=>parser(input, {
            ...mergeInternalOptions(options, overrideOptions),
            isEffectAllowed: true
        });
};
const decodeUnknownSync = (schema, options)=>getSync(schema.ast, true, options);
const decodeUnknownOption = (schema, options)=>getOption(schema.ast, true, options);
const decodeUnknownEither = (schema, options)=>getEither(schema.ast, true, options);
const decodeUnknownPromise = (schema, options)=>{
    const parser = decodeUnknown(schema, options);
    return (u, overrideOptions)=>_effectJs.runPromise(parser(u, overrideOptions));
};
const decodeUnknown = (schema, options)=>getEffect(schema.ast, true, options);
const encodeUnknownSync = (schema, options)=>getSync(schema.ast, false, options);
const encodeUnknownOption = (schema, options)=>getOption(schema.ast, false, options);
const encodeUnknownEither = (schema, options)=>getEither(schema.ast, false, options);
const encodeUnknownPromise = (schema, options)=>{
    const parser = encodeUnknown(schema, options);
    return (u, overrideOptions)=>_effectJs.runPromise(parser(u, overrideOptions));
};
const encodeUnknown = (schema, options)=>getEffect(schema.ast, false, options);
const decodeSync = decodeUnknownSync;
const decodeOption = decodeUnknownOption;
const decodeEither = decodeUnknownEither;
const decodePromise = decodeUnknownPromise;
const decode = decodeUnknown;
const validateSync = (schema, options)=>getSync(_schemaASTJs.typeAST(schema.ast), true, options);
const validateOption = (schema, options)=>getOption(_schemaASTJs.typeAST(schema.ast), true, options);
const validateEither = (schema, options)=>getEither(_schemaASTJs.typeAST(schema.ast), true, options);
const validatePromise = (schema, options)=>{
    const parser = validate(schema, options);
    return (u, overrideOptions)=>_effectJs.runPromise(parser(u, overrideOptions));
};
const validate = (schema, options)=>getEffect(_schemaASTJs.typeAST(schema.ast), true, options);
const is = (schema, options)=>{
    const parser = goMemo(_schemaASTJs.typeAST(schema.ast), true);
    return (u, overrideOptions)=>_eitherJs.isRight(parser(u, {
            exact: true,
            ...mergeInternalOptions(options, overrideOptions)
        }));
};
const asserts = (schema, options)=>{
    const parser = goMemo(_schemaASTJs.typeAST(schema.ast), true);
    return (u, overrideOptions)=>{
        const result = parser(u, {
            exact: true,
            ...mergeInternalOptions(options, overrideOptions)
        });
        if (_eitherJs.isLeft(result)) throw parseError(result.left);
    };
};
const encodeSync = encodeUnknownSync;
const encodeOption = encodeUnknownOption;
const encodeEither = encodeUnknownEither;
const encodePromise = encodeUnknownPromise;
const encode = encodeUnknown;
const decodeMemoMap = /*#__PURE__*/ (0, _globalValueJs.globalValue)(/*#__PURE__*/ Symbol.for("effect/ParseResult/decodeMemoMap"), ()=>new WeakMap());
const encodeMemoMap = /*#__PURE__*/ (0, _globalValueJs.globalValue)(/*#__PURE__*/ Symbol.for("effect/ParseResult/encodeMemoMap"), ()=>new WeakMap());
const goMemo = (ast, isDecoding)=>{
    const memoMap = isDecoding ? decodeMemoMap : encodeMemoMap;
    const memo = memoMap.get(ast);
    if (memo) return memo;
    const raw = go(ast, isDecoding);
    const parseOptionsAnnotation = _schemaASTJs.getParseOptionsAnnotation(ast);
    const parserWithOptions = _optionJs.isSome(parseOptionsAnnotation) ? (i, options)=>raw(i, mergeInternalOptions(options, parseOptionsAnnotation.value)) : raw;
    const decodingFallbackAnnotation = _schemaASTJs.getDecodingFallbackAnnotation(ast);
    const parser = isDecoding && _optionJs.isSome(decodingFallbackAnnotation) ? (i, options)=>handleForbidden(orElse(parserWithOptions(i, options), decodingFallbackAnnotation.value), ast, i, options) : parserWithOptions;
    memoMap.set(ast, parser);
    return parser;
};
const getConcurrency = (ast)=>_optionJs.getOrUndefined(_schemaASTJs.getConcurrencyAnnotation(ast));
const getBatching = (ast)=>_optionJs.getOrUndefined(_schemaASTJs.getBatchingAnnotation(ast));
const go = (ast, isDecoding)=>{
    switch(ast._tag){
        case "Refinement":
            if (isDecoding) {
                const from = goMemo(ast.from, true);
                return (i, options)=>{
                    options = options ?? _schemaASTJs.defaultParseOption;
                    const allErrors = options?.errors === "all";
                    const result = flatMap(orElse(from(i, options), (ef)=>{
                        const issue = new Refinement(ast, i, "From", ef);
                        if (allErrors && _schemaASTJs.hasStableFilter(ast) && isComposite(ef)) return _optionJs.match(ast.filter(i, options, ast), {
                            onNone: ()=>_eitherJs.left(issue),
                            onSome: (ep)=>_eitherJs.left(new Composite(ast, i, [
                                    issue,
                                    new Refinement(ast, i, "Predicate", ep)
                                ]))
                        });
                        return _eitherJs.left(issue);
                    }), (a)=>_optionJs.match(ast.filter(a, options, ast), {
                            onNone: ()=>_eitherJs.right(a),
                            onSome: (ep)=>_eitherJs.left(new Refinement(ast, i, "Predicate", ep))
                        }));
                    return handleForbidden(result, ast, i, options);
                };
            } else {
                const from = goMemo(_schemaASTJs.typeAST(ast), true);
                const to = goMemo(dropRightRefinement(ast.from), false);
                return (i, options)=>handleForbidden(flatMap(from(i, options), (a)=>to(a, options)), ast, i, options);
            }
        case "Transformation":
            {
                const transform = getFinalTransformation(ast.transformation, isDecoding);
                const from = isDecoding ? goMemo(ast.from, true) : goMemo(ast.to, false);
                const to = isDecoding ? goMemo(ast.to, true) : goMemo(ast.from, false);
                return (i, options)=>handleForbidden(flatMap(mapError(from(i, options), (e)=>new Transformation(ast, i, isDecoding ? "Encoded" : "Type", e)), (a)=>flatMap(mapError(transform(a, options ?? _schemaASTJs.defaultParseOption, ast, i), (e)=>new Transformation(ast, i, "Transformation", e)), (i2)=>mapError(to(i2, options), (e)=>new Transformation(ast, i, isDecoding ? "Type" : "Encoded", e)))), ast, i, options);
            }
        case "Declaration":
            {
                const parse = isDecoding ? ast.decodeUnknown(...ast.typeParameters) : ast.encodeUnknown(...ast.typeParameters);
                return (i, options)=>handleForbidden(parse(i, options ?? _schemaASTJs.defaultParseOption, ast), ast, i, options);
            }
        case "Literal":
            return fromRefinement(ast, (u)=>u === ast.literal);
        case "UniqueSymbol":
            return fromRefinement(ast, (u)=>u === ast.symbol);
        case "UndefinedKeyword":
            return fromRefinement(ast, _predicateJs.isUndefined);
        case "NeverKeyword":
            return fromRefinement(ast, _predicateJs.isNever);
        case "UnknownKeyword":
        case "AnyKeyword":
        case "VoidKeyword":
            return _eitherJs.right;
        case "StringKeyword":
            return fromRefinement(ast, _predicateJs.isString);
        case "NumberKeyword":
            return fromRefinement(ast, _predicateJs.isNumber);
        case "BooleanKeyword":
            return fromRefinement(ast, _predicateJs.isBoolean);
        case "BigIntKeyword":
            return fromRefinement(ast, _predicateJs.isBigInt);
        case "SymbolKeyword":
            return fromRefinement(ast, _predicateJs.isSymbol);
        case "ObjectKeyword":
            return fromRefinement(ast, _predicateJs.isObject);
        case "Enums":
            return fromRefinement(ast, (u)=>ast.enums.some(([_, value])=>value === u));
        case "TemplateLiteral":
            {
                const regex = _schemaASTJs.getTemplateLiteralRegExp(ast);
                return fromRefinement(ast, (u)=>_predicateJs.isString(u) && regex.test(u));
            }
        case "TupleType":
            {
                const elements = ast.elements.map((e)=>goMemo(e.type, isDecoding));
                const rest = ast.rest.map((annotatedAST)=>goMemo(annotatedAST.type, isDecoding));
                let requiredTypes = ast.elements.filter((e)=>!e.isOptional);
                if (ast.rest.length > 0) requiredTypes = requiredTypes.concat(ast.rest.slice(1));
                const requiredLen = requiredTypes.length;
                const expectedIndexes = ast.elements.length > 0 ? ast.elements.map((_, i)=>i).join(" | ") : "never";
                const concurrency = getConcurrency(ast);
                const batching = getBatching(ast);
                return (input, options)=>{
                    if (!_arrayJs.isArray(input)) return _eitherJs.left(new Type(ast, input));
                    const allErrors = options?.errors === "all";
                    const es = [];
                    let stepKey = 0;
                    const output = [];
                    // ---------------------------------------------
                    // handle missing indexes
                    // ---------------------------------------------
                    const len = input.length;
                    for(let i = len; i <= requiredLen - 1; i++){
                        const e = new Pointer(i, input, new Missing(requiredTypes[i - len]));
                        if (allErrors) {
                            es.push([
                                stepKey++,
                                e
                            ]);
                            continue;
                        } else return _eitherJs.left(new Composite(ast, input, e, output));
                    }
                    // ---------------------------------------------
                    // handle excess indexes
                    // ---------------------------------------------
                    if (ast.rest.length === 0) for(let i = ast.elements.length; i <= len - 1; i++){
                        const e = new Pointer(i, input, new Unexpected(input[i], `is unexpected, expected: ${expectedIndexes}`));
                        if (allErrors) {
                            es.push([
                                stepKey++,
                                e
                            ]);
                            continue;
                        } else return _eitherJs.left(new Composite(ast, input, e, output));
                    }
                    let i = 0;
                    let queue = undefined;
                    // ---------------------------------------------
                    // handle elements
                    // ---------------------------------------------
                    for(; i < elements.length; i++)if (len < i + 1) {
                        if (ast.elements[i].isOptional) continue;
                    } else {
                        const parser = elements[i];
                        const te = parser(input[i], options);
                        if (isEither(te)) {
                            if (_eitherJs.isLeft(te)) {
                                // the input element is present but is not valid
                                const e = new Pointer(i, input, te.left);
                                if (allErrors) {
                                    es.push([
                                        stepKey++,
                                        e
                                    ]);
                                    continue;
                                } else return _eitherJs.left(new Composite(ast, input, e, sortByIndex(output)));
                            }
                            output.push([
                                stepKey++,
                                te.right
                            ]);
                        } else {
                            const nk = stepKey++;
                            const index = i;
                            if (!queue) queue = [];
                            queue.push(({ es, output })=>_effectJs.flatMap(_effectJs.either(te), (t)=>{
                                    if (_eitherJs.isLeft(t)) {
                                        // the input element is present but is not valid
                                        const e = new Pointer(index, input, t.left);
                                        if (allErrors) {
                                            es.push([
                                                nk,
                                                e
                                            ]);
                                            return _effectJs.void;
                                        } else return _eitherJs.left(new Composite(ast, input, e, sortByIndex(output)));
                                    }
                                    output.push([
                                        nk,
                                        t.right
                                    ]);
                                    return _effectJs.void;
                                }));
                        }
                    }
                    // ---------------------------------------------
                    // handle rest element
                    // ---------------------------------------------
                    if (_arrayJs.isNonEmptyReadonlyArray(rest)) {
                        const [head, ...tail] = rest;
                        for(; i < len - tail.length; i++){
                            const te = head(input[i], options);
                            if (isEither(te)) {
                                if (_eitherJs.isLeft(te)) {
                                    const e = new Pointer(i, input, te.left);
                                    if (allErrors) {
                                        es.push([
                                            stepKey++,
                                            e
                                        ]);
                                        continue;
                                    } else return _eitherJs.left(new Composite(ast, input, e, sortByIndex(output)));
                                } else output.push([
                                    stepKey++,
                                    te.right
                                ]);
                            } else {
                                const nk = stepKey++;
                                const index = i;
                                if (!queue) queue = [];
                                queue.push(({ es, output })=>_effectJs.flatMap(_effectJs.either(te), (t)=>{
                                        if (_eitherJs.isLeft(t)) {
                                            const e = new Pointer(index, input, t.left);
                                            if (allErrors) {
                                                es.push([
                                                    nk,
                                                    e
                                                ]);
                                                return _effectJs.void;
                                            } else return _eitherJs.left(new Composite(ast, input, e, sortByIndex(output)));
                                        } else {
                                            output.push([
                                                nk,
                                                t.right
                                            ]);
                                            return _effectJs.void;
                                        }
                                    }));
                            }
                        }
                        // ---------------------------------------------
                        // handle post rest elements
                        // ---------------------------------------------
                        for(let j = 0; j < tail.length; j++){
                            i += j;
                            if (len < i + 1) continue;
                            else {
                                const te = tail[j](input[i], options);
                                if (isEither(te)) {
                                    if (_eitherJs.isLeft(te)) {
                                        // the input element is present but is not valid
                                        const e = new Pointer(i, input, te.left);
                                        if (allErrors) {
                                            es.push([
                                                stepKey++,
                                                e
                                            ]);
                                            continue;
                                        } else return _eitherJs.left(new Composite(ast, input, e, sortByIndex(output)));
                                    }
                                    output.push([
                                        stepKey++,
                                        te.right
                                    ]);
                                } else {
                                    const nk = stepKey++;
                                    const index = i;
                                    if (!queue) queue = [];
                                    queue.push(({ es, output })=>_effectJs.flatMap(_effectJs.either(te), (t)=>{
                                            if (_eitherJs.isLeft(t)) {
                                                // the input element is present but is not valid
                                                const e = new Pointer(index, input, t.left);
                                                if (allErrors) {
                                                    es.push([
                                                        nk,
                                                        e
                                                    ]);
                                                    return _effectJs.void;
                                                } else return _eitherJs.left(new Composite(ast, input, e, sortByIndex(output)));
                                            }
                                            output.push([
                                                nk,
                                                t.right
                                            ]);
                                            return _effectJs.void;
                                        }));
                                }
                            }
                        }
                    }
                    // ---------------------------------------------
                    // compute result
                    // ---------------------------------------------
                    const computeResult = ({ es, output })=>_arrayJs.isNonEmptyArray(es) ? _eitherJs.left(new Composite(ast, input, sortByIndex(es), sortByIndex(output))) : _eitherJs.right(sortByIndex(output));
                    if (queue && queue.length > 0) {
                        const cqueue = queue;
                        return _effectJs.suspend(()=>{
                            const state = {
                                es: _arrayJs.copy(es),
                                output: _arrayJs.copy(output)
                            };
                            return _effectJs.flatMap(_effectJs.forEach(cqueue, (f)=>f(state), {
                                concurrency,
                                batching,
                                discard: true
                            }), ()=>computeResult(state));
                        });
                    }
                    return computeResult({
                        output,
                        es
                    });
                };
            }
        case "TypeLiteral":
            {
                if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) return fromRefinement(ast, _predicateJs.isNotNullable);
                const propertySignatures = [];
                const expectedKeysMap = {};
                const expectedKeys = [];
                for (const ps of ast.propertySignatures){
                    propertySignatures.push([
                        goMemo(ps.type, isDecoding),
                        ps
                    ]);
                    expectedKeysMap[ps.name] = null;
                    expectedKeys.push(ps.name);
                }
                const indexSignatures = ast.indexSignatures.map((is)=>[
                        goMemo(is.parameter, isDecoding),
                        goMemo(is.type, isDecoding),
                        is.parameter
                    ]);
                const expectedAST = _schemaASTJs.Union.make(ast.indexSignatures.map((is)=>is.parameter).concat(expectedKeys.map((key)=>_predicateJs.isSymbol(key) ? new _schemaASTJs.UniqueSymbol(key) : new _schemaASTJs.Literal(key))));
                const expected = goMemo(expectedAST, isDecoding);
                const concurrency = getConcurrency(ast);
                const batching = getBatching(ast);
                return (input, options)=>{
                    if (!_predicateJs.isRecord(input)) return _eitherJs.left(new Type(ast, input));
                    const allErrors = options?.errors === "all";
                    const es = [];
                    let stepKey = 0;
                    // ---------------------------------------------
                    // handle excess properties
                    // ---------------------------------------------
                    const onExcessPropertyError = options?.onExcessProperty === "error";
                    const onExcessPropertyPreserve = options?.onExcessProperty === "preserve";
                    const output = {};
                    let inputKeys;
                    if (onExcessPropertyError || onExcessPropertyPreserve) {
                        inputKeys = _utilJs.ownKeys(input);
                        for (const key of inputKeys){
                            const te = expected(key, options);
                            if (isEither(te) && _eitherJs.isLeft(te)) {
                                // key is unexpected
                                if (onExcessPropertyError) {
                                    const e = new Pointer(key, input, new Unexpected(input[key], `is unexpected, expected: ${String(expectedAST)}`));
                                    if (allErrors) {
                                        es.push([
                                            stepKey++,
                                            e
                                        ]);
                                        continue;
                                    } else return _eitherJs.left(new Composite(ast, input, e, output));
                                } else // preserve key
                                output[key] = input[key];
                            }
                        }
                    }
                    let queue = undefined;
                    const isExact = options?.exact === true;
                    for(let i = 0; i < propertySignatures.length; i++){
                        const ps = propertySignatures[i][1];
                        const name = ps.name;
                        const hasKey = Object.prototype.hasOwnProperty.call(input, name);
                        if (!hasKey) {
                            if (ps.isOptional) continue;
                            else if (isExact) {
                                const e = new Pointer(name, input, new Missing(ps));
                                if (allErrors) {
                                    es.push([
                                        stepKey++,
                                        e
                                    ]);
                                    continue;
                                } else return _eitherJs.left(new Composite(ast, input, e, output));
                            }
                        }
                        const parser = propertySignatures[i][0];
                        const te = parser(input[name], options);
                        if (isEither(te)) {
                            if (_eitherJs.isLeft(te)) {
                                const e = new Pointer(name, input, hasKey ? te.left : new Missing(ps));
                                if (allErrors) {
                                    es.push([
                                        stepKey++,
                                        e
                                    ]);
                                    continue;
                                } else return _eitherJs.left(new Composite(ast, input, e, output));
                            }
                            output[name] = te.right;
                        } else {
                            const nk = stepKey++;
                            const index = name;
                            if (!queue) queue = [];
                            queue.push(({ es, output })=>_effectJs.flatMap(_effectJs.either(te), (t)=>{
                                    if (_eitherJs.isLeft(t)) {
                                        const e = new Pointer(index, input, hasKey ? t.left : new Missing(ps));
                                        if (allErrors) {
                                            es.push([
                                                nk,
                                                e
                                            ]);
                                            return _effectJs.void;
                                        } else return _eitherJs.left(new Composite(ast, input, e, output));
                                    }
                                    output[index] = t.right;
                                    return _effectJs.void;
                                }));
                        }
                    }
                    // ---------------------------------------------
                    // handle index signatures
                    // ---------------------------------------------
                    for(let i = 0; i < indexSignatures.length; i++){
                        const indexSignature = indexSignatures[i];
                        const parameter = indexSignature[0];
                        const type = indexSignature[1];
                        const keys = _utilJs.getKeysForIndexSignature(input, indexSignature[2]);
                        for (const key of keys){
                            // ---------------------------------------------
                            // handle keys
                            // ---------------------------------------------
                            const keu = parameter(key, options);
                            if (isEither(keu) && _eitherJs.isRight(keu)) {
                                // ---------------------------------------------
                                // handle values
                                // ---------------------------------------------
                                const vpr = type(input[key], options);
                                if (isEither(vpr)) {
                                    if (_eitherJs.isLeft(vpr)) {
                                        const e = new Pointer(key, input, vpr.left);
                                        if (allErrors) {
                                            es.push([
                                                stepKey++,
                                                e
                                            ]);
                                            continue;
                                        } else return _eitherJs.left(new Composite(ast, input, e, output));
                                    } else if (!Object.prototype.hasOwnProperty.call(expectedKeysMap, key)) output[key] = vpr.right;
                                } else {
                                    const nk = stepKey++;
                                    const index = key;
                                    if (!queue) queue = [];
                                    queue.push(({ es, output })=>_effectJs.flatMap(_effectJs.either(vpr), (tv)=>{
                                            if (_eitherJs.isLeft(tv)) {
                                                const e = new Pointer(index, input, tv.left);
                                                if (allErrors) {
                                                    es.push([
                                                        nk,
                                                        e
                                                    ]);
                                                    return _effectJs.void;
                                                } else return _eitherJs.left(new Composite(ast, input, e, output));
                                            } else {
                                                if (!Object.prototype.hasOwnProperty.call(expectedKeysMap, key)) output[key] = tv.right;
                                                return _effectJs.void;
                                            }
                                        }));
                                }
                            }
                        }
                    }
                    // ---------------------------------------------
                    // compute result
                    // ---------------------------------------------
                    const computeResult = ({ es, output })=>{
                        if (_arrayJs.isNonEmptyArray(es)) return _eitherJs.left(new Composite(ast, input, sortByIndex(es), output));
                        if (options?.propertyOrder === "original") {
                            // preserve input keys order
                            const keys = inputKeys || _utilJs.ownKeys(input);
                            for (const name of expectedKeys)if (keys.indexOf(name) === -1) keys.push(name);
                            const out = {};
                            for (const key of keys)if (Object.prototype.hasOwnProperty.call(output, key)) out[key] = output[key];
                            return _eitherJs.right(out);
                        }
                        return _eitherJs.right(output);
                    };
                    if (queue && queue.length > 0) {
                        const cqueue = queue;
                        return _effectJs.suspend(()=>{
                            const state = {
                                es: _arrayJs.copy(es),
                                output: Object.assign({}, output)
                            };
                            return _effectJs.flatMap(_effectJs.forEach(cqueue, (f)=>f(state), {
                                concurrency,
                                batching,
                                discard: true
                            }), ()=>computeResult(state));
                        });
                    }
                    return computeResult({
                        es,
                        output
                    });
                };
            }
        case "Union":
            {
                const searchTree = getSearchTree(ast.types, isDecoding);
                const ownKeys = _utilJs.ownKeys(searchTree.keys);
                const ownKeysLen = ownKeys.length;
                const astTypesLen = ast.types.length;
                const map = new Map();
                for(let i = 0; i < astTypesLen; i++)map.set(ast.types[i], goMemo(ast.types[i], isDecoding));
                const concurrency = getConcurrency(ast) ?? 1;
                const batching = getBatching(ast);
                return (input, options)=>{
                    const es = [];
                    let stepKey = 0;
                    let candidates = [];
                    if (ownKeysLen > 0) {
                        if (_predicateJs.isRecordOrArray(input)) for(let i = 0; i < ownKeysLen; i++){
                            const name = ownKeys[i];
                            const buckets = searchTree.keys[name].buckets;
                            // for each property that should contain a literal, check if the input contains that property
                            if (Object.prototype.hasOwnProperty.call(input, name)) {
                                const literal = String(input[name]);
                                // check that the value obtained from the input for the property corresponds to an existing bucket
                                if (Object.prototype.hasOwnProperty.call(buckets, literal)) // retrive the minimal set of candidates for decoding
                                candidates = candidates.concat(buckets[literal]);
                                else {
                                    const { candidates, literals } = searchTree.keys[name];
                                    const literalsUnion = _schemaASTJs.Union.make(literals);
                                    const errorAst = candidates.length === astTypesLen ? new _schemaASTJs.TypeLiteral([
                                        new _schemaASTJs.PropertySignature(name, literalsUnion, false, true)
                                    ], []) : _schemaASTJs.Union.make(candidates);
                                    es.push([
                                        stepKey++,
                                        new Composite(errorAst, input, new Pointer(name, input, new Type(literalsUnion, input[name])))
                                    ]);
                                }
                            } else {
                                const { candidates, literals } = searchTree.keys[name];
                                const fakePropertySignature = new _schemaASTJs.PropertySignature(name, _schemaASTJs.Union.make(literals), false, true);
                                const errorAst = candidates.length === astTypesLen ? new _schemaASTJs.TypeLiteral([
                                    fakePropertySignature
                                ], []) : _schemaASTJs.Union.make(candidates);
                                es.push([
                                    stepKey++,
                                    new Composite(errorAst, input, new Pointer(name, input, new Missing(fakePropertySignature)))
                                ]);
                            }
                        }
                        else {
                            const errorAst = searchTree.candidates.length === astTypesLen ? ast : _schemaASTJs.Union.make(searchTree.candidates);
                            es.push([
                                stepKey++,
                                new Type(errorAst, input)
                            ]);
                        }
                    }
                    if (searchTree.otherwise.length > 0) candidates = candidates.concat(searchTree.otherwise);
                    let queue = undefined;
                    for(let i = 0; i < candidates.length; i++){
                        const candidate = candidates[i];
                        const pr = map.get(candidate)(input, options);
                        // the members of a union are ordered based on which one should be decoded first,
                        // therefore if one member has added a task, all subsequent members must
                        // also add a task to the queue even if they are synchronous
                        if (isEither(pr) && (!queue || queue.length === 0)) {
                            if (_eitherJs.isRight(pr)) return pr;
                            else es.push([
                                stepKey++,
                                pr.left
                            ]);
                        } else {
                            const nk = stepKey++;
                            if (!queue) queue = [];
                            queue.push((state)=>_effectJs.suspend(()=>{
                                    if ("finalResult" in state) return _effectJs.void;
                                    else return _effectJs.flatMap(_effectJs.either(pr), (t)=>{
                                        if (_eitherJs.isRight(t)) state.finalResult = t;
                                        else state.es.push([
                                            nk,
                                            t.left
                                        ]);
                                        return _effectJs.void;
                                    });
                                }));
                        }
                    }
                    // ---------------------------------------------
                    // compute result
                    // ---------------------------------------------
                    const computeResult = (es)=>_arrayJs.isNonEmptyArray(es) ? es.length === 1 && es[0][1]._tag === "Type" ? _eitherJs.left(es[0][1]) : _eitherJs.left(new Composite(ast, input, sortByIndex(es))) : // this should never happen
                        _eitherJs.left(new Type(ast, input));
                    if (queue && queue.length > 0) {
                        const cqueue = queue;
                        return _effectJs.suspend(()=>{
                            const state = {
                                es: _arrayJs.copy(es)
                            };
                            return _effectJs.flatMap(_effectJs.forEach(cqueue, (f)=>f(state), {
                                concurrency,
                                batching,
                                discard: true
                            }), ()=>{
                                if ("finalResult" in state) return state.finalResult;
                                return computeResult(state.es);
                            });
                        });
                    }
                    return computeResult(es);
                };
            }
        case "Suspend":
            {
                const get = _utilJs.memoizeThunk(()=>goMemo(_schemaASTJs.annotations(ast.f(), ast.annotations), isDecoding));
                return (a, options)=>get()(a, options);
            }
    }
};
const fromRefinement = (ast, refinement)=>(u)=>refinement(u) ? _eitherJs.right(u) : _eitherJs.left(new Type(ast, u));
const getLiterals = (ast, isDecoding)=>{
    switch(ast._tag){
        case "Declaration":
            {
                const annotation = _schemaASTJs.getSurrogateAnnotation(ast);
                if (_optionJs.isSome(annotation)) return getLiterals(annotation.value, isDecoding);
                break;
            }
        case "TypeLiteral":
            {
                const out = [];
                for(let i = 0; i < ast.propertySignatures.length; i++){
                    const propertySignature = ast.propertySignatures[i];
                    const type = isDecoding ? _schemaASTJs.encodedAST(propertySignature.type) : _schemaASTJs.typeAST(propertySignature.type);
                    if (_schemaASTJs.isLiteral(type) && !propertySignature.isOptional) out.push([
                        propertySignature.name,
                        type
                    ]);
                }
                return out;
            }
        case "TupleType":
            {
                const out = [];
                for(let i = 0; i < ast.elements.length; i++){
                    const element = ast.elements[i];
                    const type = isDecoding ? _schemaASTJs.encodedAST(element.type) : _schemaASTJs.typeAST(element.type);
                    if (_schemaASTJs.isLiteral(type) && !element.isOptional) out.push([
                        i,
                        type
                    ]);
                }
                return out;
            }
        case "Refinement":
            return getLiterals(ast.from, isDecoding);
        case "Suspend":
            return getLiterals(ast.f(), isDecoding);
        case "Transformation":
            return getLiterals(isDecoding ? ast.from : ast.to, isDecoding);
    }
    return [];
};
const getSearchTree = (members, isDecoding)=>{
    const keys = {};
    const otherwise = [];
    const candidates = [];
    for(let i = 0; i < members.length; i++){
        const member = members[i];
        const tags = getLiterals(member, isDecoding);
        if (tags.length > 0) {
            candidates.push(member);
            for(let j = 0; j < tags.length; j++){
                const [key, literal] = tags[j];
                const hash = String(literal.literal);
                keys[key] = keys[key] || {
                    buckets: {},
                    literals: [],
                    candidates: []
                };
                const buckets = keys[key].buckets;
                if (Object.prototype.hasOwnProperty.call(buckets, hash)) {
                    if (j < tags.length - 1) continue;
                    buckets[hash].push(member);
                    keys[key].literals.push(literal);
                    keys[key].candidates.push(member);
                } else {
                    buckets[hash] = [
                        member
                    ];
                    keys[key].literals.push(literal);
                    keys[key].candidates.push(member);
                    break;
                }
            }
        } else otherwise.push(member);
    }
    return {
        keys,
        otherwise,
        candidates
    };
};
const dropRightRefinement = (ast)=>_schemaASTJs.isRefinement(ast) ? dropRightRefinement(ast.from) : ast;
const handleForbidden = (effect, ast, actual, options)=>{
    // If effects are allowed, return the original effect
    if (options?.isEffectAllowed === true) return effect;
    // If the effect is already an Either, return it directly
    if (isEither(effect)) return effect;
    // Otherwise, attempt to execute the effect synchronously
    const scheduler = new _schedulerJs.SyncScheduler();
    const fiber = _effectJs.runFork(effect, {
        scheduler
    });
    scheduler.flush();
    const exit = fiber.unsafePoll();
    if (exit) {
        if (_exitJs.isSuccess(exit)) // If the effect successfully resolves, wrap the value in a Right
        return _eitherJs.right(exit.value);
        const cause = exit.cause;
        if (_causeJs.isFailType(cause)) // The effect executed synchronously but failed due to a ParseIssue
        return _eitherJs.left(cause.error);
        // The effect executed synchronously but failed due to a defect (e.g., a missing dependency)
        return _eitherJs.left(new Forbidden(ast, actual, _causeJs.pretty(cause)));
    }
    // The effect could not be resolved synchronously, meaning it performs async work
    return _eitherJs.left(new Forbidden(ast, actual, "cannot be be resolved synchronously, this is caused by using runSync on an effect that performs async work"));
};
const compare = ([a], [b])=>a > b ? 1 : a < b ? -1 : 0;
function sortByIndex(es) {
    return es.sort(compare).map((t)=>t[1]);
}
const getFinalTransformation = (transformation, isDecoding)=>{
    switch(transformation._tag){
        case "FinalTransformation":
            return isDecoding ? transformation.decode : transformation.encode;
        case "ComposeTransformation":
            return _eitherJs.right;
        case "TypeLiteralTransformation":
            return (input)=>{
                let out = _eitherJs.right(input);
                // ---------------------------------------------
                // handle property signature transformations
                // ---------------------------------------------
                for (const pst of transformation.propertySignatureTransformations){
                    const [from, to] = isDecoding ? [
                        pst.from,
                        pst.to
                    ] : [
                        pst.to,
                        pst.from
                    ];
                    const transformation = isDecoding ? pst.decode : pst.encode;
                    const f = (input)=>{
                        const o = transformation(Object.prototype.hasOwnProperty.call(input, from) ? _optionJs.some(input[from]) : _optionJs.none());
                        delete input[from];
                        if (_optionJs.isSome(o)) input[to] = o.value;
                        return input;
                    };
                    out = map(out, f);
                }
                return out;
            };
    }
};
const makeTree = (value, forest = [])=>({
        value,
        forest
    });
const TreeFormatter = {
    formatIssue: (issue)=>map(formatTree(issue), drawTree),
    formatIssueSync: (issue)=>{
        const e = TreeFormatter.formatIssue(issue);
        return isEither(e) ? _eitherJs.getOrThrow(e) : _effectJs.runSync(e);
    },
    formatError: (error)=>TreeFormatter.formatIssue(error.issue),
    formatErrorSync: (error)=>TreeFormatter.formatIssueSync(error.issue)
};
const drawTree = (tree)=>tree.value + draw("\n", tree.forest);
const draw = (indentation, forest)=>{
    let r = "";
    const len = forest.length;
    let tree;
    for(let i = 0; i < len; i++){
        tree = forest[i];
        const isLast = i === len - 1;
        r += indentation + (isLast ? "\u2514" : "\u251C") + "\u2500 " + tree.value;
        r += draw(indentation + (len > 1 && !isLast ? "\u2502  " : "   "), tree.forest);
    }
    return r;
};
const formatTransformationKind = (kind)=>{
    switch(kind){
        case "Encoded":
            return "Encoded side transformation failure";
        case "Transformation":
            return "Transformation process failure";
        case "Type":
            return "Type side transformation failure";
    }
};
const formatRefinementKind = (kind)=>{
    switch(kind){
        case "From":
            return "From side refinement failure";
        case "Predicate":
            return "Predicate refinement failure";
    }
};
const getAnnotated = (issue)=>"ast" in issue ? _optionJs.some(issue.ast) : _optionJs.none();
// TODO: replace with Either.void when 3.13 lands
const Either_void = /*#__PURE__*/ _eitherJs.right(undefined);
const getCurrentMessage = (issue)=>getAnnotated(issue).pipe(_optionJs.flatMap(_schemaASTJs.getMessageAnnotation), _optionJs.match({
        onNone: ()=>Either_void,
        onSome: (messageAnnotation)=>{
            const union = messageAnnotation(issue);
            if (_predicateJs.isString(union)) return _eitherJs.right({
                message: union,
                override: false
            });
            if (_effectJs.isEffect(union)) return _effectJs.map(union, (message)=>({
                    message,
                    override: false
                }));
            if (_predicateJs.isString(union.message)) return _eitherJs.right({
                message: union.message,
                override: union.override
            });
            return _effectJs.map(union.message, (message)=>({
                    message,
                    override: union.override
                }));
        }
    }));
const createParseIssueGuard = (tag)=>(issue)=>issue._tag === tag;
const isComposite = /*#__PURE__*/ createParseIssueGuard("Composite");
const isRefinement = /*#__PURE__*/ createParseIssueGuard("Refinement");
const isTransformation = /*#__PURE__*/ createParseIssueGuard("Transformation");
const getMessage = (issue)=>flatMap(getCurrentMessage(issue), (currentMessage)=>{
        if (currentMessage !== undefined) {
            const useInnerMessage = !currentMessage.override && (isComposite(issue) || isRefinement(issue) && issue.kind === "From" || isTransformation(issue) && issue.kind !== "Transformation");
            return useInnerMessage ? isTransformation(issue) || isRefinement(issue) ? getMessage(issue.issue) : Either_void : _eitherJs.right(currentMessage.message);
        }
        return Either_void;
    });
const getParseIssueTitleAnnotation = (issue)=>getAnnotated(issue).pipe(_optionJs.flatMap(_schemaASTJs.getParseIssueTitleAnnotation), _optionJs.flatMapNullable((annotation)=>annotation(issue)), _optionJs.getOrUndefined);
function getRefinementExpected(ast) {
    return _schemaASTJs.getDescriptionAnnotation(ast).pipe(_optionJs.orElse(()=>_schemaASTJs.getTitleAnnotation(ast)), _optionJs.orElse(()=>_schemaASTJs.getAutoTitleAnnotation(ast)), _optionJs.orElse(()=>_schemaASTJs.getIdentifierAnnotation(ast)), _optionJs.getOrElse(()=>`{ ${ast.from} | filter }`));
}
function getDefaultTypeMessage(issue) {
    if (issue.message !== undefined) return issue.message;
    const expected = _schemaASTJs.isRefinement(issue.ast) ? getRefinementExpected(issue.ast) : String(issue.ast);
    return `Expected ${expected}, actual ${_utilJs.formatUnknown(issue.actual)}`;
}
const formatTypeMessage = (issue)=>map(getMessage(issue), (message)=>message ?? getParseIssueTitleAnnotation(issue) ?? getDefaultTypeMessage(issue));
const getParseIssueTitle = (issue)=>getParseIssueTitleAnnotation(issue) ?? String(issue.ast);
const formatForbiddenMessage = (issue)=>issue.message ?? "is forbidden";
const formatUnexpectedMessage = (issue)=>issue.message ?? "is unexpected";
const formatMissingMessage = (issue)=>{
    const missingMessageAnnotation = _schemaASTJs.getMissingMessageAnnotation(issue.ast);
    if (_optionJs.isSome(missingMessageAnnotation)) {
        const annotation = missingMessageAnnotation.value();
        return _predicateJs.isString(annotation) ? _eitherJs.right(annotation) : annotation;
    }
    return _eitherJs.right(issue.message ?? "is missing");
};
const formatTree = (issue)=>{
    switch(issue._tag){
        case "Type":
            return map(formatTypeMessage(issue), makeTree);
        case "Forbidden":
            return _eitherJs.right(makeTree(getParseIssueTitle(issue), [
                makeTree(formatForbiddenMessage(issue))
            ]));
        case "Unexpected":
            return _eitherJs.right(makeTree(formatUnexpectedMessage(issue)));
        case "Missing":
            return map(formatMissingMessage(issue), makeTree);
        case "Transformation":
            return flatMap(getMessage(issue), (message)=>{
                if (message !== undefined) return _eitherJs.right(makeTree(message));
                return map(formatTree(issue.issue), (tree)=>makeTree(getParseIssueTitle(issue), [
                        makeTree(formatTransformationKind(issue.kind), [
                            tree
                        ])
                    ]));
            });
        case "Refinement":
            return flatMap(getMessage(issue), (message)=>{
                if (message !== undefined) return _eitherJs.right(makeTree(message));
                return map(formatTree(issue.issue), (tree)=>makeTree(getParseIssueTitle(issue), [
                        makeTree(formatRefinementKind(issue.kind), [
                            tree
                        ])
                    ]));
            });
        case "Pointer":
            return map(formatTree(issue.issue), (tree)=>makeTree(_utilJs.formatPath(issue.path), [
                    tree
                ]));
        case "Composite":
            return flatMap(getMessage(issue), (message)=>{
                if (message !== undefined) return _eitherJs.right(makeTree(message));
                const parseIssueTitle = getParseIssueTitle(issue);
                return _utilJs.isNonEmpty(issue.issues) ? map(_effectJs.forEach(issue.issues, formatTree), (forest)=>makeTree(parseIssueTitle, forest)) : map(formatTree(issue.issues), (tree)=>makeTree(parseIssueTitle, [
                        tree
                    ]));
            });
    }
};
const makeArrayFormatterIssue = (_tag, path, message)=>({
        _tag,
        path,
        message
    });
const ArrayFormatter = {
    formatIssue: (issue)=>getArrayFormatterIssues(issue, undefined, []),
    formatIssueSync: (issue)=>{
        const e = ArrayFormatter.formatIssue(issue);
        return isEither(e) ? _eitherJs.getOrThrow(e) : _effectJs.runSync(e);
    },
    formatError: (error)=>ArrayFormatter.formatIssue(error.issue),
    formatErrorSync: (error)=>ArrayFormatter.formatIssueSync(error.issue)
};
const getArrayFormatterIssues = (issue, parentTag, path)=>{
    const _tag = issue._tag;
    switch(_tag){
        case "Type":
            return map(formatTypeMessage(issue), (message)=>[
                    makeArrayFormatterIssue(parentTag ?? _tag, path, message)
                ]);
        case "Forbidden":
            return _eitherJs.right([
                makeArrayFormatterIssue(_tag, path, formatForbiddenMessage(issue))
            ]);
        case "Unexpected":
            return _eitherJs.right([
                makeArrayFormatterIssue(_tag, path, formatUnexpectedMessage(issue))
            ]);
        case "Missing":
            return map(formatMissingMessage(issue), (message)=>[
                    makeArrayFormatterIssue(_tag, path, message)
                ]);
        case "Pointer":
            return getArrayFormatterIssues(issue.issue, undefined, path.concat(issue.path));
        case "Composite":
            return flatMap(getMessage(issue), (message)=>{
                if (message !== undefined) return _eitherJs.right([
                    makeArrayFormatterIssue(_tag, path, message)
                ]);
                return _utilJs.isNonEmpty(issue.issues) ? map(_effectJs.forEach(issue.issues, (issue)=>getArrayFormatterIssues(issue, undefined, path)), _arrayJs.flatten) : getArrayFormatterIssues(issue.issues, undefined, path);
            });
        case "Refinement":
            return flatMap(getMessage(issue), (message)=>{
                if (message !== undefined) return _eitherJs.right([
                    makeArrayFormatterIssue(_tag, path, message)
                ]);
                return getArrayFormatterIssues(issue.issue, issue.kind === "Predicate" ? _tag : undefined, path);
            });
        case "Transformation":
            return flatMap(getMessage(issue), (message)=>{
                if (message !== undefined) return _eitherJs.right([
                    makeArrayFormatterIssue(_tag, path, message)
                ]);
                return getArrayFormatterIssues(issue.issue, issue.kind === "Transformation" ? _tag : undefined, path);
            });
    }
};

},{"./Array.js":"8L2Gk","./Cause.js":"gQcQI","./Data.js":"4e85E","./Effect.js":"j5L8O","./Either.js":"4amnT","./Exit.js":"eUJDu","./Function.js":"21gOL","./GlobalValue.js":"5w3Hn","./Inspectable.js":"1Ur70","./internal/schema/util.js":"d71wj","./Option.js":"6sHA7","./Predicate.js":"gW5pd","./Scheduler.js":"hR5Dj","./SchemaAST.js":"7CDm2","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"d71wj":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getKeysForIndexSignature", ()=>getKeysForIndexSignature);
parcelHelpers.export(exports, "ownKeys", ()=>ownKeys);
parcelHelpers.export(exports, "memoizeThunk", ()=>memoizeThunk);
parcelHelpers.export(exports, "formatDate", ()=>formatDate);
parcelHelpers.export(exports, "formatUnknown", ()=>formatUnknown);
parcelHelpers.export(exports, "formatPropertyKey", ()=>formatPropertyKey);
parcelHelpers.export(exports, "isNonEmpty", ()=>isNonEmpty);
parcelHelpers.export(exports, "isSingle", ()=>isSingle);
parcelHelpers.export(exports, "formatPathKey", ()=>formatPathKey);
parcelHelpers.export(exports, "formatPath", ()=>formatPath);
var _predicateJs = require("../../Predicate.js");
const getKeysForIndexSignature = (input, parameter)=>{
    switch(parameter._tag){
        case "StringKeyword":
        case "TemplateLiteral":
            return Object.keys(input);
        case "SymbolKeyword":
            return Object.getOwnPropertySymbols(input);
        case "Refinement":
            return getKeysForIndexSignature(input, parameter.from);
    }
};
const ownKeys = (o)=>Object.keys(o).concat(Object.getOwnPropertySymbols(o));
const memoizeThunk = (f)=>{
    let done = false;
    let a;
    return ()=>{
        if (done) return a;
        a = f();
        done = true;
        return a;
    };
};
const formatDate = (date)=>{
    try {
        return date.toISOString();
    } catch (e) {
        return String(date);
    }
};
const formatUnknown = (u, checkCircular = true)=>{
    if (Array.isArray(u)) return `[${u.map((i)=>formatUnknown(i, checkCircular)).join(",")}]`;
    if (_predicateJs.isDate(u)) return formatDate(u);
    if (_predicateJs.hasProperty(u, "toString") && _predicateJs.isFunction(u["toString"]) && u["toString"] !== Object.prototype.toString) return u["toString"]();
    if (_predicateJs.isString(u)) return JSON.stringify(u);
    if (_predicateJs.isNumber(u) || u == null || _predicateJs.isBoolean(u) || _predicateJs.isSymbol(u)) return String(u);
    if (_predicateJs.isBigInt(u)) return String(u) + "n";
    if (_predicateJs.isIterable(u)) return `${u.constructor.name}(${formatUnknown(Array.from(u), checkCircular)})`;
    try {
        if (checkCircular) JSON.stringify(u); // check for circular references
        const pojo = `{${ownKeys(u).map((k)=>`${_predicateJs.isString(k) ? JSON.stringify(k) : String(k)}:${formatUnknown(u[k], false)}`).join(",")}}`;
        const name = u.constructor.name;
        return u.constructor !== Object.prototype.constructor ? `${name}(${pojo})` : pojo;
    } catch (e) {
        return "<circular structure>";
    }
};
const formatPropertyKey = (name)=>typeof name === "string" ? JSON.stringify(name) : String(name);
const isNonEmpty = (x)=>Array.isArray(x);
const isSingle = (x)=>!Array.isArray(x);
const formatPathKey = (key)=>`[${formatPropertyKey(key)}]`;
const formatPath = (path)=>isNonEmpty(path) ? path.map(formatPathKey).join("") : formatPathKey(path);

},{"../../Predicate.js":"gW5pd","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"7CDm2":[function(require,module,exports,__globalThis) {
/**
 * @since 3.10.0
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BrandAnnotationId", ()=>BrandAnnotationId);
parcelHelpers.export(exports, "SchemaIdAnnotationId", ()=>SchemaIdAnnotationId);
parcelHelpers.export(exports, "MessageAnnotationId", ()=>MessageAnnotationId);
parcelHelpers.export(exports, "MissingMessageAnnotationId", ()=>MissingMessageAnnotationId);
parcelHelpers.export(exports, "IdentifierAnnotationId", ()=>IdentifierAnnotationId);
parcelHelpers.export(exports, "TitleAnnotationId", ()=>TitleAnnotationId);
parcelHelpers.export(exports, "AutoTitleAnnotationId", ()=>AutoTitleAnnotationId);
parcelHelpers.export(exports, "DescriptionAnnotationId", ()=>DescriptionAnnotationId);
parcelHelpers.export(exports, "ExamplesAnnotationId", ()=>ExamplesAnnotationId);
parcelHelpers.export(exports, "DefaultAnnotationId", ()=>DefaultAnnotationId);
parcelHelpers.export(exports, "JSONSchemaAnnotationId", ()=>JSONSchemaAnnotationId);
parcelHelpers.export(exports, "ArbitraryAnnotationId", ()=>ArbitraryAnnotationId);
parcelHelpers.export(exports, "PrettyAnnotationId", ()=>PrettyAnnotationId);
parcelHelpers.export(exports, "EquivalenceAnnotationId", ()=>EquivalenceAnnotationId);
parcelHelpers.export(exports, "DocumentationAnnotationId", ()=>DocumentationAnnotationId);
parcelHelpers.export(exports, "ConcurrencyAnnotationId", ()=>ConcurrencyAnnotationId);
parcelHelpers.export(exports, "BatchingAnnotationId", ()=>BatchingAnnotationId);
parcelHelpers.export(exports, "ParseIssueTitleAnnotationId", ()=>ParseIssueTitleAnnotationId);
parcelHelpers.export(exports, "ParseOptionsAnnotationId", ()=>ParseOptionsAnnotationId);
parcelHelpers.export(exports, "DecodingFallbackAnnotationId", ()=>DecodingFallbackAnnotationId);
parcelHelpers.export(exports, "SurrogateAnnotationId", ()=>SurrogateAnnotationId);
parcelHelpers.export(exports, "StableFilterAnnotationId", ()=>StableFilterAnnotationId);
parcelHelpers.export(exports, "getAnnotation", ()=>getAnnotation);
parcelHelpers.export(exports, "getBrandAnnotation", ()=>getBrandAnnotation);
parcelHelpers.export(exports, "getSchemaIdAnnotation", ()=>getSchemaIdAnnotation);
parcelHelpers.export(exports, "getMessageAnnotation", ()=>getMessageAnnotation);
parcelHelpers.export(exports, "getMissingMessageAnnotation", ()=>getMissingMessageAnnotation);
parcelHelpers.export(exports, "getTitleAnnotation", ()=>getTitleAnnotation);
parcelHelpers.export(exports, "getAutoTitleAnnotation", ()=>getAutoTitleAnnotation);
parcelHelpers.export(exports, "getIdentifierAnnotation", ()=>getIdentifierAnnotation);
parcelHelpers.export(exports, "getDescriptionAnnotation", ()=>getDescriptionAnnotation);
parcelHelpers.export(exports, "getExamplesAnnotation", ()=>getExamplesAnnotation);
parcelHelpers.export(exports, "getDefaultAnnotation", ()=>getDefaultAnnotation);
parcelHelpers.export(exports, "getJSONSchemaAnnotation", ()=>getJSONSchemaAnnotation);
parcelHelpers.export(exports, "getDocumentationAnnotation", ()=>getDocumentationAnnotation);
parcelHelpers.export(exports, "getConcurrencyAnnotation", ()=>getConcurrencyAnnotation);
parcelHelpers.export(exports, "getBatchingAnnotation", ()=>getBatchingAnnotation);
parcelHelpers.export(exports, "getParseIssueTitleAnnotation", ()=>getParseIssueTitleAnnotation);
parcelHelpers.export(exports, "getParseOptionsAnnotation", ()=>getParseOptionsAnnotation);
parcelHelpers.export(exports, "getDecodingFallbackAnnotation", ()=>getDecodingFallbackAnnotation);
parcelHelpers.export(exports, "getSurrogateAnnotation", ()=>getSurrogateAnnotation);
parcelHelpers.export(exports, "hasStableFilter", ()=>hasStableFilter);
parcelHelpers.export(exports, "JSONIdentifierAnnotationId", ()=>JSONIdentifierAnnotationId);
parcelHelpers.export(exports, "getJSONIdentifierAnnotation", ()=>getJSONIdentifierAnnotation);
parcelHelpers.export(exports, "getJSONIdentifier", ()=>getJSONIdentifier);
parcelHelpers.export(exports, "ParseJsonSchemaId", ()=>ParseJsonSchemaId);
/**
 * @category model
 * @since 3.10.0
 */ parcelHelpers.export(exports, "Declaration", ()=>Declaration);
parcelHelpers.export(exports, "isDeclaration", ()=>isDeclaration);
/**
 * @category model
 * @since 3.10.0
 */ parcelHelpers.export(exports, "Literal", ()=>Literal);
parcelHelpers.export(exports, "isLiteral", ()=>isLiteral);
parcelHelpers.export(exports, "null", ()=>/**
 * @category constructors
 * @since 3.10.0
 */ $null);
/**
 * @category model
 * @since 3.10.0
 */ parcelHelpers.export(exports, "UniqueSymbol", ()=>UniqueSymbol);
parcelHelpers.export(exports, "isUniqueSymbol", ()=>isUniqueSymbol);
/**
 * @category model
 * @since 3.10.0
 */ parcelHelpers.export(exports, "UndefinedKeyword", ()=>UndefinedKeyword);
parcelHelpers.export(exports, "undefinedKeyword", ()=>undefinedKeyword);
parcelHelpers.export(exports, "isUndefinedKeyword", ()=>isUndefinedKeyword);
/**
 * @category model
 * @since 3.10.0
 */ parcelHelpers.export(exports, "VoidKeyword", ()=>VoidKeyword);
parcelHelpers.export(exports, "voidKeyword", ()=>voidKeyword);
parcelHelpers.export(exports, "isVoidKeyword", ()=>isVoidKeyword);
/**
 * @category model
 * @since 3.10.0
 */ parcelHelpers.export(exports, "NeverKeyword", ()=>NeverKeyword);
parcelHelpers.export(exports, "neverKeyword", ()=>neverKeyword);
parcelHelpers.export(exports, "isNeverKeyword", ()=>isNeverKeyword);
/**
 * @category model
 * @since 3.10.0
 */ parcelHelpers.export(exports, "UnknownKeyword", ()=>UnknownKeyword);
parcelHelpers.export(exports, "unknownKeyword", ()=>unknownKeyword);
parcelHelpers.export(exports, "isUnknownKeyword", ()=>isUnknownKeyword);
/**
 * @category model
 * @since 3.10.0
 */ parcelHelpers.export(exports, "AnyKeyword", ()=>AnyKeyword);
parcelHelpers.export(exports, "anyKeyword", ()=>anyKeyword);
parcelHelpers.export(exports, "isAnyKeyword", ()=>isAnyKeyword);
/**
 * @category model
 * @since 3.10.0
 */ parcelHelpers.export(exports, "StringKeyword", ()=>StringKeyword);
parcelHelpers.export(exports, "stringKeyword", ()=>stringKeyword);
parcelHelpers.export(exports, "isStringKeyword", ()=>isStringKeyword);
/**
 * @category model
 * @since 3.10.0
 */ parcelHelpers.export(exports, "NumberKeyword", ()=>NumberKeyword);
parcelHelpers.export(exports, "numberKeyword", ()=>numberKeyword);
parcelHelpers.export(exports, "isNumberKeyword", ()=>isNumberKeyword);
/**
 * @category model
 * @since 3.10.0
 */ parcelHelpers.export(exports, "BooleanKeyword", ()=>BooleanKeyword);
parcelHelpers.export(exports, "booleanKeyword", ()=>booleanKeyword);
parcelHelpers.export(exports, "isBooleanKeyword", ()=>isBooleanKeyword);
/**
 * @category model
 * @since 3.10.0
 */ parcelHelpers.export(exports, "BigIntKeyword", ()=>BigIntKeyword);
parcelHelpers.export(exports, "bigIntKeyword", ()=>bigIntKeyword);
parcelHelpers.export(exports, "isBigIntKeyword", ()=>isBigIntKeyword);
/**
 * @category model
 * @since 3.10.0
 */ parcelHelpers.export(exports, "SymbolKeyword", ()=>SymbolKeyword);
parcelHelpers.export(exports, "symbolKeyword", ()=>symbolKeyword);
parcelHelpers.export(exports, "isSymbolKeyword", ()=>isSymbolKeyword);
/**
 * @category model
 * @since 3.10.0
 */ parcelHelpers.export(exports, "ObjectKeyword", ()=>ObjectKeyword);
parcelHelpers.export(exports, "objectKeyword", ()=>objectKeyword);
parcelHelpers.export(exports, "isObjectKeyword", ()=>isObjectKeyword);
/**
 * @category model
 * @since 3.10.0
 */ parcelHelpers.export(exports, "Enums", ()=>Enums);
parcelHelpers.export(exports, "isEnums", ()=>isEnums);
/**
 * @category model
 * @since 3.10.0
 */ parcelHelpers.export(exports, "TemplateLiteralSpan", ()=>TemplateLiteralSpan);
/**
 * @category model
 * @since 3.10.0
 */ parcelHelpers.export(exports, "TemplateLiteral", ()=>TemplateLiteral);
parcelHelpers.export(exports, "isTemplateLiteral", ()=>isTemplateLiteral);
/**
 * @category model
 * @since 3.10.0
 */ parcelHelpers.export(exports, "Type", ()=>Type);
/**
 * @category model
 * @since 3.10.0
 */ parcelHelpers.export(exports, "OptionalType", ()=>OptionalType);
/**
 * @category model
 * @since 3.10.0
 */ parcelHelpers.export(exports, "TupleType", ()=>TupleType);
parcelHelpers.export(exports, "isTupleType", ()=>isTupleType);
/**
 * @category model
 * @since 3.10.0
 */ parcelHelpers.export(exports, "PropertySignature", ()=>PropertySignature);
parcelHelpers.export(exports, "isParameter", ()=>isParameter);
/**
 * @category model
 * @since 3.10.0
 */ parcelHelpers.export(exports, "IndexSignature", ()=>IndexSignature);
/**
 * @category model
 * @since 3.10.0
 */ parcelHelpers.export(exports, "TypeLiteral", ()=>TypeLiteral);
parcelHelpers.export(exports, "isTypeLiteral", ()=>isTypeLiteral);
parcelHelpers.export(exports, "flatten", ()=>flatten);
parcelHelpers.export(exports, "unify", ()=>unify);
/**
 * @category model
 * @since 3.10.0
 */ parcelHelpers.export(exports, "Union", ()=>Union);
parcelHelpers.export(exports, "mapMembers", ()=>mapMembers);
parcelHelpers.export(exports, "isMembers", ()=>isMembers);
parcelHelpers.export(exports, "isUnion", ()=>isUnion);
/**
 * @category model
 * @since 3.10.0
 */ parcelHelpers.export(exports, "Suspend", ()=>Suspend);
parcelHelpers.export(exports, "isSuspend", ()=>isSuspend);
/**
 * @category model
 * @since 3.10.0
 */ parcelHelpers.export(exports, "Refinement", ()=>Refinement);
parcelHelpers.export(exports, "isRefinement", ()=>isRefinement);
parcelHelpers.export(exports, "defaultParseOption", ()=>defaultParseOption);
/**
 * @category model
 * @since 3.10.0
 */ parcelHelpers.export(exports, "Transformation", ()=>Transformation);
parcelHelpers.export(exports, "isTransformation", ()=>isTransformation);
/**
 * @category model
 * @since 3.10.0
 */ parcelHelpers.export(exports, "FinalTransformation", ()=>FinalTransformation);
parcelHelpers.export(exports, "isFinalTransformation", ()=>isFinalTransformation);
/**
 * @category model
 * @since 3.10.0
 */ parcelHelpers.export(exports, "ComposeTransformation", ()=>ComposeTransformation);
parcelHelpers.export(exports, "composeTransformation", ()=>composeTransformation);
parcelHelpers.export(exports, "isComposeTransformation", ()=>isComposeTransformation);
/**
 * Represents a `PropertySignature -> PropertySignature` transformation
 *
 * The semantic of `decode` is:
 * - `none()` represents the absence of the key/value pair
 * - `some(value)` represents the presence of the key/value pair
 *
 * The semantic of `encode` is:
 * - `none()` you don't want to output the key/value pair
 * - `some(value)` you want to output the key/value pair
 *
 * @category model
 * @since 3.10.0
 */ parcelHelpers.export(exports, "PropertySignatureTransformation", ()=>PropertySignatureTransformation);
/**
 * @category model
 * @since 3.10.0
 */ parcelHelpers.export(exports, "TypeLiteralTransformation", ()=>TypeLiteralTransformation);
parcelHelpers.export(exports, "isTypeLiteralTransformation", ()=>isTypeLiteralTransformation);
parcelHelpers.export(exports, "annotations", ()=>annotations);
parcelHelpers.export(exports, "keyof", ()=>keyof);
parcelHelpers.export(exports, "getTemplateLiteralRegExp", ()=>getTemplateLiteralRegExp);
parcelHelpers.export(exports, "getTemplateLiteralCapturingRegExp", ()=>getTemplateLiteralCapturingRegExp);
parcelHelpers.export(exports, "getPropertySignatures", ()=>getPropertySignatures);
parcelHelpers.export(exports, "getNumberIndexedAccess", ()=>getNumberIndexedAccess);
parcelHelpers.export(exports, "getPropertyKeyIndexedAccess", ()=>getPropertyKeyIndexedAccess);
parcelHelpers.export(exports, "record", ()=>record);
parcelHelpers.export(exports, "pick", ()=>pick);
parcelHelpers.export(exports, "omit", ()=>omit);
parcelHelpers.export(exports, "orUndefined", ()=>orUndefined);
parcelHelpers.export(exports, "partial", ()=>partial);
parcelHelpers.export(exports, "required", ()=>required);
parcelHelpers.export(exports, "mutable", ()=>mutable);
parcelHelpers.export(exports, "getCompiler", ()=>getCompiler);
parcelHelpers.export(exports, "pickAnnotations", ()=>pickAnnotations);
parcelHelpers.export(exports, "omitAnnotations", ()=>omitAnnotations);
parcelHelpers.export(exports, "typeAST", ()=>typeAST);
parcelHelpers.export(exports, "getTransformationFrom", ()=>getTransformationFrom);
parcelHelpers.export(exports, "encodedAST", ()=>encodedAST);
parcelHelpers.export(exports, "encodedBoundAST", ()=>encodedBoundAST);
parcelHelpers.export(exports, "getEncodedParameter", ()=>getEncodedParameter);
parcelHelpers.export(exports, "equals", ()=>equals);
parcelHelpers.export(exports, "compose", ()=>compose);
parcelHelpers.export(exports, "rename", ()=>rename);
parcelHelpers.export(exports, "pruneUndefined", ()=>pruneUndefined);
var _arrayJs = require("./Array.js");
var _functionJs = require("./Function.js");
var _globalValueJs = require("./GlobalValue.js");
var _errorsJs = require("./internal/schema/errors.js");
var _utilJs = require("./internal/schema/util.js");
var _numberJs = require("./Number.js");
var _optionJs = require("./Option.js");
var _orderJs = require("./Order.js");
var _predicateJs = require("./Predicate.js");
var _regExpJs = require("./RegExp.js");
const BrandAnnotationId = /*#__PURE__*/ Symbol.for("effect/annotation/Brand");
const SchemaIdAnnotationId = /*#__PURE__*/ Symbol.for("effect/annotation/SchemaId");
const MessageAnnotationId = /*#__PURE__*/ Symbol.for("effect/annotation/Message");
const MissingMessageAnnotationId = /*#__PURE__*/ Symbol.for("effect/annotation/MissingMessage");
const IdentifierAnnotationId = /*#__PURE__*/ Symbol.for("effect/annotation/Identifier");
const TitleAnnotationId = /*#__PURE__*/ Symbol.for("effect/annotation/Title");
const AutoTitleAnnotationId = /*#__PURE__*/ Symbol.for("effect/annotation/AutoTitle");
const DescriptionAnnotationId = /*#__PURE__*/ Symbol.for("effect/annotation/Description");
const ExamplesAnnotationId = /*#__PURE__*/ Symbol.for("effect/annotation/Examples");
const DefaultAnnotationId = /*#__PURE__*/ Symbol.for("effect/annotation/Default");
const JSONSchemaAnnotationId = /*#__PURE__*/ Symbol.for("effect/annotation/JSONSchema");
const ArbitraryAnnotationId = /*#__PURE__*/ Symbol.for("effect/annotation/Arbitrary");
const PrettyAnnotationId = /*#__PURE__*/ Symbol.for("effect/annotation/Pretty");
const EquivalenceAnnotationId = /*#__PURE__*/ Symbol.for("effect/annotation/Equivalence");
const DocumentationAnnotationId = /*#__PURE__*/ Symbol.for("effect/annotation/Documentation");
const ConcurrencyAnnotationId = /*#__PURE__*/ Symbol.for("effect/annotation/Concurrency");
const BatchingAnnotationId = /*#__PURE__*/ Symbol.for("effect/annotation/Batching");
const ParseIssueTitleAnnotationId = /*#__PURE__*/ Symbol.for("effect/annotation/ParseIssueTitle");
const ParseOptionsAnnotationId = /*#__PURE__*/ Symbol.for("effect/annotation/ParseOptions");
const DecodingFallbackAnnotationId = /*#__PURE__*/ Symbol.for("effect/annotation/DecodingFallback");
const SurrogateAnnotationId = /*#__PURE__*/ Symbol.for("effect/annotation/Surrogate");
const StableFilterAnnotationId = /*#__PURE__*/ Symbol.for("effect/annotation/StableFilter");
const getAnnotation = /*#__PURE__*/ (0, _functionJs.dual)(2, (annotated, key)=>Object.prototype.hasOwnProperty.call(annotated.annotations, key) ? _optionJs.some(annotated.annotations[key]) : _optionJs.none());
const getBrandAnnotation = /*#__PURE__*/ getAnnotation(BrandAnnotationId);
const getSchemaIdAnnotation = /*#__PURE__*/ getAnnotation(SchemaIdAnnotationId);
const getMessageAnnotation = /*#__PURE__*/ getAnnotation(MessageAnnotationId);
const getMissingMessageAnnotation = /*#__PURE__*/ getAnnotation(MissingMessageAnnotationId);
const getTitleAnnotation = /*#__PURE__*/ getAnnotation(TitleAnnotationId);
const getAutoTitleAnnotation = /*#__PURE__*/ getAnnotation(AutoTitleAnnotationId);
const getIdentifierAnnotation = /*#__PURE__*/ getAnnotation(IdentifierAnnotationId);
const getDescriptionAnnotation = /*#__PURE__*/ getAnnotation(DescriptionAnnotationId);
const getExamplesAnnotation = /*#__PURE__*/ getAnnotation(ExamplesAnnotationId);
const getDefaultAnnotation = /*#__PURE__*/ getAnnotation(DefaultAnnotationId);
const getJSONSchemaAnnotation = /*#__PURE__*/ getAnnotation(JSONSchemaAnnotationId);
const getDocumentationAnnotation = /*#__PURE__*/ getAnnotation(DocumentationAnnotationId);
const getConcurrencyAnnotation = /*#__PURE__*/ getAnnotation(ConcurrencyAnnotationId);
const getBatchingAnnotation = /*#__PURE__*/ getAnnotation(BatchingAnnotationId);
const getParseIssueTitleAnnotation = /*#__PURE__*/ getAnnotation(ParseIssueTitleAnnotationId);
const getParseOptionsAnnotation = /*#__PURE__*/ getAnnotation(ParseOptionsAnnotationId);
const getDecodingFallbackAnnotation = /*#__PURE__*/ getAnnotation(DecodingFallbackAnnotationId);
const getSurrogateAnnotation = /*#__PURE__*/ getAnnotation(SurrogateAnnotationId);
const getStableFilterAnnotation = /*#__PURE__*/ getAnnotation(StableFilterAnnotationId);
const hasStableFilter = (annotated)=>_optionJs.exists(getStableFilterAnnotation(annotated), (b)=>b === true);
const JSONIdentifierAnnotationId = /*#__PURE__*/ Symbol.for("effect/annotation/JSONIdentifier");
const getJSONIdentifierAnnotation = /*#__PURE__*/ getAnnotation(JSONIdentifierAnnotationId);
const getJSONIdentifier = (annotated)=>_optionJs.orElse(getJSONIdentifierAnnotation(annotated), ()=>getIdentifierAnnotation(annotated));
const ParseJsonSchemaId = /*#__PURE__*/ Symbol.for("effect/schema/ParseJson");
class Declaration {
    typeParameters;
    decodeUnknown;
    encodeUnknown;
    annotations;
    /**
   * @since 3.10.0
   */ _tag = "Declaration";
    constructor(typeParameters, decodeUnknown, encodeUnknown, annotations = {}){
        this.typeParameters = typeParameters;
        this.decodeUnknown = decodeUnknown;
        this.encodeUnknown = encodeUnknown;
        this.annotations = annotations;
    }
    /**
   * @since 3.10.0
   */ toString() {
        return _optionJs.getOrElse(getExpected(this), ()=>"<declaration schema>");
    }
    /**
   * @since 3.10.0
   */ toJSON() {
        return {
            _tag: this._tag,
            typeParameters: this.typeParameters.map((ast)=>ast.toJSON()),
            annotations: toJSONAnnotations(this.annotations)
        };
    }
}
const createASTGuard = (tag)=>(ast)=>ast._tag === tag;
const isDeclaration = /*#__PURE__*/ createASTGuard("Declaration");
class Literal {
    literal;
    annotations;
    /**
   * @since 3.10.0
   */ _tag = "Literal";
    constructor(literal, annotations = {}){
        this.literal = literal;
        this.annotations = annotations;
    }
    /**
   * @since 3.10.0
   */ toString() {
        return _optionJs.getOrElse(getExpected(this), ()=>_utilJs.formatUnknown(this.literal));
    }
    /**
   * @since 3.10.0
   */ toJSON() {
        return {
            _tag: this._tag,
            literal: _predicateJs.isBigInt(this.literal) ? String(this.literal) : this.literal,
            annotations: toJSONAnnotations(this.annotations)
        };
    }
}
const isLiteral = /*#__PURE__*/ createASTGuard("Literal");
const $null = /*#__PURE__*/ new Literal(null);
class UniqueSymbol {
    symbol;
    annotations;
    /**
   * @since 3.10.0
   */ _tag = "UniqueSymbol";
    constructor(symbol, annotations = {}){
        this.symbol = symbol;
        this.annotations = annotations;
    }
    /**
   * @since 3.10.0
   */ toString() {
        return _optionJs.getOrElse(getExpected(this), ()=>_utilJs.formatUnknown(this.symbol));
    }
    /**
   * @since 3.10.0
   */ toJSON() {
        return {
            _tag: this._tag,
            symbol: String(this.symbol),
            annotations: toJSONAnnotations(this.annotations)
        };
    }
}
const isUniqueSymbol = /*#__PURE__*/ createASTGuard("UniqueSymbol");
class UndefinedKeyword {
    annotations;
    /**
   * @since 3.10.0
   */ _tag = "UndefinedKeyword";
    constructor(annotations = {}){
        this.annotations = annotations;
    }
    /**
   * @since 3.10.0
   */ toString() {
        return formatKeyword(this);
    }
    /**
   * @since 3.10.0
   */ toJSON() {
        return {
            _tag: this._tag,
            annotations: toJSONAnnotations(this.annotations)
        };
    }
}
const undefinedKeyword = /*#__PURE__*/ new UndefinedKeyword({
    [TitleAnnotationId]: "undefined"
});
const isUndefinedKeyword = /*#__PURE__*/ createASTGuard("UndefinedKeyword");
class VoidKeyword {
    annotations;
    /**
   * @since 3.10.0
   */ _tag = "VoidKeyword";
    constructor(annotations = {}){
        this.annotations = annotations;
    }
    /**
   * @since 3.10.0
   */ toString() {
        return formatKeyword(this);
    }
    /**
   * @since 3.10.0
   */ toJSON() {
        return {
            _tag: this._tag,
            annotations: toJSONAnnotations(this.annotations)
        };
    }
}
const voidKeyword = /*#__PURE__*/ new VoidKeyword({
    [TitleAnnotationId]: "void"
});
const isVoidKeyword = /*#__PURE__*/ createASTGuard("VoidKeyword");
class NeverKeyword {
    annotations;
    /**
   * @since 3.10.0
   */ _tag = "NeverKeyword";
    constructor(annotations = {}){
        this.annotations = annotations;
    }
    /**
   * @since 3.10.0
   */ toString() {
        return formatKeyword(this);
    }
    /**
   * @since 3.10.0
   */ toJSON() {
        return {
            _tag: this._tag,
            annotations: toJSONAnnotations(this.annotations)
        };
    }
}
const neverKeyword = /*#__PURE__*/ new NeverKeyword({
    [TitleAnnotationId]: "never"
});
const isNeverKeyword = /*#__PURE__*/ createASTGuard("NeverKeyword");
class UnknownKeyword {
    annotations;
    /**
   * @since 3.10.0
   */ _tag = "UnknownKeyword";
    constructor(annotations = {}){
        this.annotations = annotations;
    }
    /**
   * @since 3.10.0
   */ toString() {
        return formatKeyword(this);
    }
    /**
   * @since 3.10.0
   */ toJSON() {
        return {
            _tag: this._tag,
            annotations: toJSONAnnotations(this.annotations)
        };
    }
}
const unknownKeyword = /*#__PURE__*/ new UnknownKeyword({
    [TitleAnnotationId]: "unknown"
});
const isUnknownKeyword = /*#__PURE__*/ createASTGuard("UnknownKeyword");
class AnyKeyword {
    annotations;
    /**
   * @since 3.10.0
   */ _tag = "AnyKeyword";
    constructor(annotations = {}){
        this.annotations = annotations;
    }
    /**
   * @since 3.10.0
   */ toString() {
        return formatKeyword(this);
    }
    /**
   * @since 3.10.0
   */ toJSON() {
        return {
            _tag: this._tag,
            annotations: toJSONAnnotations(this.annotations)
        };
    }
}
const anyKeyword = /*#__PURE__*/ new AnyKeyword({
    [TitleAnnotationId]: "any"
});
const isAnyKeyword = /*#__PURE__*/ createASTGuard("AnyKeyword");
class StringKeyword {
    annotations;
    /**
   * @since 3.10.0
   */ _tag = "StringKeyword";
    constructor(annotations = {}){
        this.annotations = annotations;
    }
    /**
   * @since 3.10.0
   */ toString() {
        return formatKeyword(this);
    }
    /**
   * @since 3.10.0
   */ toJSON() {
        return {
            _tag: this._tag,
            annotations: toJSONAnnotations(this.annotations)
        };
    }
}
const stringKeyword = /*#__PURE__*/ new StringKeyword({
    [TitleAnnotationId]: "string",
    [DescriptionAnnotationId]: "a string"
});
const isStringKeyword = /*#__PURE__*/ createASTGuard("StringKeyword");
class NumberKeyword {
    annotations;
    /**
   * @since 3.10.0
   */ _tag = "NumberKeyword";
    constructor(annotations = {}){
        this.annotations = annotations;
    }
    /**
   * @since 3.10.0
   */ toString() {
        return formatKeyword(this);
    }
    /**
   * @since 3.10.0
   */ toJSON() {
        return {
            _tag: this._tag,
            annotations: toJSONAnnotations(this.annotations)
        };
    }
}
const numberKeyword = /*#__PURE__*/ new NumberKeyword({
    [TitleAnnotationId]: "number",
    [DescriptionAnnotationId]: "a number"
});
const isNumberKeyword = /*#__PURE__*/ createASTGuard("NumberKeyword");
class BooleanKeyword {
    annotations;
    /**
   * @since 3.10.0
   */ _tag = "BooleanKeyword";
    constructor(annotations = {}){
        this.annotations = annotations;
    }
    /**
   * @since 3.10.0
   */ toString() {
        return formatKeyword(this);
    }
    /**
   * @since 3.10.0
   */ toJSON() {
        return {
            _tag: this._tag,
            annotations: toJSONAnnotations(this.annotations)
        };
    }
}
const booleanKeyword = /*#__PURE__*/ new BooleanKeyword({
    [TitleAnnotationId]: "boolean",
    [DescriptionAnnotationId]: "a boolean"
});
const isBooleanKeyword = /*#__PURE__*/ createASTGuard("BooleanKeyword");
class BigIntKeyword {
    annotations;
    /**
   * @since 3.10.0
   */ _tag = "BigIntKeyword";
    constructor(annotations = {}){
        this.annotations = annotations;
    }
    /**
   * @since 3.10.0
   */ toString() {
        return formatKeyword(this);
    }
    /**
   * @since 3.10.0
   */ toJSON() {
        return {
            _tag: this._tag,
            annotations: toJSONAnnotations(this.annotations)
        };
    }
}
const bigIntKeyword = /*#__PURE__*/ new BigIntKeyword({
    [TitleAnnotationId]: "bigint",
    [DescriptionAnnotationId]: "a bigint"
});
const isBigIntKeyword = /*#__PURE__*/ createASTGuard("BigIntKeyword");
class SymbolKeyword {
    annotations;
    /**
   * @since 3.10.0
   */ _tag = "SymbolKeyword";
    constructor(annotations = {}){
        this.annotations = annotations;
    }
    /**
   * @since 3.10.0
   */ toString() {
        return formatKeyword(this);
    }
    /**
   * @since 3.10.0
   */ toJSON() {
        return {
            _tag: this._tag,
            annotations: toJSONAnnotations(this.annotations)
        };
    }
}
const symbolKeyword = /*#__PURE__*/ new SymbolKeyword({
    [TitleAnnotationId]: "symbol",
    [DescriptionAnnotationId]: "a symbol"
});
const isSymbolKeyword = /*#__PURE__*/ createASTGuard("SymbolKeyword");
class ObjectKeyword {
    annotations;
    /**
   * @since 3.10.0
   */ _tag = "ObjectKeyword";
    constructor(annotations = {}){
        this.annotations = annotations;
    }
    /**
   * @since 3.10.0
   */ toString() {
        return formatKeyword(this);
    }
    /**
   * @since 3.10.0
   */ toJSON() {
        return {
            _tag: this._tag,
            annotations: toJSONAnnotations(this.annotations)
        };
    }
}
const objectKeyword = /*#__PURE__*/ new ObjectKeyword({
    [TitleAnnotationId]: "object",
    [DescriptionAnnotationId]: "an object in the TypeScript meaning, i.e. the `object` type"
});
const isObjectKeyword = /*#__PURE__*/ createASTGuard("ObjectKeyword");
class Enums {
    enums;
    annotations;
    /**
   * @since 3.10.0
   */ _tag = "Enums";
    constructor(enums, annotations = {}){
        this.enums = enums;
        this.annotations = annotations;
    }
    /**
   * @since 3.10.0
   */ toString() {
        return _optionJs.getOrElse(getExpected(this), ()=>`<enum ${this.enums.length} value(s): ${this.enums.map(([_, value])=>JSON.stringify(value)).join(" | ")}>`);
    }
    /**
   * @since 3.10.0
   */ toJSON() {
        return {
            _tag: this._tag,
            enums: this.enums,
            annotations: toJSONAnnotations(this.annotations)
        };
    }
}
const isEnums = /*#__PURE__*/ createASTGuard("Enums");
const isTemplateLiteralSpanType = (ast)=>{
    switch(ast._tag){
        case "Literal":
        case "NumberKeyword":
        case "StringKeyword":
        case "TemplateLiteral":
            return true;
        case "Union":
            return ast.types.every(isTemplateLiteralSpanType);
    }
    return false;
};
const templateLiteralSpanUnionTypeToString = (type)=>{
    switch(type._tag){
        case "Literal":
            return JSON.stringify(String(type.literal));
        case "StringKeyword":
            return "string";
        case "NumberKeyword":
            return "number";
        case "TemplateLiteral":
            return String(type);
        case "Union":
            return type.types.map(templateLiteralSpanUnionTypeToString).join(" | ");
    }
};
const templateLiteralSpanTypeToString = (type)=>{
    switch(type._tag){
        case "Literal":
            return String(type.literal);
        case "StringKeyword":
            return "${string}";
        case "NumberKeyword":
            return "${number}";
        case "TemplateLiteral":
            return "${" + String(type) + "}";
        case "Union":
            return "${" + type.types.map(templateLiteralSpanUnionTypeToString).join(" | ") + "}";
    }
};
class TemplateLiteralSpan {
    literal;
    /**
   * @since 3.10.0
   */ type;
    constructor(type, literal){
        this.literal = literal;
        if (isTemplateLiteralSpanType(type)) this.type = type;
        else throw new Error(_errorsJs.getSchemaUnsupportedLiteralSpanErrorMessage(type));
    }
    /**
   * @since 3.10.0
   */ toString() {
        return templateLiteralSpanTypeToString(this.type) + this.literal;
    }
    /**
   * @since 3.10.0
   */ toJSON() {
        return {
            type: this.type.toJSON(),
            literal: this.literal
        };
    }
}
class TemplateLiteral {
    head;
    spans;
    annotations;
    /**
   * @since 3.10.0
   */ _tag = "TemplateLiteral";
    constructor(head, spans, annotations = {}){
        this.head = head;
        this.spans = spans;
        this.annotations = annotations;
    }
    /**
   * @since 3.10.0
   */ toString() {
        return _optionJs.getOrElse(getExpected(this), ()=>formatTemplateLiteral(this));
    }
    /**
   * @since 3.10.0
   */ toJSON() {
        return {
            _tag: this._tag,
            head: this.head,
            spans: this.spans.map((span)=>span.toJSON()),
            annotations: toJSONAnnotations(this.annotations)
        };
    }
}
const formatTemplateLiteral = (ast)=>"`" + ast.head + ast.spans.map(String).join("") + "`";
const isTemplateLiteral = /*#__PURE__*/ createASTGuard("TemplateLiteral");
class Type {
    type;
    annotations;
    constructor(type, annotations = {}){
        this.type = type;
        this.annotations = annotations;
    }
    /**
   * @since 3.10.0
   */ toJSON() {
        return {
            type: this.type.toJSON(),
            annotations: toJSONAnnotations(this.annotations)
        };
    }
    /**
   * @since 3.10.0
   */ toString() {
        return String(this.type);
    }
}
class OptionalType extends Type {
    isOptional;
    constructor(type, isOptional, annotations = {}){
        super(type, annotations);
        this.isOptional = isOptional;
    }
    /**
   * @since 3.10.0
   */ toJSON() {
        return {
            type: this.type.toJSON(),
            isOptional: this.isOptional,
            annotations: toJSONAnnotations(this.annotations)
        };
    }
    /**
   * @since 3.10.0
   */ toString() {
        return String(this.type) + (this.isOptional ? "?" : "");
    }
}
const getRestASTs = (rest)=>rest.map((annotatedAST)=>annotatedAST.type);
class TupleType {
    elements;
    rest;
    isReadonly;
    annotations;
    /**
   * @since 3.10.0
   */ _tag = "TupleType";
    constructor(elements, rest, isReadonly, annotations = {}){
        this.elements = elements;
        this.rest = rest;
        this.isReadonly = isReadonly;
        this.annotations = annotations;
        let hasOptionalElement = false;
        let hasIllegalRequiredElement = false;
        for (const e of elements){
            if (e.isOptional) hasOptionalElement = true;
            else if (hasOptionalElement) {
                hasIllegalRequiredElement = true;
                break;
            }
        }
        if (hasIllegalRequiredElement || hasOptionalElement && rest.length > 1) throw new Error(_errorsJs.getASTRequiredElementFollowinAnOptionalElementErrorMessage);
    }
    /**
   * @since 3.10.0
   */ toString() {
        return _optionJs.getOrElse(getExpected(this), ()=>formatTuple(this));
    }
    /**
   * @since 3.10.0
   */ toJSON() {
        return {
            _tag: this._tag,
            elements: this.elements.map((e)=>e.toJSON()),
            rest: this.rest.map((ast)=>ast.toJSON()),
            isReadonly: this.isReadonly,
            annotations: toJSONAnnotations(this.annotations)
        };
    }
}
const formatTuple = (ast)=>{
    const formattedElements = ast.elements.map(String).join(", ");
    return _arrayJs.matchLeft(ast.rest, {
        onEmpty: ()=>`readonly [${formattedElements}]`,
        onNonEmpty: (head, tail)=>{
            const formattedHead = String(head);
            const wrappedHead = formattedHead.includes(" | ") ? `(${formattedHead})` : formattedHead;
            if (tail.length > 0) {
                const formattedTail = tail.map(String).join(", ");
                if (ast.elements.length > 0) return `readonly [${formattedElements}, ...${wrappedHead}[], ${formattedTail}]`;
                else return `readonly [...${wrappedHead}[], ${formattedTail}]`;
            } else {
                if (ast.elements.length > 0) return `readonly [${formattedElements}, ...${wrappedHead}[]]`;
                else return `ReadonlyArray<${formattedHead}>`;
            }
        }
    });
};
const isTupleType = /*#__PURE__*/ createASTGuard("TupleType");
class PropertySignature extends OptionalType {
    name;
    isReadonly;
    constructor(name, type, isOptional, isReadonly, annotations){
        super(type, isOptional, annotations);
        this.name = name;
        this.isReadonly = isReadonly;
    }
    /**
   * @since 3.10.0
   */ toString() {
        return (this.isReadonly ? "readonly " : "") + String(this.name) + (this.isOptional ? "?" : "") + ": " + this.type;
    }
    /**
   * @since 3.10.0
   */ toJSON() {
        return {
            name: String(this.name),
            type: this.type.toJSON(),
            isOptional: this.isOptional,
            isReadonly: this.isReadonly,
            annotations: toJSONAnnotations(this.annotations)
        };
    }
}
const isParameter = (ast)=>{
    switch(ast._tag){
        case "StringKeyword":
        case "SymbolKeyword":
        case "TemplateLiteral":
            return true;
        case "Refinement":
            return isParameter(ast.from);
    }
    return false;
};
class IndexSignature {
    type;
    isReadonly;
    /**
   * @since 3.10.0
   */ parameter;
    constructor(parameter, type, isReadonly){
        this.type = type;
        this.isReadonly = isReadonly;
        if (isParameter(parameter)) this.parameter = parameter;
        else throw new Error(_errorsJs.getASTIndexSignatureParameterErrorMessage);
    }
    /**
   * @since 3.10.0
   */ toString() {
        return (this.isReadonly ? "readonly " : "") + `[x: ${this.parameter}]: ${this.type}`;
    }
    /**
   * @since 3.10.0
   */ toJSON() {
        return {
            parameter: this.parameter.toJSON(),
            type: this.type.toJSON(),
            isReadonly: this.isReadonly
        };
    }
}
class TypeLiteral {
    annotations;
    /**
   * @since 3.10.0
   */ _tag = "TypeLiteral";
    /**
   * @since 3.10.0
   */ propertySignatures;
    /**
   * @since 3.10.0
   */ indexSignatures;
    constructor(propertySignatures, indexSignatures, annotations = {}){
        this.annotations = annotations;
        // check for duplicate property signatures
        const keys = {};
        for(let i = 0; i < propertySignatures.length; i++){
            const name = propertySignatures[i].name;
            if (Object.prototype.hasOwnProperty.call(keys, name)) throw new Error(_errorsJs.getASTDuplicatePropertySignatureErrorMessage(name));
            keys[name] = null;
        }
        // check for duplicate index signatures
        const parameters = {
            string: false,
            symbol: false
        };
        for(let i = 0; i < indexSignatures.length; i++){
            const encodedParameter = getEncodedParameter(indexSignatures[i].parameter);
            if (isStringKeyword(encodedParameter)) {
                if (parameters.string) throw new Error(_errorsJs.getASTDuplicateIndexSignatureErrorMessage("string"));
                parameters.string = true;
            } else if (isSymbolKeyword(encodedParameter)) {
                if (parameters.symbol) throw new Error(_errorsJs.getASTDuplicateIndexSignatureErrorMessage("symbol"));
                parameters.symbol = true;
            }
        }
        this.propertySignatures = propertySignatures;
        this.indexSignatures = indexSignatures;
    }
    /**
   * @since 3.10.0
   */ toString() {
        return _optionJs.getOrElse(getExpected(this), ()=>formatTypeLiteral(this));
    }
    /**
   * @since 3.10.0
   */ toJSON() {
        return {
            _tag: this._tag,
            propertySignatures: this.propertySignatures.map((ps)=>ps.toJSON()),
            indexSignatures: this.indexSignatures.map((ps)=>ps.toJSON()),
            annotations: toJSONAnnotations(this.annotations)
        };
    }
}
const formatIndexSignatures = (iss)=>iss.map(String).join("; ");
const formatTypeLiteral = (ast)=>{
    if (ast.propertySignatures.length > 0) {
        const pss = ast.propertySignatures.map(String).join("; ");
        if (ast.indexSignatures.length > 0) return `{ ${pss}; ${formatIndexSignatures(ast.indexSignatures)} }`;
        else return `{ ${pss} }`;
    } else {
        if (ast.indexSignatures.length > 0) return `{ ${formatIndexSignatures(ast.indexSignatures)} }`;
        else return "{}";
    }
};
const isTypeLiteral = /*#__PURE__*/ createASTGuard("TypeLiteral");
const sortCandidates = /*#__PURE__*/ _arrayJs.sort(/*#__PURE__*/ _orderJs.mapInput(_numberJs.Order, (ast)=>{
    switch(ast._tag){
        case "AnyKeyword":
            return 0;
        case "UnknownKeyword":
            return 1;
        case "ObjectKeyword":
            return 2;
        case "StringKeyword":
        case "NumberKeyword":
        case "BooleanKeyword":
        case "BigIntKeyword":
        case "SymbolKeyword":
            return 3;
    }
    return 4;
}));
const literalMap = {
    string: "StringKeyword",
    number: "NumberKeyword",
    boolean: "BooleanKeyword",
    bigint: "BigIntKeyword"
};
const flatten = (candidates)=>_arrayJs.flatMap(candidates, (ast)=>isUnion(ast) ? flatten(ast.types) : [
            ast
        ]);
const unify = (candidates)=>{
    const cs = sortCandidates(candidates);
    const out = [];
    const uniques = {};
    const literals = [];
    for (const ast of cs)switch(ast._tag){
        case "NeverKeyword":
            break;
        case "AnyKeyword":
            return [
                anyKeyword
            ];
        case "UnknownKeyword":
            return [
                unknownKeyword
            ];
        // uniques
        case "ObjectKeyword":
        case "UndefinedKeyword":
        case "VoidKeyword":
        case "StringKeyword":
        case "NumberKeyword":
        case "BooleanKeyword":
        case "BigIntKeyword":
        case "SymbolKeyword":
            if (!uniques[ast._tag]) {
                uniques[ast._tag] = ast;
                out.push(ast);
            }
            break;
        case "Literal":
            {
                const type = typeof ast.literal;
                switch(type){
                    case "string":
                    case "number":
                    case "bigint":
                    case "boolean":
                        {
                            const _tag = literalMap[type];
                            if (!uniques[_tag] && !literals.includes(ast.literal)) {
                                literals.push(ast.literal);
                                out.push(ast);
                            }
                            break;
                        }
                    // null
                    case "object":
                        if (!literals.includes(ast.literal)) {
                            literals.push(ast.literal);
                            out.push(ast);
                        }
                        break;
                }
                break;
            }
        case "UniqueSymbol":
            if (!uniques["SymbolKeyword"] && !literals.includes(ast.symbol)) {
                literals.push(ast.symbol);
                out.push(ast);
            }
            break;
        case "TupleType":
            if (!uniques["ObjectKeyword"]) out.push(ast);
            break;
        case "TypeLiteral":
            if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
                if (!uniques["{}"]) {
                    uniques["{}"] = ast;
                    out.push(ast);
                }
            } else if (!uniques["ObjectKeyword"]) out.push(ast);
            break;
        default:
            out.push(ast);
    }
    return out;
};
class Union {
    types;
    annotations;
    static make = (types, annotations)=>{
        return isMembers(types) ? new Union(types, annotations) : types.length === 1 ? types[0] : neverKeyword;
    };
    /** @internal */ static unify = (candidates, annotations)=>{
        return Union.make(unify(flatten(candidates)), annotations);
    };
    /**
   * @since 3.10.0
   */ _tag = "Union";
    constructor(types, annotations = {}){
        this.types = types;
        this.annotations = annotations;
    }
    /**
   * @since 3.10.0
   */ toString() {
        return _optionJs.getOrElse(getExpected(this), ()=>this.types.map(String).join(" | "));
    }
    /**
   * @since 3.10.0
   */ toJSON() {
        return {
            _tag: this._tag,
            types: this.types.map((ast)=>ast.toJSON()),
            annotations: toJSONAnnotations(this.annotations)
        };
    }
}
const mapMembers = (members, f)=>members.map(f);
const isMembers = (as)=>as.length > 1;
const isUnion = /*#__PURE__*/ createASTGuard("Union");
const toJSONMemoMap = /*#__PURE__*/ (0, _globalValueJs.globalValue)(/*#__PURE__*/ Symbol.for("effect/Schema/AST/toJSONMemoMap"), ()=>new WeakMap());
class Suspend {
    f;
    annotations;
    /**
   * @since 3.10.0
   */ _tag = "Suspend";
    constructor(f, annotations = {}){
        this.f = f;
        this.annotations = annotations;
        this.f = _utilJs.memoizeThunk(f);
    }
    /**
   * @since 3.10.0
   */ toString() {
        return getExpected(this).pipe(_optionJs.orElse(()=>_optionJs.flatMap(_optionJs.liftThrowable(this.f)(), (ast)=>getExpected(ast))), _optionJs.getOrElse(()=>"<suspended schema>"));
    }
    /**
   * @since 3.10.0
   */ toJSON() {
        const ast = this.f();
        let out = toJSONMemoMap.get(ast);
        if (out) return out;
        toJSONMemoMap.set(ast, {
            _tag: this._tag
        });
        out = {
            _tag: this._tag,
            ast: ast.toJSON(),
            annotations: toJSONAnnotations(this.annotations)
        };
        toJSONMemoMap.set(ast, out);
        return out;
    }
}
const isSuspend = /*#__PURE__*/ createASTGuard("Suspend");
class Refinement {
    from;
    filter;
    annotations;
    /**
   * @since 3.10.0
   */ _tag = "Refinement";
    constructor(from, filter, annotations = {}){
        this.from = from;
        this.filter = filter;
        this.annotations = annotations;
    }
    /**
   * @since 3.10.0
   */ toString() {
        return getIdentifierAnnotation(this).pipe(_optionJs.getOrElse(()=>_optionJs.match(getOrElseExpected(this), {
                onNone: ()=>`{ ${this.from} | filter }`,
                onSome: (expected)=>isRefinement(this.from) ? String(this.from) + " & " + expected : expected
            })));
    }
    /**
   * @since 3.10.0
   */ toJSON() {
        return {
            _tag: this._tag,
            from: this.from.toJSON(),
            annotations: toJSONAnnotations(this.annotations)
        };
    }
}
const isRefinement = /*#__PURE__*/ createASTGuard("Refinement");
const defaultParseOption = {};
class Transformation {
    from;
    to;
    transformation;
    annotations;
    /**
   * @since 3.10.0
   */ _tag = "Transformation";
    constructor(from, to, transformation, annotations = {}){
        this.from = from;
        this.to = to;
        this.transformation = transformation;
        this.annotations = annotations;
    }
    /**
   * @since 3.10.0
   */ toString() {
        return _optionJs.getOrElse(getExpected(this), ()=>`(${String(this.from)} <-> ${String(this.to)})`);
    }
    /**
   * @since 3.10.0
   */ toJSON() {
        return {
            _tag: this._tag,
            from: this.from.toJSON(),
            to: this.to.toJSON(),
            annotations: toJSONAnnotations(this.annotations)
        };
    }
}
const isTransformation = /*#__PURE__*/ createASTGuard("Transformation");
class FinalTransformation {
    decode;
    encode;
    /**
   * @since 3.10.0
   */ _tag = "FinalTransformation";
    constructor(decode, encode){
        this.decode = decode;
        this.encode = encode;
    }
}
const createTransformationGuard = (tag)=>(ast)=>ast._tag === tag;
const isFinalTransformation = /*#__PURE__*/ createTransformationGuard("FinalTransformation");
class ComposeTransformation {
    /**
   * @since 3.10.0
   */ _tag = "ComposeTransformation";
}
const composeTransformation = /*#__PURE__*/ new ComposeTransformation();
const isComposeTransformation = /*#__PURE__*/ createTransformationGuard("ComposeTransformation");
class PropertySignatureTransformation {
    from;
    to;
    decode;
    encode;
    constructor(from, to, decode, encode){
        this.from = from;
        this.to = to;
        this.decode = decode;
        this.encode = encode;
    }
}
const isRenamingPropertySignatureTransformation = (t)=>t.decode === (0, _functionJs.identity) && t.encode === (0, _functionJs.identity);
class TypeLiteralTransformation {
    propertySignatureTransformations;
    /**
   * @since 3.10.0
   */ _tag = "TypeLiteralTransformation";
    constructor(propertySignatureTransformations){
        this.propertySignatureTransformations = propertySignatureTransformations;
        // check for duplicate property signature transformations
        const fromKeys = {};
        const toKeys = {};
        for (const pst of propertySignatureTransformations){
            const from = pst.from;
            if (fromKeys[from]) throw new Error(_errorsJs.getASTDuplicatePropertySignatureTransformationErrorMessage(from));
            fromKeys[from] = true;
            const to = pst.to;
            if (toKeys[to]) throw new Error(_errorsJs.getASTDuplicatePropertySignatureTransformationErrorMessage(to));
            toKeys[to] = true;
        }
    }
}
const isTypeLiteralTransformation = /*#__PURE__*/ createTransformationGuard("TypeLiteralTransformation");
const annotations = (ast, overrides)=>{
    const d = Object.getOwnPropertyDescriptors(ast);
    const value = {
        ...ast.annotations,
        ...overrides
    };
    const surrogate = getSurrogateAnnotation(ast);
    if (_optionJs.isSome(surrogate)) value[SurrogateAnnotationId] = annotations(surrogate.value, overrides);
    d.annotations.value = value;
    return Object.create(Object.getPrototypeOf(ast), d);
};
const keyof = (ast)=>Union.unify(_keyof(ast));
const STRING_KEYWORD_PATTERN = "[\\s\\S]*"; // any string, including newlines
const NUMBER_KEYWORD_PATTERN = "[+-]?\\d*\\.?\\d+(?:[Ee][+-]?\\d+)?";
const getTemplateLiteralSpanTypePattern = (type, capture)=>{
    switch(type._tag){
        case "Literal":
            return _regExpJs.escape(String(type.literal));
        case "StringKeyword":
            return STRING_KEYWORD_PATTERN;
        case "NumberKeyword":
            return NUMBER_KEYWORD_PATTERN;
        case "TemplateLiteral":
            return getTemplateLiteralPattern(type, capture, false);
        case "Union":
            return type.types.map((type)=>getTemplateLiteralSpanTypePattern(type, capture)).join("|");
    }
};
const handleTemplateLiteralSpanTypeParens = (type, s, capture, top)=>{
    if (isUnion(type)) {
        if (capture && !top) return `(?:${s})`;
    } else if (!capture || !top) return s;
    return `(${s})`;
};
const getTemplateLiteralPattern = (ast, capture, top)=>{
    let pattern = ``;
    if (ast.head !== "") {
        const head = _regExpJs.escape(ast.head);
        pattern += capture && top ? `(${head})` : head;
    }
    for (const span of ast.spans){
        const spanPattern = getTemplateLiteralSpanTypePattern(span.type, capture);
        pattern += handleTemplateLiteralSpanTypeParens(span.type, spanPattern, capture, top);
        if (span.literal !== "") {
            const literal = _regExpJs.escape(span.literal);
            pattern += capture && top ? `(${literal})` : literal;
        }
    }
    return pattern;
};
const getTemplateLiteralRegExp = (ast)=>new RegExp(`^${getTemplateLiteralPattern(ast, false, true)}$`);
const getTemplateLiteralCapturingRegExp = (ast)=>new RegExp(`^${getTemplateLiteralPattern(ast, true, true)}$`);
const getPropertySignatures = (ast)=>{
    const annotation = getSurrogateAnnotation(ast);
    if (_optionJs.isSome(annotation)) return getPropertySignatures(annotation.value);
    switch(ast._tag){
        case "TypeLiteral":
            return ast.propertySignatures.slice();
        case "Suspend":
            return getPropertySignatures(ast.f());
        case "Refinement":
            return getPropertySignatures(ast.from);
    }
    return getPropertyKeys(ast).map((name)=>getPropertyKeyIndexedAccess(ast, name));
};
const getIndexSignatures = (ast)=>{
    const annotation = getSurrogateAnnotation(ast);
    if (_optionJs.isSome(annotation)) return getIndexSignatures(annotation.value);
    switch(ast._tag){
        case "TypeLiteral":
            return ast.indexSignatures.slice();
        case "Suspend":
            return getIndexSignatures(ast.f());
        case "Refinement":
            return getIndexSignatures(ast.from);
    }
    return [];
};
const getNumberIndexedAccess = (ast)=>{
    switch(ast._tag){
        case "TupleType":
            {
                let hasOptional = false;
                let out = [];
                for (const e of ast.elements){
                    if (e.isOptional) hasOptional = true;
                    out.push(e.type);
                }
                if (hasOptional) out.push(undefinedKeyword);
                out = out.concat(getRestASTs(ast.rest));
                return Union.make(out);
            }
        case "Refinement":
            return getNumberIndexedAccess(ast.from);
        case "Union":
            return Union.make(ast.types.map(getNumberIndexedAccess));
        case "Suspend":
            return getNumberIndexedAccess(ast.f());
    }
    throw new Error(_errorsJs.getASTUnsupportedSchemaErrorMessage(ast));
};
const getTypeLiteralPropertySignature = (ast, name)=>{
    // from property signatures...
    const ops = _arrayJs.findFirst(ast.propertySignatures, (ps)=>ps.name === name);
    if (_optionJs.isSome(ops)) return ops.value;
    // from index signatures...
    if (_predicateJs.isString(name)) {
        let out = undefined;
        for (const is of ast.indexSignatures){
            const encodedParameter = getEncodedParameter(is.parameter);
            switch(encodedParameter._tag){
                case "TemplateLiteral":
                    {
                        const regex = getTemplateLiteralRegExp(encodedParameter);
                        if (regex.test(name)) return new PropertySignature(name, is.type, false, true);
                        break;
                    }
                case "StringKeyword":
                    if (out === undefined) out = new PropertySignature(name, is.type, false, true);
            }
        }
        if (out) return out;
    } else if (_predicateJs.isSymbol(name)) for (const is of ast.indexSignatures){
        const encodedParameter = getEncodedParameter(is.parameter);
        if (isSymbolKeyword(encodedParameter)) return new PropertySignature(name, is.type, false, true);
    }
};
const getPropertyKeyIndexedAccess = (ast, name)=>{
    const annotation = getSurrogateAnnotation(ast);
    if (_optionJs.isSome(annotation)) return getPropertyKeyIndexedAccess(annotation.value, name);
    switch(ast._tag){
        case "TypeLiteral":
            {
                const ps = getTypeLiteralPropertySignature(ast, name);
                if (ps) return ps;
                break;
            }
        case "Union":
            return new PropertySignature(name, Union.make(ast.types.map((ast)=>getPropertyKeyIndexedAccess(ast, name).type)), false, true);
        case "Suspend":
            return getPropertyKeyIndexedAccess(ast.f(), name);
        case "Refinement":
            return getPropertyKeyIndexedAccess(ast.from, name);
    }
    throw new Error(_errorsJs.getASTUnsupportedSchemaErrorMessage(ast));
};
const getPropertyKeys = (ast)=>{
    const annotation = getSurrogateAnnotation(ast);
    if (_optionJs.isSome(annotation)) return getPropertyKeys(annotation.value);
    switch(ast._tag){
        case "TypeLiteral":
            return ast.propertySignatures.map((ps)=>ps.name);
        case "Union":
            return ast.types.slice(1).reduce((out, ast)=>_arrayJs.intersection(out, getPropertyKeys(ast)), getPropertyKeys(ast.types[0]));
        case "Suspend":
            return getPropertyKeys(ast.f());
        case "Refinement":
            return getPropertyKeys(ast.from);
        case "Transformation":
            return getPropertyKeys(ast.to);
    }
    return [];
};
const record = (key, value)=>{
    const propertySignatures = [];
    const indexSignatures = [];
    const go = (key)=>{
        switch(key._tag){
            case "NeverKeyword":
                break;
            case "StringKeyword":
            case "SymbolKeyword":
            case "TemplateLiteral":
            case "Refinement":
                indexSignatures.push(new IndexSignature(key, value, true));
                break;
            case "Literal":
                if (_predicateJs.isString(key.literal) || _predicateJs.isNumber(key.literal)) propertySignatures.push(new PropertySignature(key.literal, value, false, true));
                else throw new Error(_errorsJs.getASTUnsupportedLiteralErrorMessage(key.literal));
                break;
            case "Enums":
                for (const [_, name] of key.enums)propertySignatures.push(new PropertySignature(name, value, false, true));
                break;
            case "UniqueSymbol":
                propertySignatures.push(new PropertySignature(key.symbol, value, false, true));
                break;
            case "Union":
                key.types.forEach(go);
                break;
            default:
                throw new Error(_errorsJs.getASTUnsupportedKeySchemaErrorMessage(key));
        }
    };
    go(key);
    return {
        propertySignatures,
        indexSignatures
    };
};
const pick = (ast, keys)=>{
    const annotation = getSurrogateAnnotation(ast);
    if (_optionJs.isSome(annotation)) return pick(annotation.value, keys);
    switch(ast._tag){
        case "TypeLiteral":
            {
                const pss = [];
                const names = {};
                for (const ps of ast.propertySignatures){
                    names[ps.name] = null;
                    if (keys.includes(ps.name)) pss.push(ps);
                }
                for (const key of keys)if (!(key in names)) {
                    const ps = getTypeLiteralPropertySignature(ast, key);
                    if (ps) pss.push(ps);
                }
                return new TypeLiteral(pss, []);
            }
        case "Union":
            return new TypeLiteral(keys.map((name)=>getPropertyKeyIndexedAccess(ast, name)), []);
        case "Suspend":
            return pick(ast.f(), keys);
        case "Refinement":
            return pick(ast.from, keys);
        case "Transformation":
            switch(ast.transformation._tag){
                case "ComposeTransformation":
                    return new Transformation(pick(ast.from, keys), pick(ast.to, keys), composeTransformation);
                case "TypeLiteralTransformation":
                    {
                        const ts = [];
                        const fromKeys = [];
                        for (const k of keys){
                            const t = ast.transformation.propertySignatureTransformations.find((t)=>t.to === k);
                            if (t) {
                                ts.push(t);
                                fromKeys.push(t.from);
                            } else fromKeys.push(k);
                        }
                        return _arrayJs.isNonEmptyReadonlyArray(ts) ? new Transformation(pick(ast.from, fromKeys), pick(ast.to, keys), new TypeLiteralTransformation(ts)) : pick(ast.from, fromKeys);
                    }
            }
    }
    throw new Error(_errorsJs.getASTUnsupportedSchemaErrorMessage(ast));
};
const omit = (ast, keys)=>{
    let indexSignatures = getIndexSignatures(ast);
    if (indexSignatures.length > 0) {
        if (indexSignatures.some((is)=>isStringKeyword(getEncodedParameter(is.parameter)))) indexSignatures = indexSignatures.filter((is)=>!isTemplateLiteral(getEncodedParameter(is.parameter)));
        return new TypeLiteral([], indexSignatures);
    }
    return pick(ast, getPropertyKeys(ast).filter((name)=>!keys.includes(name)));
};
const orUndefined = (ast)=>Union.make([
        ast,
        undefinedKeyword
    ]);
const partial = (ast, options)=>{
    const exact = options?.exact === true;
    switch(ast._tag){
        case "TupleType":
            return new TupleType(ast.elements.map((e)=>new OptionalType(exact ? e.type : orUndefined(e.type), true)), _arrayJs.match(ast.rest, {
                onEmpty: ()=>ast.rest,
                onNonEmpty: (rest)=>[
                        new Type(Union.make([
                            ...getRestASTs(rest),
                            undefinedKeyword
                        ]))
                    ]
            }), ast.isReadonly);
        case "TypeLiteral":
            return new TypeLiteral(ast.propertySignatures.map((ps)=>new PropertySignature(ps.name, exact ? ps.type : orUndefined(ps.type), true, ps.isReadonly, ps.annotations)), ast.indexSignatures.map((is)=>new IndexSignature(is.parameter, orUndefined(is.type), is.isReadonly)));
        case "Union":
            return Union.make(ast.types.map((member)=>partial(member, options)));
        case "Suspend":
            return new Suspend(()=>partial(ast.f(), options));
        case "Declaration":
        case "Refinement":
            throw new Error(_errorsJs.getASTUnsupportedSchemaErrorMessage(ast));
        case "Transformation":
            if (isTypeLiteralTransformation(ast.transformation) && ast.transformation.propertySignatureTransformations.every(isRenamingPropertySignatureTransformation)) return new Transformation(partial(ast.from, options), partial(ast.to, options), ast.transformation);
            throw new Error(_errorsJs.getASTUnsupportedSchemaErrorMessage(ast));
    }
    return ast;
};
const required = (ast)=>{
    switch(ast._tag){
        case "TupleType":
            return new TupleType(ast.elements.map((e)=>new OptionalType(e.type, false)), ast.rest, ast.isReadonly);
        case "TypeLiteral":
            return new TypeLiteral(ast.propertySignatures.map((f)=>new PropertySignature(f.name, f.type, false, f.isReadonly, f.annotations)), ast.indexSignatures);
        case "Union":
            return Union.make(ast.types.map((member)=>required(member)));
        case "Suspend":
            return new Suspend(()=>required(ast.f()));
        case "Declaration":
        case "Refinement":
            throw new Error(_errorsJs.getASTUnsupportedSchemaErrorMessage(ast));
        case "Transformation":
            if (isTypeLiteralTransformation(ast.transformation) && ast.transformation.propertySignatureTransformations.every(isRenamingPropertySignatureTransformation)) return new Transformation(required(ast.from), required(ast.to), ast.transformation);
            throw new Error(_errorsJs.getASTUnsupportedSchemaErrorMessage(ast));
    }
    return ast;
};
const mutable = (ast)=>{
    switch(ast._tag){
        case "TupleType":
            return ast.isReadonly === false ? ast : new TupleType(ast.elements, ast.rest, false, ast.annotations);
        case "TypeLiteral":
            {
                const propertySignatures = changeMap(ast.propertySignatures, (ps)=>ps.isReadonly === false ? ps : new PropertySignature(ps.name, ps.type, ps.isOptional, false, ps.annotations));
                const indexSignatures = changeMap(ast.indexSignatures, (is)=>is.isReadonly === false ? is : new IndexSignature(is.parameter, is.type, false));
                return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral(propertySignatures, indexSignatures, ast.annotations);
            }
        case "Union":
            {
                const types = changeMap(ast.types, mutable);
                return types === ast.types ? ast : Union.make(types, ast.annotations);
            }
        case "Suspend":
            return new Suspend(()=>mutable(ast.f()), ast.annotations);
        case "Refinement":
            {
                const from = mutable(ast.from);
                return from === ast.from ? ast : new Refinement(from, ast.filter, ast.annotations);
            }
        case "Transformation":
            {
                const from = mutable(ast.from);
                const to = mutable(ast.to);
                return from === ast.from && to === ast.to ? ast : new Transformation(from, to, ast.transformation, ast.annotations);
            }
    }
    return ast;
};
const getCompiler = (match)=>{
    const compile = (ast, path)=>match[ast._tag](ast, compile, path);
    return compile;
};
const pickAnnotations = (annotationIds)=>(annotated)=>{
        let out = undefined;
        for (const id of annotationIds)if (Object.prototype.hasOwnProperty.call(annotated.annotations, id)) {
            if (out === undefined) out = {};
            out[id] = annotated.annotations[id];
        }
        return out;
    };
const omitAnnotations = (annotationIds)=>(annotated)=>{
        const out = {
            ...annotated.annotations
        };
        for (const id of annotationIds)delete out[id];
        return out;
    };
const preserveTransformationAnnotations = /*#__PURE__*/ pickAnnotations([
    ExamplesAnnotationId,
    DefaultAnnotationId,
    JSONSchemaAnnotationId,
    ArbitraryAnnotationId,
    PrettyAnnotationId,
    EquivalenceAnnotationId
]);
const typeAST = (ast)=>{
    switch(ast._tag){
        case "Declaration":
            {
                const typeParameters = changeMap(ast.typeParameters, typeAST);
                return typeParameters === ast.typeParameters ? ast : new Declaration(typeParameters, ast.decodeUnknown, ast.encodeUnknown, ast.annotations);
            }
        case "TupleType":
            {
                const elements = changeMap(ast.elements, (e)=>{
                    const type = typeAST(e.type);
                    return type === e.type ? e : new OptionalType(type, e.isOptional);
                });
                const restASTs = getRestASTs(ast.rest);
                const rest = changeMap(restASTs, typeAST);
                return elements === ast.elements && rest === restASTs ? ast : new TupleType(elements, rest.map((type)=>new Type(type)), ast.isReadonly, ast.annotations);
            }
        case "TypeLiteral":
            {
                const propertySignatures = changeMap(ast.propertySignatures, (p)=>{
                    const type = typeAST(p.type);
                    return type === p.type ? p : new PropertySignature(p.name, type, p.isOptional, p.isReadonly);
                });
                const indexSignatures = changeMap(ast.indexSignatures, (is)=>{
                    const type = typeAST(is.type);
                    return type === is.type ? is : new IndexSignature(is.parameter, type, is.isReadonly);
                });
                return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral(propertySignatures, indexSignatures, ast.annotations);
            }
        case "Union":
            {
                const types = changeMap(ast.types, typeAST);
                return types === ast.types ? ast : Union.make(types, ast.annotations);
            }
        case "Suspend":
            return new Suspend(()=>typeAST(ast.f()), ast.annotations);
        case "Refinement":
            {
                const from = typeAST(ast.from);
                return from === ast.from ? ast : new Refinement(from, ast.filter, ast.annotations);
            }
        case "Transformation":
            {
                const preserve = preserveTransformationAnnotations(ast);
                return typeAST(preserve !== undefined ? annotations(ast.to, preserve) : ast.to);
            }
    }
    return ast;
};
// To generate a JSON Schema from a recursive schema, an `identifier` annotation
// is required. So, when we calculate the encodedAST, we need to preserve the
// annotation in the form of an internal custom annotation that acts as a
// surrogate for the identifier, which the JSON Schema compiler can then read.
const createJSONIdentifierAnnotation = (annotated)=>_optionJs.match(getJSONIdentifier(annotated), {
        onNone: ()=>undefined,
        onSome: (identifier)=>({
                [JSONIdentifierAnnotationId]: identifier
            })
    });
function changeMap(as, f) {
    let changed = false;
    const out = _arrayJs.allocate(as.length);
    for(let i = 0; i < as.length; i++){
        const a = as[i];
        const fa = f(a);
        if (fa !== a) changed = true;
        out[i] = fa;
    }
    return changed ? out : as;
}
const getTransformationFrom = (ast)=>{
    switch(ast._tag){
        case "Transformation":
            return ast.from;
        case "Refinement":
            return getTransformationFrom(ast.from);
        case "Suspend":
            return getTransformationFrom(ast.f());
    }
};
const encodedAST_ = (ast, isBound)=>{
    switch(ast._tag){
        case "Declaration":
            {
                const typeParameters = changeMap(ast.typeParameters, (ast)=>encodedAST_(ast, isBound));
                return typeParameters === ast.typeParameters ? ast : new Declaration(typeParameters, ast.decodeUnknown, ast.encodeUnknown, ast.annotations);
            }
        case "TupleType":
            {
                const elements = changeMap(ast.elements, (e)=>{
                    const type = encodedAST_(e.type, isBound);
                    return type === e.type ? e : new OptionalType(type, e.isOptional);
                });
                const restASTs = getRestASTs(ast.rest);
                const rest = changeMap(restASTs, (ast)=>encodedAST_(ast, isBound));
                return elements === ast.elements && rest === restASTs ? ast : new TupleType(elements, rest.map((ast)=>new Type(ast)), ast.isReadonly, createJSONIdentifierAnnotation(ast));
            }
        case "TypeLiteral":
            {
                const propertySignatures = changeMap(ast.propertySignatures, (ps)=>{
                    const type = encodedAST_(ps.type, isBound);
                    return type === ps.type ? ps : new PropertySignature(ps.name, type, ps.isOptional, ps.isReadonly);
                });
                const indexSignatures = changeMap(ast.indexSignatures, (is)=>{
                    const type = encodedAST_(is.type, isBound);
                    return type === is.type ? is : new IndexSignature(is.parameter, type, is.isReadonly);
                });
                return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral(propertySignatures, indexSignatures, createJSONIdentifierAnnotation(ast));
            }
        case "Union":
            {
                const types = changeMap(ast.types, (ast)=>encodedAST_(ast, isBound));
                return types === ast.types ? ast : Union.make(types, createJSONIdentifierAnnotation(ast));
            }
        case "Suspend":
            return new Suspend(()=>encodedAST_(ast.f(), isBound), createJSONIdentifierAnnotation(ast));
        case "Refinement":
            {
                const from = encodedAST_(ast.from, isBound);
                if (isBound) {
                    if (from === ast.from) return ast;
                    if (getTransformationFrom(ast.from) === undefined && hasStableFilter(ast)) return new Refinement(from, ast.filter, ast.annotations);
                }
                const identifier = createJSONIdentifierAnnotation(ast);
                return identifier ? annotations(from, identifier) : from;
            }
        case "Transformation":
            {
                const identifier = createJSONIdentifierAnnotation(ast);
                return encodedAST_(identifier ? annotations(ast.from, identifier) : ast.from, isBound);
            }
    }
    return ast;
};
const encodedAST = (ast)=>encodedAST_(ast, false);
const encodedBoundAST = (ast)=>encodedAST_(ast, true);
const toJSONAnnotations = (annotations)=>{
    const out = {};
    for (const k of Object.getOwnPropertySymbols(annotations))out[String(k)] = annotations[k];
    return out;
};
const getEncodedParameter = (ast)=>{
    switch(ast._tag){
        case "StringKeyword":
        case "SymbolKeyword":
        case "TemplateLiteral":
            return ast;
        case "Refinement":
            return getEncodedParameter(ast.from);
    }
};
const equals = (self, that)=>{
    switch(self._tag){
        case "Literal":
            return isLiteral(that) && that.literal === self.literal;
        case "UniqueSymbol":
            return isUniqueSymbol(that) && that.symbol === self.symbol;
        case "UndefinedKeyword":
        case "VoidKeyword":
        case "NeverKeyword":
        case "UnknownKeyword":
        case "AnyKeyword":
        case "StringKeyword":
        case "NumberKeyword":
        case "BooleanKeyword":
        case "BigIntKeyword":
        case "SymbolKeyword":
        case "ObjectKeyword":
            return that._tag === self._tag;
        case "TemplateLiteral":
            return isTemplateLiteral(that) && that.head === self.head && equalsTemplateLiteralSpan(that.spans, self.spans);
        case "Enums":
            return isEnums(that) && equalsEnums(that.enums, self.enums);
        case "Union":
            return isUnion(that) && equalsUnion(self.types, that.types);
        case "Refinement":
        case "TupleType":
        case "TypeLiteral":
        case "Suspend":
        case "Transformation":
        case "Declaration":
            return self === that;
    }
};
const equalsTemplateLiteralSpan = /*#__PURE__*/ _arrayJs.getEquivalence((self, that)=>{
    return self.literal === that.literal && equals(self.type, that.type);
});
const equalsEnums = /*#__PURE__*/ _arrayJs.getEquivalence((self, that)=>that[0] === self[0] && that[1] === self[1]);
const equalsUnion = /*#__PURE__*/ _arrayJs.getEquivalence(equals);
const intersection = /*#__PURE__*/ _arrayJs.intersectionWith(equals);
const _keyof = (ast)=>{
    switch(ast._tag){
        case "Declaration":
            {
                const annotation = getSurrogateAnnotation(ast);
                if (_optionJs.isSome(annotation)) return _keyof(annotation.value);
                break;
            }
        case "TypeLiteral":
            return ast.propertySignatures.map((p)=>_predicateJs.isSymbol(p.name) ? new UniqueSymbol(p.name) : new Literal(p.name)).concat(ast.indexSignatures.map((is)=>getEncodedParameter(is.parameter)));
        case "Suspend":
            return _keyof(ast.f());
        case "Union":
            return ast.types.slice(1).reduce((out, ast)=>intersection(out, _keyof(ast)), _keyof(ast.types[0]));
        case "Transformation":
            return _keyof(ast.to);
    }
    throw new Error(_errorsJs.getASTUnsupportedSchemaErrorMessage(ast));
};
const compose = (ab, cd)=>new Transformation(ab, cd, composeTransformation);
const rename = (ast, mapping)=>{
    switch(ast._tag){
        case "TypeLiteral":
            {
                const propertySignatureTransformations = [];
                for (const key of _utilJs.ownKeys(mapping)){
                    const name = mapping[key];
                    if (name !== undefined) propertySignatureTransformations.push(new PropertySignatureTransformation(key, name, (0, _functionJs.identity), (0, _functionJs.identity)));
                }
                if (propertySignatureTransformations.length === 0) return ast;
                return new Transformation(ast, new TypeLiteral(ast.propertySignatures.map((ps)=>{
                    const name = mapping[ps.name];
                    return new PropertySignature(name === undefined ? ps.name : name, typeAST(ps.type), ps.isOptional, ps.isReadonly, ps.annotations);
                }), ast.indexSignatures), new TypeLiteralTransformation(propertySignatureTransformations));
            }
        case "Union":
            return Union.make(ast.types.map((ast)=>rename(ast, mapping)));
        case "Suspend":
            return new Suspend(()=>rename(ast.f(), mapping));
        case "Transformation":
            return compose(ast, rename(typeAST(ast), mapping));
    }
    throw new Error(_errorsJs.getASTUnsupportedRenameSchemaErrorMessage(ast));
};
const formatKeyword = (ast)=>_optionJs.getOrElse(getExpected(ast), ()=>ast._tag);
function getBrands(ast) {
    return _optionJs.match(getBrandAnnotation(ast), {
        onNone: ()=>"",
        onSome: (brands)=>brands.map((brand)=>` & Brand<${_utilJs.formatUnknown(brand)}>`).join("")
    });
}
const getOrElseExpected = (ast)=>getTitleAnnotation(ast).pipe(_optionJs.orElse(()=>getDescriptionAnnotation(ast)), _optionJs.orElse(()=>getAutoTitleAnnotation(ast)), _optionJs.map((s)=>s + getBrands(ast)));
const getExpected = (ast)=>_optionJs.orElse(getIdentifierAnnotation(ast), ()=>getOrElseExpected(ast));
const pruneUndefined = (ast, self, onTransformation)=>{
    switch(ast._tag){
        case "UndefinedKeyword":
            return neverKeyword;
        case "Union":
            {
                const types = [];
                let hasUndefined = false;
                for (const type of ast.types){
                    const pruned = self(type);
                    if (pruned) {
                        hasUndefined = true;
                        if (!isNeverKeyword(pruned)) types.push(pruned);
                    } else types.push(type);
                }
                if (hasUndefined) return Union.make(types);
                break;
            }
        case "Suspend":
            return self(ast.f());
        case "Transformation":
            return onTransformation(ast);
    }
};

},{"./Array.js":"8L2Gk","./Function.js":"21gOL","./GlobalValue.js":"5w3Hn","./internal/schema/errors.js":"dIEWu","./internal/schema/util.js":"d71wj","./Number.js":"al4Y3","./Option.js":"6sHA7","./Order.js":"lQMwD","./Predicate.js":"gW5pd","./RegExp.js":"aPf0s","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"dIEWu":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getInvalidArgumentErrorMessage", ()=>getInvalidArgumentErrorMessage);
parcelHelpers.export(exports, "getArbitraryUnsupportedErrorMessage", ()=>getArbitraryUnsupportedErrorMessage);
parcelHelpers.export(exports, "getArbitraryMissingAnnotationErrorMessage", ()=>getArbitraryMissingAnnotationErrorMessage);
parcelHelpers.export(exports, "getArbitraryEmptyEnumErrorMessage", ()=>getArbitraryEmptyEnumErrorMessage);
parcelHelpers.export(exports, "getEquivalenceUnsupportedErrorMessage", ()=>getEquivalenceUnsupportedErrorMessage);
parcelHelpers.export(exports, "getJSONSchemaMissingAnnotationErrorMessage", ()=>getJSONSchemaMissingAnnotationErrorMessage);
parcelHelpers.export(exports, "getJSONSchemaMissingIdentifierAnnotationErrorMessage", ()=>getJSONSchemaMissingIdentifierAnnotationErrorMessage);
parcelHelpers.export(exports, "getJSONSchemaUnsupportedPostRestElementsErrorMessage", ()=>getJSONSchemaUnsupportedPostRestElementsErrorMessage);
parcelHelpers.export(exports, "getJSONSchemaUnsupportedKeyErrorMessage", ()=>getJSONSchemaUnsupportedKeyErrorMessage);
parcelHelpers.export(exports, "getPrettyMissingAnnotationErrorMessage", ()=>getPrettyMissingAnnotationErrorMessage);
parcelHelpers.export(exports, "getPrettyNeverErrorMessage", ()=>getPrettyNeverErrorMessage);
parcelHelpers.export(exports, "getPrettyNoMatchingSchemaErrorMessage", ()=>getPrettyNoMatchingSchemaErrorMessage);
parcelHelpers.export(exports, "getSchemaExtendErrorMessage", ()=>getSchemaExtendErrorMessage);
parcelHelpers.export(exports, "getSchemaUnsupportedLiteralSpanErrorMessage", ()=>getSchemaUnsupportedLiteralSpanErrorMessage);
parcelHelpers.export(exports, "getASTUnsupportedSchemaErrorMessage", ()=>getASTUnsupportedSchemaErrorMessage);
parcelHelpers.export(exports, "getASTUnsupportedKeySchemaErrorMessage", ()=>getASTUnsupportedKeySchemaErrorMessage);
parcelHelpers.export(exports, "getASTUnsupportedLiteralErrorMessage", ()=>getASTUnsupportedLiteralErrorMessage);
parcelHelpers.export(exports, "getASTDuplicateIndexSignatureErrorMessage", ()=>getASTDuplicateIndexSignatureErrorMessage);
parcelHelpers.export(exports, "getASTIndexSignatureParameterErrorMessage", ()=>getASTIndexSignatureParameterErrorMessage);
parcelHelpers.export(exports, "getASTRequiredElementFollowinAnOptionalElementErrorMessage", ()=>getASTRequiredElementFollowinAnOptionalElementErrorMessage);
parcelHelpers.export(exports, "getASTDuplicatePropertySignatureTransformationErrorMessage", ()=>getASTDuplicatePropertySignatureTransformationErrorMessage);
parcelHelpers.export(exports, "getASTUnsupportedRenameSchemaErrorMessage", ()=>getASTUnsupportedRenameSchemaErrorMessage);
parcelHelpers.export(exports, "getASTDuplicatePropertySignatureErrorMessage", ()=>getASTDuplicatePropertySignatureErrorMessage);
var _arrayJs = require("../../Array.js");
var _utilJs = require("./util.js");
const getErrorMessage = (reason, details, path, ast)=>{
    let out = reason;
    if (path && _arrayJs.isNonEmptyReadonlyArray(path)) out += `\nat path: ${_utilJs.formatPath(path)}`;
    if (details !== undefined) out += `\ndetails: ${details}`;
    if (ast) out += `\nschema (${ast._tag}): ${ast}`;
    return out;
};
const getInvalidArgumentErrorMessage = (details)=>getErrorMessage("Invalid Argument", details);
const getUnsupportedSchemaErrorMessage = (details, path, ast)=>getErrorMessage("Unsupported schema", details, path, ast);
const getMissingAnnotationErrorMessage = (details, path, ast)=>getErrorMessage("Missing annotation", details, path, ast);
const getArbitraryUnsupportedErrorMessage = (path, ast)=>getUnsupportedSchemaErrorMessage("Cannot build an Arbitrary for this schema", path, ast);
const getArbitraryMissingAnnotationErrorMessage = (path, ast)=>getMissingAnnotationErrorMessage(`Generating an Arbitrary for this schema requires an "arbitrary" annotation`, path, ast);
const getArbitraryEmptyEnumErrorMessage = (path)=>getErrorMessage("Empty Enums schema", "Generating an Arbitrary for this schema requires at least one enum", path);
const getEquivalenceUnsupportedErrorMessage = (ast, path)=>getUnsupportedSchemaErrorMessage("Cannot build an Equivalence", path, ast);
const getJSONSchemaMissingAnnotationErrorMessage = (path, ast)=>getMissingAnnotationErrorMessage(`Generating a JSON Schema for this schema requires a "jsonSchema" annotation`, path, ast);
const getJSONSchemaMissingIdentifierAnnotationErrorMessage = (path, ast)=>getMissingAnnotationErrorMessage(`Generating a JSON Schema for this schema requires an "identifier" annotation`, path, ast);
const getJSONSchemaUnsupportedPostRestElementsErrorMessage = (path)=>getErrorMessage("Generating a JSON Schema for post-rest elements is not currently supported. You're welcome to contribute by submitting a Pull Request", undefined, path);
const getJSONSchemaUnsupportedKeyErrorMessage = (key, path)=>getErrorMessage("Unsupported key", `Cannot encode ${_utilJs.formatPropertyKey(key)} key to JSON Schema`, path);
const getPrettyMissingAnnotationErrorMessage = (path, ast)=>getMissingAnnotationErrorMessage(`Generating a Pretty for this schema requires a "pretty" annotation`, path, ast);
const getPrettyNeverErrorMessage = "Cannot pretty print a `never` value";
const getPrettyNoMatchingSchemaErrorMessage = (actual, path, ast)=>getErrorMessage("Unexpected Error", `Cannot find a matching schema for ${_utilJs.formatUnknown(actual)}`, path, ast);
const getSchemaExtendErrorMessage = (x, y, path)=>getErrorMessage("Unsupported schema or overlapping types", `cannot extend ${x} with ${y}`, path);
const getSchemaUnsupportedLiteralSpanErrorMessage = (ast)=>getErrorMessage("Unsupported template literal span", undefined, undefined, ast);
const getASTUnsupportedSchemaErrorMessage = (ast)=>getUnsupportedSchemaErrorMessage(undefined, undefined, ast);
const getASTUnsupportedKeySchemaErrorMessage = (ast)=>getErrorMessage("Unsupported key schema", undefined, undefined, ast);
const getASTUnsupportedLiteralErrorMessage = (literal)=>getErrorMessage("Unsupported literal", `literal value: ${_utilJs.formatUnknown(literal)}`);
const getASTDuplicateIndexSignatureErrorMessage = (type)=>getErrorMessage("Duplicate index signature", `${type} index signature`);
const getASTIndexSignatureParameterErrorMessage = /*#__PURE__*/ getErrorMessage("Unsupported index signature parameter", "An index signature parameter type must be `string`, `symbol`, a template literal type or a refinement of the previous types");
const getASTRequiredElementFollowinAnOptionalElementErrorMessage = /*#__PURE__*/ getErrorMessage("Invalid element", "A required element cannot follow an optional element. ts(1257)");
const getASTDuplicatePropertySignatureTransformationErrorMessage = (key)=>getErrorMessage("Duplicate property signature transformation", `Duplicate key ${_utilJs.formatUnknown(key)}`);
const getASTUnsupportedRenameSchemaErrorMessage = (ast)=>getUnsupportedSchemaErrorMessage(undefined, undefined, ast);
const getASTDuplicatePropertySignatureErrorMessage = (key)=>getErrorMessage("Duplicate property signature", `Duplicate key ${_utilJs.formatUnknown(key)}`);

},{"../../Array.js":"8L2Gk","./util.js":"d71wj","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"2ijjW":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RedactedTypeId", ()=>RedactedTypeId);
parcelHelpers.export(exports, "isRedacted", ()=>isRedacted);
parcelHelpers.export(exports, "make", ()=>make);
parcelHelpers.export(exports, "value", ()=>value);
parcelHelpers.export(exports, "unsafeWipe", ()=>unsafeWipe);
parcelHelpers.export(exports, "getEquivalence", ()=>getEquivalence);
var _equivalenceJs = require("./Equivalence.js");
var _redactedJs = require("./internal/redacted.js");
const RedactedTypeId = _redactedJs.RedactedTypeId;
const isRedacted = _redactedJs.isRedacted;
const make = _redactedJs.make;
const value = _redactedJs.value;
const unsafeWipe = _redactedJs.unsafeWipe;
const getEquivalence = (isEquivalent)=>_equivalenceJs.make((x, y)=>isEquivalent(value(x), value(y)));

},{"./Equivalence.js":"1WBUa","./internal/redacted.js":"cJZqF","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"1qGF0":[function(require,module,exports,__globalThis) {
/**
 * @since 3.10.0
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/* c8 ignore start */ parcelHelpers.export(exports, "asserts", ()=>(0, _parseResultJs.asserts));
parcelHelpers.export(exports, "decodeOption", ()=>(0, _parseResultJs.decodeOption));
parcelHelpers.export(exports, "decodeSync", ()=>(0, _parseResultJs.decodeSync));
parcelHelpers.export(exports, "decodeUnknownOption", ()=>(0, _parseResultJs.decodeUnknownOption));
parcelHelpers.export(exports, "decodeUnknownSync", ()=>(0, _parseResultJs.decodeUnknownSync));
parcelHelpers.export(exports, "encodeOption", ()=>(0, _parseResultJs.encodeOption));
parcelHelpers.export(exports, "encodeSync", ()=>(0, _parseResultJs.encodeSync));
parcelHelpers.export(exports, "encodeUnknownOption", ()=>(0, _parseResultJs.encodeUnknownOption));
parcelHelpers.export(exports, "encodeUnknownSync", ()=>(0, _parseResultJs.encodeUnknownSync));
parcelHelpers.export(exports, "is", ()=>(0, _parseResultJs.is));
parcelHelpers.export(exports, "validateOption", ()=>(0, _parseResultJs.validateOption));
parcelHelpers.export(exports, "validateSync", ()=>(0, _parseResultJs.validateSync));
parcelHelpers.export(exports, "TypeId", ()=>TypeId);
/**
 * @category constructors
 * @since 3.10.0
 */ parcelHelpers.export(exports, "make", ()=>make);
parcelHelpers.export(exports, "standardSchemaV1", ()=>standardSchemaV1);
/**
 * @since 3.10.0
 */ parcelHelpers.export(exports, "asSchema", ()=>asSchema);
parcelHelpers.export(exports, "format", ()=>format);
parcelHelpers.export(exports, "encodedSchema", ()=>encodedSchema);
parcelHelpers.export(exports, "encodedBoundSchema", ()=>encodedBoundSchema);
parcelHelpers.export(exports, "typeSchema", ()=>typeSchema);
parcelHelpers.export(exports, "encodeUnknown", ()=>encodeUnknown);
parcelHelpers.export(exports, "encodeUnknownEither", ()=>encodeUnknownEither);
parcelHelpers.export(exports, "encodeUnknownPromise", ()=>encodeUnknownPromise);
parcelHelpers.export(exports, "encode", ()=>encode);
parcelHelpers.export(exports, "encodeEither", ()=>encodeEither);
parcelHelpers.export(exports, "encodePromise", ()=>encodePromise);
parcelHelpers.export(exports, "decodeUnknown", ()=>decodeUnknown);
parcelHelpers.export(exports, "decodeUnknownEither", ()=>decodeUnknownEither);
parcelHelpers.export(exports, "decodeUnknownPromise", ()=>decodeUnknownPromise);
parcelHelpers.export(exports, "decode", ()=>decode);
parcelHelpers.export(exports, "decodeEither", ()=>decodeEither);
parcelHelpers.export(exports, "decodePromise", ()=>decodePromise);
parcelHelpers.export(exports, "validate", ()=>validate);
parcelHelpers.export(exports, "validateEither", ()=>validateEither);
parcelHelpers.export(exports, "validatePromise", ()=>validatePromise);
parcelHelpers.export(exports, "isSchema", ()=>isSchema);
parcelHelpers.export(exports, "Literal", ()=>Literal);
parcelHelpers.export(exports, "pickLiteral", ()=>pickLiteral);
parcelHelpers.export(exports, "UniqueSymbolFromSelf", ()=>UniqueSymbolFromSelf);
parcelHelpers.export(exports, "Enums", ()=>Enums);
parcelHelpers.export(exports, "TemplateLiteral", ()=>TemplateLiteral);
parcelHelpers.export(exports, "TemplateLiteralParser", ()=>TemplateLiteralParser);
parcelHelpers.export(exports, "declare", ()=>declare);
parcelHelpers.export(exports, "BrandSchemaId", ()=>BrandSchemaId);
parcelHelpers.export(exports, "fromBrand", ()=>fromBrand);
parcelHelpers.export(exports, "InstanceOfSchemaId", ()=>InstanceOfSchemaId);
parcelHelpers.export(exports, "instanceOf", ()=>instanceOf);
/**
 * @category primitives
 * @since 3.10.0
 */ parcelHelpers.export(exports, "Undefined", ()=>Undefined);
/**
 * @category primitives
 * @since 3.10.0
 */ parcelHelpers.export(exports, "Void", ()=>Void);
/**
 * @category primitives
 * @since 3.10.0
 */ parcelHelpers.export(exports, "Null", ()=>Null);
/**
 * @category primitives
 * @since 3.10.0
 */ parcelHelpers.export(exports, "Never", ()=>Never);
/**
 * @category primitives
 * @since 3.10.0
 */ parcelHelpers.export(exports, "Unknown", ()=>Unknown);
/**
 * @category primitives
 * @since 3.10.0
 */ parcelHelpers.export(exports, "Any", ()=>Any);
/**
 * @category primitives
 * @since 3.10.0
 */ parcelHelpers.export(exports, "BigIntFromSelf", ()=>BigIntFromSelf);
/**
 * @category primitives
 * @since 3.10.0
 */ parcelHelpers.export(exports, "SymbolFromSelf", ()=>SymbolFromSelf);
parcelHelpers.export(exports, "Boolean", ()=>/**
 * @category primitives
 * @since 3.10.0
 */ Boolean$);
parcelHelpers.export(exports, "Number", ()=>/**
 * @category primitives
 * @since 3.10.0
 */ Number$);
parcelHelpers.export(exports, "Object", ()=>/**
 * @category primitives
 * @since 3.10.0
 */ Object$);
parcelHelpers.export(exports, "String", ()=>/**
 * @category primitives
 * @since 3.10.0
 */ String$);
parcelHelpers.export(exports, "Union", ()=>Union);
parcelHelpers.export(exports, "NullOr", ()=>NullOr);
parcelHelpers.export(exports, "UndefinedOr", ()=>UndefinedOr);
parcelHelpers.export(exports, "NullishOr", ()=>NullishOr);
parcelHelpers.export(exports, "keyof", ()=>keyof);
parcelHelpers.export(exports, "element", ()=>element);
parcelHelpers.export(exports, "optionalElement", ()=>optionalElement);
parcelHelpers.export(exports, "Tuple", ()=>Tuple);
parcelHelpers.export(exports, "Array", ()=>/**
 * @category constructors
 * @since 3.10.0
 */ Array$);
parcelHelpers.export(exports, "NonEmptyArray", ()=>NonEmptyArray);
/**
 * @category constructors
 * @since 3.10.0
 */ parcelHelpers.export(exports, "ArrayEnsure", ()=>ArrayEnsure);
/**
 * @category constructors
 * @since 3.10.0
 */ parcelHelpers.export(exports, "NonEmptyArrayEnsure", ()=>NonEmptyArrayEnsure);
/**
 * @category PropertySignature
 * @since 3.10.0
 */ parcelHelpers.export(exports, "PropertySignatureDeclaration", ()=>PropertySignatureDeclaration);
/**
 * @category PropertySignature
 * @since 3.10.0
 */ parcelHelpers.export(exports, "FromPropertySignature", ()=>FromPropertySignature);
/**
 * @category PropertySignature
 * @since 3.10.0
 */ parcelHelpers.export(exports, "ToPropertySignature", ()=>ToPropertySignature);
/**
 * @category PropertySignature
 * @since 3.10.0
 */ parcelHelpers.export(exports, "PropertySignatureTransformation", ()=>PropertySignatureTransformation);
parcelHelpers.export(exports, "PropertySignatureTypeId", ()=>PropertySignatureTypeId);
parcelHelpers.export(exports, "isPropertySignature", ()=>isPropertySignature);
parcelHelpers.export(exports, "makePropertySignature", ()=>makePropertySignature);
parcelHelpers.export(exports, "propertySignature", ()=>propertySignature);
parcelHelpers.export(exports, "withConstructorDefault", ()=>withConstructorDefault);
parcelHelpers.export(exports, "withDecodingDefault", ()=>withDecodingDefault);
parcelHelpers.export(exports, "withDefaults", ()=>withDefaults);
parcelHelpers.export(exports, "fromKey", ()=>fromKey);
parcelHelpers.export(exports, "optionalToRequired", ()=>optionalToRequired);
parcelHelpers.export(exports, "requiredToOptional", ()=>requiredToOptional);
parcelHelpers.export(exports, "optionalToOptional", ()=>optionalToOptional);
parcelHelpers.export(exports, "optional", ()=>optional);
parcelHelpers.export(exports, "optionalWith", ()=>optionalWith);
parcelHelpers.export(exports, "Struct", ()=>Struct);
parcelHelpers.export(exports, "tag", ()=>tag);
parcelHelpers.export(exports, "TaggedStruct", ()=>TaggedStruct);
parcelHelpers.export(exports, "Record", ()=>Record);
parcelHelpers.export(exports, "pick", ()=>pick);
parcelHelpers.export(exports, "omit", ()=>omit);
parcelHelpers.export(exports, "pluck", ()=>pluck);
parcelHelpers.export(exports, "brand", ()=>brand);
parcelHelpers.export(exports, "partial", ()=>partial);
parcelHelpers.export(exports, "partialWith", ()=>partialWith);
parcelHelpers.export(exports, "required", ()=>required);
parcelHelpers.export(exports, "mutable", ()=>mutable);
parcelHelpers.export(exports, "extend", ()=>extend);
parcelHelpers.export(exports, "compose", ()=>compose);
parcelHelpers.export(exports, "suspend", ()=>suspend);
parcelHelpers.export(exports, "RefineSchemaId", ()=>RefineSchemaId);
parcelHelpers.export(exports, "filter", ()=>filter);
parcelHelpers.export(exports, "filterEffect", ()=>filterEffect);
parcelHelpers.export(exports, "transformOrFail", ()=>transformOrFail);
parcelHelpers.export(exports, "transform", ()=>transform);
/**
 * Creates a new `Schema` which transforms literal values.
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import * as S from "effect/Schema"
 *
 * const schema = S.transformLiteral(0, "a")
 *
 * assert.deepStrictEqual(S.decodeSync(schema)(0), "a")
 * ```
 *
 * @category constructors
 * @since 3.10.0
 */ parcelHelpers.export(exports, "transformLiteral", ()=>transformLiteral);
parcelHelpers.export(exports, "transformLiterals", ()=>transformLiterals);
parcelHelpers.export(exports, "attachPropertySignature", ()=>attachPropertySignature);
parcelHelpers.export(exports, "annotations", ()=>annotations);
parcelHelpers.export(exports, "rename", ()=>rename);
parcelHelpers.export(exports, "TrimmedSchemaId", ()=>TrimmedSchemaId);
parcelHelpers.export(exports, "trimmed", ()=>trimmed);
parcelHelpers.export(exports, "MaxLengthSchemaId", ()=>MaxLengthSchemaId);
parcelHelpers.export(exports, "maxLength", ()=>maxLength);
parcelHelpers.export(exports, "MinLengthSchemaId", ()=>MinLengthSchemaId);
parcelHelpers.export(exports, "minLength", ()=>minLength);
parcelHelpers.export(exports, "LengthSchemaId", ()=>LengthSchemaId);
parcelHelpers.export(exports, "length", ()=>length);
parcelHelpers.export(exports, "PatternSchemaId", ()=>PatternSchemaId);
parcelHelpers.export(exports, "pattern", ()=>pattern);
parcelHelpers.export(exports, "StartsWithSchemaId", ()=>StartsWithSchemaId);
parcelHelpers.export(exports, "startsWith", ()=>startsWith);
parcelHelpers.export(exports, "EndsWithSchemaId", ()=>EndsWithSchemaId);
parcelHelpers.export(exports, "endsWith", ()=>endsWith);
parcelHelpers.export(exports, "IncludesSchemaId", ()=>IncludesSchemaId);
parcelHelpers.export(exports, "includes", ()=>includes);
parcelHelpers.export(exports, "LowercasedSchemaId", ()=>LowercasedSchemaId);
parcelHelpers.export(exports, "lowercased", ()=>lowercased);
/**
 * @category string constructors
 * @since 3.10.0
 */ parcelHelpers.export(exports, "Lowercased", ()=>Lowercased);
parcelHelpers.export(exports, "UppercasedSchemaId", ()=>UppercasedSchemaId);
parcelHelpers.export(exports, "uppercased", ()=>uppercased);
/**
 * @category string constructors
 * @since 3.10.0
 */ parcelHelpers.export(exports, "Uppercased", ()=>Uppercased);
parcelHelpers.export(exports, "CapitalizedSchemaId", ()=>CapitalizedSchemaId);
parcelHelpers.export(exports, "capitalized", ()=>capitalized);
/**
 * @category string constructors
 * @since 3.10.0
 */ parcelHelpers.export(exports, "Capitalized", ()=>Capitalized);
parcelHelpers.export(exports, "UncapitalizedSchemaId", ()=>UncapitalizedSchemaId);
parcelHelpers.export(exports, "uncapitalized", ()=>uncapitalized);
/**
 * @category string constructors
 * @since 3.10.0
 */ parcelHelpers.export(exports, "Uncapitalized", ()=>Uncapitalized);
/**
 * A schema representing a single character.
 *
 * @category string constructors
 * @since 3.10.0
 */ parcelHelpers.export(exports, "Char", ()=>Char);
parcelHelpers.export(exports, "nonEmptyString", ()=>nonEmptyString);
/**
 * This schema converts a string to lowercase.
 *
 * @category string transformations
 * @since 3.10.0
 */ parcelHelpers.export(exports, "Lowercase", ()=>Lowercase);
/**
 * This schema converts a string to uppercase.
 *
 * @category string transformations
 * @since 3.10.0
 */ parcelHelpers.export(exports, "Uppercase", ()=>Uppercase);
/**
 * This schema converts a string to capitalized one.
 *
 * @category string transformations
 * @since 3.10.0
 */ parcelHelpers.export(exports, "Capitalize", ()=>Capitalize);
/**
 * This schema converts a string to uncapitalized one.
 *
 * @category string transformations
 * @since 3.10.0
 */ parcelHelpers.export(exports, "Uncapitalize", ()=>Uncapitalize);
/**
 * @category string constructors
 * @since 3.10.0
 */ parcelHelpers.export(exports, "Trimmed", ()=>Trimmed);
/**
 * Useful for validating strings that must contain meaningful characters without
 * leading or trailing whitespace.
 *
 * @example
 * ```ts
 * import { Schema } from "effect"
 *
 * console.log(Schema.decodeOption(Schema.NonEmptyTrimmedString)("")) // Option.none()
 * console.log(Schema.decodeOption(Schema.NonEmptyTrimmedString)(" a ")) // Option.none()
 * console.log(Schema.decodeOption(Schema.NonEmptyTrimmedString)("a")) // Option.some("a")
 * ```
 *
 * @category string constructors
 * @since 3.10.0
 */ parcelHelpers.export(exports, "NonEmptyTrimmedString", ()=>NonEmptyTrimmedString);
/**
 * This schema allows removing whitespaces from the beginning and end of a string.
 *
 * @category string transformations
 * @since 3.10.0
 */ parcelHelpers.export(exports, "Trim", ()=>Trim);
parcelHelpers.export(exports, "split", ()=>split);
parcelHelpers.export(exports, "parseJson", ()=>parseJson);
/**
 * @category string constructors
 * @since 3.10.0
 */ parcelHelpers.export(exports, "NonEmptyString", ()=>NonEmptyString);
parcelHelpers.export(exports, "UUIDSchemaId", ()=>UUIDSchemaId);
/**
 * Represents a Universally Unique Identifier (UUID).
 *
 * This schema ensures that the provided string adheres to the standard UUID format.
 *
 * @category string constructors
 * @since 3.10.0
 */ parcelHelpers.export(exports, "UUID", ()=>UUID);
parcelHelpers.export(exports, "ULIDSchemaId", ()=>ULIDSchemaId);
/**
 * Represents a Universally Unique Lexicographically Sortable Identifier (ULID).
 *
 * ULIDs are designed to be compact, URL-safe, and ordered, making them suitable for use as identifiers.
 * This schema ensures that the provided string adheres to the standard ULID format.
 *
 * @category string constructors
 * @since 3.10.0
 */ parcelHelpers.export(exports, "ULID", ()=>ULID);
/**
 * Defines a schema that represents a `URL` object.
 *
 * @category URL constructors
 * @since 3.11.0
 */ parcelHelpers.export(exports, "URLFromSelf", ()=>URLFromSelf);
parcelHelpers.export(exports, "URL", ()=>/**
 * Defines a schema that attempts to convert a `string` to a `URL` object using
 * the `new URL` constructor.
 *
 * @category URL transformations
 * @since 3.11.0
 */ URL$);
parcelHelpers.export(exports, "FiniteSchemaId", ()=>FiniteSchemaId);
parcelHelpers.export(exports, "finite", ()=>finite);
parcelHelpers.export(exports, "GreaterThanSchemaId", ()=>GreaterThanSchemaId);
parcelHelpers.export(exports, "greaterThan", ()=>greaterThan);
parcelHelpers.export(exports, "GreaterThanOrEqualToSchemaId", ()=>GreaterThanOrEqualToSchemaId);
parcelHelpers.export(exports, "greaterThanOrEqualTo", ()=>greaterThanOrEqualTo);
parcelHelpers.export(exports, "MultipleOfSchemaId", ()=>MultipleOfSchemaId);
parcelHelpers.export(exports, "multipleOf", ()=>multipleOf);
parcelHelpers.export(exports, "IntSchemaId", ()=>IntSchemaId);
parcelHelpers.export(exports, "int", ()=>int);
parcelHelpers.export(exports, "LessThanSchemaId", ()=>LessThanSchemaId);
parcelHelpers.export(exports, "lessThan", ()=>lessThan);
parcelHelpers.export(exports, "LessThanOrEqualToSchemaId", ()=>LessThanOrEqualToSchemaId);
parcelHelpers.export(exports, "lessThanOrEqualTo", ()=>lessThanOrEqualTo);
parcelHelpers.export(exports, "BetweenSchemaId", ()=>BetweenSchemaId);
parcelHelpers.export(exports, "between", ()=>between);
parcelHelpers.export(exports, "NonNaNSchemaId", ()=>NonNaNSchemaId);
parcelHelpers.export(exports, "nonNaN", ()=>nonNaN);
parcelHelpers.export(exports, "positive", ()=>positive);
parcelHelpers.export(exports, "negative", ()=>negative);
parcelHelpers.export(exports, "nonPositive", ()=>nonPositive);
parcelHelpers.export(exports, "nonNegative", ()=>nonNegative);
parcelHelpers.export(exports, "clamp", ()=>clamp);
/**
 * Transforms a `string` into a `number` by parsing the string using the `parse`
 * function of the `effect/Number` module.
 *
 * It returns an error if the value can't be converted (for example when
 * non-numeric characters are provided).
 *
 * The following special string values are supported: "NaN", "Infinity",
 * "-Infinity".
 *
 * @category number transformations
 * @since 3.10.0
 */ parcelHelpers.export(exports, "parseNumber", ()=>parseNumber);
/**
 * This schema transforms a `string` into a `number` by parsing the string using the `parse` function of the `effect/Number` module.
 *
 * It returns an error if the value can't be converted (for example when non-numeric characters are provided).
 *
 * The following special string values are supported: "NaN", "Infinity", "-Infinity".
 *
 * @category number transformations
 * @since 3.10.0
 */ parcelHelpers.export(exports, "NumberFromString", ()=>NumberFromString);
/**
 * @category number constructors
 * @since 3.10.0
 */ parcelHelpers.export(exports, "Finite", ()=>Finite);
/**
 * @category number constructors
 * @since 3.10.0
 */ parcelHelpers.export(exports, "Int", ()=>Int);
/**
 * @category number constructors
 * @since 3.10.0
 */ parcelHelpers.export(exports, "NonNaN", ()=>NonNaN);
/**
 * @category number constructors
 * @since 3.10.0
 */ parcelHelpers.export(exports, "Positive", ()=>Positive);
/**
 * @category number constructors
 * @since 3.10.0
 */ parcelHelpers.export(exports, "Negative", ()=>Negative);
/**
 * @category number constructors
 * @since 3.10.0
 */ parcelHelpers.export(exports, "NonPositive", ()=>NonPositive);
/**
 * @category number constructors
 * @since 3.10.0
 */ parcelHelpers.export(exports, "NonNegative", ()=>NonNegative);
parcelHelpers.export(exports, "JsonNumberSchemaId", ()=>JsonNumberSchemaId);
/**
 * The `JsonNumber` is a schema for representing JSON numbers. It ensures that the provided value is a valid
 * number by filtering out `NaN` and `(+/-) Infinity`. This is useful when you want to validate and represent numbers in JSON
 * format.
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import * as Schema from "effect/Schema"
 *
 * const is = Schema.is(S.JsonNumber)
 *
 * assert.deepStrictEqual(is(42), true)
 * assert.deepStrictEqual(is(Number.NaN), false)
 * assert.deepStrictEqual(is(Number.POSITIVE_INFINITY), false)
 * assert.deepStrictEqual(is(Number.NEGATIVE_INFINITY), false)
 * ```
 *
 * @category number constructors
 * @since 3.10.0
 */ parcelHelpers.export(exports, "JsonNumber", ()=>JsonNumber);
/**
 * @category boolean transformations
 * @since 3.10.0
 */ parcelHelpers.export(exports, "Not", ()=>Not);
parcelHelpers.export(exports, "Symbol", ()=>/**
 * Converts a string key into a globally shared symbol.
 *
 * @category symbol transformations
 * @since 3.10.0
 */ Symbol$);
parcelHelpers.export(exports, "GreaterThanBigIntSchemaId", ()=>GreaterThanBigIntSchemaId);
parcelHelpers.export(exports, "greaterThanBigInt", ()=>greaterThanBigInt);
parcelHelpers.export(exports, "GreaterThanOrEqualToBigIntSchemaId", ()=>GreaterThanOrEqualToBigIntSchemaId);
parcelHelpers.export(exports, "greaterThanOrEqualToBigInt", ()=>greaterThanOrEqualToBigInt);
parcelHelpers.export(exports, "LessThanBigIntSchemaId", ()=>LessThanBigIntSchemaId);
parcelHelpers.export(exports, "lessThanBigInt", ()=>lessThanBigInt);
parcelHelpers.export(exports, "LessThanOrEqualToBigIntSchemaId", ()=>LessThanOrEqualToBigIntSchemaId);
parcelHelpers.export(exports, "lessThanOrEqualToBigInt", ()=>lessThanOrEqualToBigInt);
parcelHelpers.export(exports, "BetweenBigIntSchemaId", ()=>BetweenBigIntSchemaId);
parcelHelpers.export(exports, "betweenBigInt", ()=>betweenBigInt);
parcelHelpers.export(exports, "positiveBigInt", ()=>positiveBigInt);
parcelHelpers.export(exports, "negativeBigInt", ()=>negativeBigInt);
parcelHelpers.export(exports, "nonNegativeBigInt", ()=>nonNegativeBigInt);
parcelHelpers.export(exports, "nonPositiveBigInt", ()=>nonPositiveBigInt);
parcelHelpers.export(exports, "clampBigInt", ()=>clampBigInt);
parcelHelpers.export(exports, "BigInt", ()=>/**
 * This schema transforms a `string` into a `bigint` by parsing the string using the `BigInt` function.
 *
 * It returns an error if the value can't be converted (for example when non-numeric characters are provided).
 *
 * @category bigint transformations
 * @since 3.10.0
 */ BigInt$);
parcelHelpers.export(exports, "PositiveBigIntFromSelf", ()=>PositiveBigIntFromSelf);
parcelHelpers.export(exports, "PositiveBigInt", ()=>PositiveBigInt);
parcelHelpers.export(exports, "NegativeBigIntFromSelf", ()=>NegativeBigIntFromSelf);
parcelHelpers.export(exports, "NegativeBigInt", ()=>NegativeBigInt);
parcelHelpers.export(exports, "NonPositiveBigIntFromSelf", ()=>NonPositiveBigIntFromSelf);
parcelHelpers.export(exports, "NonPositiveBigInt", ()=>NonPositiveBigInt);
parcelHelpers.export(exports, "NonNegativeBigIntFromSelf", ()=>NonNegativeBigIntFromSelf);
parcelHelpers.export(exports, "NonNegativeBigInt", ()=>NonNegativeBigInt);
/**
 * This schema transforms a `number` into a `bigint` by parsing the number using the `BigInt` function.
 *
 * It returns an error if the value can't be safely encoded as a `number` due to being out of range.
 *
 * @category bigint transformations
 * @since 3.10.0
 */ parcelHelpers.export(exports, "BigIntFromNumber", ()=>BigIntFromNumber);
parcelHelpers.export(exports, "RedactedFromSelf", ()=>RedactedFromSelf);
/**
 * A transformation that transform a `Schema<A, I, R>` into a
 * `RedactedFromSelf<A>`.
 *
 * @category Redacted transformations
 * @since 3.10.0
 */ parcelHelpers.export(exports, "Redacted", ()=>Redacted);
/**
 * @category Duration constructors
 * @since 3.10.0
 */ parcelHelpers.export(exports, "DurationFromSelf", ()=>DurationFromSelf);
/**
 * A schema that transforms a non negative `bigint` into a `Duration`. Treats
 * the value as the number of nanoseconds.
 *
 * @category Duration transformations
 * @since 3.10.0
 */ parcelHelpers.export(exports, "DurationFromNanos", ()=>DurationFromNanos);
parcelHelpers.export(exports, "NonNegativeInt", ()=>NonNegativeInt);
/**
 * A schema that transforms a (possibly Infinite) non negative number into a
 * `Duration`. Treats the value as the number of milliseconds.
 *
 * @category Duration transformations
 * @since 3.10.0
 */ parcelHelpers.export(exports, "DurationFromMillis", ()=>DurationFromMillis);
// TODO(4.0): remove HRTime union member
/**
 * A schema that converts a JSON-compatible tagged union into a `Duration`.
 *
 * @category Duration transformations
 * @since 3.10.0
 */ parcelHelpers.export(exports, "Duration", ()=>Duration);
parcelHelpers.export(exports, "clampDuration", ()=>clampDuration);
parcelHelpers.export(exports, "LessThanDurationSchemaId", ()=>LessThanDurationSchemaId);
parcelHelpers.export(exports, "lessThanDuration", ()=>lessThanDuration);
parcelHelpers.export(exports, "LessThanOrEqualToDurationSchemaId", ()=>LessThanOrEqualToDurationSchemaId);
parcelHelpers.export(exports, "lessThanOrEqualToDuration", ()=>lessThanOrEqualToDuration);
parcelHelpers.export(exports, "GreaterThanDurationSchemaId", ()=>GreaterThanDurationSchemaId);
parcelHelpers.export(exports, "greaterThanDuration", ()=>greaterThanDuration);
parcelHelpers.export(exports, "GreaterThanOrEqualToDurationSchemaId", ()=>GreaterThanOrEqualToDurationSchemaId);
parcelHelpers.export(exports, "greaterThanOrEqualToDuration", ()=>greaterThanOrEqualToDuration);
parcelHelpers.export(exports, "BetweenDurationSchemaId", ()=>BetweenDurationSchemaId);
parcelHelpers.export(exports, "betweenDuration", ()=>betweenDuration);
/**
 * @category Uint8Array constructors
 * @since 3.10.0
 */ parcelHelpers.export(exports, "Uint8ArrayFromSelf", ()=>Uint8ArrayFromSelf);
/**
 * @category number constructors
 * @since 3.11.10
 */ parcelHelpers.export(exports, "Uint8", ()=>Uint8);
parcelHelpers.export(exports, "Uint8Array", ()=>/**
 * A schema that transforms an array of numbers into a `Uint8Array`.
 *
 * @category Uint8Array transformations
 * @since 3.10.0
 */ Uint8Array$);
parcelHelpers.export(exports, "Uint8ArrayFromBase64", ()=>Uint8ArrayFromBase64);
parcelHelpers.export(exports, "Uint8ArrayFromBase64Url", ()=>Uint8ArrayFromBase64Url);
parcelHelpers.export(exports, "Uint8ArrayFromHex", ()=>Uint8ArrayFromHex);
parcelHelpers.export(exports, "StringFromBase64", ()=>StringFromBase64);
parcelHelpers.export(exports, "StringFromBase64Url", ()=>StringFromBase64Url);
parcelHelpers.export(exports, "StringFromHex", ()=>StringFromHex);
parcelHelpers.export(exports, "StringFromUriComponent", ()=>StringFromUriComponent);
parcelHelpers.export(exports, "MinItemsSchemaId", ()=>MinItemsSchemaId);
parcelHelpers.export(exports, "minItems", ()=>minItems);
parcelHelpers.export(exports, "MaxItemsSchemaId", ()=>MaxItemsSchemaId);
parcelHelpers.export(exports, "maxItems", ()=>maxItems);
parcelHelpers.export(exports, "ItemsCountSchemaId", ()=>ItemsCountSchemaId);
parcelHelpers.export(exports, "itemsCount", ()=>itemsCount);
parcelHelpers.export(exports, "getNumberIndexedAccess", ()=>getNumberIndexedAccess);
/**
 * Get the first element of a `ReadonlyArray`, or `None` if the array is empty.
 *
 * @category ReadonlyArray transformations
 * @since 3.10.0
 */ parcelHelpers.export(exports, "head", ()=>head);
/**
 * Get the first element of a `NonEmptyReadonlyArray`.
 *
 * @category NonEmptyReadonlyArray transformations
 * @since 3.12.0
 */ parcelHelpers.export(exports, "headNonEmpty", ()=>headNonEmpty);
parcelHelpers.export(exports, "headOrElse", ()=>headOrElse);
parcelHelpers.export(exports, "ValidDateSchemaId", ()=>ValidDateSchemaId);
parcelHelpers.export(exports, "validDate", ()=>validDate);
parcelHelpers.export(exports, "LessThanDateSchemaId", ()=>LessThanDateSchemaId);
parcelHelpers.export(exports, "lessThanDate", ()=>lessThanDate);
parcelHelpers.export(exports, "LessThanOrEqualToDateSchemaId", ()=>LessThanOrEqualToDateSchemaId);
parcelHelpers.export(exports, "lessThanOrEqualToDate", ()=>lessThanOrEqualToDate);
parcelHelpers.export(exports, "GreaterThanDateSchemaId", ()=>GreaterThanDateSchemaId);
parcelHelpers.export(exports, "greaterThanDate", ()=>greaterThanDate);
parcelHelpers.export(exports, "GreaterThanOrEqualToDateSchemaId", ()=>GreaterThanOrEqualToDateSchemaId);
parcelHelpers.export(exports, "greaterThanOrEqualToDate", ()=>greaterThanOrEqualToDate);
parcelHelpers.export(exports, "BetweenDateSchemaId", ()=>BetweenDateSchemaId);
parcelHelpers.export(exports, "betweenDate", ()=>betweenDate);
parcelHelpers.export(exports, "DateFromSelfSchemaId", ()=>DateFromSelfSchemaId);
/**
 * Describes a schema that accommodates potentially invalid `Date` instances,
 * such as `new Date("Invalid Date")`, without rejection.
 *
 * @category Date constructors
 * @since 3.10.0
 */ parcelHelpers.export(exports, "DateFromSelf", ()=>DateFromSelf);
/**
 * Defines a schema that ensures only valid dates are accepted. This schema
 * rejects values like `new Date("Invalid Date")`, which, despite being a `Date`
 * instance, represents an invalid date. Such stringent validation ensures that
 * all date objects processed through this schema are properly formed and
 * represent real dates.
 *
 * @category Date constructors
 * @since 3.10.0
 */ parcelHelpers.export(exports, "ValidDateFromSelf", ()=>ValidDateFromSelf);
/**
 * Defines a schema that attempts to convert a `string` to a `Date` object using
 * the `new Date` constructor. This conversion is lenient, meaning it does not
 * reject strings that do not form valid dates (e.g., using `new Date("Invalid
 * Date")` results in a `Date` object, despite being invalid).
 *
 * @category Date transformations
 * @since 3.10.0
 */ parcelHelpers.export(exports, "DateFromString", ()=>DateFromString);
parcelHelpers.export(exports, "Date", ()=>/**
 * This schema converts a `string` into a `Date` object using the `new Date`
 * constructor. It ensures that only valid date strings are accepted,
 * rejecting any strings that would result in an invalid date, such as `new
 * Date("Invalid Date")`.
 *
 * @category Date transformations
 * @since 3.10.0
 */ Date$);
/**
 * Defines a schema that converts a `number` into a `Date` object using the `new
 * Date` constructor. This schema does not validate the numerical input,
 * allowing potentially invalid values such as `NaN`, `Infinity`, and
 * `-Infinity` to be converted into `Date` objects. During the encoding process,
 * any invalid `Date` object will be encoded to `NaN`.
 *
 * @category Date transformations
 * @since 3.10.0
 */ parcelHelpers.export(exports, "DateFromNumber", ()=>DateFromNumber);
/**
 * Describes a schema that represents a `DateTime.Utc` instance.
 *
 * @category DateTime.Utc constructors
 * @since 3.10.0
 */ parcelHelpers.export(exports, "DateTimeUtcFromSelf", ()=>DateTimeUtcFromSelf);
/**
 * Defines a schema that attempts to convert a `number` to a `DateTime.Utc` instance using the `DateTime.unsafeMake` constructor.
 *
 * @category DateTime.Utc transformations
 * @since 3.10.0
 */ parcelHelpers.export(exports, "DateTimeUtcFromNumber", ()=>DateTimeUtcFromNumber);
/**
 * Defines a schema that attempts to convert a `Date` to a `DateTime.Utc` instance using the `DateTime.unsafeMake` constructor.
 *
 * @category DateTime.Utc transformations
 * @since 3.12.0
 */ parcelHelpers.export(exports, "DateTimeUtcFromDate", ()=>DateTimeUtcFromDate);
/**
 * Defines a schema that attempts to convert a `string` to a `DateTime.Utc` instance using the `DateTime.unsafeMake` constructor.
 *
 * @category DateTime.Utc transformations
 * @since 3.10.0
 */ parcelHelpers.export(exports, "DateTimeUtc", ()=>DateTimeUtc);
/**
 * Describes a schema that represents a `TimeZone.Offset` instance.
 *
 * @category TimeZone constructors
 * @since 3.10.0
 */ parcelHelpers.export(exports, "TimeZoneOffsetFromSelf", ()=>TimeZoneOffsetFromSelf);
/**
 * Defines a schema that converts a `number` to a `TimeZone.Offset` instance using the `DateTime.zoneMakeOffset` constructor.
 *
 * @category TimeZone transformations
 * @since 3.10.0
 */ parcelHelpers.export(exports, "TimeZoneOffset", ()=>TimeZoneOffset);
/**
 * Describes a schema that represents a `TimeZone.Named` instance.
 *
 * @category TimeZone constructors
 * @since 3.10.0
 */ parcelHelpers.export(exports, "TimeZoneNamedFromSelf", ()=>TimeZoneNamedFromSelf);
/**
 * Defines a schema that attempts to convert a `string` to a `TimeZone.Named` instance using the `DateTime.zoneUnsafeMakeNamed` constructor.
 *
 * @category TimeZone transformations
 * @since 3.10.0
 */ parcelHelpers.export(exports, "TimeZoneNamed", ()=>TimeZoneNamed);
/**
 * @category TimeZone constructors
 * @since 3.10.0
 */ parcelHelpers.export(exports, "TimeZoneFromSelf", ()=>TimeZoneFromSelf);
/**
 * Defines a schema that attempts to convert a `string` to a `TimeZone` using the `DateTime.zoneFromString` constructor.
 *
 * @category TimeZone transformations
 * @since 3.10.0
 */ parcelHelpers.export(exports, "TimeZone", ()=>TimeZone);
/**
 * Describes a schema that represents a `DateTime.Zoned` instance.
 *
 * @category DateTime.Zoned constructors
 * @since 3.10.0
 */ parcelHelpers.export(exports, "DateTimeZonedFromSelf", ()=>DateTimeZonedFromSelf);
/**
 * Defines a schema that attempts to convert a `string` to a `DateTime.Zoned` instance.
 *
 * @category DateTime.Zoned transformations
 * @since 3.10.0
 */ parcelHelpers.export(exports, "DateTimeZoned", ()=>DateTimeZoned);
parcelHelpers.export(exports, "OptionFromSelf", ()=>OptionFromSelf);
/**
 * @category Option transformations
 * @since 3.10.0
 */ parcelHelpers.export(exports, "Option", ()=>Option);
/**
 * @category Option transformations
 * @since 3.10.0
 */ parcelHelpers.export(exports, "OptionFromNullOr", ()=>OptionFromNullOr);
/**
 * @category Option transformations
 * @since 3.10.0
 */ parcelHelpers.export(exports, "OptionFromNullishOr", ()=>OptionFromNullishOr);
/**
 * @category Option transformations
 * @since 3.10.0
 */ parcelHelpers.export(exports, "OptionFromUndefinedOr", ()=>OptionFromUndefinedOr);
/**
 * Transforms strings into an Option type, effectively filtering out empty or
 * whitespace-only strings by trimming them and checking their length. Returns
 * `none` for invalid inputs and `some` for valid non-empty strings.
 *
 * @example
 * ```ts
 * import { Schema } from "effect"
 *
 * console.log(Schema.decodeSync(Schema.OptionFromNonEmptyTrimmedString)("")) // Option.none()
 * console.log(Schema.decodeSync(Schema.OptionFromNonEmptyTrimmedString)(" a ")) // Option.some("a")
 * console.log(Schema.decodeSync(Schema.OptionFromNonEmptyTrimmedString)("a")) // Option.some("a")
 * ```
 *
 * @category Option transformations
 * @since 3.10.0
 */ parcelHelpers.export(exports, "OptionFromNonEmptyTrimmedString", ()=>OptionFromNonEmptyTrimmedString);
parcelHelpers.export(exports, "EitherFromSelf", ()=>EitherFromSelf);
parcelHelpers.export(exports, "Either", ()=>Either);
parcelHelpers.export(exports, "EitherFromUnion", ()=>EitherFromUnion);
parcelHelpers.export(exports, "ReadonlyMapFromSelf", ()=>ReadonlyMapFromSelf);
parcelHelpers.export(exports, "MapFromSelf", ()=>MapFromSelf);
/**
 * @category ReadonlyMap transformations
 * @since 3.10.0
 */ parcelHelpers.export(exports, "ReadonlyMap", ()=>ReadonlyMap);
parcelHelpers.export(exports, "Map", ()=>/**
 * @category Map transformations
 * @since 3.10.0
 */ map);
parcelHelpers.export(exports, "ReadonlyMapFromRecord", ()=>ReadonlyMapFromRecord);
parcelHelpers.export(exports, "MapFromRecord", ()=>MapFromRecord);
parcelHelpers.export(exports, "ReadonlySetFromSelf", ()=>ReadonlySetFromSelf);
parcelHelpers.export(exports, "SetFromSelf", ()=>SetFromSelf);
/**
 * @category ReadonlySet transformations
 * @since 3.10.0
 */ parcelHelpers.export(exports, "ReadonlySet", ()=>ReadonlySet);
parcelHelpers.export(exports, "Set", ()=>/**
 * @category Set transformations
 * @since 3.10.0
 */ set);
/**
 * @category BigDecimal constructors
 * @since 3.10.0
 */ parcelHelpers.export(exports, "BigDecimalFromSelf", ()=>BigDecimalFromSelf);
/**
 * @category BigDecimal transformations
 * @since 3.10.0
 */ parcelHelpers.export(exports, "BigDecimal", ()=>BigDecimal);
/**
 * A schema that transforms a `number` into a `BigDecimal`.
 * When encoding, this Schema will produce incorrect results if the BigDecimal exceeds the 64-bit range of a number.
 *
 * @category BigDecimal transformations
 * @since 3.10.0
 */ parcelHelpers.export(exports, "BigDecimalFromNumber", ()=>BigDecimalFromNumber);
parcelHelpers.export(exports, "GreaterThanBigDecimalSchemaId", ()=>GreaterThanBigDecimalSchemaId);
parcelHelpers.export(exports, "greaterThanBigDecimal", ()=>greaterThanBigDecimal);
parcelHelpers.export(exports, "GreaterThanOrEqualToBigDecimalSchemaId", ()=>GreaterThanOrEqualToBigDecimalSchemaId);
parcelHelpers.export(exports, "greaterThanOrEqualToBigDecimal", ()=>greaterThanOrEqualToBigDecimal);
parcelHelpers.export(exports, "LessThanBigDecimalSchemaId", ()=>LessThanBigDecimalSchemaId);
parcelHelpers.export(exports, "lessThanBigDecimal", ()=>lessThanBigDecimal);
parcelHelpers.export(exports, "LessThanOrEqualToBigDecimalSchemaId", ()=>LessThanOrEqualToBigDecimalSchemaId);
parcelHelpers.export(exports, "lessThanOrEqualToBigDecimal", ()=>lessThanOrEqualToBigDecimal);
parcelHelpers.export(exports, "PositiveBigDecimalSchemaId", ()=>PositiveBigDecimalSchemaId);
parcelHelpers.export(exports, "positiveBigDecimal", ()=>positiveBigDecimal);
parcelHelpers.export(exports, "PositiveBigDecimalFromSelf", ()=>PositiveBigDecimalFromSelf);
parcelHelpers.export(exports, "NonNegativeBigDecimalSchemaId", ()=>NonNegativeBigDecimalSchemaId);
parcelHelpers.export(exports, "nonNegativeBigDecimal", ()=>nonNegativeBigDecimal);
parcelHelpers.export(exports, "NonNegativeBigDecimalFromSelf", ()=>NonNegativeBigDecimalFromSelf);
parcelHelpers.export(exports, "NegativeBigDecimalSchemaId", ()=>NegativeBigDecimalSchemaId);
parcelHelpers.export(exports, "negativeBigDecimal", ()=>negativeBigDecimal);
parcelHelpers.export(exports, "NegativeBigDecimalFromSelf", ()=>NegativeBigDecimalFromSelf);
parcelHelpers.export(exports, "NonPositiveBigDecimalSchemaId", ()=>NonPositiveBigDecimalSchemaId);
parcelHelpers.export(exports, "nonPositiveBigDecimal", ()=>nonPositiveBigDecimal);
parcelHelpers.export(exports, "NonPositiveBigDecimalFromSelf", ()=>NonPositiveBigDecimalFromSelf);
parcelHelpers.export(exports, "BetweenBigDecimalSchemaId", ()=>BetweenBigDecimalSchemaId);
parcelHelpers.export(exports, "betweenBigDecimal", ()=>betweenBigDecimal);
parcelHelpers.export(exports, "clampBigDecimal", ()=>clampBigDecimal);
parcelHelpers.export(exports, "ChunkFromSelf", ()=>ChunkFromSelf);
/**
 * @category Chunk transformations
 * @since 3.10.0
 */ parcelHelpers.export(exports, "Chunk", ()=>Chunk);
parcelHelpers.export(exports, "NonEmptyChunkFromSelf", ()=>NonEmptyChunkFromSelf);
/**
 * @category Chunk transformations
 * @since 3.10.0
 */ parcelHelpers.export(exports, "NonEmptyChunk", ()=>NonEmptyChunk);
parcelHelpers.export(exports, "DataFromSelf", ()=>DataFromSelf);
parcelHelpers.export(exports, "Data", ()=>Data);
parcelHelpers.export(exports, "Class", ()=>Class);
parcelHelpers.export(exports, "getClassTag", ()=>getClassTag);
parcelHelpers.export(exports, "TaggedClass", ()=>TaggedClass);
parcelHelpers.export(exports, "TaggedError", ()=>TaggedError);
/**
 * @category FiberId constructors
 * @since 3.10.0
 */ parcelHelpers.export(exports, "FiberIdFromSelf", ()=>FiberIdFromSelf);
/**
 * @category FiberId transformations
 * @since 3.10.0
 */ parcelHelpers.export(exports, "FiberId", ()=>FiberId);
parcelHelpers.export(exports, "CauseFromSelf", ()=>CauseFromSelf);
parcelHelpers.export(exports, "Cause", ()=>Cause);
/**
 * Defines a schema for handling JavaScript errors (`Error` instances) and other types of defects.
 * It decodes objects into Error instances if they match the expected structure (i.e., have a `message` and optionally a `name` and `stack`),
 * or converts other values to their string representations.
 *
 * When encoding, it converts `Error` instances back into plain objects containing only the error's name and message,
 * or other values into their string forms.
 *
 * This is useful for serializing and deserializing errors across network boundaries where error objects do not natively serialize.
 *
 * @category defect
 * @since 3.10.0
 */ parcelHelpers.export(exports, "Defect", ()=>Defect);
parcelHelpers.export(exports, "ExitFromSelf", ()=>ExitFromSelf);
parcelHelpers.export(exports, "Exit", ()=>Exit);
parcelHelpers.export(exports, "HashSetFromSelf", ()=>HashSetFromSelf);
/**
 * @category HashSet transformations
 * @since 3.10.0
 */ parcelHelpers.export(exports, "HashSet", ()=>HashSet);
parcelHelpers.export(exports, "HashMapFromSelf", ()=>HashMapFromSelf);
parcelHelpers.export(exports, "HashMap", ()=>HashMap);
parcelHelpers.export(exports, "ListFromSelf", ()=>ListFromSelf);
/**
 * @category List transformations
 * @since 3.10.0
 */ parcelHelpers.export(exports, "List", ()=>List);
parcelHelpers.export(exports, "SortedSetFromSelf", ()=>SortedSetFromSelf);
/**
 * @category SortedSet transformations
 * @since 3.10.0
 */ parcelHelpers.export(exports, "SortedSet", ()=>SortedSet);
/**
 * Converts an arbitrary value to a `boolean` by testing whether it is truthy.
 * Uses `!!val` to coerce the value to a `boolean`.
 *
 * @see https://developer.mozilla.org/docs/Glossary/Truthy
 *
 * @category boolean constructors
 * @since 3.10.0
 */ parcelHelpers.export(exports, "BooleanFromUnknown", ()=>BooleanFromUnknown);
/**
 * Converts an `string` value into its corresponding `boolean`
 * ("true" as `true` and "false" as `false`).
 *
 * @category boolean transformations
 * @since 3.11.0
 */ parcelHelpers.export(exports, "BooleanFromString", ()=>BooleanFromString);
parcelHelpers.export(exports, "Config", ()=>Config);
parcelHelpers.export(exports, "symbolSerializable", ()=>symbolSerializable);
parcelHelpers.export(exports, "asSerializable", ()=>asSerializable);
parcelHelpers.export(exports, "serializableSchema", ()=>serializableSchema);
parcelHelpers.export(exports, "serialize", ()=>serialize);
parcelHelpers.export(exports, "deserialize", ()=>deserialize);
parcelHelpers.export(exports, "symbolWithResult", ()=>symbolWithResult);
parcelHelpers.export(exports, "asWithResult", ()=>asWithResult);
parcelHelpers.export(exports, "failureSchema", ()=>failureSchema);
parcelHelpers.export(exports, "successSchema", ()=>successSchema);
parcelHelpers.export(exports, "exitSchema", ()=>exitSchema);
parcelHelpers.export(exports, "serializeFailure", ()=>serializeFailure);
parcelHelpers.export(exports, "deserializeFailure", ()=>deserializeFailure);
parcelHelpers.export(exports, "serializeSuccess", ()=>serializeSuccess);
parcelHelpers.export(exports, "deserializeSuccess", ()=>deserializeSuccess);
parcelHelpers.export(exports, "serializeExit", ()=>serializeExit);
parcelHelpers.export(exports, "deserializeExit", ()=>deserializeExit);
parcelHelpers.export(exports, "asSerializableWithResult", ()=>asSerializableWithResult);
parcelHelpers.export(exports, "TaggedRequest", ()=>TaggedRequest);
parcelHelpers.export(exports, "equivalence", ()=>equivalence);
parcelHelpers.export(exports, "PropertyKey", ()=>/**
 * @since 3.12.5
 */ PropertyKey$);
/**
 * @category ArrayFormatter
 * @since 3.12.5
 */ parcelHelpers.export(exports, "ArrayFormatterIssue", ()=>ArrayFormatterIssue);
var _arrayJs = require("./Array.js");
var _bigDecimalJs = require("./BigDecimal.js");
var _bigIntJs = require("./BigInt.js");
var _booleanJs = require("./Boolean.js");
var _causeJs = require("./Cause.js");
var _chunkJs = require("./Chunk.js");
var _configJs = require("./Config.js");
var _configErrorJs = require("./ConfigError.js");
var _dataJs = require("./Data.js");
var _dateTimeJs = require("./DateTime.js");
var _durationJs = require("./Duration.js");
var _effectJs = require("./Effect.js");
var _eitherJs = require("./Either.js");
var _encodingJs = require("./Encoding.js");
var _equalJs = require("./Equal.js");
var _equivalenceJs = require("./Equivalence.js");
var _exitJs = require("./Exit.js");
var _fastCheckJs = require("./FastCheck.js");
var _fiberIdJs = require("./FiberId.js");
var _functionJs = require("./Function.js");
var _globalValueJs = require("./GlobalValue.js");
var _hashMapJs = require("./HashMap.js");
var _hashSetJs = require("./HashSet.js");
var _causeJs1 = require("./internal/cause.js");
var _errorsJs = require("./internal/schema/errors.js");
var _schemaIdJs = require("./internal/schema/schemaId.js");
var _utilJs = require("./internal/schema/util.js");
var _listJs = require("./List.js");
var _numberJs = require("./Number.js");
var _optionJs = require("./Option.js");
var _parseResultJs = require("./ParseResult.js");
var _pipeableJs = require("./Pipeable.js");
var _predicateJs = require("./Predicate.js");
var _redactedJs = require("./Redacted.js");
var _requestJs = require("./Request.js");
var _schedulerJs = require("./Scheduler.js");
var _schemaASTJs = require("./SchemaAST.js");
var _sortedSetJs = require("./SortedSet.js");
var _stringJs = require("./String.js");
var _structJs = require("./Struct.js");
const TypeId = /*#__PURE__*/ Symbol.for("effect/Schema");
function make(ast) {
    return class SchemaClass {
        [TypeId] = variance;
        static ast = ast;
        static annotations(annotations) {
            return make(mergeSchemaAnnotations(this.ast, annotations));
        }
        static pipe() {
            return (0, _pipeableJs.pipeArguments)(this, arguments);
        }
        static toString() {
            return String(ast);
        }
        static Type;
        static Encoded;
        static Context;
        static [TypeId] = variance;
    };
}
const variance = {
    /* c8 ignore next */ _A: (_)=>_,
    /* c8 ignore next */ _I: (_)=>_,
    /* c8 ignore next */ _R: (_)=>_
};
const makeStandardResult = (exit)=>_exitJs.isSuccess(exit) ? exit.value : makeStandardFailureResult(_causeJs.pretty(exit.cause));
const makeStandardFailureResult = (message)=>({
        issues: [
            {
                message
            }
        ]
    });
const makeStandardFailureFromParseIssue = (issue)=>_effectJs.map(_parseResultJs.ArrayFormatter.formatIssue(issue), (issues)=>({
            issues: issues.map((issue)=>({
                    path: issue.path,
                    message: issue.message
                }))
        }));
const standardSchemaV1 = (schema, overrideOptions)=>{
    const decodeUnknown = _parseResultJs.decodeUnknown(schema, {
        errors: "all"
    });
    return class StandardSchemaV1Class extends make(schema.ast) {
        static "~standard" = {
            version: 1,
            vendor: "effect",
            validate (value) {
                const scheduler = new _schedulerJs.SyncScheduler();
                const fiber = _effectJs.runFork(_effectJs.matchEffect(decodeUnknown(value, overrideOptions), {
                    onFailure: makeStandardFailureFromParseIssue,
                    onSuccess: (value)=>_effectJs.succeed({
                            value
                        })
                }), {
                    scheduler
                });
                scheduler.flush();
                const exit = fiber.unsafePoll();
                if (exit) return makeStandardResult(exit);
                return new Promise((resolve)=>{
                    fiber.addObserver((exit)=>{
                        resolve(makeStandardResult(exit));
                    });
                });
            }
        };
    };
};
const builtInAnnotations = {
    schemaId: _schemaASTJs.SchemaIdAnnotationId,
    message: _schemaASTJs.MessageAnnotationId,
    missingMessage: _schemaASTJs.MissingMessageAnnotationId,
    identifier: _schemaASTJs.IdentifierAnnotationId,
    title: _schemaASTJs.TitleAnnotationId,
    description: _schemaASTJs.DescriptionAnnotationId,
    examples: _schemaASTJs.ExamplesAnnotationId,
    default: _schemaASTJs.DefaultAnnotationId,
    documentation: _schemaASTJs.DocumentationAnnotationId,
    jsonSchema: _schemaASTJs.JSONSchemaAnnotationId,
    arbitrary: _schemaASTJs.ArbitraryAnnotationId,
    pretty: _schemaASTJs.PrettyAnnotationId,
    equivalence: _schemaASTJs.EquivalenceAnnotationId,
    concurrency: _schemaASTJs.ConcurrencyAnnotationId,
    batching: _schemaASTJs.BatchingAnnotationId,
    parseIssueTitle: _schemaASTJs.ParseIssueTitleAnnotationId,
    parseOptions: _schemaASTJs.ParseOptionsAnnotationId,
    decodingFallback: _schemaASTJs.DecodingFallbackAnnotationId
};
const toASTAnnotations = (annotations)=>{
    if (!annotations) return {};
    const out = {
        ...annotations
    };
    for(const key in builtInAnnotations)if (key in annotations) {
        const id = builtInAnnotations[key];
        out[id] = annotations[key];
        delete out[key];
    }
    return out;
};
const mergeSchemaAnnotations = (ast, annotations)=>_schemaASTJs.annotations(ast, toASTAnnotations(annotations));
function asSchema(schema) {
    return schema;
}
const format = (schema)=>String(schema.ast);
const encodedSchema = (schema)=>make(_schemaASTJs.encodedAST(schema.ast));
const encodedBoundSchema = (schema)=>make(_schemaASTJs.encodedBoundAST(schema.ast));
const typeSchema = (schema)=>make(_schemaASTJs.typeAST(schema.ast));
const encodeUnknown = (schema, options)=>{
    const encodeUnknown = _parseResultJs.encodeUnknown(schema, options);
    return (u, overrideOptions)=>_parseResultJs.mapError(encodeUnknown(u, overrideOptions), _parseResultJs.parseError);
};
const encodeUnknownEither = (schema, options)=>{
    const encodeUnknownEither = _parseResultJs.encodeUnknownEither(schema, options);
    return (u, overrideOptions)=>_eitherJs.mapLeft(encodeUnknownEither(u, overrideOptions), _parseResultJs.parseError);
};
const encodeUnknownPromise = (schema, options)=>{
    const parser = encodeUnknown(schema, options);
    return (u, overrideOptions)=>_effectJs.runPromise(parser(u, overrideOptions));
};
const encode = encodeUnknown;
const encodeEither = encodeUnknownEither;
const encodePromise = encodeUnknownPromise;
const decodeUnknown = (schema, options)=>{
    const decodeUnknown = _parseResultJs.decodeUnknown(schema, options);
    return (u, overrideOptions)=>_parseResultJs.mapError(decodeUnknown(u, overrideOptions), _parseResultJs.parseError);
};
const decodeUnknownEither = (schema, options)=>{
    const decodeUnknownEither = _parseResultJs.decodeUnknownEither(schema, options);
    return (u, overrideOptions)=>_eitherJs.mapLeft(decodeUnknownEither(u, overrideOptions), _parseResultJs.parseError);
};
const decodeUnknownPromise = (schema, options)=>{
    const parser = decodeUnknown(schema, options);
    return (u, overrideOptions)=>_effectJs.runPromise(parser(u, overrideOptions));
};
const decode = decodeUnknown;
const decodeEither = decodeUnknownEither;
const decodePromise = decodeUnknownPromise;
const validate = (schema, options)=>{
    const validate = _parseResultJs.validate(schema, options);
    return (u, overrideOptions)=>_parseResultJs.mapError(validate(u, overrideOptions), _parseResultJs.parseError);
};
const validateEither = (schema, options)=>{
    const validateEither = _parseResultJs.validateEither(schema, options);
    return (u, overrideOptions)=>_eitherJs.mapLeft(validateEither(u, overrideOptions), _parseResultJs.parseError);
};
const validatePromise = (schema, options)=>{
    const parser = validate(schema, options);
    return (u, overrideOptions)=>_effectJs.runPromise(parser(u, overrideOptions));
};
const isSchema = (u)=>_predicateJs.hasProperty(u, TypeId) && _predicateJs.isObject(u[TypeId]);
function getDefaultLiteralAST(literals) {
    return _schemaASTJs.isMembers(literals) ? _schemaASTJs.Union.make(_schemaASTJs.mapMembers(literals, (literal)=>new _schemaASTJs.Literal(literal))) : new _schemaASTJs.Literal(literals[0]);
}
function makeLiteralClass(literals, ast = getDefaultLiteralAST(literals)) {
    return class LiteralClass extends make(ast) {
        static annotations(annotations) {
            return makeLiteralClass(this.literals, mergeSchemaAnnotations(this.ast, annotations));
        }
        static literals = [
            ...literals
        ];
    };
}
function Literal(...literals) {
    return _arrayJs.isNonEmptyReadonlyArray(literals) ? makeLiteralClass(literals) : Never;
}
const pickLiteral = (...literals)=>(_schema)=>Literal(...literals);
const UniqueSymbolFromSelf = (symbol)=>make(new _schemaASTJs.UniqueSymbol(symbol));
const getDefaultEnumsAST = (enums)=>new _schemaASTJs.Enums(Object.keys(enums).filter((key)=>typeof enums[enums[key]] !== "number").map((key)=>[
            key,
            enums[key]
        ]));
const makeEnumsClass = (enums, ast = getDefaultEnumsAST(enums))=>class EnumsClass extends make(ast) {
        static annotations(annotations) {
            return makeEnumsClass(this.enums, mergeSchemaAnnotations(this.ast, annotations));
        }
        static enums = {
            ...enums
        };
    };
const Enums = (enums)=>makeEnumsClass(enums);
const TemplateLiteral = (...[head, ...tail])=>{
    const spans = [];
    let h = "";
    let ts = tail;
    if (isSchema(head)) {
        if (_schemaASTJs.isLiteral(head.ast)) h = String(head.ast.literal);
        else ts = [
            head,
            ...ts
        ];
    } else h = String(head);
    for(let i = 0; i < ts.length; i++){
        const item = ts[i];
        if (isSchema(item)) {
            if (i < ts.length - 1) {
                const next = ts[i + 1];
                if (isSchema(next)) {
                    if (_schemaASTJs.isLiteral(next.ast)) {
                        spans.push(new _schemaASTJs.TemplateLiteralSpan(item.ast, String(next.ast.literal)));
                        i++;
                        continue;
                    }
                } else {
                    spans.push(new _schemaASTJs.TemplateLiteralSpan(item.ast, String(next)));
                    i++;
                    continue;
                }
            }
            spans.push(new _schemaASTJs.TemplateLiteralSpan(item.ast, ""));
        } else spans.push(new _schemaASTJs.TemplateLiteralSpan(new _schemaASTJs.Literal(item), ""));
    }
    if (_arrayJs.isNonEmptyArray(spans)) return make(new _schemaASTJs.TemplateLiteral(h, spans));
    else return make(new _schemaASTJs.TemplateLiteral("", [
        new _schemaASTJs.TemplateLiteralSpan(new _schemaASTJs.Literal(h), "")
    ]));
};
function getTemplateLiteralParserCoercedElement(encoded, schema) {
    const ast = encoded.ast;
    switch(ast._tag){
        case "Literal":
            {
                const literal = ast.literal;
                if (!_predicateJs.isString(literal)) {
                    const s = String(literal);
                    return transform(Literal(s), schema, {
                        strict: true,
                        decode: ()=>literal,
                        encode: ()=>s
                    });
                }
                break;
            }
        case "NumberKeyword":
            return compose(NumberFromString, schema);
        case "Union":
            {
                const members = [];
                let hasCoercions = false;
                for (const member of ast.types){
                    const schema = make(member);
                    const encoded = encodedSchema(schema);
                    const coerced = getTemplateLiteralParserCoercedElement(encoded, schema);
                    if (coerced) hasCoercions = true;
                    members.push(coerced ?? schema);
                }
                return hasCoercions ? compose(Union(...members), schema) : schema;
            }
    }
}
const TemplateLiteralParser = (...params)=>{
    const encodedSchemas = [];
    const elements = [];
    const schemas = [];
    let coerced = false;
    for(let i = 0; i < params.length; i++){
        const param = params[i];
        const schema = isSchema(param) ? param : Literal(param);
        schemas.push(schema);
        const encoded = encodedSchema(schema);
        encodedSchemas.push(encoded);
        const element = getTemplateLiteralParserCoercedElement(encoded, schema);
        if (element) {
            elements.push(element);
            coerced = true;
        } else elements.push(schema);
    }
    const from = TemplateLiteral(...encodedSchemas);
    const re = _schemaASTJs.getTemplateLiteralCapturingRegExp(from.ast);
    let to = Tuple(...elements);
    if (coerced) to = to.annotations({
        [_schemaASTJs.AutoTitleAnnotationId]: format(Tuple(...schemas))
    });
    return class TemplateLiteralParserClass extends transformOrFail(from, to, {
        strict: false,
        decode: (i, _, ast)=>{
            const match = re.exec(i);
            return match ? _parseResultJs.succeed(match.slice(1, params.length + 1)) : _parseResultJs.fail(new _parseResultJs.Type(ast, i, `${re.source}: no match for ${JSON.stringify(i)}`));
        },
        encode: (tuple)=>_parseResultJs.succeed(tuple.join(""))
    }) {
        static params = params.slice();
    };
};
const declareConstructor = (typeParameters, options, annotations)=>makeDeclareClass(typeParameters, new _schemaASTJs.Declaration(typeParameters.map((tp)=>tp.ast), (...typeParameters)=>options.decode(...typeParameters.map(make)), (...typeParameters)=>options.encode(...typeParameters.map(make)), toASTAnnotations(annotations)));
const declarePrimitive = (is, annotations)=>{
    const decodeUnknown = ()=>(input, _, ast)=>is(input) ? _parseResultJs.succeed(input) : _parseResultJs.fail(new _parseResultJs.Type(ast, input));
    const encodeUnknown = decodeUnknown;
    return makeDeclareClass([], new _schemaASTJs.Declaration([], decodeUnknown, encodeUnknown, toASTAnnotations(annotations)));
};
function makeDeclareClass(typeParameters, ast) {
    return class DeclareClass extends make(ast) {
        static annotations(annotations) {
            return makeDeclareClass(this.typeParameters, mergeSchemaAnnotations(this.ast, annotations));
        }
        static typeParameters = [
            ...typeParameters
        ];
    };
}
const declare = function() {
    if (Array.isArray(arguments[0])) {
        const typeParameters = arguments[0];
        const options = arguments[1];
        const annotations = arguments[2];
        return declareConstructor(typeParameters, options, annotations);
    }
    const is = arguments[0];
    const annotations = arguments[1];
    return declarePrimitive(is, annotations);
};
const BrandSchemaId = /*#__PURE__*/ Symbol.for("effect/SchemaId/Brand");
const fromBrand = (constructor, annotations)=>(self)=>{
        const out = makeBrandClass(self, new _schemaASTJs.Refinement(self.ast, function predicate(a, _, ast) {
            const either = constructor.either(a);
            return _eitherJs.isLeft(either) ? _optionJs.some(new _parseResultJs.Type(ast, a, either.left.map((v)=>v.message).join(", "))) : _optionJs.none();
        }, toASTAnnotations({
            schemaId: BrandSchemaId,
            [BrandSchemaId]: {
                constructor
            },
            ...annotations
        })));
        return out;
    };
const InstanceOfSchemaId = /*#__PURE__*/ Symbol.for("effect/SchemaId/InstanceOf");
const instanceOf = (constructor, annotations)=>declare((u)=>u instanceof constructor, {
        title: constructor.name,
        description: `an instance of ${constructor.name}`,
        pretty: ()=>String,
        schemaId: InstanceOfSchemaId,
        [InstanceOfSchemaId]: {
            constructor
        },
        ...annotations
    });
class Undefined extends /*#__PURE__*/ make(_schemaASTJs.undefinedKeyword) {
}
class Void extends /*#__PURE__*/ make(_schemaASTJs.voidKeyword) {
}
class Null extends /*#__PURE__*/ make(_schemaASTJs.null) {
}
class Never extends /*#__PURE__*/ make(_schemaASTJs.neverKeyword) {
}
class Unknown extends /*#__PURE__*/ make(_schemaASTJs.unknownKeyword) {
}
class Any extends /*#__PURE__*/ make(_schemaASTJs.anyKeyword) {
}
class BigIntFromSelf extends /*#__PURE__*/ make(_schemaASTJs.bigIntKeyword) {
}
class SymbolFromSelf extends /*#__PURE__*/ make(_schemaASTJs.symbolKeyword) {
}
/** @ignore */ class String$ extends /*#__PURE__*/ make(_schemaASTJs.stringKeyword) {
}
/** @ignore */ class Number$ extends /*#__PURE__*/ make(_schemaASTJs.numberKeyword) {
}
/** @ignore */ class Boolean$ extends /*#__PURE__*/ make(_schemaASTJs.booleanKeyword) {
}
/** @ignore */ class Object$ extends /*#__PURE__*/ make(_schemaASTJs.objectKeyword) {
}
const getDefaultUnionAST = (members)=>_schemaASTJs.Union.make(members.map((m)=>m.ast));
function makeUnionClass(members, ast = getDefaultUnionAST(members)) {
    return class UnionClass extends make(ast) {
        static annotations(annotations) {
            return makeUnionClass(this.members, mergeSchemaAnnotations(this.ast, annotations));
        }
        static members = [
            ...members
        ];
    };
}
function Union(...members) {
    return _schemaASTJs.isMembers(members) ? makeUnionClass(members) : _arrayJs.isNonEmptyReadonlyArray(members) ? members[0] : Never;
}
const NullOr = (self)=>Union(self, Null);
const UndefinedOr = (self)=>Union(self, Undefined);
const NullishOr = (self)=>Union(self, Null, Undefined);
const keyof = (self)=>make(_schemaASTJs.keyof(self.ast));
const element = (self)=>new ElementImpl(new _schemaASTJs.OptionalType(self.ast, false), self);
const optionalElement = (self)=>new ElementImpl(new _schemaASTJs.OptionalType(self.ast, true), self);
class ElementImpl {
    ast;
    from;
    [TypeId];
    _Token;
    constructor(ast, from){
        this.ast = ast;
        this.from = from;
    }
    annotations(annotations) {
        return new ElementImpl(new _schemaASTJs.OptionalType(this.ast.type, this.ast.isOptional, {
            ...this.ast.annotations,
            ...toASTAnnotations(annotations)
        }), this.from);
    }
    toString() {
        return `${this.ast.type}${this.ast.isOptional ? "?" : ""}`;
    }
}
const getDefaultTupleTypeAST = (elements, rest)=>new _schemaASTJs.TupleType(elements.map((el)=>isSchema(el) ? new _schemaASTJs.OptionalType(el.ast, false) : el.ast), rest.map((el)=>isSchema(el) ? new _schemaASTJs.Type(el.ast) : el.ast), true);
function makeTupleTypeClass(elements, rest, ast = getDefaultTupleTypeAST(elements, rest)) {
    return class TupleTypeClass extends make(ast) {
        static annotations(annotations) {
            return makeTupleTypeClass(this.elements, this.rest, mergeSchemaAnnotations(this.ast, annotations));
        }
        static elements = [
            ...elements
        ];
        static rest = [
            ...rest
        ];
    };
}
function Tuple(...args) {
    return Array.isArray(args[0]) ? makeTupleTypeClass(args[0], args.slice(1)) : makeTupleTypeClass(args, []);
}
function makeArrayClass(value, ast) {
    return class ArrayClass extends makeTupleTypeClass([], [
        value
    ], ast) {
        static annotations(annotations) {
            return makeArrayClass(this.value, mergeSchemaAnnotations(this.ast, annotations));
        }
        static value = value;
    };
}
const Array$ = (value)=>makeArrayClass(value);
function makeNonEmptyArrayClass(value, ast) {
    return class NonEmptyArrayClass extends makeTupleTypeClass([
        value
    ], [
        value
    ], ast) {
        static annotations(annotations) {
            return makeNonEmptyArrayClass(this.value, mergeSchemaAnnotations(this.ast, annotations));
        }
        static value = value;
    };
}
const NonEmptyArray = (value)=>makeNonEmptyArrayClass(value);
function ArrayEnsure(value) {
    return transform(Union(value, Array$(value)), Array$(typeSchema(asSchema(value))), {
        strict: true,
        decode: (i)=>_arrayJs.ensure(i),
        encode: (a)=>a.length === 1 ? a[0] : a
    });
}
function NonEmptyArrayEnsure(value) {
    return transform(Union(value, NonEmptyArray(value)), NonEmptyArray(typeSchema(asSchema(value))), {
        strict: true,
        decode: (i)=>_arrayJs.isNonEmptyReadonlyArray(i) ? i : _arrayJs.of(i),
        encode: (a)=>a.length === 1 ? a[0] : a
    });
}
const formatPropertySignatureToken = (isOptional)=>isOptional ? "\"?:\"" : "\":\"";
class PropertySignatureDeclaration extends _schemaASTJs.OptionalType {
    isReadonly;
    defaultValue;
    /**
   * @since 3.10.0
   */ _tag = "PropertySignatureDeclaration";
    constructor(type, isOptional, isReadonly, annotations, defaultValue){
        super(type, isOptional, annotations);
        this.isReadonly = isReadonly;
        this.defaultValue = defaultValue;
    }
    /**
   * @since 3.10.0
   */ toString() {
        const token = formatPropertySignatureToken(this.isOptional);
        const type = String(this.type);
        return `PropertySignature<${token}, ${type}, never, ${token}, ${type}>`;
    }
}
class FromPropertySignature extends _schemaASTJs.OptionalType {
    isReadonly;
    fromKey;
    constructor(type, isOptional, isReadonly, annotations, fromKey){
        super(type, isOptional, annotations);
        this.isReadonly = isReadonly;
        this.fromKey = fromKey;
    }
}
class ToPropertySignature extends _schemaASTJs.OptionalType {
    isReadonly;
    defaultValue;
    constructor(type, isOptional, isReadonly, annotations, defaultValue){
        super(type, isOptional, annotations);
        this.isReadonly = isReadonly;
        this.defaultValue = defaultValue;
    }
}
const formatPropertyKey = (p)=>{
    if (p === undefined) return "never";
    if (_predicateJs.isString(p)) return JSON.stringify(p);
    return String(p);
};
class PropertySignatureTransformation {
    from;
    to;
    decode;
    encode;
    /**
   * @since 3.10.0
   */ _tag = "PropertySignatureTransformation";
    constructor(from, to, decode, encode){
        this.from = from;
        this.to = to;
        this.decode = decode;
        this.encode = encode;
    }
    /**
   * @since 3.10.0
   */ toString() {
        return `PropertySignature<${formatPropertySignatureToken(this.to.isOptional)}, ${this.to.type}, ${formatPropertyKey(this.from.fromKey)}, ${formatPropertySignatureToken(this.from.isOptional)}, ${this.from.type}>`;
    }
}
const mergeSignatureAnnotations = (ast, annotations)=>{
    switch(ast._tag){
        case "PropertySignatureDeclaration":
            return new PropertySignatureDeclaration(ast.type, ast.isOptional, ast.isReadonly, {
                ...ast.annotations,
                ...annotations
            }, ast.defaultValue);
        case "PropertySignatureTransformation":
            return new PropertySignatureTransformation(ast.from, new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, {
                ...ast.to.annotations,
                ...annotations
            }, ast.to.defaultValue), ast.decode, ast.encode);
    }
};
const PropertySignatureTypeId = /*#__PURE__*/ Symbol.for("effect/PropertySignature");
const isPropertySignature = (u)=>_predicateJs.hasProperty(u, PropertySignatureTypeId);
class PropertySignatureImpl {
    ast;
    [TypeId];
    [PropertySignatureTypeId] = null;
    _TypeToken;
    _Key;
    _EncodedToken;
    _HasDefault;
    constructor(ast){
        this.ast = ast;
    }
    pipe() {
        return (0, _pipeableJs.pipeArguments)(this, arguments);
    }
    annotations(annotations) {
        return new PropertySignatureImpl(mergeSignatureAnnotations(this.ast, toASTAnnotations(annotations)));
    }
    toString() {
        return String(this.ast);
    }
}
const makePropertySignature = (ast)=>new PropertySignatureImpl(ast);
class PropertySignatureWithFromImpl extends PropertySignatureImpl {
    from;
    constructor(ast, from){
        super(ast);
        this.from = from;
    }
    annotations(annotations) {
        return new PropertySignatureWithFromImpl(mergeSignatureAnnotations(this.ast, toASTAnnotations(annotations)), this.from);
    }
}
const propertySignature = (self)=>new PropertySignatureWithFromImpl(new PropertySignatureDeclaration(self.ast, false, true, {}, undefined), self);
const withConstructorDefault = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, defaultValue)=>{
    const ast = self.ast;
    switch(ast._tag){
        case "PropertySignatureDeclaration":
            return makePropertySignature(new PropertySignatureDeclaration(ast.type, ast.isOptional, ast.isReadonly, ast.annotations, defaultValue));
        case "PropertySignatureTransformation":
            return makePropertySignature(new PropertySignatureTransformation(ast.from, new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, ast.to.annotations, defaultValue), ast.decode, ast.encode));
    }
});
const applyDefaultValue = (o, defaultValue)=>_optionJs.match(o, {
        onNone: ()=>_optionJs.some(defaultValue()),
        onSome: (value)=>_optionJs.some(value === undefined ? defaultValue() : value)
    });
const pruneUndefined = (ast)=>_schemaASTJs.pruneUndefined(ast, pruneUndefined, (ast)=>{
        const pruned = pruneUndefined(ast.to);
        if (pruned) return new _schemaASTJs.Transformation(ast.from, pruned, ast.transformation);
    });
const withDecodingDefault = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, defaultValue)=>{
    const ast = self.ast;
    switch(ast._tag){
        case "PropertySignatureDeclaration":
            {
                const to = _schemaASTJs.typeAST(ast.type);
                return makePropertySignature(new PropertySignatureTransformation(new FromPropertySignature(ast.type, ast.isOptional, ast.isReadonly, ast.annotations), new ToPropertySignature(pruneUndefined(to) ?? to, false, true, {}, ast.defaultValue), (o)=>applyDefaultValue(o, defaultValue), (0, _functionJs.identity)));
            }
        case "PropertySignatureTransformation":
            {
                const to = ast.to.type;
                return makePropertySignature(new PropertySignatureTransformation(ast.from, new ToPropertySignature(pruneUndefined(to) ?? to, false, ast.to.isReadonly, ast.to.annotations, ast.to.defaultValue), (o)=>applyDefaultValue(ast.decode(o), defaultValue), ast.encode));
            }
    }
});
const withDefaults = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, defaults)=>self.pipe(withDecodingDefault(defaults.decoding), withConstructorDefault(defaults.constructor)));
const fromKey = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, key)=>{
    const ast = self.ast;
    switch(ast._tag){
        case "PropertySignatureDeclaration":
            return makePropertySignature(new PropertySignatureTransformation(new FromPropertySignature(ast.type, ast.isOptional, ast.isReadonly, ast.annotations, key), new ToPropertySignature(_schemaASTJs.typeAST(ast.type), ast.isOptional, ast.isReadonly, {}, ast.defaultValue), (0, _functionJs.identity), (0, _functionJs.identity)));
        case "PropertySignatureTransformation":
            return makePropertySignature(new PropertySignatureTransformation(new FromPropertySignature(ast.from.type, ast.from.isOptional, ast.from.isReadonly, ast.from.annotations, key), ast.to, ast.decode, ast.encode));
    }
});
const optionalToRequired = (from, to, options)=>makePropertySignature(new PropertySignatureTransformation(new FromPropertySignature(from.ast, true, true, {}, undefined), new ToPropertySignature(to.ast, false, true, {}, undefined), (o)=>_optionJs.some(options.decode(o)), _optionJs.flatMap(options.encode)));
const requiredToOptional = (from, to, options)=>makePropertySignature(new PropertySignatureTransformation(new FromPropertySignature(from.ast, false, true, {}, undefined), new ToPropertySignature(to.ast, true, true, {}, undefined), _optionJs.flatMap(options.decode), (o)=>_optionJs.some(options.encode(o))));
const optionalToOptional = (from, to, options)=>makePropertySignature(new PropertySignatureTransformation(new FromPropertySignature(from.ast, true, true, {}, undefined), new ToPropertySignature(to.ast, true, true, {}, undefined), options.decode, options.encode));
const optionalPropertySignatureAST = (self, options)=>{
    const isExact = options?.exact;
    const defaultValue = options?.default;
    const isNullable = options?.nullable;
    const asOption = options?.as == "Option";
    const asOptionEncode = options?.onNoneEncoding ? _optionJs.orElse(options.onNoneEncoding) : (0, _functionJs.identity);
    if (isExact) {
        if (defaultValue) {
            if (isNullable) return withConstructorDefault(optionalToRequired(NullOr(self), typeSchema(self), {
                decode: _optionJs.match({
                    onNone: defaultValue,
                    onSome: (a)=>a === null ? defaultValue() : a
                }),
                encode: _optionJs.some
            }), defaultValue).ast;
            else return withConstructorDefault(optionalToRequired(self, typeSchema(self), {
                decode: _optionJs.match({
                    onNone: defaultValue,
                    onSome: (0, _functionJs.identity)
                }),
                encode: _optionJs.some
            }), defaultValue).ast;
        } else if (asOption) {
            if (isNullable) return optionalToRequired(NullOr(self), OptionFromSelf(typeSchema(self)), {
                decode: _optionJs.filter(_predicateJs.isNotNull),
                encode: asOptionEncode
            }).ast;
            else return optionalToRequired(self, OptionFromSelf(typeSchema(self)), {
                decode: (0, _functionJs.identity),
                encode: (0, _functionJs.identity)
            }).ast;
        } else {
            if (isNullable) return optionalToOptional(NullOr(self), typeSchema(self), {
                decode: _optionJs.filter(_predicateJs.isNotNull),
                encode: (0, _functionJs.identity)
            }).ast;
            else return new PropertySignatureDeclaration(self.ast, true, true, {}, undefined);
        }
    } else {
        if (defaultValue) {
            if (isNullable) return withConstructorDefault(optionalToRequired(NullishOr(self), typeSchema(self), {
                decode: _optionJs.match({
                    onNone: defaultValue,
                    onSome: (a)=>a == null ? defaultValue() : a
                }),
                encode: _optionJs.some
            }), defaultValue).ast;
            else return withConstructorDefault(optionalToRequired(UndefinedOr(self), typeSchema(self), {
                decode: _optionJs.match({
                    onNone: defaultValue,
                    onSome: (a)=>a === undefined ? defaultValue() : a
                }),
                encode: _optionJs.some
            }), defaultValue).ast;
        } else if (asOption) {
            if (isNullable) return optionalToRequired(NullishOr(self), OptionFromSelf(typeSchema(self)), {
                decode: _optionJs.filter((a)=>a != null),
                encode: asOptionEncode
            }).ast;
            else return optionalToRequired(UndefinedOr(self), OptionFromSelf(typeSchema(self)), {
                decode: _optionJs.filter(_predicateJs.isNotUndefined),
                encode: asOptionEncode
            }).ast;
        } else {
            if (isNullable) return optionalToOptional(NullishOr(self), UndefinedOr(typeSchema(self)), {
                decode: _optionJs.filter(_predicateJs.isNotNull),
                encode: (0, _functionJs.identity)
            }).ast;
            else return new PropertySignatureDeclaration(UndefinedOr(self).ast, true, true, {}, undefined);
        }
    }
};
const optional = (self)=>{
    const ast = self.ast === _schemaASTJs.undefinedKeyword || self.ast === _schemaASTJs.neverKeyword ? _schemaASTJs.undefinedKeyword : UndefinedOr(self).ast;
    return new PropertySignatureWithFromImpl(new PropertySignatureDeclaration(ast, true, true, {}, undefined), self);
};
const optionalWith = /*#__PURE__*/ (0, _functionJs.dual)((args)=>isSchema(args[0]), (self, options)=>{
    return new PropertySignatureWithFromImpl(optionalPropertySignatureAST(self, options), self);
});
const preserveMissingMessageAnnotation = /*#__PURE__*/ _schemaASTJs.pickAnnotations([
    _schemaASTJs.MissingMessageAnnotationId
]);
const getDefaultTypeLiteralAST = (fields, records)=>{
    const ownKeys = _utilJs.ownKeys(fields);
    const pss = [];
    if (ownKeys.length > 0) {
        const from = [];
        const to = [];
        const transformations = [];
        for(let i = 0; i < ownKeys.length; i++){
            const key = ownKeys[i];
            const field = fields[key];
            if (isPropertySignature(field)) {
                const ast = field.ast;
                switch(ast._tag){
                    case "PropertySignatureDeclaration":
                        {
                            const type = ast.type;
                            const isOptional = ast.isOptional;
                            const toAnnotations = ast.annotations;
                            from.push(new _schemaASTJs.PropertySignature(key, type, isOptional, true, preserveMissingMessageAnnotation(ast)));
                            to.push(new _schemaASTJs.PropertySignature(key, _schemaASTJs.typeAST(type), isOptional, true, toAnnotations));
                            pss.push(new _schemaASTJs.PropertySignature(key, type, isOptional, true, toAnnotations));
                            break;
                        }
                    case "PropertySignatureTransformation":
                        {
                            const fromKey = ast.from.fromKey ?? key;
                            from.push(new _schemaASTJs.PropertySignature(fromKey, ast.from.type, ast.from.isOptional, true, ast.from.annotations));
                            to.push(new _schemaASTJs.PropertySignature(key, ast.to.type, ast.to.isOptional, true, ast.to.annotations));
                            transformations.push(new _schemaASTJs.PropertySignatureTransformation(fromKey, key, ast.decode, ast.encode));
                            break;
                        }
                }
            } else {
                from.push(new _schemaASTJs.PropertySignature(key, field.ast, false, true));
                to.push(new _schemaASTJs.PropertySignature(key, _schemaASTJs.typeAST(field.ast), false, true));
                pss.push(new _schemaASTJs.PropertySignature(key, field.ast, false, true));
            }
        }
        if (_arrayJs.isNonEmptyReadonlyArray(transformations)) {
            const issFrom = [];
            const issTo = [];
            for (const r of records){
                const { indexSignatures, propertySignatures } = _schemaASTJs.record(r.key.ast, r.value.ast);
                propertySignatures.forEach((ps)=>{
                    from.push(ps);
                    to.push(new _schemaASTJs.PropertySignature(ps.name, _schemaASTJs.typeAST(ps.type), ps.isOptional, ps.isReadonly, ps.annotations));
                });
                indexSignatures.forEach((is)=>{
                    issFrom.push(is);
                    issTo.push(new _schemaASTJs.IndexSignature(is.parameter, _schemaASTJs.typeAST(is.type), is.isReadonly));
                });
            }
            return new _schemaASTJs.Transformation(new _schemaASTJs.TypeLiteral(from, issFrom, {
                [_schemaASTJs.AutoTitleAnnotationId]: "Struct (Encoded side)"
            }), new _schemaASTJs.TypeLiteral(to, issTo, {
                [_schemaASTJs.AutoTitleAnnotationId]: "Struct (Type side)"
            }), new _schemaASTJs.TypeLiteralTransformation(transformations));
        }
    }
    const iss = [];
    for (const r of records){
        const { indexSignatures, propertySignatures } = _schemaASTJs.record(r.key.ast, r.value.ast);
        propertySignatures.forEach((ps)=>pss.push(ps));
        indexSignatures.forEach((is)=>iss.push(is));
    }
    return new _schemaASTJs.TypeLiteral(pss, iss);
};
const lazilyMergeDefaults = (fields, out)=>{
    const ownKeys = _utilJs.ownKeys(fields);
    for (const key of ownKeys){
        const field = fields[key];
        if (out[key] === undefined && isPropertySignature(field)) {
            const ast = field.ast;
            const defaultValue = ast._tag === "PropertySignatureDeclaration" ? ast.defaultValue : ast.to.defaultValue;
            if (defaultValue !== undefined) out[key] = defaultValue();
        }
    }
    return out;
};
function makeTypeLiteralClass(fields, records, ast = getDefaultTypeLiteralAST(fields, records)) {
    return class TypeLiteralClass extends make(ast) {
        static annotations(annotations) {
            return makeTypeLiteralClass(this.fields, this.records, mergeSchemaAnnotations(this.ast, annotations));
        }
        static fields = {
            ...fields
        };
        static records = [
            ...records
        ];
        static make = (props, options)=>{
            const propsWithDefaults = lazilyMergeDefaults(fields, {
                ...props
            });
            return getDisableValidationMakeOption(options) ? propsWithDefaults : _parseResultJs.validateSync(this)(propsWithDefaults);
        };
        static pick(...keys) {
            return Struct(_structJs.pick(fields, ...keys));
        }
        static omit(...keys) {
            return Struct(_structJs.omit(fields, ...keys));
        }
    };
}
function Struct(fields, ...records) {
    return makeTypeLiteralClass(fields, records);
}
const tag = (tag)=>Literal(tag).pipe(propertySignature, withConstructorDefault(()=>tag));
const TaggedStruct = (value, fields)=>Struct({
        _tag: tag(value),
        ...fields
    });
function makeRecordClass(key, value, ast) {
    return class RecordClass extends makeTypeLiteralClass({}, [
        {
            key,
            value
        }
    ], ast) {
        static annotations(annotations) {
            return makeRecordClass(key, value, mergeSchemaAnnotations(this.ast, annotations));
        }
        static key = key;
        static value = value;
    };
}
const Record = (options)=>makeRecordClass(options.key, options.value);
const pick = (...keys)=>(self)=>make(_schemaASTJs.pick(self.ast, keys));
const omit = (...keys)=>(self)=>make(_schemaASTJs.omit(self.ast, keys));
const pluck = /*#__PURE__*/ (0, _functionJs.dual)(2, (schema, key)=>{
    const ps = _schemaASTJs.getPropertyKeyIndexedAccess(_schemaASTJs.typeAST(schema.ast), key);
    const value = make(ps.isOptional ? _schemaASTJs.orUndefined(ps.type) : ps.type);
    const out = transform(schema.pipe(pick(key)), value, {
        strict: true,
        decode: (i)=>i[key],
        encode: (a)=>ps.isOptional && a === undefined ? {} : {
                [key]: a
            }
    });
    return out;
});
function makeBrandClass(from, ast) {
    return class BrandClass extends make(ast) {
        static annotations(annotations) {
            return makeBrandClass(this.from, mergeSchemaAnnotations(this.ast, annotations));
        }
        static make = (a, options)=>{
            return getDisableValidationMakeOption(options) ? a : _parseResultJs.validateSync(this)(a);
        };
        static from = from;
    };
}
const brand = (brand, annotations)=>(self)=>{
        const annotation = _optionJs.match(_schemaASTJs.getBrandAnnotation(self.ast), {
            onNone: ()=>[
                    brand
                ],
            onSome: (brands)=>[
                    ...brands,
                    brand
                ]
        });
        const ast = _schemaASTJs.annotations(self.ast, toASTAnnotations({
            [_schemaASTJs.BrandAnnotationId]: annotation,
            ...annotations
        }));
        return makeBrandClass(self, ast);
    };
const partial = (self)=>make(_schemaASTJs.partial(self.ast));
const partialWith = /*#__PURE__*/ (0, _functionJs.dual)((args)=>isSchema(args[0]), (self, options)=>make(_schemaASTJs.partial(self.ast, options)));
const required = (self)=>make(_schemaASTJs.required(self.ast));
const mutable = (schema)=>make(_schemaASTJs.mutable(schema.ast));
const intersectTypeLiterals = (x, y, path)=>{
    if (_schemaASTJs.isTypeLiteral(x) && _schemaASTJs.isTypeLiteral(y)) {
        const propertySignatures = [
            ...x.propertySignatures
        ];
        for (const ps of y.propertySignatures){
            const name = ps.name;
            const i = propertySignatures.findIndex((ps)=>ps.name === name);
            if (i === -1) propertySignatures.push(ps);
            else {
                const { isOptional, type } = propertySignatures[i];
                propertySignatures[i] = new _schemaASTJs.PropertySignature(name, extendAST(type, ps.type, path.concat(name)), isOptional, true);
            }
        }
        return new _schemaASTJs.TypeLiteral(propertySignatures, x.indexSignatures.concat(y.indexSignatures));
    }
    throw new Error(_errorsJs.getSchemaExtendErrorMessage(x, y, path));
};
const preserveRefinementAnnotations = /*#__PURE__*/ _schemaASTJs.omitAnnotations([
    _schemaASTJs.IdentifierAnnotationId
]);
const addRefinementToMembers = (refinement, asts)=>asts.map((ast)=>new _schemaASTJs.Refinement(ast, refinement.filter, preserveRefinementAnnotations(refinement)));
const extendAST = (x, y, path)=>_schemaASTJs.Union.make(intersectUnionMembers([
        x
    ], [
        y
    ], path));
const getTypes = (ast)=>_schemaASTJs.isUnion(ast) ? ast.types : [
        ast
    ];
const intersectUnionMembers = (xs, ys, path)=>_arrayJs.flatMap(xs, (x)=>_arrayJs.flatMap(ys, (y)=>{
            switch(y._tag){
                case "Literal":
                    if (_predicateJs.isString(y.literal) && _schemaASTJs.isStringKeyword(x) || _predicateJs.isNumber(y.literal) && _schemaASTJs.isNumberKeyword(x) || _predicateJs.isBoolean(y.literal) && _schemaASTJs.isBooleanKeyword(x)) return [
                        y
                    ];
                    break;
                case "StringKeyword":
                    if (y === _schemaASTJs.stringKeyword) {
                        if (_schemaASTJs.isStringKeyword(x) || _schemaASTJs.isLiteral(x) && _predicateJs.isString(x.literal)) return [
                            x
                        ];
                        else if (_schemaASTJs.isRefinement(x)) return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [
                            y
                        ], path));
                    } else if (x === _schemaASTJs.stringKeyword) return [
                        y
                    ];
                    break;
                case "NumberKeyword":
                    if (y === _schemaASTJs.numberKeyword) {
                        if (_schemaASTJs.isNumberKeyword(x) || _schemaASTJs.isLiteral(x) && _predicateJs.isNumber(x.literal)) return [
                            x
                        ];
                        else if (_schemaASTJs.isRefinement(x)) return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [
                            y
                        ], path));
                    } else if (x === _schemaASTJs.numberKeyword) return [
                        y
                    ];
                    break;
                case "BooleanKeyword":
                    if (y === _schemaASTJs.booleanKeyword) {
                        if (_schemaASTJs.isBooleanKeyword(x) || _schemaASTJs.isLiteral(x) && _predicateJs.isBoolean(x.literal)) return [
                            x
                        ];
                        else if (_schemaASTJs.isRefinement(x)) return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [
                            y
                        ], path));
                    } else if (x === _schemaASTJs.booleanKeyword) return [
                        y
                    ];
                    break;
                case "Union":
                    return intersectUnionMembers(getTypes(x), y.types, path);
                case "Suspend":
                    return [
                        new _schemaASTJs.Suspend(()=>extendAST(x, y.f(), path))
                    ];
                case "Refinement":
                    return addRefinementToMembers(y, intersectUnionMembers(getTypes(x), getTypes(y.from), path));
                case "TypeLiteral":
                    switch(x._tag){
                        case "Union":
                            return intersectUnionMembers(x.types, [
                                y
                            ], path);
                        case "Suspend":
                            return [
                                new _schemaASTJs.Suspend(()=>extendAST(x.f(), y, path))
                            ];
                        case "Refinement":
                            return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [
                                y
                            ], path));
                        case "TypeLiteral":
                            return [
                                intersectTypeLiterals(x, y, path)
                            ];
                        case "Transformation":
                            {
                                const transformation = x.transformation;
                                const from = intersectTypeLiterals(x.from, y, path);
                                const to = intersectTypeLiterals(x.to, _schemaASTJs.typeAST(y), path);
                                switch(transformation._tag){
                                    case "TypeLiteralTransformation":
                                        return [
                                            new _schemaASTJs.Transformation(from, to, new _schemaASTJs.TypeLiteralTransformation(transformation.propertySignatureTransformations))
                                        ];
                                    case "ComposeTransformation":
                                        return [
                                            new _schemaASTJs.Transformation(from, to, _schemaASTJs.composeTransformation)
                                        ];
                                    case "FinalTransformation":
                                        return [
                                            new _schemaASTJs.Transformation(from, to, new _schemaASTJs.FinalTransformation((fromA, options, ast, fromI)=>_parseResultJs.map(transformation.decode(fromA, options, ast, fromI), (partial)=>({
                                                        ...fromA,
                                                        ...partial
                                                    })), (toI, options, ast, toA)=>_parseResultJs.map(transformation.encode(toI, options, ast, toA), (partial)=>({
                                                        ...toI,
                                                        ...partial
                                                    }))))
                                        ];
                                }
                            }
                    }
                    break;
                case "Transformation":
                    if (_schemaASTJs.isTransformation(x)) {
                        if (_schemaASTJs.isTypeLiteralTransformation(y.transformation) && _schemaASTJs.isTypeLiteralTransformation(x.transformation)) return [
                            new _schemaASTJs.Transformation(intersectTypeLiterals(x.from, y.from, path), intersectTypeLiterals(x.to, y.to, path), new _schemaASTJs.TypeLiteralTransformation(y.transformation.propertySignatureTransformations.concat(x.transformation.propertySignatureTransformations)))
                        ];
                    } else return intersectUnionMembers([
                        y
                    ], [
                        x
                    ], path);
                    break;
            }
            throw new Error(_errorsJs.getSchemaExtendErrorMessage(x, y, path));
        }));
const extend = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, that)=>make(extendAST(self.ast, that.ast, [])));
const compose = /*#__PURE__*/ (0, _functionJs.dual)((args)=>isSchema(args[1]), (from, to)=>makeTransformationClass(from, to, _schemaASTJs.compose(from.ast, to.ast)));
const suspend = (f)=>make(new _schemaASTJs.Suspend(()=>f().ast));
const RefineSchemaId = /*#__PURE__*/ Symbol.for("effect/SchemaId/Refine");
function makeRefineClass(from, filter, ast) {
    return class RefineClass extends make(ast) {
        static annotations(annotations) {
            return makeRefineClass(this.from, this.filter, mergeSchemaAnnotations(this.ast, annotations));
        }
        static [RefineSchemaId] = from;
        static from = from;
        static filter = filter;
        static make = (a, options)=>{
            return getDisableValidationMakeOption(options) ? a : _parseResultJs.validateSync(this)(a);
        };
    };
}
const fromFilterPredicateReturnTypeItem = (item, ast, input)=>{
    if (_predicateJs.isBoolean(item)) return item ? _optionJs.none() : _optionJs.some(new _parseResultJs.Type(ast, input));
    if (_predicateJs.isString(item)) return _optionJs.some(new _parseResultJs.Type(ast, input, item));
    if (item !== undefined) {
        if ("_tag" in item) return _optionJs.some(item);
        const issue = new _parseResultJs.Type(ast, input, item.message);
        return _optionJs.some(_arrayJs.isNonEmptyReadonlyArray(item.path) ? new _parseResultJs.Pointer(item.path, input, issue) : issue);
    }
    return _optionJs.none();
};
const toFilterParseIssue = (out, ast, input)=>{
    if (_utilJs.isSingle(out)) return fromFilterPredicateReturnTypeItem(out, ast, input);
    if (_arrayJs.isNonEmptyReadonlyArray(out)) {
        const issues = _arrayJs.filterMap(out, (issue)=>fromFilterPredicateReturnTypeItem(issue, ast, input));
        if (_arrayJs.isNonEmptyReadonlyArray(issues)) return _optionJs.some(issues.length === 1 ? issues[0] : new _parseResultJs.Composite(ast, input, issues));
    }
    return _optionJs.none();
};
function filter(predicate, annotations) {
    return (self)=>{
        function filter(input, options, ast) {
            return toFilterParseIssue(predicate(input, options, ast), ast, input);
        }
        const ast = new _schemaASTJs.Refinement(self.ast, filter, toASTAnnotations(annotations));
        return makeRefineClass(self, filter, ast);
    };
}
const filterEffect = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, f)=>transformOrFail(self, typeSchema(self), {
        strict: true,
        decode: (i, options, ast)=>_parseResultJs.flatMap(f(i, options, ast), (filterReturnType)=>_optionJs.match(toFilterParseIssue(filterReturnType, ast, i), {
                    onNone: ()=>_parseResultJs.succeed(i),
                    onSome: _parseResultJs.fail
                })),
        encode: (a)=>_parseResultJs.succeed(a)
    }));
function makeTransformationClass(from, to, ast) {
    return class TransformationClass extends make(ast) {
        static annotations(annotations) {
            return makeTransformationClass(this.from, this.to, mergeSchemaAnnotations(this.ast, annotations));
        }
        static from = from;
        static to = to;
    };
}
const transformOrFail = /*#__PURE__*/ (0, _functionJs.dual)((args)=>isSchema(args[0]) && isSchema(args[1]), (from, to, options)=>makeTransformationClass(from, to, new _schemaASTJs.Transformation(from.ast, to.ast, new _schemaASTJs.FinalTransformation(options.decode, options.encode))));
const transform = /*#__PURE__*/ (0, _functionJs.dual)((args)=>isSchema(args[0]) && isSchema(args[1]), (from, to, options)=>transformOrFail(from, to, {
        strict: true,
        decode: (fromA, _options, _ast, toA)=>_parseResultJs.succeed(options.decode(fromA, toA)),
        encode: (toI, _options, _ast, toA)=>_parseResultJs.succeed(options.encode(toI, toA))
    }));
function transformLiteral(from, to) {
    return transform(Literal(from), Literal(to), {
        strict: true,
        decode: ()=>to,
        encode: ()=>from
    });
}
function transformLiterals(...pairs) {
    return Union(...pairs.map(([from, to])=>transformLiteral(from, to)));
}
const attachPropertySignature = /*#__PURE__*/ (0, _functionJs.dual)((args)=>isSchema(args[0]), (schema, key, value, annotations)=>{
    const ast = extend(typeSchema(schema), Struct({
        [key]: _predicateJs.isSymbol(value) ? UniqueSymbolFromSelf(value) : Literal(value)
    })).ast;
    return make(new _schemaASTJs.Transformation(schema.ast, annotations ? mergeSchemaAnnotations(ast, annotations) : ast, new _schemaASTJs.TypeLiteralTransformation([
        new _schemaASTJs.PropertySignatureTransformation(key, key, ()=>_optionJs.some(value), ()=>_optionJs.none())
    ])));
});
const annotations = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, annotations)=>self.annotations(annotations));
const rename = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, mapping)=>make(_schemaASTJs.rename(self.ast, mapping)));
const TrimmedSchemaId = /*#__PURE__*/ Symbol.for("effect/SchemaId/Trimmed");
const trimmed = (annotations)=>(self)=>self.pipe(filter((a)=>a === a.trim(), {
            schemaId: TrimmedSchemaId,
            title: "trimmed",
            description: "a string with no leading or trailing whitespace",
            jsonSchema: {
                pattern: "^\\S[\\s\\S]*\\S$|^\\S$|^$"
            },
            ...annotations
        }));
const MaxLengthSchemaId = _schemaIdJs.MaxLengthSchemaId;
const maxLength = (maxLength, annotations)=>(self)=>self.pipe(filter((a)=>a.length <= maxLength, {
            schemaId: MaxLengthSchemaId,
            title: `maxLength(${maxLength})`,
            description: `a string at most ${maxLength} character(s) long`,
            jsonSchema: {
                maxLength
            },
            ...annotations
        }));
const MinLengthSchemaId = _schemaIdJs.MinLengthSchemaId;
const minLength = (minLength, annotations)=>(self)=>self.pipe(filter((a)=>a.length >= minLength, {
            schemaId: MinLengthSchemaId,
            title: `minLength(${minLength})`,
            description: `a string at least ${minLength} character(s) long`,
            jsonSchema: {
                minLength
            },
            ...annotations
        }));
const LengthSchemaId = _schemaIdJs.LengthSchemaId;
const length = (length, annotations)=>(self)=>{
        const minLength = _predicateJs.isObject(length) ? Math.max(0, Math.floor(length.min)) : Math.max(0, Math.floor(length));
        const maxLength = _predicateJs.isObject(length) ? Math.max(minLength, Math.floor(length.max)) : minLength;
        if (minLength !== maxLength) return self.pipe(filter((a)=>a.length >= minLength && a.length <= maxLength, {
            schemaId: LengthSchemaId,
            title: `length({ min: ${minLength}, max: ${maxLength})`,
            description: `a string at least ${minLength} character(s) and at most ${maxLength} character(s) long`,
            jsonSchema: {
                minLength,
                maxLength
            },
            ...annotations
        }));
        return self.pipe(filter((a)=>a.length === minLength, {
            schemaId: LengthSchemaId,
            title: `length(${minLength})`,
            description: minLength === 1 ? `a single character` : `a string ${minLength} character(s) long`,
            jsonSchema: {
                minLength,
                maxLength: minLength
            },
            ...annotations
        }));
    };
const PatternSchemaId = /*#__PURE__*/ Symbol.for("effect/SchemaId/Pattern");
const pattern = (regex, annotations)=>(self)=>{
        const source = regex.source;
        return self.pipe(filter((a)=>{
            // The following line ensures that `lastIndex` is reset to `0` in case the user has specified the `g` flag
            regex.lastIndex = 0;
            return regex.test(a);
        }, {
            schemaId: PatternSchemaId,
            [PatternSchemaId]: {
                regex
            },
            // title: `pattern(/${source}/)`, // avoiding this because it can be very long
            description: `a string matching the pattern ${source}`,
            jsonSchema: {
                pattern: source
            },
            ...annotations
        }));
    };
const StartsWithSchemaId = /*#__PURE__*/ Symbol.for("effect/SchemaId/StartsWith");
const startsWith = (startsWith, annotations)=>(self)=>{
        const formatted = JSON.stringify(startsWith);
        return self.pipe(filter((a)=>a.startsWith(startsWith), {
            schemaId: StartsWithSchemaId,
            [StartsWithSchemaId]: {
                startsWith
            },
            title: `startsWith(${formatted})`,
            description: `a string starting with ${formatted}`,
            jsonSchema: {
                pattern: `^${startsWith}`
            },
            ...annotations
        }));
    };
const EndsWithSchemaId = /*#__PURE__*/ Symbol.for("effect/SchemaId/EndsWith");
const endsWith = (endsWith, annotations)=>(self)=>{
        const formatted = JSON.stringify(endsWith);
        return self.pipe(filter((a)=>a.endsWith(endsWith), {
            schemaId: EndsWithSchemaId,
            [EndsWithSchemaId]: {
                endsWith
            },
            title: `endsWith(${formatted})`,
            description: `a string ending with ${formatted}`,
            jsonSchema: {
                pattern: `^.*${endsWith}$`
            },
            ...annotations
        }));
    };
const IncludesSchemaId = /*#__PURE__*/ Symbol.for("effect/SchemaId/Includes");
const includes = (searchString, annotations)=>(self)=>{
        const formatted = JSON.stringify(searchString);
        return self.pipe(filter((a)=>a.includes(searchString), {
            schemaId: IncludesSchemaId,
            [IncludesSchemaId]: {
                includes: searchString
            },
            title: `includes(${formatted})`,
            description: `a string including ${formatted}`,
            jsonSchema: {
                pattern: `.*${searchString}.*`
            },
            ...annotations
        }));
    };
const LowercasedSchemaId = /*#__PURE__*/ Symbol.for("effect/SchemaId/Lowercased");
const lowercased = (annotations)=>(self)=>self.pipe(filter((a)=>a === a.toLowerCase(), {
            schemaId: LowercasedSchemaId,
            title: "lowercased",
            description: "a lowercase string",
            jsonSchema: {
                pattern: "^[^A-Z]*$"
            },
            ...annotations
        }));
class Lowercased extends /*#__PURE__*/ String$.pipe(/*#__PURE__*/ lowercased({
    identifier: "Lowercased"
})) {
}
const UppercasedSchemaId = /*#__PURE__*/ Symbol.for("effect/SchemaId/Uppercased");
const uppercased = (annotations)=>(self)=>self.pipe(filter((a)=>a === a.toUpperCase(), {
            schemaId: UppercasedSchemaId,
            title: "uppercased",
            description: "an uppercase string",
            jsonSchema: {
                pattern: "^[^a-z]*$"
            },
            ...annotations
        }));
class Uppercased extends /*#__PURE__*/ String$.pipe(/*#__PURE__*/ uppercased({
    identifier: "Uppercased"
})) {
}
const CapitalizedSchemaId = /*#__PURE__*/ Symbol.for("effect/SchemaId/Capitalized");
const capitalized = (annotations)=>(self)=>self.pipe(filter((a)=>a[0]?.toUpperCase() === a[0], {
            schemaId: CapitalizedSchemaId,
            title: "capitalized",
            description: "a capitalized string",
            jsonSchema: {
                pattern: "^[^a-z]?.*$"
            },
            ...annotations
        }));
class Capitalized extends /*#__PURE__*/ String$.pipe(/*#__PURE__*/ capitalized({
    identifier: "Capitalized"
})) {
}
const UncapitalizedSchemaId = /*#__PURE__*/ Symbol.for("effect/SchemaId/Uncapitalized");
const uncapitalized = (annotations)=>(self)=>self.pipe(filter((a)=>a[0]?.toLowerCase() === a[0], {
            schemaId: UncapitalizedSchemaId,
            title: "uncapitalized",
            description: "a uncapitalized string",
            jsonSchema: {
                pattern: "^[^A-Z]?.*$"
            },
            ...annotations
        }));
class Uncapitalized extends /*#__PURE__*/ String$.pipe(/*#__PURE__*/ uncapitalized({
    identifier: "Uncapitalized"
})) {
}
class Char extends /*#__PURE__*/ String$.pipe(/*#__PURE__*/ length(1, {
    identifier: "Char"
})) {
}
const nonEmptyString = (annotations)=>minLength(1, {
        title: "nonEmptyString",
        description: "a non empty string",
        ...annotations
    });
class Lowercase extends /*#__PURE__*/ transform(String$.annotations({
    description: "a string that will be converted to lowercase"
}), Lowercased, {
    strict: true,
    decode: (i)=>i.toLowerCase(),
    encode: (0, _functionJs.identity)
}).annotations({
    identifier: "Lowercase"
}) {
}
class Uppercase extends /*#__PURE__*/ transform(String$.annotations({
    description: "a string that will be converted to uppercase"
}), Uppercased, {
    strict: true,
    decode: (i)=>i.toUpperCase(),
    encode: (0, _functionJs.identity)
}).annotations({
    identifier: "Uppercase"
}) {
}
class Capitalize extends /*#__PURE__*/ transform(String$.annotations({
    description: "a string that will be converted to a capitalized format"
}), Capitalized, {
    strict: true,
    decode: (i)=>_stringJs.capitalize(i),
    encode: (0, _functionJs.identity)
}).annotations({
    identifier: "Capitalize"
}) {
}
class Uncapitalize extends /*#__PURE__*/ transform(String$.annotations({
    description: "a string that will be converted to an uncapitalized format"
}), Uncapitalized, {
    strict: true,
    decode: (i)=>_stringJs.uncapitalize(i),
    encode: (0, _functionJs.identity)
}).annotations({
    identifier: "Uncapitalize"
}) {
}
class Trimmed extends /*#__PURE__*/ String$.pipe(/*#__PURE__*/ trimmed({
    identifier: "Trimmed"
})) {
}
class NonEmptyTrimmedString extends /*#__PURE__*/ Trimmed.pipe(/*#__PURE__*/ nonEmptyString({
    identifier: "NonEmptyTrimmedString"
})) {
}
class Trim extends /*#__PURE__*/ transform(String$.annotations({
    description: "a string that will be trimmed"
}), Trimmed, {
    strict: true,
    decode: (i)=>i.trim(),
    encode: (0, _functionJs.identity)
}).annotations({
    identifier: "Trim"
}) {
}
const split = (separator)=>transform(String$.annotations({
        description: "a string that will be split"
    }), Array$(String$), {
        strict: true,
        decode: (i)=>i.split(separator),
        encode: (a)=>a.join(separator)
    });
const getErrorMessage = (e)=>e instanceof Error ? e.message : String(e);
const getParseJsonTransformation = (options)=>transformOrFail(String$.annotations({
        description: "a string to be decoded into JSON"
    }), Unknown, {
        strict: true,
        decode: (i, _, ast)=>_parseResultJs.try({
                try: ()=>JSON.parse(i, options?.reviver),
                catch: (e)=>new _parseResultJs.Type(ast, i, getErrorMessage(e))
            }),
        encode: (a, _, ast)=>_parseResultJs.try({
                try: ()=>JSON.stringify(a, options?.replacer, options?.space),
                catch: (e)=>new _parseResultJs.Type(ast, a, getErrorMessage(e))
            })
    }).annotations({
        title: "parseJson",
        schemaId: _schemaASTJs.ParseJsonSchemaId
    });
const parseJson = (schemaOrOptions, o)=>isSchema(schemaOrOptions) ? compose(parseJson(o), schemaOrOptions) : getParseJsonTransformation(schemaOrOptions);
class NonEmptyString extends /*#__PURE__*/ String$.pipe(/*#__PURE__*/ nonEmptyString({
    identifier: "NonEmptyString"
})) {
}
const UUIDSchemaId = /*#__PURE__*/ Symbol.for("effect/SchemaId/UUID");
const uuidRegexp = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;
class UUID extends /*#__PURE__*/ String$.pipe(/*#__PURE__*/ pattern(uuidRegexp, {
    schemaId: UUIDSchemaId,
    identifier: "UUID",
    jsonSchema: {
        format: "uuid",
        pattern: uuidRegexp.source
    },
    description: "a Universally Unique Identifier",
    arbitrary: ()=>(fc)=>fc.uuid()
})) {
}
const ULIDSchemaId = /*#__PURE__*/ Symbol.for("effect/SchemaId/ULID");
const ulidRegexp = /^[0-7][0-9A-HJKMNP-TV-Z]{25}$/i;
class ULID extends /*#__PURE__*/ String$.pipe(/*#__PURE__*/ pattern(ulidRegexp, {
    schemaId: ULIDSchemaId,
    identifier: "ULID",
    description: "a Universally Unique Lexicographically Sortable Identifier",
    arbitrary: ()=>(fc)=>fc.ulid()
})) {
}
class URLFromSelf extends /*#__PURE__*/ instanceOf(URL, {
    identifier: "URLFromSelf",
    arbitrary: ()=>(fc)=>fc.webUrl().map((s)=>new URL(s)),
    pretty: ()=>(url)=>url.toString()
}) {
}
/** @ignore */ class URL$ extends /*#__PURE__*/ transformOrFail(String$.annotations({
    description: "a string to be decoded into a URL"
}), URLFromSelf, {
    strict: true,
    decode: (i, _, ast)=>_parseResultJs.try({
            try: ()=>new URL(i),
            catch: (e)=>new _parseResultJs.Type(ast, i, `Unable to decode ${JSON.stringify(i)} into a URL. ${getErrorMessage(e)}`)
        }),
    encode: (a)=>_parseResultJs.succeed(a.toString())
}).annotations({
    identifier: "URL",
    pretty: ()=>(url)=>url.toString()
}) {
}
const FiniteSchemaId = _schemaIdJs.FiniteSchemaId;
const finite = (annotations)=>(self)=>self.pipe(filter(Number.isFinite, {
            schemaId: FiniteSchemaId,
            title: "finite",
            description: "a finite number",
            jsonSchema: {
                "type": "number"
            },
            ...annotations
        }));
const GreaterThanSchemaId = _schemaIdJs.GreaterThanSchemaId;
const greaterThan = (exclusiveMinimum, annotations)=>(self)=>self.pipe(filter((a)=>a > exclusiveMinimum, {
            schemaId: GreaterThanSchemaId,
            title: `greaterThan(${exclusiveMinimum})`,
            description: exclusiveMinimum === 0 ? "a positive number" : `a number greater than ${exclusiveMinimum}`,
            jsonSchema: {
                exclusiveMinimum
            },
            ...annotations
        }));
const GreaterThanOrEqualToSchemaId = _schemaIdJs.GreaterThanOrEqualToSchemaId;
const greaterThanOrEqualTo = (minimum, annotations)=>(self)=>self.pipe(filter((a)=>a >= minimum, {
            schemaId: GreaterThanOrEqualToSchemaId,
            title: `greaterThanOrEqualTo(${minimum})`,
            description: minimum === 0 ? "a non-negative number" : `a number greater than or equal to ${minimum}`,
            jsonSchema: {
                minimum
            },
            ...annotations
        }));
const MultipleOfSchemaId = /*#__PURE__*/ Symbol.for("effect/SchemaId/MultipleOf");
const multipleOf = (divisor, annotations)=>(self)=>{
        const positiveDivisor = Math.abs(divisor); // spec requires positive divisor
        return self.pipe(filter((a)=>_numberJs.remainder(a, divisor) === 0, {
            schemaId: MultipleOfSchemaId,
            title: `multipleOf(${positiveDivisor})`,
            description: `a number divisible by ${positiveDivisor}`,
            jsonSchema: {
                multipleOf: positiveDivisor
            },
            ...annotations
        }));
    };
const IntSchemaId = _schemaIdJs.IntSchemaId;
const int = (annotations)=>(self)=>self.pipe(filter((a)=>Number.isSafeInteger(a), {
            schemaId: IntSchemaId,
            title: "int",
            description: "an integer",
            jsonSchema: {
                type: "integer"
            },
            ...annotations
        }));
const LessThanSchemaId = _schemaIdJs.LessThanSchemaId;
const lessThan = (exclusiveMaximum, annotations)=>(self)=>self.pipe(filter((a)=>a < exclusiveMaximum, {
            schemaId: LessThanSchemaId,
            title: `lessThan(${exclusiveMaximum})`,
            description: exclusiveMaximum === 0 ? "a negative number" : `a number less than ${exclusiveMaximum}`,
            jsonSchema: {
                exclusiveMaximum
            },
            ...annotations
        }));
const LessThanOrEqualToSchemaId = _schemaIdJs.LessThanOrEqualToSchemaId;
const lessThanOrEqualTo = (maximum, annotations)=>(self)=>self.pipe(filter((a)=>a <= maximum, {
            schemaId: LessThanOrEqualToSchemaId,
            title: `lessThanOrEqualTo(${maximum})`,
            description: maximum === 0 ? "a non-positive number" : `a number less than or equal to ${maximum}`,
            jsonSchema: {
                maximum
            },
            ...annotations
        }));
const BetweenSchemaId = _schemaIdJs.BetweenSchemaId;
const between = (minimum, maximum, annotations)=>(self)=>self.pipe(filter((a)=>a >= minimum && a <= maximum, {
            schemaId: BetweenSchemaId,
            title: `between(${minimum}, ${maximum})`,
            description: `a number between ${minimum} and ${maximum}`,
            jsonSchema: {
                minimum,
                maximum
            },
            ...annotations
        }));
const NonNaNSchemaId = _schemaIdJs.NonNaNSchemaId;
const nonNaN = (annotations)=>(self)=>self.pipe(filter((a)=>!Number.isNaN(a), {
            schemaId: NonNaNSchemaId,
            title: "nonNaN",
            description: "a number excluding NaN",
            ...annotations
        }));
const positive = (annotations)=>greaterThan(0, {
        title: "positive",
        ...annotations
    });
const negative = (annotations)=>lessThan(0, {
        title: "negative",
        ...annotations
    });
const nonPositive = (annotations)=>lessThanOrEqualTo(0, {
        title: "nonPositive",
        ...annotations
    });
const nonNegative = (annotations)=>greaterThanOrEqualTo(0, {
        title: "nonNegative",
        ...annotations
    });
const clamp = (minimum, maximum)=>(self)=>{
        return transform(self, typeSchema(self).pipe(between(minimum, maximum)), {
            strict: false,
            decode: (i)=>_numberJs.clamp(i, {
                    minimum,
                    maximum
                }),
            encode: (0, _functionJs.identity)
        });
    };
function parseNumber(self) {
    return transformOrFail(self, Number$, {
        strict: false,
        decode: (i, _, ast)=>_parseResultJs.fromOption(_numberJs.parse(i), ()=>new _parseResultJs.Type(ast, i, `Unable to decode ${JSON.stringify(i)} into a number`)),
        encode: (a)=>_parseResultJs.succeed(String(a))
    });
}
class NumberFromString extends /*#__PURE__*/ parseNumber(String$.annotations({
    description: "a string to be decoded into a number"
})).annotations({
    identifier: "NumberFromString"
}) {
}
class Finite extends /*#__PURE__*/ Number$.pipe(/*#__PURE__*/ finite({
    identifier: "Finite"
})) {
}
class Int extends /*#__PURE__*/ Number$.pipe(/*#__PURE__*/ int({
    identifier: "Int"
})) {
}
class NonNaN extends /*#__PURE__*/ Number$.pipe(/*#__PURE__*/ nonNaN({
    identifier: "NonNaN"
})) {
}
class Positive extends /*#__PURE__*/ Number$.pipe(/*#__PURE__*/ positive({
    identifier: "Positive"
})) {
}
class Negative extends /*#__PURE__*/ Number$.pipe(/*#__PURE__*/ negative({
    identifier: "Negative"
})) {
}
class NonPositive extends /*#__PURE__*/ Number$.pipe(/*#__PURE__*/ nonPositive({
    identifier: "NonPositive"
})) {
}
class NonNegative extends /*#__PURE__*/ Number$.pipe(/*#__PURE__*/ nonNegative({
    identifier: "NonNegative"
})) {
}
const JsonNumberSchemaId = _schemaIdJs.JsonNumberSchemaId;
class JsonNumber extends /*#__PURE__*/ Number$.pipe(/*#__PURE__*/ finite({
    schemaId: JsonNumberSchemaId,
    identifier: "JsonNumber"
})) {
}
class Not extends /*#__PURE__*/ transform(/*#__PURE__*/ Boolean$.annotations({
    description: "a boolean that will be negated"
}), Boolean$, {
    strict: true,
    decode: (i)=>_booleanJs.not(i),
    encode: (a)=>_booleanJs.not(a)
}) {
}
const encodeSymbol = (sym, ast)=>{
    const key = Symbol.keyFor(sym);
    return key === undefined ? _parseResultJs.fail(new _parseResultJs.Type(ast, sym, `Unable to encode a unique symbol ${String(sym)} into a string`)) : _parseResultJs.succeed(key);
};
const decodeSymbol = (s)=>_parseResultJs.succeed(Symbol.for(s));
/** @ignore */ class Symbol$ extends /*#__PURE__*/ transformOrFail(String$.annotations({
    description: "a string to be decoded into a globally shared symbol"
}), SymbolFromSelf, {
    strict: false,
    decode: (i)=>decodeSymbol(i),
    encode: (a, _, ast)=>encodeSymbol(a, ast)
}).annotations({
    identifier: "Symbol"
}) {
}
const GreaterThanBigIntSchemaId = _schemaIdJs.GreaterThanBigintSchemaId;
const greaterThanBigInt = (min, annotations)=>(self)=>self.pipe(filter((a)=>a > min, {
            schemaId: GreaterThanBigIntSchemaId,
            [GreaterThanBigIntSchemaId]: {
                min
            },
            title: `greaterThanBigInt(${min})`,
            description: min === 0n ? "a positive bigint" : `a bigint greater than ${min}n`,
            ...annotations
        }));
const GreaterThanOrEqualToBigIntSchemaId = _schemaIdJs.GreaterThanOrEqualToBigIntSchemaId;
const greaterThanOrEqualToBigInt = (min, annotations)=>(self)=>self.pipe(filter((a)=>a >= min, {
            schemaId: GreaterThanOrEqualToBigIntSchemaId,
            [GreaterThanOrEqualToBigIntSchemaId]: {
                min
            },
            title: `greaterThanOrEqualToBigInt(${min})`,
            description: min === 0n ? "a non-negative bigint" : `a bigint greater than or equal to ${min}n`,
            ...annotations
        }));
const LessThanBigIntSchemaId = _schemaIdJs.LessThanBigIntSchemaId;
const lessThanBigInt = (max, annotations)=>(self)=>self.pipe(filter((a)=>a < max, {
            schemaId: LessThanBigIntSchemaId,
            [LessThanBigIntSchemaId]: {
                max
            },
            title: `lessThanBigInt(${max})`,
            description: max === 0n ? "a negative bigint" : `a bigint less than ${max}n`,
            ...annotations
        }));
const LessThanOrEqualToBigIntSchemaId = _schemaIdJs.LessThanOrEqualToBigIntSchemaId;
const lessThanOrEqualToBigInt = (max, annotations)=>(self)=>self.pipe(filter((a)=>a <= max, {
            schemaId: LessThanOrEqualToBigIntSchemaId,
            [LessThanOrEqualToBigIntSchemaId]: {
                max
            },
            title: `lessThanOrEqualToBigInt(${max})`,
            description: max === 0n ? "a non-positive bigint" : `a bigint less than or equal to ${max}n`,
            ...annotations
        }));
const BetweenBigIntSchemaId = _schemaIdJs.BetweenBigintSchemaId;
const betweenBigInt = (min, max, annotations)=>(self)=>self.pipe(filter((a)=>a >= min && a <= max, {
            schemaId: BetweenBigIntSchemaId,
            [BetweenBigIntSchemaId]: {
                min,
                max
            },
            title: `betweenBigInt(${min}, ${max})`,
            description: `a bigint between ${min}n and ${max}n`,
            ...annotations
        }));
const positiveBigInt = (annotations)=>greaterThanBigInt(0n, {
        title: "positiveBigInt",
        ...annotations
    });
const negativeBigInt = (annotations)=>lessThanBigInt(0n, {
        title: "negativeBigInt",
        ...annotations
    });
const nonNegativeBigInt = (annotations)=>greaterThanOrEqualToBigInt(0n, {
        title: "nonNegativeBigInt",
        ...annotations
    });
const nonPositiveBigInt = (annotations)=>lessThanOrEqualToBigInt(0n, {
        title: "nonPositiveBigInt",
        ...annotations
    });
const clampBigInt = (minimum, maximum)=>(self)=>transform(self, self.pipe(typeSchema, betweenBigInt(minimum, maximum)), {
            strict: false,
            decode: (i)=>_bigIntJs.clamp(i, {
                    minimum,
                    maximum
                }),
            encode: (0, _functionJs.identity)
        });
/** @ignore */ class BigInt$ extends /*#__PURE__*/ transformOrFail(String$.annotations({
    description: "a string to be decoded into a bigint"
}), BigIntFromSelf, {
    strict: true,
    decode: (i, _, ast)=>_parseResultJs.fromOption(_bigIntJs.fromString(i), ()=>new _parseResultJs.Type(ast, i, `Unable to decode ${JSON.stringify(i)} into a bigint`)),
    encode: (a)=>_parseResultJs.succeed(String(a))
}).annotations({
    identifier: "BigInt"
}) {
}
const PositiveBigIntFromSelf = /*#__PURE__*/ BigIntFromSelf.pipe(/*#__PURE__*/ positiveBigInt({
    identifier: "PositiveBigintFromSelf"
}));
const PositiveBigInt = /*#__PURE__*/ BigInt$.pipe(/*#__PURE__*/ positiveBigInt({
    identifier: "PositiveBigint"
}));
const NegativeBigIntFromSelf = /*#__PURE__*/ BigIntFromSelf.pipe(/*#__PURE__*/ negativeBigInt({
    identifier: "NegativeBigintFromSelf"
}));
const NegativeBigInt = /*#__PURE__*/ BigInt$.pipe(/*#__PURE__*/ negativeBigInt({
    identifier: "NegativeBigint"
}));
const NonPositiveBigIntFromSelf = /*#__PURE__*/ BigIntFromSelf.pipe(/*#__PURE__*/ nonPositiveBigInt({
    identifier: "NonPositiveBigintFromSelf"
}));
const NonPositiveBigInt = /*#__PURE__*/ BigInt$.pipe(/*#__PURE__*/ nonPositiveBigInt({
    identifier: "NonPositiveBigint"
}));
const NonNegativeBigIntFromSelf = /*#__PURE__*/ BigIntFromSelf.pipe(/*#__PURE__*/ nonNegativeBigInt({
    identifier: "NonNegativeBigintFromSelf"
}));
const NonNegativeBigInt = /*#__PURE__*/ BigInt$.pipe(/*#__PURE__*/ nonNegativeBigInt({
    identifier: "NonNegativeBigint"
}));
class BigIntFromNumber extends /*#__PURE__*/ transformOrFail(Number$.annotations({
    description: "a number to be decoded into a bigint"
}), BigIntFromSelf.pipe(betweenBigInt(BigInt(Number.MIN_SAFE_INTEGER), BigInt(Number.MAX_SAFE_INTEGER))), {
    strict: true,
    decode: (i, _, ast)=>_parseResultJs.fromOption(_bigIntJs.fromNumber(i), ()=>new _parseResultJs.Type(ast, i, `Unable to decode ${i} into a bigint`)),
    encode: (a, _, ast)=>_parseResultJs.fromOption(_bigIntJs.toNumber(a), ()=>new _parseResultJs.Type(ast, a, `Unable to encode ${a}n into a number`))
}).annotations({
    identifier: "BigIntFromNumber"
}) {
}
const redactedArbitrary = (value)=>(fc)=>value(fc).map(_redactedJs.make);
const toComposite = (eff, onSuccess, ast, actual)=>_parseResultJs.mapBoth(eff, {
        onFailure: (e)=>new _parseResultJs.Composite(ast, actual, e),
        onSuccess
    });
const redactedParse = (decodeUnknown)=>(u, options, ast)=>_redactedJs.isRedacted(u) ? toComposite(decodeUnknown(_redactedJs.value(u), options), _redactedJs.make, ast, u) : _parseResultJs.fail(new _parseResultJs.Type(ast, u));
const RedactedFromSelf = (value)=>declare([
        value
    ], {
        decode: (value)=>redactedParse(_parseResultJs.decodeUnknown(value)),
        encode: (value)=>redactedParse(_parseResultJs.encodeUnknown(value))
    }, {
        description: "Redacted(<redacted>)",
        pretty: ()=>()=>"Redacted(<redacted>)",
        arbitrary: redactedArbitrary,
        equivalence: _redactedJs.getEquivalence
    });
function Redacted(value) {
    return transform(value, RedactedFromSelf(typeSchema(asSchema(value))), {
        strict: true,
        decode: (i)=>_redactedJs.make(i),
        encode: (a)=>_redactedJs.value(a)
    });
}
class DurationFromSelf extends /*#__PURE__*/ declare(_durationJs.isDuration, {
    identifier: "DurationFromSelf",
    pretty: ()=>String,
    arbitrary: ()=>(fc)=>fc.oneof(fc.constant(_durationJs.infinity), fc.bigInt({
                min: 0n
            }).map((_)=>_durationJs.nanos(_)), fc.maxSafeNat().map((_)=>_durationJs.millis(_))),
    equivalence: ()=>_durationJs.Equivalence
}) {
}
class DurationFromNanos extends /*#__PURE__*/ transformOrFail(NonNegativeBigIntFromSelf.annotations({
    description: "a bigint to be decoded into a Duration"
}), DurationFromSelf.pipe(filter((duration)=>_durationJs.isFinite(duration), {
    description: "a finite duration"
})), {
    strict: true,
    decode: (i)=>_parseResultJs.succeed(_durationJs.nanos(i)),
    encode: (a, _, ast)=>_optionJs.match(_durationJs.toNanos(a), {
            onNone: ()=>_parseResultJs.fail(new _parseResultJs.Type(ast, a, `Unable to encode ${a} into a bigint`)),
            onSome: (nanos)=>_parseResultJs.succeed(nanos)
        })
}).annotations({
    identifier: "DurationFromNanos"
}) {
}
const NonNegativeInt = /*#__PURE__*/ NonNegative.pipe(int()).annotations({
    identifier: "NonNegativeInt"
});
class DurationFromMillis extends /*#__PURE__*/ transform(NonNegative.annotations({
    description: "a non-negative number to be decoded into a Duration"
}), DurationFromSelf, {
    strict: true,
    decode: (i)=>_durationJs.millis(i),
    encode: (a)=>_durationJs.toMillis(a)
}).annotations({
    identifier: "DurationFromMillis"
}) {
}
const DurationValueMillis = /*#__PURE__*/ TaggedStruct("Millis", {
    millis: NonNegativeInt
});
const DurationValueNanos = /*#__PURE__*/ TaggedStruct("Nanos", {
    nanos: BigInt$
});
const DurationValueInfinity = /*#__PURE__*/ TaggedStruct("Infinity", {});
const durationValueInfinity = /*#__PURE__*/ DurationValueInfinity.make({});
const DurationValue = /*#__PURE__*/ Union(DurationValueMillis, DurationValueNanos, DurationValueInfinity).annotations({
    identifier: "DurationValue",
    description: "an JSON-compatible tagged union to be decoded into a Duration"
});
const FiniteHRTime = /*#__PURE__*/ Tuple(element(NonNegativeInt).annotations({
    title: "seconds"
}), element(NonNegativeInt).annotations({
    title: "nanos"
})).annotations({
    identifier: "FiniteHRTime"
});
const InfiniteHRTime = /*#__PURE__*/ Tuple(Literal(-1), Literal(0)).annotations({
    identifier: "InfiniteHRTime"
});
const HRTime = /*#__PURE__*/ Union(FiniteHRTime, InfiniteHRTime).annotations({
    identifier: "HRTime",
    description: "a tuple of seconds and nanos to be decoded into a Duration"
});
const isDurationValue = (u)=>typeof u === "object";
class Duration extends /*#__PURE__*/ transform(Union(DurationValue, HRTime), DurationFromSelf, {
    strict: true,
    decode: (i)=>{
        if (isDurationValue(i)) switch(i._tag){
            case "Millis":
                return _durationJs.millis(i.millis);
            case "Nanos":
                return _durationJs.nanos(i.nanos);
            case "Infinity":
                return _durationJs.infinity;
        }
        const [seconds, nanos] = i;
        return seconds === -1 ? _durationJs.infinity : _durationJs.nanos(BigInt(seconds) * BigInt(1e9) + BigInt(nanos));
    },
    encode: (a)=>{
        switch(a.value._tag){
            case "Millis":
                return DurationValueMillis.make({
                    millis: a.value.millis
                });
            case "Nanos":
                return DurationValueNanos.make({
                    nanos: a.value.nanos
                });
            case "Infinity":
                return durationValueInfinity;
        }
    }
}).annotations({
    identifier: "Duration"
}) {
}
const clampDuration = (minimum, maximum)=>(self)=>transform(self, self.pipe(typeSchema, betweenDuration(minimum, maximum)), {
            strict: false,
            decode: (i)=>_durationJs.clamp(i, {
                    minimum,
                    maximum
                }),
            encode: (0, _functionJs.identity)
        });
const LessThanDurationSchemaId = /*#__PURE__*/ Symbol.for("effect/SchemaId/LessThanDuration");
const lessThanDuration = (max, annotations)=>(self)=>self.pipe(filter((a)=>_durationJs.lessThan(a, max), {
            schemaId: LessThanDurationSchemaId,
            [LessThanDurationSchemaId]: {
                max
            },
            title: `lessThanDuration(${max})`,
            description: `a Duration less than ${_durationJs.decode(max)}`,
            ...annotations
        }));
const LessThanOrEqualToDurationSchemaId = /*#__PURE__*/ Symbol.for("effect/schema/LessThanOrEqualToDuration");
const lessThanOrEqualToDuration = (max, annotations)=>(self)=>self.pipe(filter((a)=>_durationJs.lessThanOrEqualTo(a, max), {
            schemaId: LessThanDurationSchemaId,
            [LessThanDurationSchemaId]: {
                max
            },
            title: `lessThanOrEqualToDuration(${max})`,
            description: `a Duration less than or equal to ${_durationJs.decode(max)}`,
            ...annotations
        }));
const GreaterThanDurationSchemaId = /*#__PURE__*/ Symbol.for("effect/SchemaId/GreaterThanDuration");
const greaterThanDuration = (min, annotations)=>(self)=>self.pipe(filter((a)=>_durationJs.greaterThan(a, min), {
            schemaId: GreaterThanDurationSchemaId,
            [GreaterThanDurationSchemaId]: {
                min
            },
            title: `greaterThanDuration(${min})`,
            description: `a Duration greater than ${_durationJs.decode(min)}`,
            ...annotations
        }));
const GreaterThanOrEqualToDurationSchemaId = /*#__PURE__*/ Symbol.for("effect/schema/GreaterThanOrEqualToDuration");
const greaterThanOrEqualToDuration = (min, annotations)=>(self)=>self.pipe(filter((a)=>_durationJs.greaterThanOrEqualTo(a, min), {
            schemaId: GreaterThanOrEqualToDurationSchemaId,
            [GreaterThanOrEqualToDurationSchemaId]: {
                min
            },
            title: `greaterThanOrEqualToDuration(${min})`,
            description: `a Duration greater than or equal to ${_durationJs.decode(min)}`,
            ...annotations
        }));
const BetweenDurationSchemaId = /*#__PURE__*/ Symbol.for("effect/SchemaId/BetweenDuration");
const betweenDuration = (minimum, maximum, annotations)=>(self)=>self.pipe(filter((a)=>_durationJs.between(a, {
                minimum,
                maximum
            }), {
            schemaId: BetweenDurationSchemaId,
            [BetweenDurationSchemaId]: {
                maximum,
                minimum
            },
            title: `betweenDuration(${minimum}, ${maximum})`,
            description: `a Duration between ${_durationJs.decode(minimum)} and ${_durationJs.decode(maximum)}`,
            ...annotations
        }));
class Uint8ArrayFromSelf extends /*#__PURE__*/ declare(_predicateJs.isUint8Array, {
    identifier: "Uint8ArrayFromSelf",
    pretty: ()=>(u8arr)=>`new Uint8Array(${JSON.stringify(Array.from(u8arr))})`,
    arbitrary: ()=>(fc)=>fc.uint8Array(),
    equivalence: ()=>_arrayJs.getEquivalence(_equalJs.equals)
}) {
}
class Uint8 extends /*#__PURE__*/ Number$.pipe(/*#__PURE__*/ between(0, 255, {
    identifier: "Uint8",
    description: "a 8-bit unsigned integer"
})) {
}
/** @ignore */ class Uint8Array$ extends /*#__PURE__*/ transform(Array$(Uint8).annotations({
    description: "an array of 8-bit unsigned integers to be decoded into a Uint8Array"
}), Uint8ArrayFromSelf, {
    strict: true,
    decode: (i)=>Uint8Array.from(i),
    encode: (a)=>Array.from(a)
}).annotations({
    identifier: "Uint8Array"
}) {
}
const makeUint8ArrayTransformation = (id, decode, encode)=>transformOrFail(String$.annotations({
        description: "a string to be decoded into a Uint8Array"
    }), Uint8ArrayFromSelf, {
        strict: true,
        decode: (i, _, ast)=>_eitherJs.mapLeft(decode(i), (decodeException)=>new _parseResultJs.Type(ast, i, decodeException.message)),
        encode: (a)=>_parseResultJs.succeed(encode(a))
    }).annotations({
        identifier: id
    });
const Uint8ArrayFromBase64 = /*#__PURE__*/ makeUint8ArrayTransformation("Uint8ArrayFromBase64", _encodingJs.decodeBase64, _encodingJs.encodeBase64);
const Uint8ArrayFromBase64Url = /*#__PURE__*/ makeUint8ArrayTransformation("Uint8ArrayFromBase64Url", _encodingJs.decodeBase64Url, _encodingJs.encodeBase64Url);
const Uint8ArrayFromHex = /*#__PURE__*/ makeUint8ArrayTransformation("Uint8ArrayFromHex", _encodingJs.decodeHex, _encodingJs.encodeHex);
const makeEncodingTransformation = (id, decode, encode)=>transformOrFail(String$.annotations({
        description: `A string that is interpreted as being ${id}-encoded and will be decoded into a UTF-8 string`
    }), String$, {
        strict: true,
        decode: (i, _, ast)=>_eitherJs.mapLeft(decode(i), (decodeException)=>new _parseResultJs.Type(ast, i, decodeException.message)),
        encode: (a)=>_parseResultJs.succeed(encode(a))
    }).annotations({
        identifier: `StringFrom${id}`
    });
const StringFromBase64 = /*#__PURE__*/ makeEncodingTransformation("Base64", _encodingJs.decodeBase64String, _encodingJs.encodeBase64);
const StringFromBase64Url = /*#__PURE__*/ makeEncodingTransformation("Base64Url", _encodingJs.decodeBase64UrlString, _encodingJs.encodeBase64Url);
const StringFromHex = /*#__PURE__*/ makeEncodingTransformation("Hex", _encodingJs.decodeHexString, _encodingJs.encodeHex);
const StringFromUriComponent = /*#__PURE__*/ transformOrFail(String$.annotations({
    description: `A string that is interpreted as being UriComponent-encoded and will be decoded into a UTF-8 string`
}), String$, {
    strict: true,
    decode: (i, _, ast)=>_eitherJs.mapLeft(_encodingJs.decodeUriComponent(i), (decodeException)=>new _parseResultJs.Type(ast, i, decodeException.message)),
    encode: (a, _, ast)=>_eitherJs.mapLeft(_encodingJs.encodeUriComponent(a), (encodeException)=>new _parseResultJs.Type(ast, a, encodeException.message))
}).annotations({
    identifier: `StringFromUriComponent`
});
const MinItemsSchemaId = _schemaIdJs.MinItemsSchemaId;
const minItems = (n, annotations)=>(self)=>{
        const minItems = Math.floor(n);
        if (minItems < 1) throw new Error(_errorsJs.getInvalidArgumentErrorMessage(`Expected an integer greater than or equal to 1, actual ${n}`));
        return self.pipe(filter((a)=>a.length >= minItems, {
            schemaId: MinItemsSchemaId,
            title: `minItems(${minItems})`,
            description: `an array of at least ${minItems} item(s)`,
            jsonSchema: {
                minItems
            },
            [_schemaASTJs.StableFilterAnnotationId]: true,
            ...annotations
        }));
    };
const MaxItemsSchemaId = _schemaIdJs.MaxItemsSchemaId;
const maxItems = (n, annotations)=>(self)=>{
        const maxItems = Math.floor(n);
        if (maxItems < 1) throw new Error(_errorsJs.getInvalidArgumentErrorMessage(`Expected an integer greater than or equal to 1, actual ${n}`));
        return self.pipe(filter((a)=>a.length <= maxItems, {
            schemaId: MaxItemsSchemaId,
            title: `maxItems(${maxItems})`,
            description: `an array of at most ${maxItems} item(s)`,
            jsonSchema: {
                maxItems
            },
            [_schemaASTJs.StableFilterAnnotationId]: true,
            ...annotations
        }));
    };
const ItemsCountSchemaId = _schemaIdJs.ItemsCountSchemaId;
const itemsCount = (n, annotations)=>(self)=>{
        const itemsCount = Math.floor(n);
        if (itemsCount < 0) throw new Error(_errorsJs.getInvalidArgumentErrorMessage(`Expected an integer greater than or equal to 0, actual ${n}`));
        return self.pipe(filter((a)=>a.length === itemsCount, {
            schemaId: ItemsCountSchemaId,
            title: `itemsCount(${itemsCount})`,
            description: `an array of exactly ${itemsCount} item(s)`,
            jsonSchema: {
                minItems: itemsCount,
                maxItems: itemsCount
            },
            [_schemaASTJs.StableFilterAnnotationId]: true,
            ...annotations
        }));
    };
const getNumberIndexedAccess = (self)=>make(_schemaASTJs.getNumberIndexedAccess(self.ast));
function head(self) {
    return transform(self, OptionFromSelf(getNumberIndexedAccess(typeSchema(self))), {
        strict: false,
        decode: (i)=>_arrayJs.head(i),
        encode: (a)=>_optionJs.match(a, {
                onNone: ()=>[],
                onSome: _arrayJs.of
            })
    });
}
function headNonEmpty(self) {
    return transform(self, getNumberIndexedAccess(typeSchema(self)), {
        strict: false,
        decode: (i)=>_arrayJs.headNonEmpty(i),
        encode: (a)=>_arrayJs.of(a)
    });
}
const headOrElse = /*#__PURE__*/ (0, _functionJs.dual)((args)=>isSchema(args[0]), (self, fallback)=>transformOrFail(self, getNumberIndexedAccess(typeSchema(self)), {
        strict: true,
        decode: (i, _, ast)=>i.length > 0 ? _parseResultJs.succeed(i[0]) : fallback ? _parseResultJs.succeed(fallback()) : _parseResultJs.fail(new _parseResultJs.Type(ast, i, "Unable to retrieve the first element of an empty array")),
        encode: (a)=>_parseResultJs.succeed(_arrayJs.of(a))
    }));
const ValidDateSchemaId = /*#__PURE__*/ Symbol.for("effect/SchemaId/ValidDate");
const validDate = (annotations)=>(self)=>self.pipe(filter((a)=>!Number.isNaN(a.getTime()), {
            schemaId: ValidDateSchemaId,
            [ValidDateSchemaId]: {
                noInvalidDate: true
            },
            title: "validDate",
            description: "a valid Date",
            ...annotations
        }));
const LessThanDateSchemaId = /*#__PURE__*/ Symbol.for("effect/SchemaId/LessThanDate");
const lessThanDate = (max, annotations)=>(self)=>self.pipe(filter((a)=>a < max, {
            schemaId: LessThanDateSchemaId,
            [LessThanDateSchemaId]: {
                max
            },
            title: `lessThanDate(${_utilJs.formatDate(max)})`,
            description: `a date before ${_utilJs.formatDate(max)}`,
            ...annotations
        }));
const LessThanOrEqualToDateSchemaId = /*#__PURE__*/ Symbol.for("effect/schema/LessThanOrEqualToDate");
const lessThanOrEqualToDate = (max, annotations)=>(self)=>self.pipe(filter((a)=>a <= max, {
            schemaId: LessThanDateSchemaId,
            [LessThanDateSchemaId]: {
                max
            },
            title: `lessThanOrEqualToDate(${_utilJs.formatDate(max)})`,
            description: `a date before or equal to ${_utilJs.formatDate(max)}`,
            ...annotations
        }));
const GreaterThanDateSchemaId = /*#__PURE__*/ Symbol.for("effect/SchemaId/GreaterThanDate");
const greaterThanDate = (min, annotations)=>(self)=>self.pipe(filter((a)=>a > min, {
            schemaId: GreaterThanDateSchemaId,
            [GreaterThanDateSchemaId]: {
                min
            },
            title: `greaterThanDate(${_utilJs.formatDate(min)})`,
            description: `a date after ${_utilJs.formatDate(min)}`,
            ...annotations
        }));
const GreaterThanOrEqualToDateSchemaId = /*#__PURE__*/ Symbol.for("effect/schema/GreaterThanOrEqualToDate");
const greaterThanOrEqualToDate = (min, annotations)=>(self)=>self.pipe(filter((a)=>a >= min, {
            schemaId: GreaterThanOrEqualToDateSchemaId,
            [GreaterThanOrEqualToDateSchemaId]: {
                min
            },
            title: `greaterThanOrEqualToDate(${_utilJs.formatDate(min)})`,
            description: `a date after or equal to ${_utilJs.formatDate(min)}`,
            ...annotations
        }));
const BetweenDateSchemaId = /*#__PURE__*/ Symbol.for("effect/SchemaId/BetweenDate");
const betweenDate = (min, max, annotations)=>(self)=>self.pipe(filter((a)=>a <= max && a >= min, {
            schemaId: BetweenDateSchemaId,
            [BetweenDateSchemaId]: {
                max,
                min
            },
            title: `betweenDate(${_utilJs.formatDate(min)}, ${_utilJs.formatDate(max)})`,
            description: `a date between ${_utilJs.formatDate(min)} and ${_utilJs.formatDate(max)}`,
            ...annotations
        }));
const DateFromSelfSchemaId = _schemaIdJs.DateFromSelfSchemaId;
class DateFromSelf extends /*#__PURE__*/ declare(_predicateJs.isDate, {
    identifier: "DateFromSelf",
    schemaId: DateFromSelfSchemaId,
    [DateFromSelfSchemaId]: {
        noInvalidDate: false
    },
    description: "a potentially invalid Date instance",
    pretty: ()=>(date)=>`new Date(${JSON.stringify(date)})`,
    arbitrary: ()=>(fc)=>fc.date({
                noInvalidDate: false
            }),
    equivalence: ()=>_equivalenceJs.Date
}) {
}
class ValidDateFromSelf extends /*#__PURE__*/ DateFromSelf.pipe(/*#__PURE__*/ validDate({
    identifier: "ValidDateFromSelf",
    description: "a valid Date instance"
})) {
}
class DateFromString extends /*#__PURE__*/ transform(String$.annotations({
    description: "a string to be decoded into a Date"
}), DateFromSelf, {
    strict: true,
    decode: (i)=>new Date(i),
    encode: (a)=>_utilJs.formatDate(a)
}).annotations({
    identifier: "DateFromString"
}) {
}
/** @ignore */ class Date$ extends /*#__PURE__*/ DateFromString.pipe(/*#__PURE__*/ validDate({
    identifier: "Date"
})) {
}
class DateFromNumber extends /*#__PURE__*/ transform(Number$.annotations({
    description: "a number to be decoded into a Date"
}), DateFromSelf, {
    strict: true,
    decode: (i)=>new Date(i),
    encode: (a)=>a.getTime()
}).annotations({
    identifier: "DateFromNumber"
}) {
}
class DateTimeUtcFromSelf extends /*#__PURE__*/ declare((u)=>_dateTimeJs.isDateTime(u) && _dateTimeJs.isUtc(u), {
    identifier: "DateTimeUtcFromSelf",
    description: "a DateTime.Utc instance",
    pretty: ()=>(dateTime)=>dateTime.toString(),
    arbitrary: ()=>(fc)=>fc.date({
                noInvalidDate: true
            }).map((date)=>_dateTimeJs.unsafeFromDate(date)),
    equivalence: ()=>_dateTimeJs.Equivalence
}) {
}
const decodeDateTimeUtc = (input, ast)=>_parseResultJs.try({
        try: ()=>_dateTimeJs.unsafeMake(input),
        catch: ()=>new _parseResultJs.Type(ast, input, `Unable to decode ${_utilJs.formatUnknown(input)} into a DateTime.Utc`)
    });
class DateTimeUtcFromNumber extends /*#__PURE__*/ transformOrFail(Number$.annotations({
    description: "a number to be decoded into a DateTime.Utc"
}), DateTimeUtcFromSelf, {
    strict: true,
    decode: (i, _, ast)=>decodeDateTimeUtc(i, ast),
    encode: (a)=>_parseResultJs.succeed(_dateTimeJs.toEpochMillis(a))
}).annotations({
    identifier: "DateTimeUtcFromNumber"
}) {
}
class DateTimeUtcFromDate extends /*#__PURE__*/ transformOrFail(DateFromSelf.annotations({
    description: "a Date to be decoded into a DateTime.Utc"
}), DateTimeUtcFromSelf, {
    strict: true,
    decode: (i, _, ast)=>decodeDateTimeUtc(i, ast),
    encode: (a)=>_parseResultJs.succeed(_dateTimeJs.toDateUtc(a))
}).annotations({
    identifier: "DateTimeUtcFromDate"
}) {
}
class DateTimeUtc extends /*#__PURE__*/ transformOrFail(String$.annotations({
    description: "a string to be decoded into a DateTime.Utc"
}), DateTimeUtcFromSelf, {
    strict: true,
    decode: (i, _, ast)=>decodeDateTimeUtc(i, ast),
    encode: (a)=>_parseResultJs.succeed(_dateTimeJs.formatIso(a))
}).annotations({
    identifier: "DateTimeUtc"
}) {
}
const timeZoneOffsetArbitrary = ()=>(fc)=>fc.integer({
            min: -43200000,
            max: 50400000
        }).map(_dateTimeJs.zoneMakeOffset);
class TimeZoneOffsetFromSelf extends /*#__PURE__*/ declare(_dateTimeJs.isTimeZoneOffset, {
    identifier: "TimeZoneOffsetFromSelf",
    description: "a TimeZone.Offset instance",
    pretty: ()=>(zone)=>zone.toString(),
    arbitrary: timeZoneOffsetArbitrary
}) {
}
class TimeZoneOffset extends /*#__PURE__*/ transform(Number$.annotations({
    description: "a number to be decoded into a TimeZone.Offset"
}), TimeZoneOffsetFromSelf, {
    strict: true,
    decode: (i)=>_dateTimeJs.zoneMakeOffset(i),
    encode: (a)=>a.offset
}).annotations({
    identifier: "TimeZoneOffset"
}) {
}
const timeZoneNamedArbitrary = ()=>(fc)=>fc.constantFrom(...Intl.supportedValuesOf("timeZone")).map(_dateTimeJs.zoneUnsafeMakeNamed);
class TimeZoneNamedFromSelf extends /*#__PURE__*/ declare(_dateTimeJs.isTimeZoneNamed, {
    identifier: "TimeZoneNamedFromSelf",
    description: "a TimeZone.Named instance",
    pretty: ()=>(zone)=>zone.toString(),
    arbitrary: timeZoneNamedArbitrary
}) {
}
class TimeZoneNamed extends /*#__PURE__*/ transformOrFail(String$.annotations({
    description: "a string to be decoded into a TimeZone.Named"
}), TimeZoneNamedFromSelf, {
    strict: true,
    decode: (i, _, ast)=>_parseResultJs.try({
            try: ()=>_dateTimeJs.zoneUnsafeMakeNamed(i),
            catch: ()=>new _parseResultJs.Type(ast, i, `Unable to decode ${JSON.stringify(i)} into a TimeZone.Named`)
        }),
    encode: (a)=>_parseResultJs.succeed(a.id)
}).annotations({
    identifier: "TimeZoneNamed"
}) {
}
class TimeZoneFromSelf extends /*#__PURE__*/ Union(TimeZoneOffsetFromSelf, TimeZoneNamedFromSelf) {
}
class TimeZone extends /*#__PURE__*/ transformOrFail(String$.annotations({
    description: "a string to be decoded into a TimeZone"
}), TimeZoneFromSelf, {
    strict: true,
    decode: (i, _, ast)=>_optionJs.match(_dateTimeJs.zoneFromString(i), {
            onNone: ()=>_parseResultJs.fail(new _parseResultJs.Type(ast, i, `Unable to decode ${JSON.stringify(i)} into a TimeZone`)),
            onSome: _parseResultJs.succeed
        }),
    encode: (a)=>_parseResultJs.succeed(_dateTimeJs.zoneToString(a))
}).annotations({
    identifier: "TimeZone"
}) {
}
const timeZoneArbitrary = (fc)=>fc.oneof(timeZoneOffsetArbitrary()(fc), timeZoneNamedArbitrary()(fc));
class DateTimeZonedFromSelf extends /*#__PURE__*/ declare((u)=>_dateTimeJs.isDateTime(u) && _dateTimeJs.isZoned(u), {
    identifier: "DateTimeZonedFromSelf",
    description: "a DateTime.Zoned instance",
    pretty: ()=>(dateTime)=>dateTime.toString(),
    arbitrary: ()=>(fc)=>fc.tuple(fc.integer({
                // time zone db supports +/- 1000 years or so
                min: -31536000000000,
                max: 31536000000000
            }), timeZoneArbitrary(fc)).map(([millis, timeZone])=>_dateTimeJs.unsafeMakeZoned(millis, {
                    timeZone
                })),
    equivalence: ()=>_dateTimeJs.Equivalence
}) {
}
class DateTimeZoned extends /*#__PURE__*/ transformOrFail(String$.annotations({
    description: "a string to be decoded into a DateTime.Zoned"
}), DateTimeZonedFromSelf, {
    strict: true,
    decode: (i, _, ast)=>_optionJs.match(_dateTimeJs.makeZonedFromString(i), {
            onNone: ()=>_parseResultJs.fail(new _parseResultJs.Type(ast, i, `Unable to decode ${JSON.stringify(i)} into a DateTime.Zoned`)),
            onSome: _parseResultJs.succeed
        }),
    encode: (a)=>_parseResultJs.succeed(_dateTimeJs.formatIsoZoned(a))
}).annotations({
    identifier: "DateTimeZoned"
}) {
}
const OptionNoneEncoded = /*#__PURE__*/ Struct({
    _tag: Literal("None")
}).annotations({
    description: "NoneEncoded"
});
const optionSomeEncoded = (value)=>Struct({
        _tag: Literal("Some"),
        value
    }).annotations({
        description: `SomeEncoded<${format(value)}>`
    });
const optionEncoded = (value)=>Union(OptionNoneEncoded, optionSomeEncoded(value)).annotations({
        description: `OptionEncoded<${format(value)}>`
    });
const optionDecode = (input)=>input._tag === "None" ? _optionJs.none() : _optionJs.some(input.value);
const optionArbitrary = (value, ctx)=>(fc)=>fc.oneof(ctx, fc.record({
            _tag: fc.constant("None")
        }), fc.record({
            _tag: fc.constant("Some"),
            value: value(fc)
        })).map(optionDecode);
const optionPretty = (value)=>_optionJs.match({
        onNone: ()=>"none()",
        onSome: (a)=>`some(${value(a)})`
    });
const optionParse = (decodeUnknown)=>(u, options, ast)=>_optionJs.isOption(u) ? _optionJs.isNone(u) ? _parseResultJs.succeed(_optionJs.none()) : toComposite(decodeUnknown(u.value, options), _optionJs.some, ast, u) : _parseResultJs.fail(new _parseResultJs.Type(ast, u));
const OptionFromSelf = (value)=>{
    return declare([
        value
    ], {
        decode: (value)=>optionParse(_parseResultJs.decodeUnknown(value)),
        encode: (value)=>optionParse(_parseResultJs.encodeUnknown(value))
    }, {
        description: `Option<${format(value)}>`,
        pretty: optionPretty,
        arbitrary: optionArbitrary,
        equivalence: _optionJs.getEquivalence
    });
};
const makeNoneEncoded = {
    _tag: "None"
};
const makeSomeEncoded = (value)=>({
        _tag: "Some",
        value
    });
function Option(value) {
    const value_ = asSchema(value);
    const out = transform(optionEncoded(value_), OptionFromSelf(typeSchema(value_)), {
        strict: true,
        decode: (i)=>optionDecode(i),
        encode: (a)=>_optionJs.match(a, {
                onNone: ()=>makeNoneEncoded,
                onSome: makeSomeEncoded
            })
    });
    return out;
}
function OptionFromNullOr(value) {
    return transform(NullOr(value), OptionFromSelf(typeSchema(asSchema(value))), {
        strict: true,
        decode: (i)=>_optionJs.fromNullable(i),
        encode: (a)=>_optionJs.getOrNull(a)
    });
}
function OptionFromNullishOr(value, onNoneEncoding) {
    return transform(NullishOr(value), OptionFromSelf(typeSchema(asSchema(value))), {
        strict: true,
        decode: (i)=>_optionJs.fromNullable(i),
        encode: onNoneEncoding === null ? (a)=>_optionJs.getOrNull(a) : (a)=>_optionJs.getOrUndefined(a)
    });
}
function OptionFromUndefinedOr(value) {
    return transform(UndefinedOr(value), OptionFromSelf(typeSchema(asSchema(value))), {
        strict: true,
        decode: (i)=>_optionJs.fromNullable(i),
        encode: (a)=>_optionJs.getOrUndefined(a)
    });
}
class OptionFromNonEmptyTrimmedString extends /*#__PURE__*/ transform(String$, /*#__PURE__*/ OptionFromSelf(NonEmptyTrimmedString), {
    strict: true,
    decode: (i)=>_optionJs.filter(_optionJs.some(i.trim()), _stringJs.isNonEmpty),
    encode: (a)=>_optionJs.getOrElse(a, ()=>"")
}) {
}
const rightEncoded = (right)=>Struct({
        _tag: Literal("Right"),
        right
    }).annotations({
        description: `RightEncoded<${format(right)}>`
    });
const leftEncoded = (left)=>Struct({
        _tag: Literal("Left"),
        left
    }).annotations({
        description: `LeftEncoded<${format(left)}>`
    });
const eitherEncoded = (right, left)=>Union(rightEncoded(right), leftEncoded(left)).annotations({
        description: `EitherEncoded<${format(left)}, ${format(right)}>`
    });
const eitherDecode = (input)=>input._tag === "Left" ? _eitherJs.left(input.left) : _eitherJs.right(input.right);
const eitherArbitrary = (right, left)=>(fc)=>fc.oneof(fc.record({
            _tag: fc.constant("Left"),
            left: left(fc)
        }), fc.record({
            _tag: fc.constant("Right"),
            right: right(fc)
        })).map(eitherDecode);
const eitherPretty = (right, left)=>_eitherJs.match({
        onLeft: (e)=>`left(${left(e)})`,
        onRight: (a)=>`right(${right(a)})`
    });
const eitherParse = (parseRight, decodeUnknownLeft)=>(u, options, ast)=>_eitherJs.isEither(u) ? _eitherJs.match(u, {
            onLeft: (left)=>toComposite(decodeUnknownLeft(left, options), _eitherJs.left, ast, u),
            onRight: (right)=>toComposite(parseRight(right, options), _eitherJs.right, ast, u)
        }) : _parseResultJs.fail(new _parseResultJs.Type(ast, u));
const EitherFromSelf = ({ left, right })=>{
    return declare([
        right,
        left
    ], {
        decode: (right, left)=>eitherParse(_parseResultJs.decodeUnknown(right), _parseResultJs.decodeUnknown(left)),
        encode: (right, left)=>eitherParse(_parseResultJs.encodeUnknown(right), _parseResultJs.encodeUnknown(left))
    }, {
        description: `Either<${format(right)}, ${format(left)}>`,
        pretty: eitherPretty,
        arbitrary: eitherArbitrary,
        equivalence: (right, left)=>_eitherJs.getEquivalence({
                left,
                right
            })
    });
};
const makeLeftEncoded = (left)=>({
        _tag: "Left",
        left
    });
const makeRightEncoded = (right)=>({
        _tag: "Right",
        right
    });
const Either = ({ left, right })=>{
    const right_ = asSchema(right);
    const left_ = asSchema(left);
    const out = transform(eitherEncoded(right_, left_), EitherFromSelf({
        left: typeSchema(left_),
        right: typeSchema(right_)
    }), {
        strict: true,
        decode: (i)=>eitherDecode(i),
        encode: (a)=>_eitherJs.match(a, {
                onLeft: makeLeftEncoded,
                onRight: makeRightEncoded
            })
    });
    return out;
};
const EitherFromUnion = ({ left, right })=>{
    const right_ = asSchema(right);
    const left_ = asSchema(left);
    const toright = typeSchema(right_);
    const toleft = typeSchema(left_);
    const fromRight = transform(right_, rightEncoded(toright), {
        strict: true,
        decode: (i)=>makeRightEncoded(i),
        encode: (a)=>a.right
    });
    const fromLeft = transform(left_, leftEncoded(toleft), {
        strict: true,
        decode: (i)=>makeLeftEncoded(i),
        encode: (a)=>a.left
    });
    const out = transform(Union(fromRight, fromLeft), EitherFromSelf({
        left: toleft,
        right: toright
    }), {
        strict: true,
        decode: (i)=>i._tag === "Left" ? _eitherJs.left(i.left) : _eitherJs.right(i.right),
        encode: (a)=>_eitherJs.match(a, {
                onLeft: makeLeftEncoded,
                onRight: makeRightEncoded
            })
    });
    return out;
};
const mapArbitrary = (key, value, ctx)=>{
    return (fc)=>{
        const items = fc.array(fc.tuple(key(fc), value(fc)));
        return (ctx.depthIdentifier !== undefined ? fc.oneof(ctx, fc.constant([]), items) : items).map((as)=>new Map(as));
    };
};
const readonlyMapPretty = (key, value)=>(map)=>`new Map([${Array.from(map.entries()).map(([k, v])=>`[${key(k)}, ${value(v)}]`).join(", ")}])`;
const readonlyMapEquivalence = (key, value)=>{
    const arrayEquivalence = _arrayJs.getEquivalence(_equivalenceJs.make(([ka, va], [kb, vb])=>key(ka, kb) && value(va, vb)));
    return _equivalenceJs.make((a, b)=>arrayEquivalence(Array.from(a.entries()), Array.from(b.entries())));
};
const readonlyMapParse = (decodeUnknown)=>(u, options, ast)=>_predicateJs.isMap(u) ? toComposite(decodeUnknown(Array.from(u.entries()), options), (as)=>new Map(as), ast, u) : _parseResultJs.fail(new _parseResultJs.Type(ast, u));
const mapFromSelf_ = (key, value, description)=>declare([
        key,
        value
    ], {
        decode: (Key, Value)=>readonlyMapParse(_parseResultJs.decodeUnknown(Array$(Tuple(Key, Value)))),
        encode: (Key, Value)=>readonlyMapParse(_parseResultJs.encodeUnknown(Array$(Tuple(Key, Value))))
    }, {
        description,
        pretty: readonlyMapPretty,
        arbitrary: mapArbitrary,
        equivalence: readonlyMapEquivalence
    });
const ReadonlyMapFromSelf = ({ key, value })=>mapFromSelf_(key, value, `ReadonlyMap<${format(key)}, ${format(value)}>`);
const MapFromSelf = ({ key, value })=>mapFromSelf_(key, value, `Map<${format(key)}, ${format(value)}>`);
function ReadonlyMap({ key, value }) {
    return transform(Array$(Tuple(key, value)), ReadonlyMapFromSelf({
        key: typeSchema(asSchema(key)),
        value: typeSchema(asSchema(value))
    }), {
        strict: true,
        decode: (i)=>new Map(i),
        encode: (a)=>Array.from(a.entries())
    });
}
/** @ignore */ function map({ key, value }) {
    return transform(Array$(Tuple(key, value)), MapFromSelf({
        key: typeSchema(asSchema(key)),
        value: typeSchema(asSchema(value))
    }), {
        strict: true,
        decode: (i)=>new Map(i),
        encode: (a)=>Array.from(a.entries())
    });
}
const ReadonlyMapFromRecord = ({ key, value })=>transform(Record({
        key: encodedBoundSchema(key),
        value
    }).annotations({
        description: "a record to be decoded into a ReadonlyMap"
    }), ReadonlyMapFromSelf({
        key,
        value: typeSchema(value)
    }), {
        strict: true,
        decode: (i)=>new Map(Object.entries(i)),
        encode: (a)=>Object.fromEntries(a)
    });
const MapFromRecord = ({ key, value })=>transform(Record({
        key: encodedBoundSchema(key),
        value
    }).annotations({
        description: "a record to be decoded into a Map"
    }), MapFromSelf({
        key,
        value: typeSchema(value)
    }), {
        strict: true,
        decode: (i)=>new Map(Object.entries(i)),
        encode: (a)=>Object.fromEntries(a)
    });
const setArbitrary = (item, ctx)=>(fc)=>{
        const items = fc.array(item(fc));
        return (ctx.depthIdentifier !== undefined ? fc.oneof(ctx, fc.constant([]), items) : items).map((as)=>new Set(as));
    };
const readonlySetPretty = (item)=>(set)=>`new Set([${Array.from(set.values()).map((a)=>item(a)).join(", ")}])`;
const readonlySetEquivalence = (item)=>{
    const arrayEquivalence = _arrayJs.getEquivalence(item);
    return _equivalenceJs.make((a, b)=>arrayEquivalence(Array.from(a.values()), Array.from(b.values())));
};
const readonlySetParse = (decodeUnknown)=>(u, options, ast)=>_predicateJs.isSet(u) ? toComposite(decodeUnknown(Array.from(u.values()), options), (as)=>new Set(as), ast, u) : _parseResultJs.fail(new _parseResultJs.Type(ast, u));
const setFromSelf_ = (value, description)=>declare([
        value
    ], {
        decode: (item)=>readonlySetParse(_parseResultJs.decodeUnknown(Array$(item))),
        encode: (item)=>readonlySetParse(_parseResultJs.encodeUnknown(Array$(item)))
    }, {
        description,
        pretty: readonlySetPretty,
        arbitrary: setArbitrary,
        equivalence: readonlySetEquivalence
    });
const ReadonlySetFromSelf = (value)=>setFromSelf_(value, `ReadonlySet<${format(value)}>`);
const SetFromSelf = (value)=>setFromSelf_(value, `Set<${format(value)}>`);
function ReadonlySet(value) {
    return transform(Array$(value), ReadonlySetFromSelf(typeSchema(asSchema(value))), {
        strict: true,
        decode: (i)=>new Set(i),
        encode: (a)=>Array.from(a)
    });
}
/** @ignore */ function set(value) {
    return transform(Array$(value), SetFromSelf(typeSchema(asSchema(value))), {
        strict: true,
        decode: (i)=>new Set(i),
        encode: (a)=>Array.from(a)
    });
}
const bigDecimalPretty = ()=>(val)=>`BigDecimal(${_bigDecimalJs.format(_bigDecimalJs.normalize(val))})`;
const bigDecimalArbitrary = ()=>(fc)=>fc.tuple(fc.bigInt(), fc.integer({
            min: 0,
            max: 18
        })).map(([value, scale])=>_bigDecimalJs.make(value, scale));
class BigDecimalFromSelf extends /*#__PURE__*/ declare(_bigDecimalJs.isBigDecimal, {
    identifier: "BigDecimalFromSelf",
    pretty: bigDecimalPretty,
    arbitrary: bigDecimalArbitrary,
    equivalence: ()=>_bigDecimalJs.Equivalence
}) {
}
class BigDecimal extends /*#__PURE__*/ transformOrFail(String$.annotations({
    description: "a string to be decoded into a BigDecimal"
}), BigDecimalFromSelf, {
    strict: true,
    decode: (i, _, ast)=>_bigDecimalJs.fromString(i).pipe(_optionJs.match({
            onNone: ()=>_parseResultJs.fail(new _parseResultJs.Type(ast, i, `Unable to decode ${JSON.stringify(i)} into a BigDecimal`)),
            onSome: (val)=>_parseResultJs.succeed(_bigDecimalJs.normalize(val))
        })),
    encode: (a)=>_parseResultJs.succeed(_bigDecimalJs.format(_bigDecimalJs.normalize(a)))
}).annotations({
    identifier: "BigDecimal"
}) {
}
class BigDecimalFromNumber extends /*#__PURE__*/ transform(Number$.annotations({
    description: "a number to be decoded into a BigDecimal"
}), BigDecimalFromSelf, {
    strict: true,
    decode: (i)=>_bigDecimalJs.unsafeFromNumber(i),
    encode: (a)=>_bigDecimalJs.unsafeToNumber(a)
}).annotations({
    identifier: "BigDecimalFromNumber"
}) {
}
const GreaterThanBigDecimalSchemaId = /*#__PURE__*/ Symbol.for("effect/SchemaId/GreaterThanBigDecimal");
const greaterThanBigDecimal = (min, annotations)=>(self)=>{
        const formatted = _bigDecimalJs.format(min);
        return self.pipe(filter((a)=>_bigDecimalJs.greaterThan(a, min), {
            schemaId: GreaterThanBigDecimalSchemaId,
            [GreaterThanBigDecimalSchemaId]: {
                min
            },
            title: `greaterThanBigDecimal(${formatted})`,
            description: `a BigDecimal greater than ${formatted}`,
            ...annotations
        }));
    };
const GreaterThanOrEqualToBigDecimalSchemaId = /*#__PURE__*/ Symbol.for("effect/schema/GreaterThanOrEqualToBigDecimal");
const greaterThanOrEqualToBigDecimal = (min, annotations)=>(self)=>{
        const formatted = _bigDecimalJs.format(min);
        return self.pipe(filter((a)=>_bigDecimalJs.greaterThanOrEqualTo(a, min), {
            schemaId: GreaterThanOrEqualToBigDecimalSchemaId,
            [GreaterThanOrEqualToBigDecimalSchemaId]: {
                min
            },
            title: `greaterThanOrEqualToBigDecimal(${formatted})`,
            description: `a BigDecimal greater than or equal to ${formatted}`,
            ...annotations
        }));
    };
const LessThanBigDecimalSchemaId = /*#__PURE__*/ Symbol.for("effect/SchemaId/LessThanBigDecimal");
const lessThanBigDecimal = (max, annotations)=>(self)=>{
        const formatted = _bigDecimalJs.format(max);
        return self.pipe(filter((a)=>_bigDecimalJs.lessThan(a, max), {
            schemaId: LessThanBigDecimalSchemaId,
            [LessThanBigDecimalSchemaId]: {
                max
            },
            title: `lessThanBigDecimal(${formatted})`,
            description: `a BigDecimal less than ${formatted}`,
            ...annotations
        }));
    };
const LessThanOrEqualToBigDecimalSchemaId = /*#__PURE__*/ Symbol.for("effect/schema/LessThanOrEqualToBigDecimal");
const lessThanOrEqualToBigDecimal = (max, annotations)=>(self)=>{
        const formatted = _bigDecimalJs.format(max);
        return self.pipe(filter((a)=>_bigDecimalJs.lessThanOrEqualTo(a, max), {
            schemaId: LessThanOrEqualToBigDecimalSchemaId,
            [LessThanOrEqualToBigDecimalSchemaId]: {
                max
            },
            title: `lessThanOrEqualToBigDecimal(${formatted})`,
            description: `a BigDecimal less than or equal to ${formatted}`,
            ...annotations
        }));
    };
const PositiveBigDecimalSchemaId = /*#__PURE__*/ Symbol.for("effect/schema/PositiveBigDecimal");
const positiveBigDecimal = (annotations)=>(self)=>self.pipe(filter((a)=>_bigDecimalJs.isPositive(a), {
            schemaId: PositiveBigDecimalSchemaId,
            title: "positiveBigDecimal",
            description: `a positive BigDecimal`,
            ...annotations
        }));
const PositiveBigDecimalFromSelf = /*#__PURE__*/ BigDecimalFromSelf.pipe(/*#__PURE__*/ positiveBigDecimal({
    identifier: "PositiveBigDecimalFromSelf"
}));
const NonNegativeBigDecimalSchemaId = /*#__PURE__*/ Symbol.for("effect/schema/NonNegativeBigDecimal");
const nonNegativeBigDecimal = (annotations)=>(self)=>self.pipe(filter((a)=>a.value >= 0n, {
            schemaId: NonNegativeBigDecimalSchemaId,
            title: "nonNegativeBigDecimal",
            description: `a non-negative BigDecimal`,
            ...annotations
        }));
const NonNegativeBigDecimalFromSelf = /*#__PURE__*/ BigDecimalFromSelf.pipe(/*#__PURE__*/ nonNegativeBigDecimal({
    identifier: "NonNegativeBigDecimalFromSelf"
}));
const NegativeBigDecimalSchemaId = /*#__PURE__*/ Symbol.for("effect/schema/NegativeBigDecimal");
const negativeBigDecimal = (annotations)=>(self)=>self.pipe(filter((a)=>_bigDecimalJs.isNegative(a), {
            schemaId: NegativeBigDecimalSchemaId,
            title: "negativeBigDecimal",
            description: `a negative BigDecimal`,
            ...annotations
        }));
const NegativeBigDecimalFromSelf = /*#__PURE__*/ BigDecimalFromSelf.pipe(/*#__PURE__*/ negativeBigDecimal({
    identifier: "NegativeBigDecimalFromSelf"
}));
const NonPositiveBigDecimalSchemaId = /*#__PURE__*/ Symbol.for("effect/schema/NonPositiveBigDecimal");
const nonPositiveBigDecimal = (annotations)=>(self)=>self.pipe(filter((a)=>a.value <= 0n, {
            schemaId: NonPositiveBigDecimalSchemaId,
            title: "nonPositiveBigDecimal",
            description: `a non-positive BigDecimal`,
            ...annotations
        }));
const NonPositiveBigDecimalFromSelf = /*#__PURE__*/ BigDecimalFromSelf.pipe(/*#__PURE__*/ nonPositiveBigDecimal({
    identifier: "NonPositiveBigDecimalFromSelf"
}));
const BetweenBigDecimalSchemaId = /*#__PURE__*/ Symbol.for("effect/SchemaId/BetweenBigDecimal");
const betweenBigDecimal = (minimum, maximum, annotations)=>(self)=>{
        const formattedMinimum = _bigDecimalJs.format(minimum);
        const formattedMaximum = _bigDecimalJs.format(maximum);
        return self.pipe(filter((a)=>_bigDecimalJs.between(a, {
                minimum,
                maximum
            }), {
            schemaId: BetweenBigDecimalSchemaId,
            [BetweenBigDecimalSchemaId]: {
                maximum,
                minimum
            },
            title: `betweenBigDecimal(${formattedMinimum}, ${formattedMaximum})`,
            description: `a BigDecimal between ${formattedMinimum} and ${formattedMaximum}`,
            ...annotations
        }));
    };
const clampBigDecimal = (minimum, maximum)=>(self)=>transform(self, self.pipe(typeSchema, betweenBigDecimal(minimum, maximum)), {
            strict: false,
            decode: (i)=>_bigDecimalJs.clamp(i, {
                    minimum,
                    maximum
                }),
            encode: (0, _functionJs.identity)
        });
const chunkArbitrary = (item, ctx)=>(fc)=>{
        const items = fc.array(item(fc));
        return (ctx.depthIdentifier !== undefined ? fc.oneof(ctx, fc.constant([]), items) : items).map(_chunkJs.fromIterable);
    };
const chunkPretty = (item)=>(c)=>`Chunk(${_chunkJs.toReadonlyArray(c).map(item).join(", ")})`;
const chunkParse = (decodeUnknown)=>(u, options, ast)=>_chunkJs.isChunk(u) ? _chunkJs.isEmpty(u) ? _parseResultJs.succeed(_chunkJs.empty()) : toComposite(decodeUnknown(_chunkJs.toReadonlyArray(u), options), _chunkJs.fromIterable, ast, u) : _parseResultJs.fail(new _parseResultJs.Type(ast, u));
const ChunkFromSelf = (value)=>{
    return declare([
        value
    ], {
        decode: (item)=>chunkParse(_parseResultJs.decodeUnknown(Array$(item))),
        encode: (item)=>chunkParse(_parseResultJs.encodeUnknown(Array$(item)))
    }, {
        description: `Chunk<${format(value)}>`,
        pretty: chunkPretty,
        arbitrary: chunkArbitrary,
        equivalence: _chunkJs.getEquivalence
    });
};
function Chunk(value) {
    return transform(Array$(value), ChunkFromSelf(typeSchema(asSchema(value))), {
        strict: true,
        decode: (i)=>i.length === 0 ? _chunkJs.empty() : _chunkJs.fromIterable(i),
        encode: (a)=>_chunkJs.toReadonlyArray(a)
    });
}
const nonEmptyChunkArbitrary = (item)=>(fc)=>_fastCheckJs.array(item(fc), {
            minLength: 1
        }).map((as)=>_chunkJs.unsafeFromNonEmptyArray(as));
const nonEmptyChunkPretty = (item)=>(c)=>`NonEmptyChunk(${_chunkJs.toReadonlyArray(c).map(item).join(", ")})`;
const nonEmptyChunkParse = (decodeUnknown)=>(u, options, ast)=>_chunkJs.isChunk(u) && _chunkJs.isNonEmpty(u) ? toComposite(decodeUnknown(_chunkJs.toReadonlyArray(u), options), _chunkJs.unsafeFromNonEmptyArray, ast, u) : _parseResultJs.fail(new _parseResultJs.Type(ast, u));
const NonEmptyChunkFromSelf = (value)=>{
    return declare([
        value
    ], {
        decode: (item)=>nonEmptyChunkParse(_parseResultJs.decodeUnknown(NonEmptyArray(item))),
        encode: (item)=>nonEmptyChunkParse(_parseResultJs.encodeUnknown(NonEmptyArray(item)))
    }, {
        description: `NonEmptyChunk<${format(value)}>`,
        pretty: nonEmptyChunkPretty,
        arbitrary: nonEmptyChunkArbitrary,
        equivalence: _chunkJs.getEquivalence
    });
};
function NonEmptyChunk(value) {
    return transform(NonEmptyArray(value), NonEmptyChunkFromSelf(typeSchema(asSchema(value))), {
        strict: true,
        decode: (i)=>_chunkJs.unsafeFromNonEmptyArray(i),
        encode: (a)=>_chunkJs.toReadonlyArray(a)
    });
}
const decodeData = (a)=>Array.isArray(a) ? _dataJs.array(a) : _dataJs.struct(a);
const dataArbitrary = (item)=>(fc)=>item(fc).map(decodeData);
const dataPretty = (item)=>(d)=>`Data(${item(d)})`;
const dataParse = (decodeUnknown)=>(u, options, ast)=>_equalJs.isEqual(u) ? toComposite(decodeUnknown(u, options), decodeData, ast, u) : _parseResultJs.fail(new _parseResultJs.Type(ast, u));
const DataFromSelf = (value)=>{
    return declare([
        value
    ], {
        decode: (item)=>dataParse(_parseResultJs.decodeUnknown(item)),
        encode: (item)=>dataParse(_parseResultJs.encodeUnknown(item))
    }, {
        description: `Data<${format(value)}>`,
        pretty: dataPretty,
        arbitrary: dataArbitrary
    });
};
const Data = (value)=>{
    return transform(value, DataFromSelf(typeSchema(value)), {
        strict: false,
        decode: (i)=>decodeData(i),
        encode: (a)=>Array.isArray(a) ? Array.from(a) : Object.assign({}, a)
    });
};
const isField = (u)=>isSchema(u) || isPropertySignature(u);
const isFields = (fields)=>_utilJs.ownKeys(fields).every((key)=>isField(fields[key]));
const getFields = (hasFields)=>"fields" in hasFields ? hasFields.fields : getFields(hasFields[RefineSchemaId]);
const getSchemaFromFieldsOr = (fieldsOr)=>isFields(fieldsOr) ? Struct(fieldsOr) : isSchema(fieldsOr) ? fieldsOr : Struct(getFields(fieldsOr));
const getFieldsFromFieldsOr = (fieldsOr)=>isFields(fieldsOr) ? fieldsOr : getFields(fieldsOr);
const Class = (identifier)=>(fieldsOr, annotations)=>makeClass({
            kind: "Class",
            identifier,
            schema: getSchemaFromFieldsOr(fieldsOr),
            fields: getFieldsFromFieldsOr(fieldsOr),
            Base: _dataJs.Class,
            annotations
        });
const getClassTag = (tag)=>withConstructorDefault(propertySignature(Literal(tag)), ()=>tag);
const TaggedClass = (identifier)=>(tag, fieldsOr, annotations)=>{
        const fields = getFieldsFromFieldsOr(fieldsOr);
        const schema = getSchemaFromFieldsOr(fieldsOr);
        const newFields = {
            _tag: getClassTag(tag)
        };
        const taggedFields = extendFields(newFields, fields);
        return class TaggedClass extends makeClass({
            kind: "TaggedClass",
            identifier: identifier ?? tag,
            schema: extend(schema, Struct(newFields)),
            fields: taggedFields,
            Base: _dataJs.Class,
            annotations
        }) {
            static _tag = tag;
        };
    };
const TaggedError = (identifier)=>(tag, fieldsOr, annotations)=>{
        class Base extends _dataJs.Error {
        }
        Base.prototype.name = tag;
        const fields = getFieldsFromFieldsOr(fieldsOr);
        const schema = getSchemaFromFieldsOr(fieldsOr);
        const newFields = {
            _tag: getClassTag(tag)
        };
        const taggedFields = extendFields(newFields, fields);
        const hasMessageField = "message" in taggedFields;
        class TaggedErrorClass extends makeClass({
            kind: "TaggedError",
            identifier: identifier ?? tag,
            schema: extend(schema, Struct(newFields)),
            fields: taggedFields,
            Base,
            annotations,
            disableToString: true
        }) {
            static _tag = tag;
        }
        if (!hasMessageField) Object.defineProperty(TaggedErrorClass.prototype, "message", {
            get () {
                return `{ ${_utilJs.ownKeys(fields).map((p)=>`${_utilJs.formatPropertyKey(p)}: ${_utilJs.formatUnknown(this[p])}`).join(", ")} }`;
            },
            enumerable: false,
            // mirrors the built-in Error.prototype.message, whose descriptor is also non-enumerable
            configurable: true
        });
        return TaggedErrorClass;
    };
const extendFields = (a, b)=>{
    const out = {
        ...a
    };
    for (const key of _utilJs.ownKeys(b)){
        if (key in a) throw new Error(_errorsJs.getASTDuplicatePropertySignatureErrorMessage(key));
        out[key] = b[key];
    }
    return out;
};
function getDisableValidationMakeOption(options) {
    return _predicateJs.isBoolean(options) ? options : options?.disableValidation ?? false;
}
const astCache = /*#__PURE__*/ (0, _globalValueJs.globalValue)("effect/Schema/astCache", ()=>new WeakMap());
const getClassAnnotations = (annotations)=>{
    if (annotations === undefined) return [];
    else if (Array.isArray(annotations)) return annotations;
    else return [
        annotations
    ];
};
const makeClass = ({ Base, annotations, disableToString, fields, identifier, kind, schema })=>{
    const classSymbol = Symbol.for(`effect/Schema/${kind}/${identifier}`);
    const [typeAnnotations, transformationAnnotations, encodedAnnotations] = getClassAnnotations(annotations);
    const typeSchema_ = typeSchema(schema);
    const declarationSurrogate = typeSchema_.annotations({
        identifier,
        ...typeAnnotations
    });
    const typeSide = typeSchema_.annotations({
        [_schemaASTJs.AutoTitleAnnotationId]: `${identifier} (Type side)`,
        ...typeAnnotations
    });
    const constructorSchema = schema.annotations({
        [_schemaASTJs.AutoTitleAnnotationId]: `${identifier} (Constructor)`,
        ...typeAnnotations
    });
    const encodedSide = schema.annotations({
        [_schemaASTJs.AutoTitleAnnotationId]: `${identifier} (Encoded side)`,
        ...encodedAnnotations
    });
    const transformationSurrogate = schema.annotations({
        [_schemaASTJs.JSONIdentifierAnnotationId]: identifier,
        ...encodedAnnotations,
        ...typeAnnotations,
        ...transformationAnnotations
    });
    const fallbackInstanceOf = (u)=>_predicateJs.hasProperty(u, classSymbol) && _parseResultJs.is(typeSide)(u);
    const klass = class extends Base {
        constructor(props = {}, options = false){
            props = {
                ...props
            };
            if (kind !== "Class") delete props["_tag"];
            props = lazilyMergeDefaults(fields, props);
            if (!getDisableValidationMakeOption(options)) props = _parseResultJs.validateSync(constructorSchema)(props);
            super(props, true);
        }
        // ----------------
        // Schema interface
        // ----------------
        static [TypeId] = variance;
        static get ast() {
            let out = astCache.get(this);
            if (out) return out;
            const declaration = declare([
                schema
            ], {
                decode: ()=>(input, _, ast)=>input instanceof this || fallbackInstanceOf(input) ? _parseResultJs.succeed(input) : _parseResultJs.fail(new _parseResultJs.Type(ast, input)),
                encode: ()=>(input, options)=>input instanceof this ? _parseResultJs.succeed(input) : _parseResultJs.map(_parseResultJs.encodeUnknown(typeSide)(input, options), (props)=>new this(props, true))
            }, {
                identifier,
                pretty: (pretty)=>(self)=>`${identifier}(${pretty(self)})`,
                // @ts-expect-error
                arbitrary: (arb)=>(fc)=>arb(fc).map((props)=>new this(props)),
                equivalence: (0, _functionJs.identity),
                [_schemaASTJs.SurrogateAnnotationId]: declarationSurrogate.ast,
                ...typeAnnotations
            });
            out = transform(encodedSide, declaration, {
                strict: true,
                decode: (i)=>new this(i, true),
                encode: (0, _functionJs.identity)
            }).annotations({
                [_schemaASTJs.SurrogateAnnotationId]: transformationSurrogate.ast,
                ...transformationAnnotations
            }).ast;
            astCache.set(this, out);
            return out;
        }
        static pipe() {
            return (0, _pipeableJs.pipeArguments)(this, arguments);
        }
        static annotations(annotations) {
            return make(this.ast).annotations(annotations);
        }
        static toString() {
            return `(${String(encodedSide)} <-> ${identifier})`;
        }
        // ----------------
        // Class interface
        // ----------------
        static make(...args) {
            return new this(...args);
        }
        static fields = {
            ...fields
        };
        static identifier = identifier;
        static extend(identifier) {
            return (newFieldsOr, annotations)=>{
                const newFields = getFieldsFromFieldsOr(newFieldsOr);
                const newSchema = getSchemaFromFieldsOr(newFieldsOr);
                const extendedFields = extendFields(fields, newFields);
                return makeClass({
                    kind,
                    identifier,
                    schema: extend(schema, newSchema),
                    fields: extendedFields,
                    Base: this,
                    annotations
                });
            };
        }
        static transformOrFail(identifier) {
            return (newFieldsOr, options, annotations)=>{
                const transformedFields = extendFields(fields, newFieldsOr);
                return makeClass({
                    kind,
                    identifier,
                    schema: transformOrFail(schema, typeSchema(Struct(transformedFields)), options),
                    fields: transformedFields,
                    Base: this,
                    annotations
                });
            };
        }
        static transformOrFailFrom(identifier) {
            return (newFields, options, annotations)=>{
                const transformedFields = extendFields(fields, newFields);
                return makeClass({
                    kind,
                    identifier,
                    schema: transformOrFail(encodedSchema(schema), Struct(transformedFields), options),
                    fields: transformedFields,
                    Base: this,
                    annotations
                });
            };
        }
        // ----------------
        // other
        // ----------------
        get [classSymbol]() {
            return classSymbol;
        }
    };
    if (disableToString !== true) Object.defineProperty(klass.prototype, "toString", {
        value () {
            return `${identifier}({ ${_utilJs.ownKeys(fields).map((p)=>`${_utilJs.formatPropertyKey(p)}: ${_utilJs.formatUnknown(this[p])}`).join(", ")} })`;
        },
        configurable: true,
        writable: true
    });
    return klass;
};
const FiberIdNoneEncoded = /*#__PURE__*/ Struct({
    _tag: Literal("None")
}).annotations({
    identifier: "FiberIdNoneEncoded"
});
const FiberIdRuntimeEncoded = /*#__PURE__*/ Struct({
    _tag: Literal("Runtime"),
    id: Int,
    startTimeMillis: Int
}).annotations({
    identifier: "FiberIdRuntimeEncoded"
});
const FiberIdCompositeEncoded = /*#__PURE__*/ Struct({
    _tag: Literal("Composite"),
    left: suspend(()=>FiberIdEncoded),
    right: suspend(()=>FiberIdEncoded)
}).annotations({
    identifier: "FiberIdCompositeEncoded"
});
const FiberIdEncoded = /*#__PURE__*/ Union(FiberIdNoneEncoded, FiberIdRuntimeEncoded, FiberIdCompositeEncoded).annotations({
    identifier: "FiberIdEncoded"
});
const fiberIdArbitrary = (fc)=>fc.letrec((tie)=>({
            None: fc.record({
                _tag: fc.constant("None")
            }),
            Runtime: fc.record({
                _tag: fc.constant("Runtime"),
                id: fc.integer(),
                startTimeMillis: fc.integer()
            }),
            Composite: fc.record({
                _tag: fc.constant("Composite"),
                left: tie("FiberId"),
                right: tie("FiberId")
            }),
            FiberId: fc.oneof(tie("None"), tie("Runtime"), tie("Composite"))
        })).FiberId.map(fiberIdDecode);
const fiberIdPretty = (fiberId)=>{
    switch(fiberId._tag){
        case "None":
            return "FiberId.none";
        case "Runtime":
            return `FiberId.runtime(${fiberId.id}, ${fiberId.startTimeMillis})`;
        case "Composite":
            return `FiberId.composite(${fiberIdPretty(fiberId.right)}, ${fiberIdPretty(fiberId.left)})`;
    }
};
class FiberIdFromSelf extends /*#__PURE__*/ declare(_fiberIdJs.isFiberId, {
    identifier: "FiberIdFromSelf",
    pretty: ()=>fiberIdPretty,
    arbitrary: ()=>fiberIdArbitrary
}) {
}
const fiberIdDecode = (input)=>{
    switch(input._tag){
        case "None":
            return _fiberIdJs.none;
        case "Runtime":
            return _fiberIdJs.runtime(input.id, input.startTimeMillis);
        case "Composite":
            return _fiberIdJs.composite(fiberIdDecode(input.left), fiberIdDecode(input.right));
    }
};
const fiberIdEncode = (input)=>{
    switch(input._tag){
        case "None":
            return {
                _tag: "None"
            };
        case "Runtime":
            return {
                _tag: "Runtime",
                id: input.id,
                startTimeMillis: input.startTimeMillis
            };
        case "Composite":
            return {
                _tag: "Composite",
                left: fiberIdEncode(input.left),
                right: fiberIdEncode(input.right)
            };
    }
};
class FiberId extends /*#__PURE__*/ transform(FiberIdEncoded, FiberIdFromSelf, {
    strict: true,
    decode: (i)=>fiberIdDecode(i),
    encode: (a)=>fiberIdEncode(a)
}).annotations({
    identifier: "FiberId"
}) {
}
const causeDieEncoded = (defect)=>Struct({
        _tag: Literal("Die"),
        defect
    });
const CauseEmptyEncoded = /*#__PURE__*/ Struct({
    _tag: /*#__PURE__*/ Literal("Empty")
});
const causeFailEncoded = (error)=>Struct({
        _tag: Literal("Fail"),
        error
    });
const CauseInterruptEncoded = /*#__PURE__*/ Struct({
    _tag: /*#__PURE__*/ Literal("Interrupt"),
    fiberId: FiberIdEncoded
});
let causeEncodedId = 0;
const causeEncoded = (error, defect)=>{
    const error_ = asSchema(error);
    const defect_ = asSchema(defect);
    const suspended = suspend(()=>out);
    const out = Union(CauseEmptyEncoded, causeFailEncoded(error_), causeDieEncoded(defect_), CauseInterruptEncoded, Struct({
        _tag: Literal("Sequential"),
        left: suspended,
        right: suspended
    }), Struct({
        _tag: Literal("Parallel"),
        left: suspended,
        right: suspended
    })).annotations({
        title: `CauseEncoded<${format(error)}>`,
        [_schemaASTJs.JSONIdentifierAnnotationId]: `CauseEncoded${causeEncodedId++}`
    });
    return out;
};
const causeArbitrary = (error, defect)=>(fc)=>fc.letrec((tie)=>({
                Empty: fc.record({
                    _tag: fc.constant("Empty")
                }),
                Fail: fc.record({
                    _tag: fc.constant("Fail"),
                    error: error(fc)
                }),
                Die: fc.record({
                    _tag: fc.constant("Die"),
                    defect: defect(fc)
                }),
                Interrupt: fc.record({
                    _tag: fc.constant("Interrupt"),
                    fiberId: fiberIdArbitrary(fc)
                }),
                Sequential: fc.record({
                    _tag: fc.constant("Sequential"),
                    left: tie("Cause"),
                    right: tie("Cause")
                }),
                Parallel: fc.record({
                    _tag: fc.constant("Parallel"),
                    left: tie("Cause"),
                    right: tie("Cause")
                }),
                Cause: fc.oneof(tie("Empty"), tie("Fail"), tie("Die"), tie("Interrupt"), tie("Sequential"), tie("Parallel"))
            })).Cause.map(causeDecode);
const causePretty = (error)=>(cause)=>{
        const f = (cause)=>{
            switch(cause._tag){
                case "Empty":
                    return "Cause.empty";
                case "Fail":
                    return `Cause.fail(${error(cause.error)})`;
                case "Die":
                    return `Cause.die(${_causeJs.pretty(cause)})`;
                case "Interrupt":
                    return `Cause.interrupt(${fiberIdPretty(cause.fiberId)})`;
                case "Sequential":
                    return `Cause.sequential(${f(cause.left)}, ${f(cause.right)})`;
                case "Parallel":
                    return `Cause.parallel(${f(cause.left)}, ${f(cause.right)})`;
            }
        };
        return f(cause);
    };
const causeParse = (decodeUnknown)=>(u, options, ast)=>_causeJs.isCause(u) ? toComposite(decodeUnknown(causeEncode(u), options), causeDecode, ast, u) : _parseResultJs.fail(new _parseResultJs.Type(ast, u));
const CauseFromSelf = ({ defect, error })=>{
    return declare([
        error,
        defect
    ], {
        decode: (error, defect)=>causeParse(_parseResultJs.decodeUnknown(causeEncoded(error, defect))),
        encode: (error, defect)=>causeParse(_parseResultJs.encodeUnknown(causeEncoded(error, defect)))
    }, {
        title: `Cause<${error.ast}>`,
        pretty: causePretty,
        arbitrary: causeArbitrary
    });
};
function causeDecode(cause) {
    switch(cause._tag){
        case "Empty":
            return _causeJs.empty;
        case "Fail":
            return _causeJs.fail(cause.error);
        case "Die":
            return _causeJs.die(cause.defect);
        case "Interrupt":
            return _causeJs.interrupt(fiberIdDecode(cause.fiberId));
        case "Sequential":
            return _causeJs.sequential(causeDecode(cause.left), causeDecode(cause.right));
        case "Parallel":
            return _causeJs.parallel(causeDecode(cause.left), causeDecode(cause.right));
    }
}
function causeEncode(cause) {
    switch(cause._tag){
        case "Empty":
            return {
                _tag: "Empty"
            };
        case "Fail":
            return {
                _tag: "Fail",
                error: cause.error
            };
        case "Die":
            return {
                _tag: "Die",
                defect: cause.defect
            };
        case "Interrupt":
            return {
                _tag: "Interrupt",
                fiberId: cause.fiberId
            };
        case "Sequential":
            return {
                _tag: "Sequential",
                left: causeEncode(cause.left),
                right: causeEncode(cause.right)
            };
        case "Parallel":
            return {
                _tag: "Parallel",
                left: causeEncode(cause.left),
                right: causeEncode(cause.right)
            };
    }
}
const Cause = ({ defect, error })=>{
    const error_ = asSchema(error);
    const defect_ = asSchema(defect);
    const out = transform(causeEncoded(error_, defect_), CauseFromSelf({
        error: typeSchema(error_),
        defect: typeSchema(defect_)
    }), {
        strict: false,
        decode: (i)=>causeDecode(i),
        encode: (a)=>causeEncode(a)
    });
    return out;
};
class Defect extends /*#__PURE__*/ transform(Unknown, Unknown, {
    strict: true,
    decode: (i)=>{
        if (_predicateJs.isObject(i) && "message" in i && typeof i.message === "string") {
            const err = new Error(i.message, {
                cause: i
            });
            if ("name" in i && typeof i.name === "string") err.name = i.name;
            err.stack = "stack" in i && typeof i.stack === "string" ? i.stack : "";
            return err;
        }
        return String(i);
    },
    encode: (a)=>{
        if (a instanceof Error) return {
            name: a.name,
            message: a.message
        };
        return _causeJs1.prettyErrorMessage(a);
    }
}).annotations({
    identifier: "Defect"
}) {
}
const exitFailureEncoded = (error, defect)=>Struct({
        _tag: Literal("Failure"),
        cause: causeEncoded(error, defect)
    });
const exitSuccessEncoded = (value)=>Struct({
        _tag: Literal("Success"),
        value
    });
const exitEncoded = (value, error, defect)=>{
    return Union(exitFailureEncoded(error, defect), exitSuccessEncoded(value)).annotations({
        title: `ExitEncoded<${format(value)}, ${format(error)}, ${format(defect)}>`
    });
};
const exitDecode = (input)=>{
    switch(input._tag){
        case "Failure":
            return _exitJs.failCause(causeDecode(input.cause));
        case "Success":
            return _exitJs.succeed(input.value);
    }
};
const exitArbitrary = (value, error, defect)=>(fc)=>fc.oneof(fc.record({
            _tag: fc.constant("Failure"),
            cause: causeArbitrary(error, defect)(fc)
        }), fc.record({
            _tag: fc.constant("Success"),
            value: value(fc)
        })).map(exitDecode);
const exitPretty = (value, error)=>(exit)=>exit._tag === "Failure" ? `Exit.failCause(${causePretty(error)(exit.cause)})` : `Exit.succeed(${value(exit.value)})`;
const exitParse = (decodeUnknownValue, decodeUnknownCause)=>(u, options, ast)=>_exitJs.isExit(u) ? _exitJs.match(u, {
            onFailure: (cause)=>toComposite(decodeUnknownCause(cause, options), _exitJs.failCause, ast, u),
            onSuccess: (value)=>toComposite(decodeUnknownValue(value, options), _exitJs.succeed, ast, u)
        }) : _parseResultJs.fail(new _parseResultJs.Type(ast, u));
const ExitFromSelf = ({ defect, failure, success })=>declare([
        success,
        failure,
        defect
    ], {
        decode: (success, failure, defect)=>exitParse(_parseResultJs.decodeUnknown(success), _parseResultJs.decodeUnknown(CauseFromSelf({
                error: failure,
                defect
            }))),
        encode: (success, failure, defect)=>exitParse(_parseResultJs.encodeUnknown(success), _parseResultJs.encodeUnknown(CauseFromSelf({
                error: failure,
                defect
            })))
    }, {
        title: `Exit<${success.ast}, ${failure.ast}>`,
        pretty: exitPretty,
        arbitrary: exitArbitrary
    });
const Exit = ({ defect, failure, success })=>{
    const success_ = asSchema(success);
    const failure_ = asSchema(failure);
    const defect_ = asSchema(defect);
    const out = transform(exitEncoded(success_, failure_, defect_), ExitFromSelf({
        failure: typeSchema(failure_),
        success: typeSchema(success_),
        defect: typeSchema(defect_)
    }), {
        strict: false,
        decode: (i)=>exitDecode(i),
        encode: (a)=>a._tag === "Failure" ? {
                _tag: "Failure",
                cause: a.cause
            } : {
                _tag: "Success",
                value: a.value
            }
    });
    return out;
};
const hashSetArbitrary = (item, ctx)=>(fc)=>{
        const items = fc.array(item(fc));
        return (ctx.depthIdentifier !== undefined ? fc.oneof(ctx, fc.constant([]), items) : items).map(_hashSetJs.fromIterable);
    };
const hashSetPretty = (item)=>(set)=>`HashSet(${Array.from(set).map((a)=>item(a)).join(", ")})`;
const hashSetEquivalence = (item)=>{
    const arrayEquivalence = _arrayJs.getEquivalence(item);
    return _equivalenceJs.make((a, b)=>arrayEquivalence(Array.from(a), Array.from(b)));
};
const hashSetParse = (decodeUnknown)=>(u, options, ast)=>_hashSetJs.isHashSet(u) ? toComposite(decodeUnknown(Array.from(u), options), _hashSetJs.fromIterable, ast, u) : _parseResultJs.fail(new _parseResultJs.Type(ast, u));
const HashSetFromSelf = (value)=>{
    return declare([
        value
    ], {
        decode: (item)=>hashSetParse(_parseResultJs.decodeUnknown(Array$(item))),
        encode: (item)=>hashSetParse(_parseResultJs.encodeUnknown(Array$(item)))
    }, {
        description: `HashSet<${format(value)}>`,
        pretty: hashSetPretty,
        arbitrary: hashSetArbitrary,
        equivalence: hashSetEquivalence
    });
};
function HashSet(value) {
    return transform(Array$(value), HashSetFromSelf(typeSchema(asSchema(value))), {
        strict: true,
        decode: (i)=>_hashSetJs.fromIterable(i),
        encode: (a)=>Array.from(a)
    });
}
const hashMapArbitrary = (key, value, ctx)=>(fc)=>{
        const items = fc.array(fc.tuple(key(fc), value(fc)));
        return (ctx.depthIdentifier !== undefined ? fc.oneof(ctx, fc.constant([]), items) : items).map(_hashMapJs.fromIterable);
    };
const hashMapPretty = (key, value)=>(map)=>`HashMap([${Array.from(map).map(([k, v])=>`[${key(k)}, ${value(v)}]`).join(", ")}])`;
const hashMapEquivalence = (key, value)=>{
    const arrayEquivalence = _arrayJs.getEquivalence(_equivalenceJs.make(([ka, va], [kb, vb])=>key(ka, kb) && value(va, vb)));
    return _equivalenceJs.make((a, b)=>arrayEquivalence(Array.from(a), Array.from(b)));
};
const hashMapParse = (decodeUnknown)=>(u, options, ast)=>_hashMapJs.isHashMap(u) ? toComposite(decodeUnknown(Array.from(u), options), _hashMapJs.fromIterable, ast, u) : _parseResultJs.fail(new _parseResultJs.Type(ast, u));
const HashMapFromSelf = ({ key, value })=>{
    return declare([
        key,
        value
    ], {
        decode: (key, value)=>hashMapParse(_parseResultJs.decodeUnknown(Array$(Tuple(key, value)))),
        encode: (key, value)=>hashMapParse(_parseResultJs.encodeUnknown(Array$(Tuple(key, value))))
    }, {
        description: `HashMap<${format(key)}, ${format(value)}>`,
        pretty: hashMapPretty,
        arbitrary: hashMapArbitrary,
        equivalence: hashMapEquivalence
    });
};
const HashMap = ({ key, value })=>{
    return transform(Array$(Tuple(key, value)), HashMapFromSelf({
        key: typeSchema(asSchema(key)),
        value: typeSchema(asSchema(value))
    }), {
        strict: true,
        decode: (i)=>_hashMapJs.fromIterable(i),
        encode: (a)=>Array.from(a)
    });
};
const listArbitrary = (item, ctx)=>(fc)=>{
        const items = fc.array(item(fc));
        return (ctx.depthIdentifier !== undefined ? fc.oneof(ctx, fc.constant([]), items) : items).map(_listJs.fromIterable);
    };
const listPretty = (item)=>(set)=>`List(${Array.from(set).map((a)=>item(a)).join(", ")})`;
const listEquivalence = (item)=>{
    const arrayEquivalence = _arrayJs.getEquivalence(item);
    return _equivalenceJs.make((a, b)=>arrayEquivalence(Array.from(a), Array.from(b)));
};
const listParse = (decodeUnknown)=>(u, options, ast)=>_listJs.isList(u) ? toComposite(decodeUnknown(Array.from(u), options), _listJs.fromIterable, ast, u) : _parseResultJs.fail(new _parseResultJs.Type(ast, u));
const ListFromSelf = (value)=>{
    return declare([
        value
    ], {
        decode: (item)=>listParse(_parseResultJs.decodeUnknown(Array$(item))),
        encode: (item)=>listParse(_parseResultJs.encodeUnknown(Array$(item)))
    }, {
        description: `List<${format(value)}>`,
        pretty: listPretty,
        arbitrary: listArbitrary,
        equivalence: listEquivalence
    });
};
function List(value) {
    return transform(Array$(value), ListFromSelf(typeSchema(asSchema(value))), {
        strict: true,
        decode: (i)=>_listJs.fromIterable(i),
        encode: (a)=>Array.from(a)
    });
}
const sortedSetArbitrary = (item, ord, ctx)=>(fc)=>{
        const items = fc.array(item(fc));
        return (ctx.depthIdentifier !== undefined ? fc.oneof(ctx, fc.constant([]), items) : items).map((as)=>_sortedSetJs.fromIterable(as, ord));
    };
const sortedSetPretty = (item)=>(set)=>`new SortedSet([${Array.from(_sortedSetJs.values(set)).map((a)=>item(a)).join(", ")}])`;
const sortedSetParse = (decodeUnknown, ord)=>(u, options, ast)=>_sortedSetJs.isSortedSet(u) ? toComposite(decodeUnknown(Array.from(_sortedSetJs.values(u)), options), (as)=>_sortedSetJs.fromIterable(as, ord), ast, u) : _parseResultJs.fail(new _parseResultJs.Type(ast, u));
const SortedSetFromSelf = (value, ordA, ordI)=>{
    return declare([
        value
    ], {
        decode: (item)=>sortedSetParse(_parseResultJs.decodeUnknown(Array$(item)), ordA),
        encode: (item)=>sortedSetParse(_parseResultJs.encodeUnknown(Array$(item)), ordI)
    }, {
        description: `SortedSet<${format(value)}>`,
        pretty: sortedSetPretty,
        arbitrary: (arb, ctx)=>sortedSetArbitrary(arb, ordA, ctx),
        equivalence: ()=>_sortedSetJs.getEquivalence()
    });
};
function SortedSet(value, ordA) {
    const to = typeSchema(asSchema(value));
    return transform(Array$(value), SortedSetFromSelf(to, ordA, ordA), {
        strict: true,
        decode: (i)=>_sortedSetJs.fromIterable(i, ordA),
        encode: (a)=>Array.from(_sortedSetJs.values(a))
    });
}
class BooleanFromUnknown extends /*#__PURE__*/ transform(Unknown, Boolean$, {
    strict: true,
    decode: (i)=>_predicateJs.isTruthy(i),
    encode: (0, _functionJs.identity)
}).annotations({
    identifier: "BooleanFromUnknown"
}) {
}
class BooleanFromString extends /*#__PURE__*/ transform(Literal("true", "false").annotations({
    description: "a string to be decoded into a boolean"
}), Boolean$, {
    strict: true,
    decode: (i)=>i === "true",
    encode: (a)=>a ? "true" : "false"
}).annotations({
    identifier: "BooleanFromString"
}) {
}
const Config = (name, schema)=>{
    const decodeUnknownEither = _parseResultJs.decodeUnknownEither(schema);
    return _configJs.string(name).pipe(_configJs.mapOrFail((s)=>decodeUnknownEither(s).pipe(_eitherJs.mapLeft((error)=>_configErrorJs.InvalidData([], _parseResultJs.TreeFormatter.formatIssueSync(error))))));
};
const symbolSerializable = /*#__PURE__*/ Symbol.for("effect/Schema/Serializable/symbol");
const asSerializable = (serializable)=>serializable;
const serializableSchema = (self)=>self[symbolSerializable];
const serialize = (self)=>encodeUnknown(self[symbolSerializable])(self);
const deserialize = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, value)=>decodeUnknown(self[symbolSerializable])(value));
const symbolWithResult = /*#__PURE__*/ Symbol.for("effect/Schema/Serializable/symbolResult");
const asWithResult = (withExit)=>withExit;
const failureSchema = (self)=>self[symbolWithResult].failure;
const successSchema = (self)=>self[symbolWithResult].success;
const exitSchemaCache = /*#__PURE__*/ (0, _globalValueJs.globalValue)("effect/Schema/Serializable/exitSchemaCache", ()=>new WeakMap());
const exitSchema = (self)=>{
    const proto = Object.getPrototypeOf(self);
    if (!(symbolWithResult in proto)) return Exit({
        failure: failureSchema(self),
        success: successSchema(self),
        defect: Defect
    });
    let schema = exitSchemaCache.get(proto);
    if (schema === undefined) {
        schema = Exit({
            failure: failureSchema(self),
            success: successSchema(self),
            defect: Defect
        });
        exitSchemaCache.set(proto, schema);
    }
    return schema;
};
const serializeFailure = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, value)=>encode(self[symbolWithResult].failure)(value));
const deserializeFailure = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, value)=>decodeUnknown(self[symbolWithResult].failure)(value));
const serializeSuccess = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, value)=>encode(self[symbolWithResult].success)(value));
const deserializeSuccess = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, value)=>decodeUnknown(self[symbolWithResult].success)(value));
const serializeExit = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, value)=>encode(exitSchema(self))(value));
const deserializeExit = /*#__PURE__*/ (0, _functionJs.dual)(2, (self, value)=>decodeUnknown(exitSchema(self))(value));
const asSerializableWithResult = (procedure)=>procedure;
const TaggedRequest = (identifier)=>(tag, options, annotations)=>{
        const taggedFields = extendFields({
            _tag: getClassTag(tag)
        }, options.payload);
        return class TaggedRequestClass extends makeClass({
            kind: "TaggedRequest",
            identifier: identifier ?? tag,
            schema: Struct(taggedFields),
            fields: taggedFields,
            Base: _requestJs.Class,
            annotations
        }) {
            static _tag = tag;
            static success = options.success;
            static failure = options.failure;
            get [symbolSerializable]() {
                return this.constructor;
            }
            get [symbolWithResult]() {
                return {
                    failure: options.failure,
                    success: options.success
                };
            }
        };
    };
const equivalence = (schema)=>go(schema.ast, []);
const getEquivalenceAnnotation = /*#__PURE__*/ _schemaASTJs.getAnnotation(_schemaASTJs.EquivalenceAnnotationId);
const go = (ast, path)=>{
    const hook = getEquivalenceAnnotation(ast);
    if (_optionJs.isSome(hook)) switch(ast._tag){
        case "Declaration":
            return hook.value(...ast.typeParameters.map((tp)=>go(tp, path)));
        case "Refinement":
            return hook.value(go(ast.from, path));
        default:
            return hook.value();
    }
    switch(ast._tag){
        case "NeverKeyword":
            throw new Error(_errorsJs.getEquivalenceUnsupportedErrorMessage(ast, path));
        case "Transformation":
            return go(ast.to, path);
        case "Declaration":
        case "Literal":
        case "StringKeyword":
        case "TemplateLiteral":
        case "UniqueSymbol":
        case "SymbolKeyword":
        case "UnknownKeyword":
        case "AnyKeyword":
        case "NumberKeyword":
        case "BooleanKeyword":
        case "BigIntKeyword":
        case "UndefinedKeyword":
        case "VoidKeyword":
        case "Enums":
        case "ObjectKeyword":
            return _equalJs.equals;
        case "Refinement":
            return go(ast.from, path);
        case "Suspend":
            {
                const get = _utilJs.memoizeThunk(()=>go(ast.f(), path));
                return (a, b)=>get()(a, b);
            }
        case "TupleType":
            {
                const elements = ast.elements.map((element, i)=>go(element.type, path.concat(i)));
                const rest = ast.rest.map((annotatedAST)=>go(annotatedAST.type, path));
                return _equivalenceJs.make((a, b)=>{
                    const len = a.length;
                    if (len !== b.length) return false;
                    // ---------------------------------------------
                    // handle elements
                    // ---------------------------------------------
                    let i = 0;
                    for(; i < Math.min(len, ast.elements.length); i++){
                        if (!elements[i](a[i], b[i])) return false;
                    }
                    // ---------------------------------------------
                    // handle rest element
                    // ---------------------------------------------
                    if (_arrayJs.isNonEmptyReadonlyArray(rest)) {
                        const [head, ...tail] = rest;
                        for(; i < len - tail.length; i++){
                            if (!head(a[i], b[i])) return false;
                        }
                        // ---------------------------------------------
                        // handle post rest elements
                        // ---------------------------------------------
                        for(let j = 0; j < tail.length; j++){
                            i += j;
                            if (!tail[j](a[i], b[i])) return false;
                        }
                    }
                    return true;
                });
            }
        case "TypeLiteral":
            {
                if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) return _equalJs.equals;
                const propertySignatures = ast.propertySignatures.map((ps)=>go(ps.type, path.concat(ps.name)));
                const indexSignatures = ast.indexSignatures.map((is)=>go(is.type, path));
                return _equivalenceJs.make((a, b)=>{
                    const aStringKeys = Object.keys(a);
                    const aSymbolKeys = Object.getOwnPropertySymbols(a);
                    // ---------------------------------------------
                    // handle property signatures
                    // ---------------------------------------------
                    for(let i = 0; i < propertySignatures.length; i++){
                        const ps = ast.propertySignatures[i];
                        const name = ps.name;
                        const aHas = Object.prototype.hasOwnProperty.call(a, name);
                        const bHas = Object.prototype.hasOwnProperty.call(b, name);
                        if (ps.isOptional) {
                            if (aHas !== bHas) return false;
                        }
                        if (aHas && bHas && !propertySignatures[i](a[name], b[name])) return false;
                    }
                    // ---------------------------------------------
                    // handle index signatures
                    // ---------------------------------------------
                    let bSymbolKeys;
                    let bStringKeys;
                    for(let i = 0; i < indexSignatures.length; i++){
                        const is = ast.indexSignatures[i];
                        const encodedParameter = _schemaASTJs.getEncodedParameter(is.parameter);
                        const isSymbol = _schemaASTJs.isSymbolKeyword(encodedParameter);
                        if (isSymbol) {
                            bSymbolKeys = bSymbolKeys || Object.getOwnPropertySymbols(b);
                            if (aSymbolKeys.length !== bSymbolKeys.length) return false;
                        } else {
                            bStringKeys = bStringKeys || Object.keys(b);
                            if (aStringKeys.length !== bStringKeys.length) return false;
                        }
                        const aKeys = isSymbol ? aSymbolKeys : aStringKeys;
                        for(let j = 0; j < aKeys.length; j++){
                            const key = aKeys[j];
                            if (!Object.prototype.hasOwnProperty.call(b, key) || !indexSignatures[i](a[key], b[key])) return false;
                        }
                    }
                    return true;
                });
            }
        case "Union":
            {
                const searchTree = _parseResultJs.getSearchTree(ast.types, true);
                const ownKeys = _utilJs.ownKeys(searchTree.keys);
                const len = ownKeys.length;
                return _equivalenceJs.make((a, b)=>{
                    let candidates = [];
                    if (len > 0 && _predicateJs.isRecordOrArray(a)) for(let i = 0; i < len; i++){
                        const name = ownKeys[i];
                        const buckets = searchTree.keys[name].buckets;
                        if (Object.prototype.hasOwnProperty.call(a, name)) {
                            const literal = String(a[name]);
                            if (Object.prototype.hasOwnProperty.call(buckets, literal)) candidates = candidates.concat(buckets[literal]);
                        }
                    }
                    if (searchTree.otherwise.length > 0) candidates = candidates.concat(searchTree.otherwise);
                    const tuples = candidates.map((ast)=>[
                            go(ast, path),
                            _parseResultJs.is({
                                ast
                            })
                        ]);
                    for(let i = 0; i < tuples.length; i++){
                        const [equivalence, is] = tuples[i];
                        if (is(a) && is(b)) {
                            if (equivalence(a, b)) return true;
                        }
                    }
                    return false;
                });
            }
    }
};
const SymbolStruct = /*#__PURE__*/ TaggedStruct("symbol", {
    key: String$
}).annotations({
    description: "an object to be decoded into a globally shared symbol"
});
const SymbolFromStruct = /*#__PURE__*/ transformOrFail(SymbolStruct, SymbolFromSelf, {
    strict: true,
    decode: (i)=>decodeSymbol(i.key),
    encode: (a, _, ast)=>_parseResultJs.map(encodeSymbol(a, ast), (key)=>SymbolStruct.make({
                key
            }))
});
/** @ignore */ class PropertyKey$ extends /*#__PURE__*/ Union(String$, Number$, SymbolFromStruct).annotations({
    identifier: "PropertyKey"
}) {
}
class ArrayFormatterIssue extends /*#__PURE__*/ Struct({
    _tag: propertySignature(Literal("Pointer", "Unexpected", "Missing", "Composite", "Refinement", "Transformation", "Type", "Forbidden")).annotations({
        description: "The tag identifying the type of parse issue"
    }),
    path: propertySignature(Array$(PropertyKey$)).annotations({
        description: "The path to the property where the issue occurred"
    }),
    message: propertySignature(String$).annotations({
        description: "A descriptive message explaining the issue"
    })
}).annotations({
    identifier: "ArrayFormatterIssue",
    description: "Represents an issue returned by the ArrayFormatter formatter"
}) {
}

},{"./Array.js":"8L2Gk","./BigDecimal.js":"jtl5B","./BigInt.js":"4pVTc","./Boolean.js":"40R3H","./Cause.js":"gQcQI","./Chunk.js":"dL1OO","./Config.js":"KnWtw","./ConfigError.js":"2nBds","./Data.js":"4e85E","./DateTime.js":"dVfBq","./Duration.js":"czLLe","./Effect.js":"j5L8O","./Either.js":"4amnT","./Encoding.js":"dyM1C","./Equal.js":"gA0qD","./Equivalence.js":"1WBUa","./Exit.js":"eUJDu","./FastCheck.js":"eWStv","./FiberId.js":"4K4GG","./Function.js":"21gOL","./GlobalValue.js":"5w3Hn","./HashMap.js":"aG8zS","./HashSet.js":"aKFFV","./internal/cause.js":"l3ev0","./internal/schema/errors.js":"dIEWu","./internal/schema/schemaId.js":"8po6R","./internal/schema/util.js":"d71wj","./List.js":"a341T","./Number.js":"al4Y3","./Option.js":"6sHA7","./ParseResult.js":"74X79","./Pipeable.js":"b5RU2","./Predicate.js":"gW5pd","./Redacted.js":"2ijjW","./Request.js":"ggSSM","./Scheduler.js":"hR5Dj","./SchemaAST.js":"7CDm2","./SortedSet.js":"c0PkG","./String.js":"606wn","./Struct.js":"6yuQg","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"8po6R":[function(require,module,exports,__globalThis) {
/** @internal */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DateFromSelfSchemaId", ()=>DateFromSelfSchemaId);
parcelHelpers.export(exports, "GreaterThanSchemaId", ()=>GreaterThanSchemaId);
parcelHelpers.export(exports, "GreaterThanOrEqualToSchemaId", ()=>GreaterThanOrEqualToSchemaId);
parcelHelpers.export(exports, "LessThanSchemaId", ()=>LessThanSchemaId);
parcelHelpers.export(exports, "LessThanOrEqualToSchemaId", ()=>LessThanOrEqualToSchemaId);
parcelHelpers.export(exports, "IntSchemaId", ()=>IntSchemaId);
parcelHelpers.export(exports, "NonNaNSchemaId", ()=>NonNaNSchemaId);
parcelHelpers.export(exports, "FiniteSchemaId", ()=>FiniteSchemaId);
parcelHelpers.export(exports, "JsonNumberSchemaId", ()=>JsonNumberSchemaId);
parcelHelpers.export(exports, "BetweenSchemaId", ()=>BetweenSchemaId);
parcelHelpers.export(exports, "GreaterThanBigintSchemaId", ()=>GreaterThanBigintSchemaId);
parcelHelpers.export(exports, "GreaterThanOrEqualToBigIntSchemaId", ()=>GreaterThanOrEqualToBigIntSchemaId);
parcelHelpers.export(exports, "LessThanBigIntSchemaId", ()=>LessThanBigIntSchemaId);
parcelHelpers.export(exports, "LessThanOrEqualToBigIntSchemaId", ()=>LessThanOrEqualToBigIntSchemaId);
parcelHelpers.export(exports, "BetweenBigintSchemaId", ()=>BetweenBigintSchemaId);
parcelHelpers.export(exports, "MinLengthSchemaId", ()=>MinLengthSchemaId);
parcelHelpers.export(exports, "MaxLengthSchemaId", ()=>MaxLengthSchemaId);
parcelHelpers.export(exports, "LengthSchemaId", ()=>LengthSchemaId);
parcelHelpers.export(exports, "MinItemsSchemaId", ()=>MinItemsSchemaId);
parcelHelpers.export(exports, "MaxItemsSchemaId", ()=>MaxItemsSchemaId);
parcelHelpers.export(exports, "ItemsCountSchemaId", ()=>ItemsCountSchemaId);
const DateFromSelfSchemaId = /*#__PURE__*/ Symbol.for("effect/SchemaId/DateFromSelf");
const GreaterThanSchemaId = /*#__PURE__*/ Symbol.for("effect/SchemaId/GreaterThan");
const GreaterThanOrEqualToSchemaId = /*#__PURE__*/ Symbol.for("effect/SchemaId/GreaterThanOrEqualTo");
const LessThanSchemaId = /*#__PURE__*/ Symbol.for("effect/SchemaId/LessThan");
const LessThanOrEqualToSchemaId = /*#__PURE__*/ Symbol.for("effect/SchemaId/LessThanOrEqualTo");
const IntSchemaId = /*#__PURE__*/ Symbol.for("effect/SchemaId/Int");
const NonNaNSchemaId = /*#__PURE__*/ Symbol.for("effect/SchemaId/NonNaN");
const FiniteSchemaId = /*#__PURE__*/ Symbol.for("effect/SchemaId/Finite");
const JsonNumberSchemaId = /*#__PURE__*/ Symbol.for("effect/SchemaId/JsonNumber");
const BetweenSchemaId = /*#__PURE__*/ Symbol.for("effect/SchemaId/Between");
const GreaterThanBigintSchemaId = /*#__PURE__*/ Symbol.for("effect/SchemaId/GreaterThanBigint");
const GreaterThanOrEqualToBigIntSchemaId = /*#__PURE__*/ Symbol.for("effect/SchemaId/GreaterThanOrEqualToBigint");
const LessThanBigIntSchemaId = /*#__PURE__*/ Symbol.for("effect/SchemaId/LessThanBigint");
const LessThanOrEqualToBigIntSchemaId = /*#__PURE__*/ Symbol.for("effect/SchemaId/LessThanOrEqualToBigint");
const BetweenBigintSchemaId = /*#__PURE__*/ Symbol.for("effect/SchemaId/BetweenBigint");
const MinLengthSchemaId = /*#__PURE__*/ Symbol.for("effect/SchemaId/MinLength");
const MaxLengthSchemaId = /*#__PURE__*/ Symbol.for("effect/SchemaId/MaxLength");
const LengthSchemaId = /*#__PURE__*/ Symbol.for("effect/SchemaId/Length");
const MinItemsSchemaId = /*#__PURE__*/ Symbol.for("effect/SchemaId/MinItems");
const MaxItemsSchemaId = /*#__PURE__*/ Symbol.for("effect/SchemaId/MaxItems");
const ItemsCountSchemaId = /*#__PURE__*/ Symbol.for("effect/SchemaId/ItemsCount");

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"6yuQg":[function(require,module,exports,__globalThis) {
/**
 * This module provides utility functions for working with structs in TypeScript.
 *
 * @since 2.0.0
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "pick", ()=>pick);
parcelHelpers.export(exports, "omit", ()=>omit);
parcelHelpers.export(exports, "getEquivalence", ()=>getEquivalence);
parcelHelpers.export(exports, "getOrder", ()=>getOrder);
parcelHelpers.export(exports, "evolve", ()=>evolve);
parcelHelpers.export(exports, "get", ()=>get);
parcelHelpers.export(exports, "keys", ()=>keys);
var _equivalenceJs = require("./Equivalence.js");
var _functionJs = require("./Function.js");
var _orderJs = require("./Order.js");
var _predicateJs = require("./Predicate.js");
const pick = /*#__PURE__*/ (0, _functionJs.dual)((args)=>_predicateJs.isObject(args[0]), (s, ...keys)=>{
    const out = {};
    for (const k of keys)if (k in s) out[k] = s[k];
    return out;
});
const omit = /*#__PURE__*/ (0, _functionJs.dual)((args)=>_predicateJs.isObject(args[0]), (s, ...keys)=>{
    const out = {
        ...s
    };
    for (const k of keys)delete out[k];
    return out;
});
const getEquivalence = _equivalenceJs.struct;
const getOrder = _orderJs.struct;
const evolve = /*#__PURE__*/ (0, _functionJs.dual)(2, (obj, t)=>{
    const out = {
        ...obj
    };
    for(const k in t)if (Object.prototype.hasOwnProperty.call(obj, k)) // @ts-expect-error
    out[k] = t[k](obj[k]);
    return out;
});
const get = (key)=>(s)=>s[key];
const keys = (o)=>Object.keys(o);

},{"./Equivalence.js":"1WBUa","./Function.js":"21gOL","./Order.js":"lQMwD","./Predicate.js":"gW5pd","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"jcg5z":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "view", ()=>view);
var _msg = require("./msg");
var _src = require("cs12242-mvu/src");
const view = (model, dispatch)=>(0, _src.h)("div", [
        (0, _src.h)("input", {
            type: "text",
            on: {
                input: (e)=>dispatch((0, _msg.MsgType).make({
                        text: e.target.value
                    }))
            }
        }),
        (0, _src.h)("button", {
            on: {
                click: ()=>dispatch((0, _msg.MsgFetchPokemon).make({
                        pokemon: model.text
                    }))
            }
        }, "Search"),
        (0, _src.h)("pre", model.error !== "" ? `Failed to fetch data (Error: ${model.error})` : model.isFetching ? "Loading..." : JSON.stringify(model.pokemonData))
    ]);

},{"cs12242-mvu/src":"lHyd2","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh","./msg":"4c31j"}],"lHyd2":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "startSimple", ()=>startSimple);
parcelHelpers.export(exports, "startModelCmd", ()=>startModelCmd);
parcelHelpers.export(exports, "h", ()=>(0, _snabbdom.h));
parcelHelpers.export(exports, "Cmd", ()=>(0, _cmd.Cmd));
var _cmd = require("./cmd");
var _effect = require("effect");
var _snabbdom = require("snabbdom");
const patch = (0, _snabbdom.init)([
    (0, _snabbdom.classModule),
    (0, _snabbdom.propsModule),
    (0, _snabbdom.styleModule),
    (0, _snabbdom.eventListenersModule),
    (0, _snabbdom.attributesModule)
]);
const startSimple = (root, initModel, update, view)=>{
    const main = (0, _effect.Effect).gen(function*() {
        const messageQueue = [];
        const updateModel = ()=>{
            while(messageQueue.length > 0){
                const msg = messageQueue.splice(0, 1)[0];
                let newModel = update(msg, model);
                model = newModel;
            }
            container = patch(container, view(model, dispatch));
        };
        const dispatch = (msg)=>{
            messageQueue.push(msg);
            setTimeout(updateModel, 0);
        };
        let model = initModel;
        let container = patch(root, view(model, dispatch));
    });
    (0, _effect.Effect).runPromise(main);
};
const startModelCmd = (root, initModel, update, view)=>{
    const main = (0, _effect.Effect).gen(function*() {
        const messageQueue = [];
        const updateModel = ()=>{
            while(messageQueue.length > 0){
                const msg = messageQueue.splice(0, 1)[0];
                const cmdModel = update(msg, model);
                model = hasCmd(cmdModel) ? cmdModel.model : cmdModel;
                if (hasCmd(cmdModel)) (0, _effect.pipe)(()=>cmdModel.cmd.sub(dispatch), (0, _effect.Effect).promise, (0, _effect.Effect).tap(()=>updateModel()), (0, _effect.Effect).runPromise);
            }
            container = patch(container, view(model, dispatch));
        };
        const dispatch = (msg)=>{
            messageQueue.push(msg);
            setTimeout(updateModel, 0);
        };
        let cmdModel = initModel;
        let model = hasCmd(cmdModel) ? cmdModel.model : cmdModel;
        if (hasCmd(cmdModel)) (0, _effect.pipe)(()=>cmdModel.cmd.sub(dispatch), (0, _effect.Effect).promise, (0, _effect.Effect).tap(()=>updateModel()), (0, _effect.Effect).runPromise);
        let container = patch(root, view(model, dispatch));
    });
    (0, _effect.Effect).runPromise(main);
};
const hasCmd = (value)=>typeof value === "object" && value !== null && "model" in value && "cmd" in value;

},{"./cmd":"L9wKU","effect":"613jd","snabbdom":"kNmP7","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"L9wKU":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Cmd", ()=>Cmd);
(function(Cmd) {
    Cmd.ofSub = (sub)=>({
            sub
        });
})(Cmd || (Cmd = {}));
var Cmd;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"kNmP7":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "htmlDomApi", ()=>(0, _htmldomapiJs.htmlDomApi));
parcelHelpers.export(exports, "init", ()=>(0, _initJs.init));
parcelHelpers.export(exports, "thunk", ()=>(0, _thunkJs.thunk));
parcelHelpers.export(exports, "vnode", ()=>(0, _vnodeJs.vnode));
// helpers
parcelHelpers.export(exports, "attachTo", ()=>(0, _attachtoJs.attachTo));
parcelHelpers.export(exports, "array", ()=>(0, _isJs.array));
parcelHelpers.export(exports, "primitive", ()=>(0, _isJs.primitive));
parcelHelpers.export(exports, "toVNode", ()=>(0, _tovnodeJs.toVNode));
parcelHelpers.export(exports, "h", ()=>(0, _hJs.h));
parcelHelpers.export(exports, "fragment", ()=>(0, _hJs.fragment));
// modules
parcelHelpers.export(exports, "attributesModule", ()=>(0, _attributesJs.attributesModule));
parcelHelpers.export(exports, "classModule", ()=>(0, _classJs.classModule));
parcelHelpers.export(exports, "datasetModule", ()=>(0, _datasetJs.datasetModule));
parcelHelpers.export(exports, "eventListenersModule", ()=>(0, _eventlistenersJs.eventListenersModule));
parcelHelpers.export(exports, "propsModule", ()=>(0, _propsJs.propsModule));
parcelHelpers.export(exports, "styleModule", ()=>(0, _styleJs.styleModule));
// JSX
parcelHelpers.export(exports, "jsx", ()=>(0, _jsxJs.jsx));
parcelHelpers.export(exports, "Fragment", ()=>(0, _jsxJs.Fragment));
var _htmldomapiJs = require("./htmldomapi.js");
var _initJs = require("./init.js");
var _thunkJs = require("./thunk.js");
var _vnodeJs = require("./vnode.js");
var _attachtoJs = require("./helpers/attachto.js");
var _isJs = require("./is.js");
var _tovnodeJs = require("./tovnode.js");
var _hJs = require("./h.js");
// types
var _hooksJs = require("./hooks.js");
parcelHelpers.exportAll(_hooksJs, exports);
var _attributesJs = require("./modules/attributes.js");
var _classJs = require("./modules/class.js");
var _datasetJs = require("./modules/dataset.js");
var _eventlistenersJs = require("./modules/eventlisteners.js");
var _propsJs = require("./modules/props.js");
var _styleJs = require("./modules/style.js");
var _jsxJs = require("./jsx.js");

},{"./htmldomapi.js":false,"./init.js":"jc2r1","./thunk.js":false,"./vnode.js":false,"./helpers/attachto.js":false,"./is.js":false,"./tovnode.js":false,"./h.js":"9vcmV","./hooks.js":false,"./modules/attributes.js":"fLhsH","./modules/class.js":"kDzTl","./modules/dataset.js":false,"./modules/eventlisteners.js":"g5gUo","./modules/props.js":"ibAFb","./modules/style.js":"4G1tp","./jsx.js":false,"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"gr6Rj":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "htmlDomApi", ()=>htmlDomApi);
function createElement(tagName, options) {
    return document.createElement(tagName, options);
}
function createElementNS(namespaceURI, qualifiedName, options) {
    return document.createElementNS(namespaceURI, qualifiedName, options);
}
function createDocumentFragment() {
    return parseFragment(document.createDocumentFragment());
}
function createTextNode(text) {
    return document.createTextNode(text);
}
function createComment(text) {
    return document.createComment(text);
}
function insertBefore(parentNode, newNode, referenceNode) {
    if (isDocumentFragment(parentNode)) {
        let node = parentNode;
        while(node && isDocumentFragment(node)){
            const fragment = parseFragment(node);
            node = fragment.parent;
        }
        parentNode = node !== null && node !== void 0 ? node : parentNode;
    }
    if (isDocumentFragment(newNode)) newNode = parseFragment(newNode, parentNode);
    if (referenceNode && isDocumentFragment(referenceNode)) referenceNode = parseFragment(referenceNode).firstChildNode;
    parentNode.insertBefore(newNode, referenceNode);
}
function removeChild(node, child) {
    node.removeChild(child);
}
function appendChild(node, child) {
    if (isDocumentFragment(child)) child = parseFragment(child, node);
    node.appendChild(child);
}
function parentNode(node) {
    if (isDocumentFragment(node)) {
        while(node && isDocumentFragment(node)){
            const fragment = parseFragment(node);
            node = fragment.parent;
        }
        return node !== null && node !== void 0 ? node : null;
    }
    return node.parentNode;
}
function nextSibling(node) {
    var _a;
    if (isDocumentFragment(node)) {
        const fragment = parseFragment(node);
        const parent = parentNode(fragment);
        if (parent && fragment.lastChildNode) {
            const children = Array.from(parent.childNodes);
            const index = children.indexOf(fragment.lastChildNode);
            return (_a = children[index + 1]) !== null && _a !== void 0 ? _a : null;
        }
        return null;
    }
    return node.nextSibling;
}
function tagName(elm) {
    return elm.tagName;
}
function setTextContent(node, text) {
    node.textContent = text;
}
function getTextContent(node) {
    return node.textContent;
}
function isElement(node) {
    return node.nodeType === 1;
}
function isText(node) {
    return node.nodeType === 3;
}
function isComment(node) {
    return node.nodeType === 8;
}
function isDocumentFragment(node) {
    return node.nodeType === 11;
}
function parseFragment(fragmentNode, parentNode) {
    var _a, _b, _c;
    const fragment = fragmentNode;
    (_a = fragment.parent) !== null && _a !== void 0 ? _a : fragment.parent = parentNode !== null && parentNode !== void 0 ? parentNode : null;
    (_b = fragment.firstChildNode) !== null && _b !== void 0 ? _b : fragment.firstChildNode = fragmentNode.firstChild;
    (_c = fragment.lastChildNode) !== null && _c !== void 0 ? _c : fragment.lastChildNode = fragmentNode.lastChild;
    return fragment;
}
const htmlDomApi = {
    createElement,
    createElementNS,
    createTextNode,
    createDocumentFragment,
    createComment,
    insertBefore,
    removeChild,
    appendChild,
    parentNode,
    nextSibling,
    tagName,
    setTextContent,
    getTextContent,
    isElement,
    isText,
    isComment,
    isDocumentFragment
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"jc2r1":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "init", ()=>init);
var _vnodeJs = require("./vnode.js");
var _isJs = require("./is.js");
var _htmldomapiJs = require("./htmldomapi.js");
function isUndef(s) {
    return s === undefined;
}
function isDef(s) {
    return s !== undefined;
}
const emptyNode = (0, _vnodeJs.vnode)("", {}, [], undefined, undefined);
function sameVnode(vnode1, vnode2) {
    var _a, _b;
    const isSameKey = vnode1.key === vnode2.key;
    const isSameIs = ((_a = vnode1.data) === null || _a === void 0 ? void 0 : _a.is) === ((_b = vnode2.data) === null || _b === void 0 ? void 0 : _b.is);
    const isSameSel = vnode1.sel === vnode2.sel;
    const isSameTextOrFragment = !vnode1.sel && vnode1.sel === vnode2.sel ? typeof vnode1.text === typeof vnode2.text : true;
    return isSameSel && isSameKey && isSameIs && isSameTextOrFragment;
}
/**
 * @todo Remove this function when the document fragment is considered stable.
 */ function documentFragmentIsNotSupported() {
    throw new Error("The document fragment is not supported on this platform.");
}
function isElement(api, vnode) {
    return api.isElement(vnode);
}
function isDocumentFragment(api, vnode) {
    return api.isDocumentFragment(vnode);
}
function createKeyToOldIdx(children, beginIdx, endIdx) {
    var _a;
    const map = {};
    for(let i = beginIdx; i <= endIdx; ++i){
        const key = (_a = children[i]) === null || _a === void 0 ? void 0 : _a.key;
        if (key !== undefined) map[key] = i;
    }
    return map;
}
const hooks = [
    "create",
    "update",
    "remove",
    "destroy",
    "pre",
    "post"
];
function init(modules, domApi, options) {
    const cbs = {
        create: [],
        update: [],
        remove: [],
        destroy: [],
        pre: [],
        post: []
    };
    const api = domApi !== undefined ? domApi : (0, _htmldomapiJs.htmlDomApi);
    for (const hook of hooks)for (const module of modules){
        const currentHook = module[hook];
        if (currentHook !== undefined) cbs[hook].push(currentHook);
    }
    function emptyNodeAt(elm) {
        const id = elm.id ? "#" + elm.id : "";
        // elm.className doesn't return a string when elm is an SVG element inside a shadowRoot.
        // https://stackoverflow.com/questions/29454340/detecting-classname-of-svganimatedstring
        const classes = elm.getAttribute("class");
        const c = classes ? "." + classes.split(" ").join(".") : "";
        return (0, _vnodeJs.vnode)(api.tagName(elm).toLowerCase() + id + c, {}, [], undefined, elm);
    }
    function emptyDocumentFragmentAt(frag) {
        return (0, _vnodeJs.vnode)(undefined, {}, [], undefined, frag);
    }
    function createRmCb(childElm, listeners) {
        return function rmCb() {
            if (--listeners === 0) {
                const parent = api.parentNode(childElm);
                if (parent !== null) api.removeChild(parent, childElm);
            }
        };
    }
    function createElm(vnode, insertedVnodeQueue) {
        var _a, _b, _c, _d;
        let i;
        let data = vnode.data;
        if (data !== undefined) {
            const init = (_a = data.hook) === null || _a === void 0 ? void 0 : _a.init;
            if (isDef(init)) {
                init(vnode);
                data = vnode.data;
            }
        }
        const children = vnode.children;
        const sel = vnode.sel;
        if (sel === "!") {
            if (isUndef(vnode.text)) vnode.text = "";
            vnode.elm = api.createComment(vnode.text);
        } else if (sel === "") // textNode has no selector
        vnode.elm = api.createTextNode(vnode.text);
        else if (sel !== undefined) {
            // Parse selector
            const hashIdx = sel.indexOf("#");
            const dotIdx = sel.indexOf(".", hashIdx);
            const hash = hashIdx > 0 ? hashIdx : sel.length;
            const dot = dotIdx > 0 ? dotIdx : sel.length;
            const tag = hashIdx !== -1 || dotIdx !== -1 ? sel.slice(0, Math.min(hash, dot)) : sel;
            const elm = vnode.elm = isDef(data) && isDef(i = data.ns) ? api.createElementNS(i, tag, data) : api.createElement(tag, data);
            if (hash < dot) elm.setAttribute("id", sel.slice(hash + 1, dot));
            if (dotIdx > 0) elm.setAttribute("class", sel.slice(dot + 1).replace(/\./g, " "));
            for(i = 0; i < cbs.create.length; ++i)cbs.create[i](emptyNode, vnode);
            if (_isJs.primitive(vnode.text) && (!_isJs.array(children) || children.length === 0)) // allow h1 and similar nodes to be created w/ text and empty child list
            api.appendChild(elm, api.createTextNode(vnode.text));
            if (_isJs.array(children)) for(i = 0; i < children.length; ++i){
                const ch = children[i];
                if (ch != null) api.appendChild(elm, createElm(ch, insertedVnodeQueue));
            }
            const hook = vnode.data.hook;
            if (isDef(hook)) {
                (_b = hook.create) === null || _b === void 0 || _b.call(hook, emptyNode, vnode);
                if (hook.insert) insertedVnodeQueue.push(vnode);
            }
        } else if (((_c = options === null || options === void 0 ? void 0 : options.experimental) === null || _c === void 0 ? void 0 : _c.fragments) && vnode.children) {
            vnode.elm = ((_d = api.createDocumentFragment) !== null && _d !== void 0 ? _d : documentFragmentIsNotSupported)();
            for(i = 0; i < cbs.create.length; ++i)cbs.create[i](emptyNode, vnode);
            for(i = 0; i < vnode.children.length; ++i){
                const ch = vnode.children[i];
                if (ch != null) api.appendChild(vnode.elm, createElm(ch, insertedVnodeQueue));
            }
        } else vnode.elm = api.createTextNode(vnode.text);
        return vnode.elm;
    }
    function addVnodes(parentElm, before, vnodes, startIdx, endIdx, insertedVnodeQueue) {
        for(; startIdx <= endIdx; ++startIdx){
            const ch = vnodes[startIdx];
            if (ch != null) api.insertBefore(parentElm, createElm(ch, insertedVnodeQueue), before);
        }
    }
    function invokeDestroyHook(vnode) {
        var _a, _b;
        const data = vnode.data;
        if (data !== undefined) {
            (_b = (_a = data === null || data === void 0 ? void 0 : data.hook) === null || _a === void 0 ? void 0 : _a.destroy) === null || _b === void 0 || _b.call(_a, vnode);
            for(let i = 0; i < cbs.destroy.length; ++i)cbs.destroy[i](vnode);
            if (vnode.children !== undefined) for(let j = 0; j < vnode.children.length; ++j){
                const child = vnode.children[j];
                if (child != null && typeof child !== "string") invokeDestroyHook(child);
            }
        }
    }
    function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
        var _a, _b;
        for(; startIdx <= endIdx; ++startIdx){
            let listeners;
            let rm;
            const ch = vnodes[startIdx];
            if (ch != null) {
                if (isDef(ch.sel)) {
                    invokeDestroyHook(ch);
                    listeners = cbs.remove.length + 1;
                    rm = createRmCb(ch.elm, listeners);
                    for(let i = 0; i < cbs.remove.length; ++i)cbs.remove[i](ch, rm);
                    const removeHook = (_b = (_a = ch === null || ch === void 0 ? void 0 : ch.data) === null || _a === void 0 ? void 0 : _a.hook) === null || _b === void 0 ? void 0 : _b.remove;
                    if (isDef(removeHook)) removeHook(ch, rm);
                    else rm();
                } else if (ch.children) {
                    // Fragment node
                    invokeDestroyHook(ch);
                    removeVnodes(parentElm, ch.children, 0, ch.children.length - 1);
                } else // Text node
                api.removeChild(parentElm, ch.elm);
            }
        }
    }
    function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue) {
        let oldStartIdx = 0;
        let newStartIdx = 0;
        let oldEndIdx = oldCh.length - 1;
        let oldStartVnode = oldCh[0];
        let oldEndVnode = oldCh[oldEndIdx];
        let newEndIdx = newCh.length - 1;
        let newStartVnode = newCh[0];
        let newEndVnode = newCh[newEndIdx];
        let oldKeyToIdx;
        let idxInOld;
        let elmToMove;
        let before;
        while(oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx){
            if (oldStartVnode == null) oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left
            else if (oldEndVnode == null) oldEndVnode = oldCh[--oldEndIdx];
            else if (newStartVnode == null) newStartVnode = newCh[++newStartIdx];
            else if (newEndVnode == null) newEndVnode = newCh[--newEndIdx];
            else if (sameVnode(oldStartVnode, newStartVnode)) {
                patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
                oldStartVnode = oldCh[++oldStartIdx];
                newStartVnode = newCh[++newStartIdx];
            } else if (sameVnode(oldEndVnode, newEndVnode)) {
                patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
                oldEndVnode = oldCh[--oldEndIdx];
                newEndVnode = newCh[--newEndIdx];
            } else if (sameVnode(oldStartVnode, newEndVnode)) {
                // Vnode moved right
                patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
                api.insertBefore(parentElm, oldStartVnode.elm, api.nextSibling(oldEndVnode.elm));
                oldStartVnode = oldCh[++oldStartIdx];
                newEndVnode = newCh[--newEndIdx];
            } else if (sameVnode(oldEndVnode, newStartVnode)) {
                // Vnode moved left
                patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
                api.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
                oldEndVnode = oldCh[--oldEndIdx];
                newStartVnode = newCh[++newStartIdx];
            } else {
                if (oldKeyToIdx === undefined) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
                idxInOld = oldKeyToIdx[newStartVnode.key];
                if (isUndef(idxInOld)) {
                    // `newStartVnode` is new, create and insert it in beginning
                    api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
                    newStartVnode = newCh[++newStartIdx];
                } else if (isUndef(oldKeyToIdx[newEndVnode.key])) {
                    // `newEndVnode` is new, create and insert it in the end
                    api.insertBefore(parentElm, createElm(newEndVnode, insertedVnodeQueue), api.nextSibling(oldEndVnode.elm));
                    newEndVnode = newCh[--newEndIdx];
                } else {
                    // Neither of the new endpoints are new vnodes, so we make progress by
                    // moving `newStartVnode` into position
                    elmToMove = oldCh[idxInOld];
                    if (elmToMove.sel !== newStartVnode.sel) api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
                    else {
                        patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
                        oldCh[idxInOld] = undefined;
                        api.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);
                    }
                    newStartVnode = newCh[++newStartIdx];
                }
            }
        }
        if (newStartIdx <= newEndIdx) {
            before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm;
            addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
        }
        if (oldStartIdx <= oldEndIdx) removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
    }
    function patchVnode(oldVnode, vnode, insertedVnodeQueue) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const hook = (_a = vnode.data) === null || _a === void 0 ? void 0 : _a.hook;
        (_b = hook === null || hook === void 0 ? void 0 : hook.prepatch) === null || _b === void 0 || _b.call(hook, oldVnode, vnode);
        const elm = vnode.elm = oldVnode.elm;
        if (oldVnode === vnode) return;
        if (vnode.data !== undefined || isDef(vnode.text) && vnode.text !== oldVnode.text) {
            (_c = vnode.data) !== null && _c !== void 0 ? _c : vnode.data = {};
            (_d = oldVnode.data) !== null && _d !== void 0 ? _d : oldVnode.data = {};
            for(let i = 0; i < cbs.update.length; ++i)cbs.update[i](oldVnode, vnode);
            (_g = (_f = (_e = vnode.data) === null || _e === void 0 ? void 0 : _e.hook) === null || _f === void 0 ? void 0 : _f.update) === null || _g === void 0 || _g.call(_f, oldVnode, vnode);
        }
        const oldCh = oldVnode.children;
        const ch = vnode.children;
        if (isUndef(vnode.text)) {
            if (isDef(oldCh) && isDef(ch)) {
                if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue);
            } else if (isDef(ch)) {
                if (isDef(oldVnode.text)) api.setTextContent(elm, "");
                addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
            } else if (isDef(oldCh)) removeVnodes(elm, oldCh, 0, oldCh.length - 1);
            else if (isDef(oldVnode.text)) api.setTextContent(elm, "");
        } else if (oldVnode.text !== vnode.text) {
            if (isDef(oldCh)) removeVnodes(elm, oldCh, 0, oldCh.length - 1);
            api.setTextContent(elm, vnode.text);
        }
        (_h = hook === null || hook === void 0 ? void 0 : hook.postpatch) === null || _h === void 0 || _h.call(hook, oldVnode, vnode);
    }
    return function patch(oldVnode, vnode) {
        let i, elm, parent;
        const insertedVnodeQueue = [];
        for(i = 0; i < cbs.pre.length; ++i)cbs.pre[i]();
        if (isElement(api, oldVnode)) oldVnode = emptyNodeAt(oldVnode);
        else if (isDocumentFragment(api, oldVnode)) oldVnode = emptyDocumentFragmentAt(oldVnode);
        if (sameVnode(oldVnode, vnode)) patchVnode(oldVnode, vnode, insertedVnodeQueue);
        else {
            elm = oldVnode.elm;
            parent = api.parentNode(elm);
            createElm(vnode, insertedVnodeQueue);
            if (parent !== null) {
                api.insertBefore(parent, vnode.elm, api.nextSibling(elm));
                removeVnodes(parent, [
                    oldVnode
                ], 0, 0);
            }
        }
        for(i = 0; i < insertedVnodeQueue.length; ++i)insertedVnodeQueue[i].data.hook.insert(insertedVnodeQueue[i]);
        for(i = 0; i < cbs.post.length; ++i)cbs.post[i]();
        return vnode;
    };
}

},{"./vnode.js":"jupXQ","./is.js":"8WJTg","./htmldomapi.js":"gr6Rj","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"jupXQ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "vnode", ()=>vnode);
function vnode(sel, data, children, text, elm) {
    const key = data === undefined ? undefined : data.key;
    return {
        sel,
        data,
        children,
        text,
        elm,
        key
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"8WJTg":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "array", ()=>array);
parcelHelpers.export(exports, "primitive", ()=>primitive);
const array = Array.isArray;
function primitive(s) {
    return typeof s === "string" || typeof s === "number" || s instanceof String || s instanceof Number;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"9vcmV":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "addNS", ()=>addNS);
parcelHelpers.export(exports, "h", ()=>h);
/**
 * @experimental
 */ parcelHelpers.export(exports, "fragment", ()=>fragment);
var _vnodeJs = require("./vnode.js");
var _isJs = require("./is.js");
function addNS(data, children, sel) {
    data.ns = "http://www.w3.org/2000/svg";
    if (sel !== "foreignObject" && children !== undefined) for(let i = 0; i < children.length; ++i){
        const child = children[i];
        if (typeof child === "string") continue;
        const childData = child.data;
        if (childData !== undefined) addNS(childData, child.children, child.sel);
    }
}
function h(sel, b, c) {
    let data = {};
    let children;
    let text;
    let i;
    if (c !== undefined) {
        if (b !== null) data = b;
        if (_isJs.array(c)) children = c;
        else if (_isJs.primitive(c)) text = c.toString();
        else if (c && c.sel) children = [
            c
        ];
    } else if (b !== undefined && b !== null) {
        if (_isJs.array(b)) children = b;
        else if (_isJs.primitive(b)) text = b.toString();
        else if (b && b.sel) children = [
            b
        ];
        else data = b;
    }
    if (children !== undefined) {
        for(i = 0; i < children.length; ++i)if (_isJs.primitive(children[i])) children[i] = (0, _vnodeJs.vnode)(undefined, undefined, undefined, children[i], undefined);
    }
    if (sel.startsWith("svg") && (sel.length === 3 || sel[3] === "." || sel[3] === "#")) addNS(data, children, sel);
    return (0, _vnodeJs.vnode)(sel, data, children, text, undefined);
}
function fragment(children) {
    let c;
    let text;
    if (_isJs.array(children)) c = children;
    else if (_isJs.primitive(c)) text = children;
    else if (c && c.sel) c = [
        children
    ];
    if (c !== undefined) {
        for(let i = 0; i < c.length; ++i)if (_isJs.primitive(c[i])) c[i] = (0, _vnodeJs.vnode)(undefined, undefined, undefined, c[i], undefined);
    }
    return (0, _vnodeJs.vnode)(undefined, {}, c, text, undefined);
}

},{"./vnode.js":"jupXQ","./is.js":"8WJTg","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"fLhsH":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "attributesModule", ()=>attributesModule);
const xlinkNS = "http://www.w3.org/1999/xlink";
const xmlnsNS = "http://www.w3.org/2000/xmlns/";
const xmlNS = "http://www.w3.org/XML/1998/namespace";
const colonChar = 58;
const xChar = 120;
const mChar = 109;
function updateAttrs(oldVnode, vnode) {
    let key;
    const elm = vnode.elm;
    let oldAttrs = oldVnode.data.attrs;
    let attrs = vnode.data.attrs;
    if (!oldAttrs && !attrs) return;
    if (oldAttrs === attrs) return;
    oldAttrs = oldAttrs || {};
    attrs = attrs || {};
    // update modified attributes, add new attributes
    for(key in attrs){
        const cur = attrs[key];
        const old = oldAttrs[key];
        if (old !== cur) {
            if (cur === true) elm.setAttribute(key, "");
            else if (cur === false) elm.removeAttribute(key);
            else {
                if (key.charCodeAt(0) !== xChar) elm.setAttribute(key, cur);
                else if (key.charCodeAt(3) === colonChar) // Assume xml namespace
                elm.setAttributeNS(xmlNS, key, cur);
                else if (key.charCodeAt(5) === colonChar) // Assume 'xmlns' or 'xlink' namespace
                key.charCodeAt(1) === mChar ? elm.setAttributeNS(xmlnsNS, key, cur) : elm.setAttributeNS(xlinkNS, key, cur);
                else elm.setAttribute(key, cur);
            }
        }
    }
    // remove removed attributes
    // use `in` operator since the previous `for` iteration uses it (.i.e. add even attributes with undefined value)
    // the other option is to remove all attributes with value == undefined
    for(key in oldAttrs)if (!(key in attrs)) elm.removeAttribute(key);
}
const attributesModule = {
    create: updateAttrs,
    update: updateAttrs
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"kDzTl":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "classModule", ()=>classModule);
function updateClass(oldVnode, vnode) {
    let cur;
    let name;
    const elm = vnode.elm;
    let oldClass = oldVnode.data.class;
    let klass = vnode.data.class;
    if (!oldClass && !klass) return;
    if (oldClass === klass) return;
    oldClass = oldClass || {};
    klass = klass || {};
    for(name in oldClass)if (oldClass[name] && !Object.prototype.hasOwnProperty.call(klass, name)) // was `true` and now not provided
    elm.classList.remove(name);
    for(name in klass){
        cur = klass[name];
        if (cur !== oldClass[name]) elm.classList[cur ? "add" : "remove"](name);
    }
}
const classModule = {
    create: updateClass,
    update: updateClass
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"g5gUo":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "eventListenersModule", ()=>eventListenersModule);
function invokeHandler(handler, vnode, event) {
    if (typeof handler === "function") // call function handler
    handler.call(vnode, event, vnode);
    else if (typeof handler === "object") // call multiple handlers
    for(let i = 0; i < handler.length; i++)invokeHandler(handler[i], vnode, event);
}
function handleEvent(event, vnode) {
    const name = event.type;
    const on = vnode.data.on;
    // call event handler(s) if exists
    if (on && on[name]) invokeHandler(on[name], vnode, event);
}
function createListener() {
    return function handler(event) {
        handleEvent(event, handler.vnode);
    };
}
function updateEventListeners(oldVnode, vnode) {
    const oldOn = oldVnode.data.on;
    const oldListener = oldVnode.listener;
    const oldElm = oldVnode.elm;
    const on = vnode && vnode.data.on;
    const elm = vnode && vnode.elm;
    let name;
    // optimization for reused immutable handlers
    if (oldOn === on) return;
    // remove existing listeners which no longer used
    if (oldOn && oldListener) {
        // if element changed or deleted we remove all existing listeners unconditionally
        if (!on) for(name in oldOn)// remove listener if element was changed or existing listeners removed
        oldElm.removeEventListener(name, oldListener, false);
        else {
            for(name in oldOn)// remove listener if existing listener removed
            if (!on[name]) oldElm.removeEventListener(name, oldListener, false);
        }
    }
    // add new listeners which has not already attached
    if (on) {
        // reuse existing listener or create new
        const listener = vnode.listener = oldVnode.listener || createListener();
        // update vnode for listener
        listener.vnode = vnode;
        // if element changed or added we add all needed listeners unconditionally
        if (!oldOn) for(name in on)// add listener if element was changed or new listeners added
        elm.addEventListener(name, listener, false);
        else {
            for(name in on)// add listener if new listener added
            if (!oldOn[name]) elm.addEventListener(name, listener, false);
        }
    }
}
const eventListenersModule = {
    create: updateEventListeners,
    update: updateEventListeners,
    destroy: updateEventListeners
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"ibAFb":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "propsModule", ()=>propsModule);
function updateProps(oldVnode, vnode) {
    let key;
    let cur;
    let old;
    const elm = vnode.elm;
    let oldProps = oldVnode.data.props;
    let props = vnode.data.props;
    if (!oldProps && !props) return;
    if (oldProps === props) return;
    oldProps = oldProps || {};
    props = props || {};
    for(key in props){
        cur = props[key];
        old = oldProps[key];
        if (old !== cur && (key !== "value" || elm[key] !== cur)) elm[key] = cur;
    }
}
const propsModule = {
    create: updateProps,
    update: updateProps
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"4G1tp":[function(require,module,exports,__globalThis) {
// Binding `requestAnimationFrame` like this fixes a bug in IE/Edge. See #360 and #409.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "styleModule", ()=>styleModule);
const raf = typeof (window === null || window === void 0 ? void 0 : window.requestAnimationFrame) === "function" ? window.requestAnimationFrame.bind(window) : setTimeout;
const nextFrame = function(fn) {
    raf(function() {
        raf(fn);
    });
};
let reflowForced = false;
function setNextFrame(obj, prop, val) {
    nextFrame(function() {
        obj[prop] = val;
    });
}
function updateStyle(oldVnode, vnode) {
    let cur;
    let name;
    const elm = vnode.elm;
    let oldStyle = oldVnode.data.style;
    let style = vnode.data.style;
    if (!oldStyle && !style) return;
    if (oldStyle === style) return;
    oldStyle = oldStyle || {};
    style = style || {};
    const oldHasDel = "delayed" in oldStyle;
    for(name in oldStyle)if (!(name in style)) {
        if (name[0] === "-" && name[1] === "-") elm.style.removeProperty(name);
        else elm.style[name] = "";
    }
    for(name in style){
        cur = style[name];
        if (name === "delayed" && style.delayed) for(const name2 in style.delayed){
            cur = style.delayed[name2];
            if (!oldHasDel || cur !== oldStyle.delayed[name2]) setNextFrame(elm.style, name2, cur);
        }
        else if (name !== "remove" && cur !== oldStyle[name]) {
            if (name[0] === "-" && name[1] === "-") elm.style.setProperty(name, cur);
            else elm.style[name] = cur;
        }
    }
}
function applyDestroyStyle(vnode) {
    let style;
    let name;
    const elm = vnode.elm;
    const s = vnode.data.style;
    if (!s || !(style = s.destroy)) return;
    for(name in style)elm.style[name] = style[name];
}
function applyRemoveStyle(vnode, rm) {
    const s = vnode.data.style;
    if (!s || !s.remove) {
        rm();
        return;
    }
    if (!reflowForced) {
        // eslint-disable-next-line @typescript-eslint/no-unused-expressions
        vnode.elm.offsetLeft;
        reflowForced = true;
    }
    let name;
    const elm = vnode.elm;
    let i = 0;
    const style = s.remove;
    let amount = 0;
    const applied = [];
    for(name in style){
        applied.push(name);
        elm.style[name] = style[name];
    }
    const compStyle = getComputedStyle(elm);
    const props = compStyle["transition-property"].split(", ");
    for(; i < props.length; ++i)if (applied.indexOf(props[i]) !== -1) amount++;
    elm.addEventListener("transitionend", function(ev) {
        if (ev.target === elm) --amount;
        if (amount === 0) rm();
    });
}
function forceReflow() {
    reflowForced = false;
}
const styleModule = {
    pre: forceReflow,
    create: updateStyle,
    update: updateStyle,
    destroy: applyDestroyStyle,
    remove: applyRemoveStyle
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"4c31j":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Msg", ()=>Msg);
parcelHelpers.export(exports, "MsgFetchPokemon", ()=>MsgFetchPokemon);
parcelHelpers.export(exports, "MsgGotPokemon", ()=>MsgGotPokemon);
parcelHelpers.export(exports, "MsgError", ()=>MsgError);
parcelHelpers.export(exports, "MsgType", ()=>MsgType);
var _effect = require("effect");
const Msg = (0, _effect.Schema).Union((0, _effect.Schema).TaggedStruct("MsgFetchPokemon", {
    pokemon: (0, _effect.Schema).String
}), (0, _effect.Schema).TaggedStruct("MsgGotPokemon", {
    pokemonData: (0, _effect.Schema).Object
}), (0, _effect.Schema).TaggedStruct("MsgError", {
    error: (0, _effect.Schema).String
}), (0, _effect.Schema).TaggedStruct("MsgType", {
    text: (0, _effect.Schema).String
}));
const [MsgFetchPokemon, MsgGotPokemon, MsgError, MsgType] = Msg.members;

},{"effect":"613jd","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh"}],"jYYJY":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "update", ()=>update);
var _effect = require("effect");
var _msg = require("./msg");
var _model = require("./model");
var _src = require("cs12242-mvu/src");
const update = (msg, model)=>(0, _effect.Match).value(msg).pipe((0, _effect.Match).tag("MsgFetchPokemon", ({ pokemon })=>{
        return {
            model: (0, _model.Model).make({
                ...model,
                isFetching: true,
                error: ""
            }),
            cmd: (0, _src.Cmd).ofSub(async (dispatch)=>{
                try {
                    const resp = await fetch(`https://pokeapi.upd-dcs.work/api/v2/pokemon/${(0, _effect.String).toLowerCase(pokemon)}`);
                    const data = await resp.text();
                    const obj = JSON.parse(data);
                    let types = [];
                    for (const type of obj.types)types = (0, _effect.Array).append(types, type.type.name);
                    const newPokemonData = {
                        "name": obj.name,
                        "types": types,
                        "height": obj.height,
                        "weight": obj.weight
                    };
                    dispatch((0, _msg.MsgGotPokemon).make({
                        pokemonData: newPokemonData
                    }));
                } catch (e) {
                    dispatch((0, _msg.MsgError).make({
                        error: `Error: ${e}`
                    }));
                }
            })
        };
    }), (0, _effect.Match).tag("MsgGotPokemon", ({ pokemonData })=>(0, _model.Model).make({
            ...model,
            isFetching: false,
            pokemonData: pokemonData
        })), (0, _effect.Match).tag("MsgError", ({ error })=>(0, _model.Model).make({
            ...model,
            error: error
        })), (0, _effect.Match).tag("MsgType", ({ text })=>(0, _model.Model).make({
            ...model,
            text
        })), (0, _effect.Match).exhaustive);

},{"effect":"613jd","@parcel/transformer-js/src/esmodule-helpers.js":"fF6sh","./model":"lPixF","cs12242-mvu/src":"lHyd2","./msg":"4c31j"}]},["e0foL","ly4KV"], "ly4KV", "parcelRequire3099", {})

//# sourceMappingURL=lab10.5e0e6471.js.map
